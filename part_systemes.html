<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Informatique - Systèmes</title>

    <link rel="stylesheet" type="text/css" href="/assets/semantic.min.css">
    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="/assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>

<script>
$(document).ready(function() {
   $('.chapter').hide();

   $('.ui.marginnote').each(function() {
       const id = $(this).attr('id');
       $(this).detach().appendTo('#noterail')
           .replaceWith(function() { return '<div class=".ui.marginnote" id="'
                   + id + '">'+this.innerHTML + "</div>" })

       setTimeout(function() {
           $('#'+id).each(function() {
               console.log(this)
                   $(this).css({
                        position: 'absolute',
                        top: $('#' + $(this).attr('id') + 'context').position().top,
                    })
           })
        }, 500)
    })
})
</script>

  <style type="text/css">
  body {
    background-color: #FFFFFF;
  }
  html {
    font-size: 20px;
  }
  .ui.menu .item img.logo {
    margin-right: 1.5em;
  }
  .main.container {
    margin-top: 7em;
  }
  .wireframe {
    margin-top: 2em;
  }
  .ui.toc {
    margin: 10em 0em 0em;
    padding: 10em 0em;
  }
  .ui.footer.segment {
    margin: 5em 0em 0em;
    padding: 5em 0em;
  }
  </style>

  </head>
  <body>
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}

\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\ensfonctionszero[3]{\mathcal{F}_{#3,0}(#1,#2)}
\newcommand\continues[2]{\mathcal{C}(#1,#2)}
\newcommand\lineaires[2]{\mathcal{L}(#1,#2)}
\newcommand\nlineaires[3]{\mathcal{L}_{#1}(#2,#3)}
\newcommand\ensendo[1]{\mathcal{L}(#1)}
\newcommand\derivables[2]{\mathcal{D}(#1,#2)}
\newcommand\segment[2]{[#1,#2]}
\newcommand\intouvert[2]{]#1,#2[}
\newcommand\intouvertgauche[2]{]#1,#2]}
\newcommand\intouvertdroite[2]{[#1,#2[}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\voisinages[2]{\mathcal{V}_{#1}(#2)}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Vect[1]{\mbox{Vect}(#1)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\rang[1]{\mbox{rg}(#1)}
\newcommand\trace[1]{\mbox{tr}(#1)}
\newcommand\gl[1]{\mbox{GL}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\codim[0]{\mbox{codim}}
\newcommand\tr{\mbox{tr}}
\newcommand\uniondisjointe{\sqcup}
\def\Rbar{\overline\R}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\Det{\mbox{Det}}
\newcommand\indic{\mathbbm{1}}
\newcommand\groupeengendre[1]{\langle #1 \rangle}
\renewcommand\Im{\mathfrak{I}}
\newcommand\id{\mbox{id}}
\newcommand\Bary[1]{\mbox{Bary}\{#1\}}
\newcommand\Ker{\mbox{Ker}~}
\newcommand\Ima{\mbox{Im}~}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\sh{\mbox{sh}}
\newcommand\ch{\mbox{ch}}
\renewcommand\tanh{\mbox{th}}
\newcommand\Arcsin{\mbox{Arcsin}~}
\newcommand\Arccos{\mbox{Arccos}~}
\newcommand\Arctan{\mbox{Arctan}~}
\newcommand\Argsh{\mbox{Argsh}}
\newcommand\Argch{\mbox{Argch}}
\newcommand\Argth{\mbox{Argth}}
\newcommand\argu{\mbox{arg}}
\newcommand\dron[2]{\frac{\partial #1}{\partial #2}}
\newcommand\conj[1]{\overline{#1}}
\newcommand\ei[1]{e^{i #1}}
\newcommand\eii[2]{e^{#1 i #2}}
\newcommand\crochet[1]{\left[ #1 \right]}

\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}

\newcommand{\diff}{\mathop{}\mathopen{}\mathrm{d}}
\newcommand{\cc}{{\cal C}}

\)


<div class="ui fixed inverted menu">
    <div class="ui container">
      <a href="#" class="header item">
        <img class="logo" src="assets/img/logo.png">
        Informatique en CPGE
      </a>
      <a href="index.html" class="item">Accueil</a>
    </div>
  </div>


<div class="ui main container segment">

<div class="toc left dividing ui small rail">
<ul>
<li><a href="#sec:systèmes"><span class="toc-section-number">1</span> Systèmes</a>
<ul>
<li><a href="#sec:gestion-de-la-mémoire-dans-un-programme-compilé"><span class="toc-section-number">1.1</span> Gestion de la mémoire dans un programme compilé</a>
<ul>
<li><a href="#sec:orga"><span class="toc-section-number">1.1.1</span> Organisation de la mémoire</a></li>
<li><a href="#sec:portée-dun-identificateur"><span class="toc-section-number">1.1.2</span> Portée d’un identificateur</a></li>
<li><a href="#sec:durée-de-vie-dune-variable"><span class="toc-section-number">1.1.3</span> Durée de vie d’une variable</a></li>
<li><a href="#sec:piles-dexécution-variables-locales-et-paramètres"><span class="toc-section-number">1.1.4</span> Piles d’exécution, variables locales et paramètres</a></li>
</ul></li>
</ul></li>
</ul>
</div>

<div class="right dividing ui rail" id="noterail">
</div>

<h1 data-number="1" id="sec:systèmes"><span class="header-section-number">1</span> Systèmes</h1>
<h2 data-number="1.1" id="sec:gestion-de-la-mémoire-dans-un-programme-compilé"><span class="header-section-number">1.1</span> Gestion de la mémoire dans un programme compilé</h2>
<p><img class="ui image fluid" src="assets/pics/chap_memoire.jpg"/></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Ce chapitre se concentre sur la manière dont un programme compilé gère la mémoire. Il est question, en particulier, de la notion de variable. Le modèle dans lequel on se place est celui du langage C où une variable est un emplacement mémoire.</div></p>
<h3 data-number="1.1.1" id="sec:orga"><span class="header-section-number">1.1.1</span> Organisation de la mémoire</h3>
<p><div class="ui message blue"><div class="header">Note</div>Ici, je fais le choix d’une présentation assez informelle pour ne pas qu’elle soit trop liée à la réalité d’un compilateur en particulier.</div></p>
<p>Un programme compilé gère la mémoire d’un ordinateur de deux manières très différentes</p>
<ul>
<li>statiquement : c’est le cas des variables locales ou globales définies dans le programme. Au moment de la compilation, le compilateur dispose de l’information suffisante pour prévoir de la place en mémoire pour stocker ces données.</li>
<li>dynamiquement : c’est le cas des objets dont la taille n’est connue qu’à l’exécution et peut varier selon l’état du programme. C’est alors au moment de l’exécution que le programme va faire une demande d’allocation pour obtenir une place mémoire.</li>
</ul>
<p>En terme d’allocation statique, on peut distinguer plusieurs types de mémoire : <span id="marginnote1context"><span class="ui marginnote" id="marginnote1"><img src="assets/pics/memorymap.png" /> <br/>Structure de la mémoire associée à un programme</span></span></p>
<ul>
<li>les variables globales initialisées qui seront stockées dans le binaire et placées en mémoire dans une zone spécifique chargée avec le binaire</li>
<li>les variables globales non initialisées dont seule la déclaration sera dans le binaire et qui seront allouées, placées en mémoire et initialisées à 0 au moment du chargement du binaire</li>
<li>les variables locales et les paramètres qui sont placés dans une pile afin de les allouer uniquement au moment de l’exécution du bloc ou de la fonction</li>
</ul>
<p>L’allocation dynamique utilise une zone mémoire appelée tas dont une possible organisation est développée dans le problème FIXME.</p>
<p>Considérons le programme c suivant.</p>
<p><div class="ui segment compact" style="font-size:0.8em" ></p>
<div class="sourceCode" id="memoirecodeex1"><pre class="sourceCode c"><code class="sourceCode c"><span id="memoirecodeex1-1"><a href="#memoirecodeex1-1" aria-hidden="true"></a><span class="dt">const</span> <span class="dt">int</span> a  = <span class="dv">42</span>;</span>
<span id="memoirecodeex1-2"><a href="#memoirecodeex1-2" aria-hidden="true"></a><span class="dt">int</span> b[] = { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> };</span>
<span id="memoirecodeex1-3"><a href="#memoirecodeex1-3" aria-hidden="true"></a><span class="dt">int</span> c;</span>
<span id="memoirecodeex1-4"><a href="#memoirecodeex1-4" aria-hidden="true"></a></span>
<span id="memoirecodeex1-5"><a href="#memoirecodeex1-5" aria-hidden="true"></a><span class="dt">int</span> f(<span class="dt">int</span> x, <span class="dt">int</span> y)</span>
<span id="memoirecodeex1-6"><a href="#memoirecodeex1-6" aria-hidden="true"></a>{</span>
<span id="memoirecodeex1-7"><a href="#memoirecodeex1-7" aria-hidden="true"></a>    <span class="dt">int</span> z = x;</span>
<span id="memoirecodeex1-8"><a href="#memoirecodeex1-8" aria-hidden="true"></a>    z = z * y;</span>
<span id="memoirecodeex1-9"><a href="#memoirecodeex1-9" aria-hidden="true"></a>    <span class="cf">return</span> z;</span>
<span id="memoirecodeex1-10"><a href="#memoirecodeex1-10" aria-hidden="true"></a>}</span>
<span id="memoirecodeex1-11"><a href="#memoirecodeex1-11" aria-hidden="true"></a></span>
<span id="memoirecodeex1-12"><a href="#memoirecodeex1-12" aria-hidden="true"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv)</span>
<span id="memoirecodeex1-13"><a href="#memoirecodeex1-13" aria-hidden="true"></a>{</span>
<span id="memoirecodeex1-14"><a href="#memoirecodeex1-14" aria-hidden="true"></a>    <span class="dt">const</span> <span class="dt">int</span> d = <span class="dv">1664</span>;</span>
<span id="memoirecodeex1-15"><a href="#memoirecodeex1-15" aria-hidden="true"></a></span>
<span id="memoirecodeex1-16"><a href="#memoirecodeex1-16" aria-hidden="true"></a>    c = f(a, d);</span>
<span id="memoirecodeex1-17"><a href="#memoirecodeex1-17" aria-hidden="true"></a>    </span>
<span id="memoirecodeex1-18"><a href="#memoirecodeex1-18" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="memoirecodeex1-19"><a href="#memoirecodeex1-19" aria-hidden="true"></a>}</span></code></pre></div>
<p></div> Il est possible d’observer la manière dont sa mémoire sera répartie en utilisant la commande <code>objdump</code> :</p>
<p><div class="ui segment compact" style="font-size:0.8em" ></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>$ <span class="kw">gcc</span> -c memoire.c</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>$ objdump -x memoire.o</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>memoire.o:     <span class="kw">file</span> format elf64-x86-64</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>memoire.o</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>architecture: i386:x86-64, flags 0x00000011:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>HAS_RELOC, HAS_SYMS</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>start address 0x0000000000000000</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>Sections:</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>Idx Name          Size      VMA               LMA               File off  Algn</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>  0 .text         00000053  0000000000000000  0000000000000000  00000040  2**0</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>  1 .data         00000000  0000000000000000  0000000000000000  00000093  2**0</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>                  CONTENTS, ALLOC, LOAD, DATA</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>  2 .bss          00000004  0000000000000000  0000000000000000  00000094  2**2</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>                  ALLOC</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>  3 .rodata       00000014  0000000000000000  0000000000000000  00000098  2**3</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>  4 .comment      00000013  0000000000000000  0000000000000000  000000ac  2**0</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>                  CONTENTS, READONLY</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000bf  2**0</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>                  CONTENTS, READONLY</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>  6 .eh_frame     00000058  0000000000000000  0000000000000000  000000c0  2**3</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a>                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>SYMBOL TABLE:</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>0000000000000000 l    <span class="kw">df</span> *ABS*  0000000000000000 orga.c</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a>0000000000000000 l    d  .text  0000000000000000 .text</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a>0000000000000000 l    d  .data  0000000000000000 .data</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a>0000000000000000 l    d  .bss   0000000000000000 .bss</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>0000000000000000 l    d  .rodata    0000000000000000 .rodata</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a>0000000000000000 l    d  .note.GNU-stack    0000000000000000 .note.GNU-stack</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a>0000000000000000 l    d  .eh_frame  0000000000000000 .eh_frame</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a>0000000000000000 l    d  .comment   0000000000000000 .comment</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a>0000000000000000 g     O .rodata    0000000000000004 a</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a>0000000000000000 g     O .data  000000000000000c b</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a>0000000000000000 g     O .bss   0000000000000004 c</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a>0000000000000000 g     F .text  000000000000001f f</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a>000000000000001f g     F .text  0000000000000034 main</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true"></a>RELOCATION RECORDS FOR [.text]:</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true"></a>OFFSET           TYPE              VALUE </span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true"></a>0000000000000042 R_X86_64_PLT32    f-0x0000000000000004</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true"></a>0000000000000048 R_X86_64_PC32     c-0x0000000000000004</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true"></a>RELOCATION RECORDS FOR [.eh_frame]:</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true"></a>OFFSET           TYPE              VALUE </span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true"></a>0000000000000020 R_X86_64_PC32     .text</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true"></a>0000000000000040 R_X86_64_PC32     .text+0x000000000000001f</span></code></pre></div>
<p></div> On retrouve dans les sections mémoire : <span id="marginnote2context"><span class="ui marginnote" id="marginnote2">Ici, le schéma mémoire est un peu plus compliqué car une zone mémoire distincte est prévue pour les variables constantes initialisées pour des raisons de sécurité.</span></span></p>
<ul>
<li><code>.text</code> contenant le programme binaire</li>
<li><code>.data</code> contenant les variables globales initialisées et non constantes</li>
<li><code>.bss</code> contenant les variables non initialisées</li>
<li><code>.rodata</code> contenant les variables globales initialisées mais constantes.</li>
</ul>
<p>La pile et le tas sont automatiques et n’ont pas besoin de figurer dans le binaire, c’est pour cela qu’on ne les trouve pas dans la liste.</p>
<p>Dans cette description mémoire, on trouve la table des symboles qui décrit où vont se trouver en mémoire certaines variables.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Nom de variable</th>
<th style="text-align: center;">Sorte de déclaration</th>
<th style="text-align: center;">Section mémoire</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">a</td>
<td style="text-align: center;">constante globale initialisée</td>
<td style="text-align: center;">rodata</td>
</tr>
<tr class="even">
<td style="text-align: center;">b</td>
<td style="text-align: center;">globale initialisée</td>
<td style="text-align: center;">data</td>
</tr>
<tr class="odd">
<td style="text-align: center;">c</td>
<td style="text-align: center;">globale non init.</td>
<td style="text-align: center;">bss</td>
</tr>
</tbody>
</table>
<p>La section suivante permettra de compléter le tableau en étudiant comment les paramètres et variables locales sont gérés. On remarque cependant qu’il n y a pas de symboles pour ceux-ci. En effet, le nom des variables locales est a priori perdu après la compilation contrairement aux variables globales.</p>
<h3 data-number="1.1.2" id="sec:portée-dun-identificateur"><span class="header-section-number">1.1.2</span> Portée d’un identificateur</h3>
<p>En ce qui concerne une variable dans un programme, on peut définir deux notions d’apparence assez similaire.</p>
<p>D’une part la portée d’un identificateur qui correspond au texte du programme :</p>
<p><div class="ui message"><div class="header">Définition</div> La <strong>portée</strong> d’un identificateur est définie par la zone du texte d’un programme dans laquelle il est possible d’y faire référence sans erreurs. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Dans le langage C, un identificateur peut être utilisé dès sa déclaration mais tant que la variable n’est pas initialisée, le comportement n’est pas spécifié et il faut considérer cela comme une erreur. Le compilateur produit ainsi un avertissement quand on utilise le paramètre <code>-Wall</code>.</p>
<p>Dans le cas d’une définition, il est ainsi possible de faire référence à l’identificateur dans l’expression de son initialisation : <code>int x = x</code>. Ce cas est pathologique et le fait qu’on compte la ligne de déclaration dans la portée ne devrait pas inciter à écrire ce genre de code qui produira, de toutes façons, une erreur avec les options <code>-Wall -Werror</code>.</div></p>
<p>Dans le programme :</p>
<p><div class="ui segment compact" style="font-size:0.8em" ></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">int</span> a = <span class="dv">1</span>;</span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="dt">int</span> f (<span class="dt">int</span> x)</span>
<span id="cb2-4"><a href="#cb2-4"></a>{</span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="dt">int</span> y = x + a;</span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="cf">return</span> y;</span>
<span id="cb2-7"><a href="#cb2-7"></a>}</span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="dt">int</span> g()</span>
<span id="cb2-10"><a href="#cb2-10"></a>{</span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="dt">int</span> z = <span class="dv">3</span>;</span>
<span id="cb2-12"><a href="#cb2-12"></a>    <span class="cf">return</span> z + f(z);</span>
<span id="cb2-13"><a href="#cb2-13"></a>}</span></code></pre></div>
<p></div></p>
<p>La portée des identificateurs est :<span id="marginnote3context"><span class="ui marginnote" id="marginnote3">Pour une fonction, afin de pouvoir écrire des fonctions récursives, l’identificateur est utilisable dans le corps de la fonction</span></span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Identificateur</th>
<th style="text-align: center;">Portée</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">a</td>
<td style="text-align: center;">1-13</td>
</tr>
<tr class="even">
<td style="text-align: center;">x</td>
<td style="text-align: center;">3-7</td>
</tr>
<tr class="odd">
<td style="text-align: center;">y</td>
<td style="text-align: center;">5-7</td>
</tr>
<tr class="even">
<td style="text-align: center;">f</td>
<td style="text-align: center;">4-13</td>
</tr>
<tr class="odd">
<td style="text-align: center;">g</td>
<td style="text-align: center;">10-13</td>
</tr>
<tr class="even">
<td style="text-align: center;">z</td>
<td style="text-align: center;">11-13</td>
</tr>
</tbody>
</table>
<p>Comme la portée est une notion associée aux identificateurs, elle est indépendante de la notion de variables. Si on considère le programme suivant :</p>
<p><div class="ui segment compact" style="font-size:0.8em" ></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1"></a><span class="dt">void</span> f() </span>
<span id="cb3-2"><a href="#cb3-2"></a>{</span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="dt">int</span> i = <span class="dv">3</span>;</span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="cf">return</span> i;</span>
<span id="cb3-6"><a href="#cb3-6"></a>}</span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="dt">void</span> g() </span>
<span id="cb3-9"><a href="#cb3-9"></a>{</span>
<span id="cb3-10"><a href="#cb3-10"></a>    <span class="dt">int</span> i = <span class="dv">5</span>;</span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="cf">return</span> i+<span class="dv">1</span>;</span>
<span id="cb3-13"><a href="#cb3-13"></a>}</span></code></pre></div>
<p></div></p>
<p>L’identificateur <code>i</code> a pour portée les lignes 3-6 et 10-13.</p>
<p>Un autre phénomène plus complexe peut se produire quand on redéfinit un identificateur dans sa portée.</p>
<p>Considérons le programme suivant</p>
<p><div class="ui segment compact" style="font-size:0.8em" ></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1"></a><span class="dt">void</span> f() </span>
<span id="cb4-2"><a href="#cb4-2"></a>{</span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="dt">int</span> i = <span class="dv">3</span>;</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">3</span>; j++) </span>
<span id="cb4-6"><a href="#cb4-6"></a>    {</span>
<span id="cb4-7"><a href="#cb4-7"></a>        <span class="dt">int</span> i = <span class="dv">4</span>;</span>
<span id="cb4-8"><a href="#cb4-8"></a>        </span>
<span id="cb4-9"><a href="#cb4-9"></a>        i += j;</span>
<span id="cb4-10"><a href="#cb4-10"></a>    }</span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="cf">return</span> i;</span>
<span id="cb4-13"><a href="#cb4-13"></a>}</span></code></pre></div>
<p></div></p>
<p>Ici, l’identificateur <code>i</code> a pour portée les lignes 3-13 mais dans les lignes 7-10 il y a un phénomène dit de masquage où la première définition est cachée par la seconde.</p>
<p>L’identificateur associé à une variable globale a pour portée l’ensemble des lignes suivant sa déclaration.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>En C, la portée d’un identificateur est <strong>statique</strong> : elle dépend uniquement du texte du programme au moment de la compilation.</p>
<p>En Python, la portée d’un identificateur est <strong>dynamique</strong> : elle peut dépendre de l’exécution d’un programme. Par exemple si on considère le programme Python</p>
<p><div class="ui segment compact" style="font-size:0.8em" ></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="cf">if</span> condition:</span>
<span id="cb5-2"><a href="#cb5-2"></a>    x <span class="op">=</span> <span class="dv">3</span></span></code></pre></div>
<p></div></p>
<p>La portée de l’identificateur <code>x</code> dépend ici du fait que la <code>condition</code> soit réalisée ou non.</div></p>
<h3 data-number="1.1.3" id="sec:durée-de-vie-dune-variable"><span class="header-section-number">1.1.3</span> Durée de vie d’une variable</h3>
<p><div class="ui message"><div class="header">Définition</div> La <strong>durée de vie</strong> d’une variable correspond à la période de son exécution durant laquelle la variable est présente en mémoire. </div></p>
<p>Sauf indication contraire, la durée de vie d’une variable locale en C est définie par la portée de l’identificateur qui lui est associé : la place est réservée au début de sa portée et libérée à la fin.</p>
<p>La dure de vie d’une variable globale est l’intégralité du programme. En effet, comme on a pu le voir dans la section sec. 1.1.1.</p>
<p>Il est possible de définir en C des variables locales dont la durée de vie dépasse sa portée. On parle alors de variables <em>statiques</em>. Ce point étant assez technique, il sera ignoré ici.</p>
<h3 data-number="1.1.4" id="sec:piles-dexécution-variables-locales-et-paramètres"><span class="header-section-number">1.1.4</span> Piles d’exécution, variables locales et paramètres</h3>
<p>On a vu qu’en raison de leur durée de vie, les variables globales étaient allouées dès le chargement du programme. Pour les variables locales ainsi que la mécanique des appels, on utilise une <strong>pile</strong>.</p>
<p>Cette pile d’exécution est représentée en mémoire par un tableau et un indicateur de fond de pile. <span id="marginnote4context"><span class="ui marginnote" id="marginnote4">En fait, il existe des architectures où les adresses sont croissantes. Ce qui importe est que le tas et la pile aient des comportements opposées pour qu’ils puissent grandir dans la même zone mémoire.</span></span></p>
<p>Le remplissage de ce tableau s’effectue souvent des adresses hautes vers les adresses faibles : on empile en faisant diminuer les adresses.</p>
<p>Un compilateur peut faire le choix d’utiliser directement des registres processeurs pour les variables locales ou pour passer des paramètres à une fonction. Ici, pour simplifier, on va supposer que ce n’est pas le cas et que tout passe par la pile d’exécution.</p>
<p>Lors d’un appel une fonction, on commence par empiler les paramètres, puis réserver une place pour la valeur de retour et enfin l’adresse à laquelle doit revenir l’exécution une fois que la fonction aura terminé son exécution.</p>
<p>Au début de l’exécution de cette fonction, on place sur la pile l’adresse du fond de pile et on déplace celui-ci pour réserver de la place pour les variables locales.</p>
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>

  </body>
</html>
