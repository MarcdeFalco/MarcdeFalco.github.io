<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Algorithmique avancée des graphes</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

.ui.styled.accordion {
    width: 100% !important;
    font-size: 1rem !important;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\gO{\mathcal{O}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Algorithmique avancée des graphes
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:arbre-couvrant-minimal"><span>1</span> Arbre couvrant minimal</a><div class="menu"><a class="item" href="#sec:présentation-du-problème"><div class="ui label">1.1</div> Présentation du problème</a><a class="item" href="#sec:algorithme-de-kruskal"><div class="ui label">1.2</div> Algorithme de Kruskal</a><a class="item" href="#sec:correction-de-lalgorithme-de-krusal"><div class="ui label">1.3</div> Correction de l’algorithme de Krusal</a><a class="item" href="#sec:complexité-de-lalgorithme-de-kruskal"><div class="ui label">1.4</div> Complexité de l’algorithme de Kruskal</a><a class="item" href="#sec:prim-todo"><div class="ui label">1.5</div> Prim ? TODO</a></div></div><div class="item header"> <a href="#sec:kosaraju-et-composantes-fortement-connexes"><span>2</span> Kosaraju et composantes fortement connexes</a><div class="menu"><a class="item" href="#sec:rappel-des-définitions"><div class="ui label">2.1</div> Rappel des définitions</a><a class="item" href="#sec:exemple"><div class="ui label">2.2</div> Exemple</a><a class="item" href="#sec:rappels-sur-le-parcours-en-profondeur"><div class="ui label">2.3</div> Rappels sur le parcours en profondeur</a><a class="item" href="#sec:graphe-miroir"><div class="ui label">2.4</div> Graphe miroir</a><a class="item" href="#sec:algorithme-de-kosaraju"><div class="ui label">2.5</div> Algorithme de Kosaraju</a></div></div><div class="item header"> <a href="#sec:couplage-maximal-dans-un-graphe-biparti"><span>3</span> Couplage maximal dans un graphe biparti</a><div class="menu"><a class="item" href="#sec:problème"><div class="ui label">3.1</div> Problème</a><a class="item" href="#sec:chemin-augmentant"><div class="ui label">3.2</div> Chemin augmentant</a><a class="item" href="#sec:déterminer-un-chemin-augmentant-dans-un-graphe-biparti"><div class="ui label">3.3</div> Déterminer un chemin augmentant dans un graphe biparti</a></div></div><div class="item header"> <a href="#sec:exercices"><span>4</span> Exercices</a><div class="menu"></div></div><div class="item header"> <a href="#sec:travaux-pratiques"><span>5</span> Travaux pratiques</a><div class="menu"><a class="item" href="#sec:algorithme-de-kosaraju-et-2-sat"><div class="ui label">5.1</div> Algorithme de Kosaraju et 2-SAT</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:kosarau"><i class="circle icon"></i> Kosarau</a></div><a class="item" href="#sec:couplage-maximal-dans-un-graphe-biparti-1"><div class="ui label">5.2</div> Couplage maximal dans un graphe biparti</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:graphe-biparti"><i class="circle icon"></i> Graphe biparti</a><a style="font-size:0.6em" class="item" href="#sec:couplage-maximal"><i class="circle icon"></i> Couplage maximal</a></div></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Algorithmique avancée des graphes
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Algorithmique avancée des graphes     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_algo_texte.jpg"> </div></p>
<p>On présente ici trois algorithmes qui complètent les notions vue sen
première année :</p>
<ul>
<li>le calcul d’un arbre couvrant de poids minimal dans un graphe
pondéré</li>
<li>le calcul des composantes fortement connexes dans un graphe
orienté</li>
<li>une notion de couplages maximale qui est un cas particulier d’un
problème plus général de flot maximal</li>
</ul>
<h1 data-number="1" id="sec:arbre-couvrant-minimal"><span
class="header-section-number">1</span> Arbre couvrant minimal</h1>
<h2 data-number="1.1" id="sec:présentation-du-problème"><span
class="header-section-number">1.1</span> Présentation du problème</h2>
<p>Description informelle : on a un ensemble de maisons reliées par es
routes, on cherche à poser des cables le long des routes pour que toute
paire de maison soit connectée. Quelle est la longueur minimale de cable
à utiliser ?</p>
<p>On comprend assez vite qu’il faut que les cables forment un graphe
connexe et que pour des questions de réduction de coût, on peut supposer
que les graphes sont acycliques. On cherche donc un arbre qui couvre
chaque maison dont la somme des poids des arrêtes, les longueurs des
cables, est minimale.</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(G = (S, A)\)</span> un graphe non orienté
connexe on dit que <span class="math inline">\(T \subset A\)</span> est
un arbre couvrant de <span class="math inline">\(G\)</span> lorsque
:</p>
<ul>
<li><span class="math inline">\(\forall x \in S, \exists a \in T, x \in
a\)</span> : chaque sommet appartient à au moins une arête dans <span
class="math inline">\(T\)</span></li>
<li><span class="math inline">\((S, T)\)</span> est un arbre,
c’est-à-dire que c’est un sous-graphe acyclique et connexe</li>
</ul>
<p>On notera ici <span class="math inline">\(\mathcal{T}(G)\)</span>
l’ensemble des arbres couvrants de <span
class="math inline">\(G\)</span>. </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>FIXME</p>
</div>
<p>Une manière naturelle d’obtenir un arbre couvrant est de faire un
parcours quelconque ou de calculer les composantes connexes avec une
structure union-find. Dans ce dernier cas, comme le graphe est connexe,
on obtiendra directement un unique arbre dans la forêt qui est un arbre
couvrant. C’est l’ordre de traitement des arêtes qui va aiguiller vers
un arbre de <span class="math inline">\(\mathcal{T}(G)\)</span> ou un
autre.</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(G = (S, A, w)\)</span> un graphe non orienté
connexe et pondéré par <span class="math inline">\(w : A \rightarrow
\R\)</span>, on note <span class="math inline">\(w(T) = \sum_{a \in T}
w(T)\)</span> le poids d’un arbre couvant de <span
class="math inline">\(G\)</span>.</p>
<p>Comme <span class="math inline">\(\mathcal{T}(G)\)</span> est fini,
il existe, au moins, un arbre <span class="math inline">\(T_0\)</span>
tel que <span class="math display">\[
w(T_0) = \min_{T \in \mathcal{T}(G)} w(T)
\]</span> On dit que <span class="math inline">\(T_0\)</span> est un
<strong>arbre couvrant de poids minimal</strong>. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>En anglais, on parle de <em>minimum spanning tree</em>.</p>
<p></div></p>
<h2 data-number="1.2" id="sec:algorithme-de-kruskal"><span
class="header-section-number">1.2</span> Algorithme de Kruskal</h2>
<p>Pour calculer un arbre couvrant de poids minimal, on va considérer le
calcul des composantes connexes avec une structure union-find mais en
traitant les arêtes dans l’ordre croissant de leurs poids : c’est
l’algorithme de Kruksal.</p>
<div class="ui message gray">
<div class="header">
Algorithme - Kruskal
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<p>Un graphe non orienté pondéré connexe <span class="math inline">\(G =
(S, A, w)\)</span>.</p>
</div>
<ul>
<li>Pour chaque <span class="math inline">\(x \in S\)</span>
<ul>
<li><code>makeset(x)</code></li>
</ul></li>
<li>On trie <span class="math inline">\(A\)</span> par ordre croissant
de poids.</li>
<li>Pour chaque <span class="math inline">\(\{x, y\} \in A\)</span> trié
<ul>
<li>Si <code>find(x)</code> <span class="math inline">\(\neq\)</span>
<code>find(y)</code></li>
<li>Alors <code>union(x,y)</code></li>
</ul></li>
<li>On renvoie l’unique arbre de la forêt.</li>
</ul>
</div>
<h2 data-number="1.3" id="sec:correction-de-lalgorithme-de-krusal"><span
class="header-section-number">1.3</span> Correction de l’algorithme de
Krusal</h2>
<p>On va montrer la correction d’une famille d’algorithme à laquelle
Kruskal appartient.</p>
<p><div class="ui message"><div class="header">Définition</div> On dit
que <span class="math inline">\(T\)</span> est une forêt minimale de
<span class="math inline">\(G\)</span> s’il existe <span
class="math inline">\(T&#39;\)</span> arbre couvrant de poids minimal de
<span class="math inline">\(G\)</span> tel que <span
class="math inline">\(T \subset T&#39;\)</span>. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p><span class="math inline">\(\emptyset\)</span> est ainsi une forêt
minimale.</p>
<p></div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(T\)</span> une forêt minimale et <span
class="math inline">\(a \in A\)</span>. On dit que <span
class="math inline">\(a\)</span> est une arête <strong>sûre</strong> si
<span class="math inline">\(T \cup \{ a\}\)</span> est encore une forêt
minmale. </div></p>
<div class="ui message olive">
<div class="header">
Lemme
</div>
<p>Soit <span class="math inline">\(T\)</span> une forêt minimale qui
n’est pas un arbre couvrant, il existe une arête sûre <span
class="math inline">\(a\)</span> telle que <span
class="math inline">\(T\cup \{a\}\)</span> soit encore une forêt
minimale.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Comme <span
class="math inline">\(T\)</span> est une forêt minimale, il existe <span
class="math inline">\(T&#39;\)</span> arbre couvrant de poids minimal
tel que <span class="math inline">\(T\subset T&#39;\)</span>. Comme
<span class="math inline">\(T\)</span> lui-même n’est pas un arbre
couvrant, il existe <span class="math inline">\(a \in T&#39; \backslash
T\)</span>. Ona alors <span class="math inline">\(T \cup \{ a\} \subset
T&#39;\)</span> donc <span class="math inline">\(a\)</span> est une
arête sûre. </div> </div></p>
<p>On en déduit un proto-algorithme de calcul d’un arbre couvrant de
poids minimal :</p>
<div class="ui message gray">
<div class="header">
Algorithme - ArbreMinQuelconque
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<p>Un graphe non orienté pondéré connexe <span class="math inline">\(G =
(S, A, w)\)</span>.</p>
</div>
<ul>
<li>On pose <span class="math inline">\(T = \emptyset\)</span></li>
<li>Tant que <span class="math inline">\(T\)</span> n’est pas un
arbre-couvrant
<ul>
<li>Déterminer une arête sûre <span class="math inline">\(a \in
E\)</span></li>
<li><span class="math inline">\(T := T \cup \{ a\}\)</span></li>
</ul></li>
<li>Renvoyer <span class="math inline">\(T\)</span></li>
</ul>
</div>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Cet algorithme renvoie un arbre couvrant de poids minimal.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Cet algorithme vérifie directement
l’invariant suivant : <span class="math inline">\(T\)</span> est une
forêt minimale. En effet, le choix d’une arête sûre permet de prolonger
l’invariant.</p>
<p>Cet algorithme termine car il n’existe qu’un nombre fini d’arêtes à
ajouter et comme une arête sûre ne peut pas l’être une fois qu’on l’a
rajoutée, on ne peut pas faire plus d’itérations que le nombre
d’arêtes.</p>
<p>L’algorithme renvoie donc un arbre couvrant de poids minimal.
</div> </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il s’agit d’un proto-algorithme car la partie critique est de
déterminer une arête sûre et c’est la partie qui n’est pas explicitée
pour le moment.</p>
<p></div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Si <span class="math inline">\(F\)</span> est une forêt minimale non
couvrante et <span class="math inline">\(e\)</span> l’arête de plus
petit poids reliant deux arbres de <span
class="math inline">\(F\)</span>, alors <span
class="math inline">\(e\)</span> est sûre pour <span
class="math inline">\(F\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Comme <span
class="math inline">\(F\)</span> est une forêt minimale, il existe <span
class="math inline">\(T\)</span> arbre couvrant de poids minimal tel que
<span class="math inline">\(F \subset T\)</span>.</p>
<p>Soit <span class="math inline">\(e \in T\)</span>, auquel cas <span
class="math inline">\(F \cup \{ e\} \subset T\)</span> est encore iune
forêt minimale. Soit <span class="math inline">\(e \not \in T\)</span>
et comme <span class="math inline">\(T\)</span> est un arbre, <span
class="math inline">\(T \cup \{e \}\)</span> possède un cycle. On sait
que <span class="math inline">\(F \cup \{e\}\)</span> est encore une
forêt, donc ce cycle contient nécessairement une arête <span
class="math inline">\(e&#39; \in T\backslash F\)</span>.</p>
<p>Par minimalité, <span class="math inline">\(w(e&#39;) \ge
w(e)\)</span>. Si on pose <span class="math inline">\(T&#39; = (T
\backslash \{ e&#39;\})\cup \{ e\}\)</span> alors <span
class="math inline">\(T&#39;\)</span> est un arbre couvrant car comme
l’ajout de <span class="math inline">\(e\)</span> à <span
class="math inline">\(T\)</span> induit un cycle contenant <span
class="math inline">\(e&#39;\)</span>, les deux sommets de <span
class="math inline">\(e&#39;\)</span> sont couverts par des arêtes dans
ce cycle prive de <span class="math inline">\(e&#39;\)</span>. On en
déduit de même que <span class="math inline">\(T&#39;\)</span> est
connexe.</p>
<p><span class="math inline">\(T&#39;\)</span> est nécessairement
acyclique car on a cassé le seul cycle contenu dans <span
class="math inline">\(T \cup \{ e\}\)</span> en enlevant <span
class="math inline">\(e&#39;\)</span>.</p>
<p>Reste que <span class="math inline">\(w(T&#39;) = w(T) - w(e&#39;)
+w(e) \le w(T)\)</span> donc <span class="math inline">\(T&#39;\)</span>
est un arbre couvrant de poids minimal.</p>
<p>Ainsi <span class="math inline">\(F \cup \{ e \} \subset
T&#39;\)</span> est une forêt minimale et <span
class="math inline">\(e\)</span> est sûre. </div> </div></p>
<p>Comme <span class="math inline">\(\emptyset\)</span> est une forêt
minimale, on vient de valider l’invariant pour Kruskal qui est que la
forêt disjointe est une forêt minimale.</p>
<div class="ui message olive">
<div class="header">
Corollaire
</div>
<p>Kruskal renvoie un arbre couvrant de poids minimal.</p>
</div>
<h2 data-number="1.4"
id="sec:complexité-de-lalgorithme-de-kruskal"><span
class="header-section-number">1.4</span> Complexité de l’algorithme de
Kruskal</h2>
<p>On peut décomposer l’algorithme :</p>
<ul>
<li>La création avec <code>makeset</code> est en <span
class="math inline">\(O(|S|)\)</span></li>
<li>Le tri des arêtes est en <span class="math inline">\(O(|A| \log
|A|)\)</span>.</li>
<li>La boucle est en <span class="math inline">\(O(|A|
\alpha(|S|))\)</span> avec <span class="math inline">\(\alpha(|S|) =
o(\log |A|)\)</span></li>
</ul>
<p>Comme <span class="math inline">\(G\)</span> est connexe, on a <span
class="math inline">\(|A| \ge |S|-1\)</span> et ainsi <span
class="math inline">\(|S| = O(|A|)\)</span>. Ainsi la complexité global
est en <span class="math inline">\(O(|A|\log |A|)\)</span>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Kruskal fait partie de ces algorithmes qui sont linéaires après avoir
fait un tri. C’est un cas que l’on a déjà vu avec les algorithmes
gloutons. D’ailleurs, on peut dire que Kruskal est un choix glouton
d’arête sûre.</p>
<p></div></p>
<h2 data-number="1.5" id="sec:prim-todo"><span
class="header-section-number">1.5</span> Prim ? TODO</h2>
<h1 data-number="2"
id="sec:kosaraju-et-composantes-fortement-connexes"><span
class="header-section-number">2</span> Kosaraju et composantes fortement
connexes</h1>
<h2 data-number="2.1" id="sec:rappel-des-définitions"><span
class="header-section-number">2.1</span> Rappel des définitions</h2>
<p>Soit <span class="math inline">\(G = (S,A)\)</span> un graphe
<strong>orienté</strong> on note, pour <span class="math inline">\(x, y
\in S\)</span>, <span class="math inline">\(x\leadsto y\)</span> quand
il existe un chemin dans <span class="math inline">\(G\)</span> reliant
<span class="math inline">\(x\)</span> à <span
class="math inline">\(y\)</span>. On dit que <span
class="math inline">\(y\)</span> est <em>accessible</em> depuis <span
class="math inline">\(x\)</span>.</p>
<p>On note <span class="math inline">\(x \leftrightarrow y \iff
x\leadsto y \wedge y \leadsto x\)</span>. C’est la restriction
symétrique de <span class="math inline">\(\leadsto\)</span>. Comme <span
class="math inline">\(\leadsto\)</span> est réflexive et transitive,
alors <span class="math inline">\(\leftrightarrow\)</span> est une
relation d’équivalence. Les classes d’équivalences pour <span
class="math inline">\(\leftrightarrow\)</span> sont appelées les
<strong>composantes fortement connexes</strong> de <span
class="math inline">\(G\)</span>. On les note <span
class="math inline">\(CFC(G) = S / \leftrightarrow\)</span>.</p>
<p>Par exemple, sur le graphe :</p>
<p><center><div class="ui image center"><img
src="assets/pics/cfc_ex1.png" /></div></center></p>
<p>On a les deux composantes fortement connexes <span
class="math inline">\(\{a,b,c\}\)</span> et <span
class="math inline">\(\{d,e\}\)</span>.</p>
<p>On remarque une différence fondamentale avec les composantes
connexes, c’est qu’il peut il y avoir des arrêtes entre deux composantes
fortement connexes.</p>
<p>On cherche ici à déterminer un algorithme pour calculer les
composanges fortement connexes d’un graphe.</p>
<h2 data-number="2.2" id="sec:exemple"><span
class="header-section-number">2.2</span> Exemple</h2>
<p>TODO voir cours</p>
<h2 data-number="2.3"
id="sec:rappels-sur-le-parcours-en-profondeur"><span
class="header-section-number">2.3</span> Rappels sur le parcours en
profondeur</h2>
<p>Comme on vient de le voir, le parcours en profondeur et ses temps
d’entrée et de sorties sont très importants ici. On va donc faire des
rappels sur ces notions.</p>
<p>On considère le programme suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> statut = Inconnu | EnTraitement | Traite</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">type</span> etat_dfs = {</span>
<span id="cb1-4"><a href="#cb1-4"></a>    statut : statut <span class="dt">array</span>;</span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="kw">mutable</span> clock : <span class="dt">int</span>;</span>
<span id="cb1-6"><a href="#cb1-6"></a>    entree : <span class="dt">int</span> <span class="dt">array</span>;</span>
<span id="cb1-7"><a href="#cb1-7"></a>    sortie : <span class="dt">int</span> <span class="dt">array</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>}</span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">let</span> tick etat =</span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="kw">let</span> t = etat.clock <span class="kw">in</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    etat.clock &lt;- t+<span class="dv">1</span>;</span>
<span id="cb1-13"><a href="#cb1-13"></a>    t</span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="kw">let</span> <span class="kw">rec</span> dfs ladj etat x =</span>
<span id="cb1-16"><a href="#cb1-16"></a>    <span class="kw">if</span> etat.statut.(x) &lt;&gt; Traite</span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>        etat.statut.(x) &lt;- EnTraitement;</span>
<span id="cb1-19"><a href="#cb1-19"></a>        etat.entree.(x) &lt;- tick etat;</span>
<span id="cb1-20"><a href="#cb1-20"></a>        <span class="dt">List</span>.iter (<span class="kw">fun</span> y -&gt;</span>
<span id="cb1-21"><a href="#cb1-21"></a>            <span class="kw">if</span> etat.statut.(y) = Inconnu</span>
<span id="cb1-22"><a href="#cb1-22"></a>            <span class="kw">then</span> dfs ladj etat y) ladj.(x);</span>
<span id="cb1-23"><a href="#cb1-23"></a>        etat.sortie.(x) &lt;- tick etat;</span>
<span id="cb1-24"><a href="#cb1-24"></a>        etat.statut.(x) &lt;- Traite</span>
<span id="cb1-25"><a href="#cb1-25"></a>    <span class="kw">end</span></span>
<span id="cb1-26"><a href="#cb1-26"></a></span>
<span id="cb1-27"><a href="#cb1-27"></a><span class="kw">let</span> initialise_dfs ladj =</span>
<span id="cb1-28"><a href="#cb1-28"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length ladj <span class="kw">in</span></span>
<span id="cb1-29"><a href="#cb1-29"></a>    {</span>
<span id="cb1-30"><a href="#cb1-30"></a>        statut = <span class="dt">Array</span>.make n Inconnu;</span>
<span id="cb1-31"><a href="#cb1-31"></a>        clock = <span class="dv">1</span>;</span>
<span id="cb1-32"><a href="#cb1-32"></a>        entree = <span class="dt">Array</span>.make n <span class="dv">0</span>;</span>
<span id="cb1-33"><a href="#cb1-33"></a>        sortie = <span class="dt">Array</span>.make n <span class="dv">0</span></span>
<span id="cb1-34"><a href="#cb1-34"></a>    }</span></code></pre></div>
<p></div></p>
<p>Le temps d’entrée est le moment où commence à traiter un sommet et
son temps de sortie est le moment où on a fini de le traiter car on a vu
tous ses descendants. On notera ici <span
class="math inline">\(t_e(x)\)</span> le temps d’entrée de <span
class="math inline">\(x\)</span> et <span
class="math inline">\(t_s(x)\)</span> son temps de sortie.</p>
<p><div class="ui message"><div class="header">Définition</div> On
considère un DFS d’un graphe <span class="math inline">\(G =
(S,A)\)</span> et <span class="math inline">\(x \in S\)</span> découvert
par ce parcours.</p>
<p>Soit <span class="math inline">\(y \in S\)</span>, on dit que <span
class="math inline">\(y\)</span> est accesible par un chemin inconnu
depuis <span class="math inline">\(x\)</span> s’il existe un chemin de
<span class="math inline">\(x\)</span> à <span
class="math inline">\(y\)</span> ne passant que par des sommets de
statut <code>Inconnu</code> au moment où on lance le DFS en <span
class="math inline">\(x\)</span>. On note <span class="math inline">\(x
\leadsto_I y\)</span>. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><span class="math inline">\(x \leadsto_I y\)</span> si et seulement
si l’appel à DFS depuis <span class="math inline">\(x\)</span> va
appeler DFS sur <span class="math inline">\(y\)</span> avant de se
résoudre.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> * <span
class="math inline">\(\Rightarrow\)</span>) : On va raisonner par
récurrence sur la longueur du chemin inconnu.</p>
<pre><code>* Initialisation : si le chemin inconnu est vide, c&#39;est direct.
* Hérédité : si $x \leadsto_I z \rightarrow y$ avec $y$ inconnu et l&#39;hypothèse
  de récurrence valide pour $x \leadsto_I z$ alors au moment
  de l&#39;appel au DFS sur $z$, on va forcément faire un appel au DFS sur $y$,
  voisin inconnu de $z$.</code></pre>
<ul>
<li><span class="math inline">\(\Leftarrow\)</span>) : si on considère
la chaîne des appels qui ont mené jusqu’à <span
class="math inline">\(y\)</span>, vu la condition sur le statut, ce sont
nécessairement tous des sommets inconnus et ils forment un chemin, qui
est donc un chemin inconnu. </div> </div></li>
</ul>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soient <span class="math inline">\(x, y \in S\)</span> tels que <span
class="math inline">\(t_e(x) &lt; t_e(y)\)</span>.</p>
<p>Si <span class="math inline">\(x \leadsto_I y\)</span>, alors <span
class="math inline">\(t_f(y) &lt; t_f(x)\)</span>.</p>
<p>Sinon, <span class="math inline">\(t_f(x) &lt; t_e(y)\)</span>.</p>
</div>
<p>Autrement dit, soit <span class="math inline">\([t_e(y);t_f(y)]
\subset [t_e(x);t_f(x)]\)</span>, soit <span
class="math inline">\([t_e(y);t_f(y)] \cap [t_e(x);t_f(x)] =
\emptyset\)</span>.</p>
<p>On dit que les temps sont bien parenthésés. En effet, si on considère
le mot sur <span class="math inline">\(S\)</span> avec les lettres <span
class="math inline">\((_x\)</span> et <span
class="math inline">\()_x\)</span> pour chaque sommet <span
class="math inline">\(x\)</span> et tel qu’on écrive la lettre <span
class="math inline">\((_x\)</span> quand on note le temps d’entrée et
<span class="math inline">\()_x\)</span> quand on note le temps de
sortie, alors ce mot est bien parenthésé.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Sur l’exemple du graphe précédent (TODO ref précise) on pourrait
avoir le mot <span
class="math inline">\((_a(_b(_c(_d(_e)_e)_d)_c)_b)_a\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Comme <span
class="math inline">\(t_e(x) &lt; t_e(y)\)</span>, c’est qu’on a
commencé le parcours en <span class="math inline">\(x\)</span> avant de
le commencer en <span class="math inline">\(y\)</span>. i <span
class="math inline">\(x \leadsto_I y\)</span> alors par le théorème
précédent, on appelle le DFS sur <span class="math inline">\(y\)</span>
depuis l’appel du DFS sur <span class="math inline">\(x\)</span>, donc
le premier terminera avant le second et ainsi <span
class="math inline">\(t_f(y) &lt; t_f(x)\)</span>.</p>
<p>Sinon, il n’est pas possible de rencontrer <span
class="math inline">\(y\)</span> en résolvant le DFS de <span
class="math inline">\(x\)</span>, donc on aura forcément fini de traiter
<span class="math inline">\(x\)</span> avant de commencer le parcours en
<span class="math inline">\(y\)</span>. Donc <span
class="math inline">\(t_f(x) &lt; t_e(y)\)</span>. </div> </div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(C \in CFC(G)\)</span>, on note</p>
<p><span class="math display">\[
t_e(C) = \min\enscomp{t_e(x)}{x \in C}
\]</span> <span class="math display">\[
t_f(C) = \max\enscomp{t_f(x)}{x \in C}
\]</span> </div></p>
<p>On a alors une propriété de parenthésage des temps sur les
composantes fortement connexes elles-mêmes.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soient <span class="math inline">\(C, C&#39; \in CFC(G)\)</span>.</p>
<p>S’il existe <span class="math inline">\(x \in C, y \in
C&#39;\)</span> avec <span class="math inline">\(x \rightarrow
y\)</span>, alors <span class="math inline">\(t_f(C&#39;) &lt;
t_f(C)\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> On suppose qu’il existe <span
class="math inline">\(x \in C, y \in C&#39;\)</span> avec <span
class="math inline">\(x \rightarrow y\)</span>.</p>
<p>Premier cas, <span class="math inline">\(t_e(C) &lt;
t_e(C&#39;)\)</span>. On considère <span class="math inline">\(u \in
C\)</span> tel que <span class="math inline">\(t_e(C) = t_e(u)\)</span>.
On a alors forcément <span class="math inline">\(u \leadsto_I v\)</span>
pour tout <span class="math inline">\(v \in C \cup C&#39;\)</span>, en
passant par <span class="math inline">\(x \rightarrow y\)</span>. Ainsi
<span class="math inline">\(x\)</span> finit son DFS après tous les
sommets dans <span class="math inline">\(C \cup C&#39;\)</span> donc
<span class="math inline">\(t_f(C) = t_f(x)
&gt;t_f(C&#39;)\)</span>.</p>
<p>Second cas, <span class="math inline">\(t_e(C) &gt;
t_e(C&#39;)\)</span> si <span class="math inline">\(u \in
C&#39;\)</span> tel que <span class="math inline">\(t_e(u) =
t_e(C&#39;)\)</span> alors on a visité tous les sommets de <span
class="math inline">\(C&#39;\)</span> depuis <span
class="math inline">\(u\)</span>, donc <span
class="math inline">\(t_f(u) = t_f(C&#39;)\)</span> et on n’a rencontré
aucun sommet de <span class="math inline">\(c\)</span> car <span
class="math inline">\(x \rightarrow y\)</span> implique qu’il ne peut
exister une arête de <span class="math inline">\(C&#39;\)</span> vers
<span class="math inline">\(C\)</span>. On a bien <span
class="math inline">\(t_f(C) &gt; t_f(C&#39;)\)</span>.
</div> </div></p>
<h2 data-number="2.4" id="sec:graphe-miroir"><span
class="header-section-number">2.4</span> Graphe miroir</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(G = (S,A)\)</span> un graphe orienté, on
appelle <strong>graphe miroir</strong> de <span
class="math inline">\(G\)</span> le graphe <span
class="math inline">\(G^R = (S,A^R)\)</span> où <span
class="math display">\[
\forall x, y \in S, (x,y) \in A \iff (y,x) \in A^R
\]</span> </div></p>
<p>Cela revient à renverser toutes les flèches du graphe <span
class="math inline">\(G\)</span>.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><span class="math inline">\(CFC(G) = CFC(G^R)\)</span></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> On remarque que la relation <span
class="math inline">\(x \leftrightarrow_G y \iff x \leftrightarrow_{G^R}
y\)</span>. Les deux relations ont donc <em>a fortiori</em> les mêmes
classes d’équivalence. </div> </div></p>
<h2 data-number="2.5" id="sec:algorithme-de-kosaraju"><span
class="header-section-number">2.5</span> Algorithme de Kosaraju</h2>
<div class="ui message gray">
<div class="header">
Algorithme - Kosaraju
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<p>Un graphe orienté <span class="math inline">\(G = (S,A)\)</span></p>
</div>
<ul>
<li>On initialise l’état d’un DFS pour <span
class="math inline">\(G\)</span>.</li>
<li>Tant qu’il y a des sommets inconnus, on lance un DFS depuis un
sommet inconnu.</li>
<li>On trie <span class="math inline">\(S\)</span> par <strong>ordre
décroissant</strong> de temps de sortie.</li>
<li>On initialise l’état d’un DFS pour <span
class="math inline">\(G^R\)</span>.</li>
<li><span class="math inline">\(Comp \leftarrow \emptyset\)</span></li>
<li>Tant qu’il y a un sommet inconnu <span
class="math inline">\(x\)</span>
<ul>
<li>On lance un DFS dans <span class="math inline">\(G^R\)</span> à
partir de <span class="math inline">\(x\)</span> en notant les nouveaux
sommets traités dans la liste <span
class="math inline">\(C\)</span>.</li>
<li><span class="math inline">\(Comp \leftarrow Comp \cup \{ C
\}\)</span></li>
</ul></li>
<li>On renvoie <span class="math inline">\(Comp\)</span>.</li>
</ul>
</div>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><span class="math inline">\(Comp = CFC(G)\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Il suffit de montrer l’invariant
<span class="math inline">\(Comp \subset CFC(G)\)</span> pour la
dernière boucle. Au départ, comme <span class="math inline">\(Comp =
\emptyset\)</span> il est trivialement vérifié et à la fin, comme on
aura traité tous les sommets, on aura nécessairement <span
class="math inline">\(Comp = CFC(G)\)</span>.</p>
<p>Supposons donc qu’on a <span class="math inline">\(Comp \subset
CFC(G)\)</span> et qu’on relance un parcours dans <span
class="math inline">\(G^R\)</span> à partir de <span
class="math inline">\(x\)</span>. On sait que la composante <span
class="math inline">\(\overline{x}\)</span> contenant <span
class="math inline">\(x\)</span> est forcément dans les sommets que l’on
va traiter : <span class="math inline">\(\overline{x} \subset
C\)</span>. Si, par l’absurde, il existe un sommet <span
class="math inline">\(y \in C \backslash \overline{x}\)</span>, alors
<span class="math inline">\(y\)</span> est dans une autre composante
<span class="math inline">\(\overline{y}\)</span>. On a traité <span
class="math inline">\(y\)</span> depuis <span
class="math inline">\(x\)</span>, donc <span
class="math inline">\(t_e(x) &lt; t_e(y)\)</span>. Comme <span
class="math inline">\(x \leadsto y\)</span>, on a par le théorème
précédent <span class="math inline">\(t_f(y) &lt; t_f(x)\)</span>. On a
donc traité la composante <span
class="math inline">\(\overline{y}\)</span> dans un parcours précédent
et donc <span class="math inline">\(y\)</span> est traité.
Contradiction. </div> </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>La complexité de cet algorithme est dominée par les deux itérations
de DFS, on est donc en <span
class="math inline">\(O(|S|+|A|)\)</span>.</p>
<p></div></p>
<h1 data-number="3"
id="sec:couplage-maximal-dans-un-graphe-biparti"><span
class="header-section-number">3</span> Couplage maximal dans un graphe
biparti</h1>
<h2 data-number="3.1" id="sec:problème"><span
class="header-section-number">3.1</span> Problème</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(G= (S,A)\)</span> un graphe non orienté, on
appelle <strong>couplage</strong> de <span
class="math inline">\(G\)</span> une partie <span
class="math inline">\(C \subset A\)</span> telle que <span
class="math inline">\(\forall e, e&#39; \in C, e \cap e&#39; =
\emptyset\)</span>.</p>
<p>On dit qu’un couplage est <strong>maximal</strong> pour <span
class="math inline">\(G\)</span> quand il est de cardinal maximal.
</div></p>
<p>Rappel :</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(G= (S,A)\)</span> un graphe non orienté, on
dit que <span class="math inline">\(G\)</span> est
<strong>biparti</strong> lorsqu’il existe <span
class="math inline">\(S_1, S_2 \subset S\)</span> avec <span
class="math inline">\(S_1 \cup S_2 = S\)</span> et <span
class="math inline">\(S_1 \cap S_2 = \emptyset\)</span> et toutes les
arêtes relient un sommet de <span class="math inline">\(S_1\)</span> et
un sommet de <span class="math inline">\(S_2\)</span>. </div></p>
<p>On se pose alors la question de déterminer un couplage maximal dans
un graphe biparti. C’est un problème classique d’appariement. On peut
ainsi citer le cas où on a des élèves et des écoles. On met une arête
entre un élève et une école quand les deux veulent de l’autre. Un
couplage maximal est alors une manière de placer le maximum d’élèves
dans une école.</p>
<h2 data-number="3.2" id="sec:chemin-augmentant"><span
class="header-section-number">3.2</span> Chemin augmentant</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(C\)</span> un couplage d’un graphe et <span
class="math inline">\(x\)</span> un sommet. On dit que <span
class="math inline">\(x\)</span> est libre <strong>vis-à-vis</strong> de
<span class="math inline">\(C\)</span> si <span
class="math inline">\(x\)</span> n’appartient pas à une arête de <span
class="math inline">\(C\)</span>. </div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(C \subset A\)</span> un couplage d’un
graphe.</p>
<p>Un chemin de <span class="math inline">\(x\)</span> à <span
class="math inline">\(y\)</span> composé des arêtes <span
class="math inline">\((e_1,\dots,e_{2n+1})\)</span> est dit
<strong>augmentant</strong> si les arêtes pairs <span
class="math inline">\(e_{2i} \in C\)</span>, les arêtes impaires <span
class="math inline">\(e_{2i+1} \not\in C\)</span> et <span
class="math inline">\(x\)</span> et <span
class="math inline">\(y\)</span> sont libres pour <span
class="math inline">\(C\)</span>. </div></p>
<div class="ui message olive">
<div class="header">
Lemme
</div>
<p>Soit <span class="math inline">\(C, C&#39;\)</span> des couplages de
<span class="math inline">\(G = (S,A)\)</span>. On considère <span
class="math inline">\(G&#39; = (S, C \Delta C&#39;)\)</span>.</p>
<p>Les composantes connexes de <span
class="math inline">\(G&#39;\)</span> sont :</p>
<ul>
<li>soit des sommets isolés</li>
<li>soit des cycles <strong>de longueur paire</strong> alternant entre
arêtes de <span class="math inline">\(C\)</span> et <span
class="math inline">\(C&#39;\)</span></li>
<li>soit des chemins alternant entre <span
class="math inline">\(C\)</span> et <span
class="math inline">\(C&#39;\)</span> ayant des extremités
distinctes.</li>
</ul>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Il suffit de remarquer que les
sommets de <span class="math inline">\(G&#39;\)</span> sont de degré au
plus 2 car ils sont de degré au plus 1 dans <span
class="math inline">\((S,C)\)</span> et <span
class="math inline">\((S,C&#39;)\)</span>.</p>
<p>De plus, comme les arêtes d’un couplage ne peuvent avoir des
extrémités en commun un chemin devra forcément alterner entre arêtes de
<span class="math inline">\(C\)</span> et de <span
class="math inline">\(C&#39;\)</span>. Les cycles sont donc
nécessairement de longueur paire. </div> </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>(Bergé 1957) <span class="math inline">\(C\)</span> n’a pas de chemin
augmentant, ssi <span class="math inline">\(C\)</span> est un couplage
maximal.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> On va montrer la contraposée : <span
class="math inline">\(C\)</span> non maximal ssi <span
class="math inline">\(C\)</span> a un chemin augmentant.</p>
<p><span class="math inline">\(\Leftarrow\)</span>) Supposons que <span
class="math inline">\(G\)</span> dispose d’un chemin augmentant <span
class="math inline">\(\varphi\)</span>, on considère <span
class="math inline">\(C&#39;\)</span> différence symétrique de <span
class="math inline">\(C\)</span> et des arêtes dans <span
class="math inline">\(\varphi\)</span>. Ainsi, <span
class="math inline">\(C&#39;\)</span> contient les arêtes de <span
class="math inline">\(\varphi\)</span> qui ne sont pas dans <span
class="math inline">\(C\)</span>, comme <span
class="math inline">\(\varphi\)</span> commence et finit avec des arêtes
qui ne sont pas dans <span class="math inline">\(C\)</span>, <span
class="math inline">\(C&#39;\)</span> a une arête de plus que <span
class="math inline">\(C\)</span>.</p>
<p>De plus, comme <span class="math inline">\(\varphi\)</span> est
élémentaire et qu’ils relient deux sommets libres, on a l’assurance que
<span class="math inline">\(C&#39;\)</span> est un couplage. Ainsi <span
class="math inline">\(C\)</span> n’est pas maximal.</p>
<p><span class="math inline">\(\Rightarrow\)</span>) Supposons que <span
class="math inline">\(C\)</span> non maximal, il existe <span
class="math inline">\(C&#39;\)</span> tel que <span
class="math inline">\(|C&#39;|&gt;|C|\)</span> et si on considère <span
class="math inline">\(G&#39; = (S, C \Delta C&#39;)\)</span>, il a une
composante qui contient au moins une arête de plus dans <span
class="math inline">\(C&#39;\)</span> que dans <span
class="math inline">\(C\)</span>. Ça ne peut donc être un cycle et c’est
un chemin qui est par construction augmentant pour <span
class="math inline">\(C\)</span>. </div> </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il s’agit ici d’un cas particulier du théorème de Bergé.</p>
<p></div></p>
<h2 data-number="3.3"
id="sec:déterminer-un-chemin-augmentant-dans-un-graphe-biparti"><span
class="header-section-number">3.3</span> Déterminer un chemin augmentant
dans un graphe biparti</h2>
<p>On considère ici un graphe biparti avec <span class="math inline">\(S
= S_1 \cup S_2\)</span>.</p>
<p>Pour déterminer un chemin augmentant pour <span
class="math inline">\(C\)</span>, on considère une orientation des
arêtes <span class="math inline">\(\{x,y\}\)</span> ainsi :</p>
<ul>
<li><span class="math inline">\(x \rightarrow y\)</span> si <span
class="math inline">\(x \in S_2, y \in S_1\)</span> et <span
class="math inline">\((x,y) \in C\)</span>.</li>
<li><span class="math inline">\(y \rightarrow x\)</span> sinon</li>
</ul>
<p>On rajoute également deux sommets :</p>
<ul>
<li>un sommet source noté <span class="math inline">\(s\)</span> avec
<span class="math inline">\(s \rightarrow x\)</span> pour tout sommet
<strong>libre</strong> dans <span
class="math inline">\(S_1\)</span></li>
<li>un sommet but noté <span class="math inline">\(t\)</span> avec <span
class="math inline">\(x \rightarrow t\)</span> pour tout sommet
<strong>libre</strong> dans <span
class="math inline">\(S_2\)</span>.</li>
</ul>
<p>On remarque qu’un sommet non libre <span
class="math inline">\(y\)</span> de <span
class="math inline">\(S_2\)</span> est nécessairement de degré 1 et avec
une arête <span class="math inline">\(y \rightarrow x\)</span> où <span
class="math inline">\(x\)</span> non libre et <span
class="math inline">\(\{x,y\} \in C\)</span>.</p>
<p>S’il existe un chemin de <span class="math inline">\(s \leadsto
t\)</span> dans ce graphe orienté, alors il est de la forme :</p>
<p><span class="math display">\[s \rightarrow x_1 \rightarrow y_1 \dots
\rightarrow y_n \rightarrow t\]</span></p>
<p>avec :</p>
<ul>
<li><span class="math inline">\(x_1\)</span> libre dans <span
class="math inline">\(S_1\)</span></li>
<li><span class="math inline">\(y_n\)</span> libre dans <span
class="math inline">\(S_2\)</span></li>
<li>tous les autre <span class="math inline">\(x_i\)</span> et <span
class="math inline">\(y_j\)</span> sont non libres (ok) et deux à deux
distincts (pas facile là !)</li>
<li><span class="math inline">\(\{x_i,y_i\}\not \in C\)</span></li>
<li><span class="math inline">\(\{y_i,x_{i+1}\} \in C\)</span></li>
</ul>
<p>Le chemin est donc augmentant</p>
<h1 data-number="4" id="sec:exercices"><span
class="header-section-number">4</span> Exercices</h1>
<div class="ui message orange">
<div class="header">
Exercice
</div>
<p>On considère un chemin entre deux sommets <span
class="math inline">\(x\)</span> et <span
class="math inline">\(y\)</span> dans un graphe non orienté pondéré. La
largeur de ce chemin est le plus petit poids des arêtes présentes dans
ce chemin. Le chemin vide de <span class="math inline">\(x\)</span> à
<span class="math inline">\(x\)</span> est de largeur <span
class="math inline">\(+\infty\)</span>.</p>
<p>La distance de goulot d’étranglement entre <span
class="math inline">\(x\)</span> et <span
class="math inline">\(y\)</span> est la largeur maximale d’un chemin de
<span class="math inline">\(x\)</span> à <span
class="math inline">\(y\)</span>. S’il n’en existe pas, cette distance
est <span class="math inline">\(-\infty\)</span>.</p>
<ol type="1">
<li>Prouver que l’arbre couvrant de poids <strong>maximal</strong>
contient les chemins les plus larges entre toute paire de sommets.</li>
<li>Décrire un algorithme pour résoudre en temps <span
class="math inline">\(O(|S|+|A|)\)</span> le problème suivant : étant
donné un graphe non orienté pondéré <span class="math inline">\(G =
(S,A)\)</span>, <span class="math inline">\(x, y \in S\)</span> et <span
class="math inline">\(W \in \R\)</span>, est-ce que le distance de
goulot d’étranglement entre <span class="math inline">\(x\)</span> et
<span class="math inline">\(y\)</span> est inférieure ou égale à <span
class="math inline">\(W\)</span>.</li>
<li>On suppose que la distance de goulot d’étranglement entre <span
class="math inline">\(x\)</span> et <span
class="math inline">\(y\)</span> est <span
class="math inline">\(B\)</span>.
<ol type="1">
<li>Prouver que la suppression d’une arête de poids inférieur à <span
class="math inline">\(B\)</span> ne change pas cette distance.</li>
<li>Prouver que la contraction d’une arête de poids plus grand que <span
class="math inline">\(B\)</span> ne change pas cette distance. La
contraction d’une arête <span class="math inline">\((u,v)\)</span>
revient à identifier <span class="math inline">\(u\)</span> et <span
class="math inline">\(v\)</span>, si cette contraction crée des arêtes
parallèles, on ne conservera que l’arête de plus grand poids.</li>
</ol></li>
</ol>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"></p>
<ol type="1">
<li>On considère un arbre couvrant maximal <span
class="math inline">\(T\)</span> et deux sommets <span
class="math inline">\(x,y\)</span>. Supposons par l’absurde que <span
class="math inline">\(T\)</span> ne contienne pas le chemin le plus
large de <span class="math inline">\(x\)</span> à <span
class="math inline">\(y\)</span>. On considère alors le chemin dans
<span class="math inline">\(T\)</span> entre <span
class="math inline">\(x\)</span> et <span
class="math inline">\(y\)</span>, son arête de plus petit poids est
<span class="math inline">\(e = \{ a, b\}\)</span>. On considère <span
class="math inline">\(T&#39; = T \backslash\{e\}\)</span> qui n’est plus
connexe. Le chemin le plus large entre <span
class="math inline">\(x\)</span> et <span
class="math inline">\(y\)</span> contient ainsi forcément une arête
<span class="math inline">\(e&#39;\not\in T&#39;\)</span> et on peut
considérer <span class="math inline">\(T&#39; \cup \{e&#39;\} =
T&#39;&#39;\)</span> qui est un arbre couvrant avec <span
class="math inline">\(w(T&#39;&#39;) = w(T) + w(e&#39;) - w(e) &gt;
w(T)\)</span> car <span class="math inline">\(w(e&#39;) \ge
\mathop{largeur} &gt; w(e)\)</span>. Contradiction.</li>
</ol>
<p></div> </div></p>
<h1 data-number="5" id="sec:travaux-pratiques"><span
class="header-section-number">5</span> Travaux pratiques</h1>
<h2 data-number="5.1" id="sec:algorithme-de-kosaraju-et-2-sat"><span
class="header-section-number">5.1</span> Algorithme de Kosaraju et
2-SAT</h2>
<h3 data-number="5.1.1" id="sec:kosarau"><span
class="header-section-number">5.1.1</span> Kosarau</h3>
<p>On va considérer un type <code>graphe</code> où les sommets ne sont
pas forcément des entiers et où on peut stocke une table de hachage pour
faire la correspondance entre la valeur d'un sommet et son indice.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">type</span> &#39;a graphe = {</span>
<span id="cb3-2"><a href="#cb3-2"></a>    sommets : &#39;a <span class="dt">array</span>;</span>
<span id="cb3-3"><a href="#cb3-3"></a>    sommets_indices : (&#39;a, <span class="dt">int</span>) <span class="dt">Hashtbl</span>.t;</span>
<span id="cb3-4"><a href="#cb3-4"></a>    ladj : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">array</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>}</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question 1
</div>
<p>Écrire une fonction qui étant donné un tableau <code>t</code> va
construire la table des associations <code>t.(i) -&gt; i</code> qui
permettra ainsi de remonter du tableau à l'indice.</p>
<p><strong>Note</strong> C'est le moment de retourner apprendre par
coeur la doc de OCaml https://v2.ocaml.org/api/Hashtbl.html</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">let</span> table_indices (t:&#39;a <span class="dt">array</span>) : (&#39;a, <span class="dt">int</span>) <span class="dt">Hashtbl</span>.t =</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="kw">let</span> h = <span class="dt">Hashtbl</span>.create (<span class="dt">Array</span>.length t) <span class="kw">in</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> <span class="dt">Array</span>.length t - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>        <span class="dt">Hashtbl</span>.add h t.(i) i</span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="kw">done</span>;</span>
<span id="cb4-6"><a href="#cb4-6"></a>    h</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 2
</div>
<p>Écrire une fonction <code>indice</code> qui prend un graphe et un
sommet et renvoie son indice en utilisant la table
<code>sommets_indices</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">let</span> indice g a = <span class="dt">Hashtbl</span>.find g.sommets_indices a</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 3
</div>
<p>En déduire une fonction <code>cree_graphe</code> qui va prendre un
tableau <code>sommets</code> et créer un graphe sans arêtes dont ce sont
les sommets.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">let</span> cree_graphe sommets =</span>
<span id="cb6-2"><a href="#cb6-2"></a>    {</span>
<span id="cb6-3"><a href="#cb6-3"></a>        sommets = sommets;</span>
<span id="cb6-4"><a href="#cb6-4"></a>        sommets_indices = table_indices sommets;</span>
<span id="cb6-5"><a href="#cb6-5"></a>        ladj = <span class="dt">Array</span>.make (<span class="dt">Array</span>.length sommets) []</span>
<span id="cb6-6"><a href="#cb6-6"></a>    }</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 4
</div>
<p>Écrire une fonction <code>ajoute_arete</code> telle que
<code>ajoute_arete g a b</code> ajoute l'arête <code>a -&gt; b</code> où
les sommets <strong>sont donnés par leur valeur et non pas par leur
indice</strong>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">let</span> ajoute_arete g a b =</span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="kw">let</span> ia = indice g a <span class="kw">in</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="kw">let</span> ib = indice g b <span class="kw">in</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="kw">if</span> <span class="dt">not</span> (<span class="dt">List</span>.mem ib g.ladj.(ia))</span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="kw">then</span> g.ladj.(ia) &lt;- ib :: g.ladj.(ia)</span></code></pre></div>
<p></div> </div> </div></p>
<p>Les deux cellules suivantes permettent de définir le graphe vu dans
le cours en exemple.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">let</span> ex_cours = cree_graphe [|<span class="ch">&#39;a&#39;</span>;<span class="ch">&#39;b&#39;</span>;<span class="ch">&#39;c&#39;</span>;<span class="ch">&#39;d&#39;</span>;<span class="ch">&#39;e&#39;</span>;<span class="ch">&#39;f&#39;</span>;<span class="ch">&#39;g&#39;</span>;<span class="ch">&#39;h&#39;</span>;<span class="ch">&#39;i&#39;</span>;<span class="ch">&#39;j&#39;</span>;<span class="ch">&#39;k&#39;</span>;<span class="ch">&#39;l&#39;</span>;<span class="ch">&#39;m&#39;</span>;<span class="ch">&#39;n&#39;</span>;<span class="ch">&#39;o&#39;</span>;<span class="ch">&#39;p&#39;</span>|]</span></code></pre></div>
<p></div></p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1"></a><span class="dt">List</span>.iter (<span class="kw">fun</span> (a,b) -&gt; ajoute_arete ex_cours a b)</span>
<span id="cb9-2"><a href="#cb9-2"></a>    [(<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;b&#39;</span>); (<span class="ch">&#39;b&#39;</span>,<span class="ch">&#39;f&#39;</span>); (<span class="ch">&#39;g&#39;</span>,<span class="ch">&#39;a&#39;</span>);(<span class="ch">&#39;f&#39;</span>,<span class="ch">&#39;g&#39;</span>);</span>
<span id="cb9-3"><a href="#cb9-3"></a>     (<span class="ch">&#39;c&#39;</span>,<span class="ch">&#39;h&#39;</span>); (<span class="ch">&#39;g&#39;</span>,<span class="ch">&#39;c&#39;</span>); (<span class="ch">&#39;d&#39;</span>,<span class="ch">&#39;c&#39;</span>);(<span class="ch">&#39;h&#39;</span>,<span class="ch">&#39;d&#39;</span>);</span>
<span id="cb9-4"><a href="#cb9-4"></a>     (<span class="ch">&#39;e&#39;</span>,<span class="ch">&#39;f&#39;</span>); (<span class="ch">&#39;f&#39;</span>,<span class="ch">&#39;l&#39;</span>); (<span class="ch">&#39;e&#39;</span>,<span class="ch">&#39;i&#39;</span>); (<span class="ch">&#39;g&#39;</span>,<span class="ch">&#39;k&#39;</span>);</span>
<span id="cb9-5"><a href="#cb9-5"></a>     (<span class="ch">&#39;h&#39;</span>,<span class="ch">&#39;l&#39;</span>); (<span class="ch">&#39;i&#39;</span>,<span class="ch">&#39;n&#39;</span>); (<span class="ch">&#39;j&#39;</span>,<span class="ch">&#39;m&#39;</span>); (<span class="ch">&#39;j&#39;</span>,<span class="ch">&#39;k&#39;</span>);</span>
<span id="cb9-6"><a href="#cb9-6"></a>     (<span class="ch">&#39;k&#39;</span>,<span class="ch">&#39;l&#39;</span>); (<span class="ch">&#39;k&#39;</span>,<span class="ch">&#39;h&#39;</span>); (<span class="ch">&#39;l&#39;</span>,<span class="ch">&#39;o&#39;</span>); (<span class="ch">&#39;l&#39;</span>,<span class="ch">&#39;p&#39;</span>);</span>
<span id="cb9-7"><a href="#cb9-7"></a>     (<span class="ch">&#39;m&#39;</span>,<span class="ch">&#39;i&#39;</span>); (<span class="ch">&#39;n&#39;</span>,<span class="ch">&#39;j&#39;</span>); (<span class="ch">&#39;n&#39;</span>,<span class="ch">&#39;o&#39;</span>); (<span class="ch">&#39;o&#39;</span>,<span class="ch">&#39;k&#39;</span>)]</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question 5
</div>
<p>Écrire une fonction <code>graphe_miroir</code> qui renvoie le graphe
miroir du graphe donné, c’est-à-dire qui renverse toutes les arêtes.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">let</span> graphe_miroir g =</span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="kw">let</span> gr = {</span>
<span id="cb10-3"><a href="#cb10-3"></a>        sommets = g.sommets;</span>
<span id="cb10-4"><a href="#cb10-4"></a>        sommets_indices = g.sommets_indices;</span>
<span id="cb10-5"><a href="#cb10-5"></a>        ladj = <span class="dt">Array</span>.make (<span class="dt">Array</span>.length g.sommets) []</span>
<span id="cb10-6"><a href="#cb10-6"></a>    } <span class="kw">in</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> <span class="dt">Array</span>.length g.sommets - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>        <span class="dt">List</span>.iter (<span class="kw">fun</span> j -&gt; gr.ladj.(j) &lt;- i :: gr.ladj.(j)) g.ladj.(i)</span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="kw">done</span>;</span>
<span id="cb10-10"><a href="#cb10-10"></a>    gr</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 6
</div>
<p>Écrire une fonction <code>dfs</code> qui va parcourir en profondeur
un graphe et appliquer une fonction de <strong>post-traitement</strong>.
Pas besoin de noter les temps de sortie puisqu’ils correspondent au
moment où on effectue ce traitement.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">let</span> <span class="kw">rec</span> dfs g trait visites x =</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="kw">if</span> <span class="dt">not</span> visites.(x)</span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>        visites.(x) &lt;- <span class="kw">true</span>;</span>
<span id="cb11-5"><a href="#cb11-5"></a>        <span class="dt">List</span>.iter (<span class="kw">fun</span> y -&gt;</span>
<span id="cb11-6"><a href="#cb11-6"></a>            <span class="kw">if</span> <span class="dt">not</span> visites.(y)</span>
<span id="cb11-7"><a href="#cb11-7"></a>            <span class="kw">then</span> dfs g trait visites y</span>
<span id="cb11-8"><a href="#cb11-8"></a>        ) g.ladj.(x);</span>
<span id="cb11-9"><a href="#cb11-9"></a>        trait x</span>
<span id="cb11-10"><a href="#cb11-10"></a>    <span class="kw">end</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 7
</div>
<p>En déduire une fonction <code>kosaraju</code> qui renvoie un tableau
indiquant le numéro de la composante fortement connexe de chaque
sommet.</p>
<p>Attention, cette fonction va être un peu compliquée, on indique les
grandes lignes ici :</p>
<ul>
<li>on initialise un tableau de visites</li>
<li>on va construire une liste <code>ordre</code> des indices de sommets
rencontrés lors d'un premier DFS de tout le graphe grâce à un
post-traitement (avec une référence)</li>
<li>on calcule <span class="math inline">\(G^R\)</span> et on initialise
un tableau de visites</li>
<li>on fait des DFS dans <span class="math inline">\(G^R\)</span> mais
en prenant les sommets depuis la liste <code>ordre</code>. En
post-traitement, on va remplir un tableau <code>comp</code> où
<code>comp.(x)</code> sera le numéro de la composante connexe de
<code>x</code>.</li>
</ul>
<p>On commence par numéroter les composantes à 1.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">let</span> kosaraju g =</span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length g.sommets <span class="kw">in</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="kw">let</span> ordre = <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    <span class="kw">let</span> visites = <span class="dt">Array</span>.make n <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>        <span class="kw">if</span> <span class="dt">not</span> visites.(i)</span>
<span id="cb12-7"><a href="#cb12-7"></a>        <span class="kw">then</span> dfs g (<span class="kw">fun</span> x -&gt; ordre := x :: !ordre) visites i</span>
<span id="cb12-8"><a href="#cb12-8"></a>    <span class="kw">done</span>;</span>
<span id="cb12-9"><a href="#cb12-9"></a>    <span class="kw">let</span> gr = graphe_miroir g <span class="kw">in</span></span>
<span id="cb12-10"><a href="#cb12-10"></a>    <span class="kw">let</span> visites = <span class="dt">Array</span>.make n <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>    <span class="kw">let</span> ncomp = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb12-12"><a href="#cb12-12"></a>    <span class="kw">let</span> comp = <span class="dt">Array</span>.make n <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb12-13"><a href="#cb12-13"></a>    <span class="dt">List</span>.iter (<span class="kw">fun</span> ia -&gt;</span>
<span id="cb12-14"><a href="#cb12-14"></a>        <span class="kw">if</span> <span class="dt">not</span> visites.(ia)</span>
<span id="cb12-15"><a href="#cb12-15"></a>        <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb12-16"><a href="#cb12-16"></a>            <span class="dt">incr</span> ncomp;</span>
<span id="cb12-17"><a href="#cb12-17"></a>            dfs gr (<span class="kw">fun</span> x -&gt; comp.(x) &lt;- !ncomp) visites ia</span>
<span id="cb12-18"><a href="#cb12-18"></a>        <span class="kw">end</span></span>
<span id="cb12-19"><a href="#cb12-19"></a>        ) !ordre;</span>
<span id="cb12-20"><a href="#cb12-20"></a>    comp</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 8
</div>
<p>Cette représentation des composantes va nous être utile mais elle
n’est pas très maniable. Écrire une fonction <code>listes_comp</code>
telle que <code>listes_comp sommets comp</code> renvoie le tableau des
composantes données sous forme de listes de sommets.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">let</span> listes_comp sommets comp =</span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.fold_left <span class="dt">max</span> <span class="dv">0</span> comp <span class="kw">in</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="kw">let</span> comp_l = <span class="dt">Array</span>.make n [] <span class="kw">in</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> <span class="dt">Array</span>.length comp - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>        <span class="kw">let</span> n = comp.(i) <span class="kw">in</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>        comp_l.(n<span class="dv">-1</span>) &lt;- sommets.(i) :: comp_l.(n<span class="dv">-1</span>)</span>
<span id="cb13-7"><a href="#cb13-7"></a>    <span class="kw">done</span>;</span>
<span id="cb13-8"><a href="#cb13-8"></a>    comp_l</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 9
</div>
<p>On va résoudre 2-SAT en utilisant l’algorithme de Kosaraju. Tout
d’abord on rappelle que les formules de 2-SAT ne comportent que deux
littéraux dans chaque clause.</p>
<p>Exemple : <span class="math inline">\(f = (a \vee \neg b) \wedge
(\neg a \vee b) \wedge (\neg a \vee \neg b) \wedge (a \vee \neg
c)\)</span></p>
<p>On reprend un type proche de ce qui a été fait l'an dernier, sauf que
les clauses sont des couples de littéraux.</p>
</div>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">type</span> lit = Pos <span class="kw">of</span> <span class="dt">char</span> | Neg <span class="kw">of</span> <span class="dt">char</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">type</span> clause = lit * lit</span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">type</span> formule = clause <span class="dt">list</span></span></code></pre></div>
<p></div></p>
<p>La formule donnée au dessus s'écrit alors :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">let</span> f = [ (Pos <span class="ch">&#39;a&#39;</span>, Neg <span class="ch">&#39;b&#39;</span>); (Neg <span class="ch">&#39;a&#39;</span>, Pos <span class="ch">&#39;b&#39;</span>); (Neg <span class="ch">&#39;a&#39;</span>, Neg <span class="ch">&#39;b&#39;</span>); (Pos <span class="ch">&#39;a&#39;</span>, Neg <span class="ch">&#39;c&#39;</span>) ]</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question 10
</div>
<p>Écrire une fonction <code>label : lit -&gt; char</code> qui renvoie
l'étiquette d'un littéral et une fonction
<code>neg : lit -&gt; lit</code> qui renvoie le littéral opposé d'un
littéral donné.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">let</span> label = <span class="kw">function</span> Pos a | Neg a -&gt; a</span></code></pre></div>
<p></div></p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">let</span> neg = <span class="kw">function</span> Pos a -&gt; Neg a | Neg a -&gt; Pos a</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 11
</div>
<p>Écrire une fonction <code>variables</code> qui renvoie les étiquettes
de tous les littéraux <strong>sans répétitions</strong>. On pourra
utiliser <code>List.sort_uniq Stdlib.compare</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">let</span> <span class="kw">rec</span> variables f =</span>
<span id="cb18-2"><a href="#cb18-2"></a>    <span class="kw">let</span> <span class="kw">rec</span> var_aux f =</span>
<span id="cb18-3"><a href="#cb18-3"></a>        <span class="kw">match</span> f <span class="kw">with</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>        | [] -&gt; []</span>
<span id="cb18-5"><a href="#cb18-5"></a>        | c::f&#39; -&gt; var_clause c @ var_aux f&#39;</span>
<span id="cb18-6"><a href="#cb18-6"></a>    <span class="kw">and</span> var_clause (l1,l2) = [label l1; label l2]</span>
<span id="cb18-7"><a href="#cb18-7"></a>    <span class="kw">in</span> <span class="dt">List</span>.sort_uniq Stdlib.<span class="dt">compare</span> (var_aux f)</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 12
</div>
<p>On peut écrire <span class="math inline">\(a \vee b\)</span> sous la
forme implicative <span class="math inline">\((\neg a \rightarrow b)
\wedge(\neg b \rightarrow a)\)</span>.</p>
<p>En faisant cela, on peut alors construire un graphe sur les littéraux
où <span class="math inline">\(l \rightarrow l&#39;\)</span> quand cette
implication apparait dans la formule.</p>
<p>La formule <span class="math inline">\(f\)</span> donne alors le
graphe d'implication suivant :</p>
<p><img src="2SAT.png" /></p>
<p>Écrire une fonction <code>implication_graphe</code> qui étant donnée
<code>f</code> renvoie ce graphe.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">let</span> implication_graphe f =</span>
<span id="cb19-2"><a href="#cb19-2"></a>    <span class="kw">let</span> v = variables f <span class="kw">in</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="kw">let</span> s = <span class="dt">List</span>.concat (<span class="dt">List</span>.map (<span class="kw">fun</span> x -&gt; [Pos x; Neg x]) v) <span class="kw">in</span></span>
<span id="cb19-4"><a href="#cb19-4"></a>    <span class="kw">let</span> sommets = <span class="dt">Array</span>.of_list s <span class="kw">in</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>    <span class="kw">let</span> g = cree_graphe sommets <span class="kw">in</span></span>
<span id="cb19-6"><a href="#cb19-6"></a>    <span class="dt">List</span>.iter (<span class="kw">fun</span> (a,b) -&gt;</span>
<span id="cb19-7"><a href="#cb19-7"></a>        ajoute_arete g (neg a) b;</span>
<span id="cb19-8"><a href="#cb19-8"></a>        ajoute_arete g (neg b) a</span>
<span id="cb19-9"><a href="#cb19-9"></a>    ) f;</span>
<span id="cb19-10"><a href="#cb19-10"></a>    g</span></code></pre></div>
<p></div> </div> </div></p>
<p>On cherche alors une valuation des variables qui soit telle qu'il n'y
ait pas une arête <span class="math inline">\(\top \rightarrow
\perp\)</span> entre un littéral vrai et un littéral faux. En effet,
toutes les autres affectations vérifieront la clause correspondante.
Ainsi, tous les littéraux d'une composante fortement connexe doivent
nécessairement avoir la même valeur de vérité. Si <span
class="math inline">\(C \rightarrow C&#39;\)</span> pour deux
composantes, on ne peut pas affecter la valeur vraie à <span
class="math inline">\(C\)</span> et fausse à <span
class="math inline">\(C&#39;\)</span>. On remarque que le graphe est
symétrique par contraposition, donc il existe une composante niée <span
class="math inline">\(\neg C\)</span> pour chaque composante <span
class="math inline">\(C\)</span>.</p>
<p>L'idée pour résoudre 2-SAT est donc de calculer les compoantes
fortement connexes et de remonter leur DAG en affectant vraie à la
première composante rencontrée entre <span
class="math inline">\(C\)</span> et <span class="math inline">\(\neg
C\)</span>.</p>
<p>Pour résoudre 2-SAT, on va appliquer Kosaraju sur le graphe
d'implication de la formule.</p>
<p>Exemple pour <span class="math inline">\(f\)</span> :</p>
<p><img src="2SAT_SCC.png" /></p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1"></a>kosaraju (implication_graphe f)</span></code></pre></div>
<p></div></p>
<p>Sur ce graphe on remarque que si deux littéraux opposés sont dans la
même composante fortement connexe, alors la formule est insoluble. Si ce
n'est pas le cas, on peut démontrer que la valuation suivante fonctionne
:</p>
<p><span class="math display">\[\forall a \in V, v(a) = \begin{cases}
\top &amp; \text{si } comp(a) &gt; comp(\neg a) \\
\perp &amp; \text{sinon }\end{cases}\]</span></p>
<p>Cette affirmation repose sur deux propriétés :</p>
<ul>
<li>les composantes sont numérotées dans l'ordre croissant du tri
topologique de leur DAG (graphe acyclique orienté)</li>
<li>le graphe d'implication possède une symétrie par contraposition : si
<span class="math inline">\(a_1 \rightarrow a_2 \dots \rightarrow
a_n\)</span> alors <span class="math inline">\(\neg a_n \rightarrow \neg
a_{n-1} \dots \rightarrow \neg a_1\)</span>.</li>
</ul>
<div class="ui message blue">
<div class="header">
Question 13
</div>
<p>En déduire une fonction <code>resout_2sat</code> qui étant donné une
formule renvoie <code>None</code> si elle est insoluble, et
<code>Some l</code> où <code>l</code> est une liste de couples
<code>(variable,valeur)</code> représentant une valuation solution.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">let</span> resout_2sat f =</span>
<span id="cb21-2"><a href="#cb21-2"></a>    <span class="kw">let</span> g = implication_graphe f <span class="kw">in</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>    <span class="kw">let</span> comp = kosaraju g <span class="kw">in</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length g.sommets / <span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>    <span class="kw">let</span> valuation = <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb21-6"><a href="#cb21-6"></a>    <span class="kw">let</span> insoluble = <span class="dt">ref</span> <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb21-7"><a href="#cb21-7"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>        <span class="kw">let</span> a = label g.sommets.(<span class="dv">2</span>*i) <span class="kw">in</span></span>
<span id="cb21-9"><a href="#cb21-9"></a>        <span class="kw">if</span> comp.(<span class="dv">2</span>*i) = comp.(<span class="dv">2</span>*i+<span class="dv">1</span>)</span>
<span id="cb21-10"><a href="#cb21-10"></a>        <span class="kw">then</span> insoluble := <span class="kw">true</span>;</span>
<span id="cb21-11"><a href="#cb21-11"></a>    <span class="kw">done</span>;</span>
<span id="cb21-12"><a href="#cb21-12"></a>    <span class="kw">if</span> !insoluble</span>
<span id="cb21-13"><a href="#cb21-13"></a>    <span class="kw">then</span> <span class="dt">None</span></span>
<span id="cb21-14"><a href="#cb21-14"></a>    <span class="kw">else</span> <span class="dt">Some</span> !valuation</span></code></pre></div>
<p></div> </div> </div></p>
<h2 data-number="5.2"
id="sec:couplage-maximal-dans-un-graphe-biparti-1"><span
class="header-section-number">5.2</span> Couplage maximal dans un graphe
biparti</h2>
<h3 data-number="5.2.1" id="sec:graphe-biparti"><span
class="header-section-number">5.2.1</span> Graphe biparti</h3>
<p>On va considérer ici un graphe biparti donné par une liste d’arêtes
sous la forme <code>(source,but)</code>. Voici un exemple :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb22-1"><a href="#cb22-1"></a>[ (<span class="dv">0</span>,<span class="dv">3</span>); (<span class="dv">1</span>,<span class="dv">3</span>); (<span class="dv">1</span>,<span class="dv">4</span>); (<span class="dv">2</span>,<span class="dv">3</span>); (<span class="dv">2</span>,<span class="dv">4</span>) ]</span></code></pre></div>
<p></div></p>
<p>En commençant à numéroter à 0, on peut donc supposer que le nombre de
sommets est égal au plus grand entier apparaissant dans un couple plus
un.</p>
<div class="ui message blue">
<div class="header">
Question 14
</div>
<p>Écrire une fonction
<code>nombre_sommets : (int * int) list -&gt; int</code> qui calcule ce
nombre.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">let</span> <span class="kw">rec</span> nombre_sommets l =</span>
<span id="cb23-2"><a href="#cb23-2"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    | [] -&gt; <span class="dv">0</span></span>
<span id="cb23-4"><a href="#cb23-4"></a>    | (a,b)::q -&gt; <span class="kw">let</span> n = nombre_sommets q <span class="kw">in</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>        <span class="dt">max</span> (<span class="dv">1</span> + <span class="dt">max</span> a b) n</span></code></pre></div>
<p></div> </div> </div></p>
<p>On va maintenant récupérer la liste des premières composantes et la
liste des secondes composantes <strong>sans répétition</strong>.</p>
<p>Pour cela, on commence par écrire une fonction permettant de réaliser
<code>t :: q</code> en omettant <code>t</code> en cas de répétition.</p>
<div class="ui message blue">
<div class="header">
Question 15
</div>
<p>Écrire une fonction
<code>cons_uniq : 'a -&gt; a list -&gt; 'a list</code> telle que
<code>cons_uniq t q</code> renvoie <code>t::q</code> si <code>t</code>
n’est pas dans liste <code>q</code> et <code>q</code> sinon.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">let</span> cons_uniq t q = </span>
<span id="cb24-2"><a href="#cb24-2"></a>    <span class="kw">if</span> <span class="dt">List</span>.mem t q</span>
<span id="cb24-3"><a href="#cb24-3"></a>    <span class="kw">then</span> q</span>
<span id="cb24-4"><a href="#cb24-4"></a>    <span class="kw">else</span> t::q</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 16
</div>
<p>Écrire une fonction
<code>separe_liste : (int * int) list -&gt; int list * int list</code>
qui prend en argument une liste de couple d’entiers et renvoie le couple
des listes <strong>sans répétitions</strong> des premières et secondes
composantes.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">let</span> <span class="kw">rec</span> separe_liste l =</span>
<span id="cb25-2"><a href="#cb25-2"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>    | [] -&gt; [], []</span>
<span id="cb25-4"><a href="#cb25-4"></a>    | (a,b)::q -&gt; <span class="kw">let</span> l1, l2 = separe_liste q <span class="kw">in</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>        (cons_uniq a l1, cons_uniq b l2)</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 17
</div>
<p>Écrire une fonction
<code>intersection : 'a list -&gt; 'a list -&gt; 'a list</code> qui
prend en arguments deux listes sans répétitions et renvoie une liste
contenant les éléments présents dans les deux listes.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">let</span> <span class="kw">rec</span> intersection l1 l2 =</span>
<span id="cb26-2"><a href="#cb26-2"></a>    <span class="dt">List</span>.filter (<span class="kw">fun</span> x -&gt; <span class="dt">List</span>.mem x l2) l1</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 18
</div>
<p>En déduire une fonction
<code>biparti : (int * int) list -&gt; bool</code> qui vérifie qu’une
liste d’arêtes permet effectivement de représenter un graphe biparti où
les sommets sont d’un côté les premières composantes et de l’autre les
secondes.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">let</span> biparti l = </span>
<span id="cb27-2"><a href="#cb27-2"></a>     <span class="kw">let</span> l1, l2 = separe_liste l <span class="kw">in</span> intersection l1 l2 = []</span></code></pre></div>
<p></div> </div> </div></p>
<p>De cette liste d’arêtes représentant un graphe biparti à <span
class="math inline">\(n\)</span> sommets, on va en déduire le graphe
lui-même en le représentant sous la forme d’un couple
<code>(ladj, sources)</code> où <code>ladj</code> est une représentation
en liste d’adjacences et <code>sources</code> est un tableau de booléen
indiquant si un sommet appartient à la première composante du graphe
biparti, i.e. à la première composante d’un des couples d’arêtes.</p>
<p>Ainsi, les sommets qui n’apparaissent pas dans les arêtes sont
associés implicitement à la seconde composante, ce qui ne sera pas
gênant dans la suite.</p>
<div class="ui message blue">
<div class="header">
Question 19
</div>
<p>Écrire une fonction
<code>graphe_aretes : (int * int) list -&gt; int list array</code> qui
renvoie le tableau des listes d’adjacence d’un graphe <strong>non
orienté</strong> donné sous la forme d’une liste d’arêtes.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">let</span> graphe_aretes l =</span>
<span id="cb28-2"><a href="#cb28-2"></a>    <span class="kw">let</span> n = nombre_sommets l <span class="kw">in</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>    <span class="kw">let</span> ladj = <span class="dt">Array</span>.make n [] <span class="kw">in</span></span>
<span id="cb28-4"><a href="#cb28-4"></a>    <span class="dt">List</span>.iter (<span class="kw">fun</span> (a,b) -&gt; </span>
<span id="cb28-5"><a href="#cb28-5"></a>        ladj.(a) &lt;- b :: ladj.(a); ladj.(b) &lt;- a :: ladj.(b)) l;</span>
<span id="cb28-6"><a href="#cb28-6"></a>    ladj</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 20
</div>
<p>En déduire une fonction
<code>graphe_biparti : (int * int) list -&gt; int list array * bool array</code>
qui renvoie le couple <code>(ladj, sources)</code> représentant le
graphe biparti.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">let</span> graphe_biparti l =</span>
<span id="cb29-2"><a href="#cb29-2"></a>    <span class="kw">let</span> g = graphe_aretes l <span class="kw">in</span></span>
<span id="cb29-3"><a href="#cb29-3"></a>    <span class="kw">let</span> s1, _ = separe_liste l <span class="kw">in</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>    <span class="kw">let</span> sources = <span class="dt">Array</span>.make (<span class="dt">Array</span>.length g) <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb29-5"><a href="#cb29-5"></a>    <span class="dt">List</span>.iter (<span class="kw">fun</span> i -&gt; sources.(i) &lt;- <span class="kw">true</span>) s1;</span>
<span id="cb29-6"><a href="#cb29-6"></a>    g, sources</span></code></pre></div>
<p></div> </div> </div></p>
<h3 data-number="5.2.2" id="sec:couplage-maximal"><span
class="header-section-number">5.2.2</span> Couplage maximal</h3>
<p>On va programmer l’algorithme pour déterminer un couplage maximal par
des bascules successives de chemins augmentant (voir preuve du théorème
de Bergé).</p>
<p>On va adopter deux représentations d’un couplage. La représentation
élémentaire comme sous-liste de la liste d’arêtes du graphe.</p>
<p>Par exemple <code>[ (0,3); (1,4) ]</code> est un couplage pour la
liste d’arêtes données plus haut.</p>
<div class="ui message blue">
<div class="header">
Question 21
</div>
<p>Écrire une fonction <code>est_couplage : int list -&gt; bool</code>
qui vérifie si une liste d’arêtes est un couplage en vérifiant qu’il n’y
a pas d’arêtes coincidentes.</p>
<p>Votre fonction devra être de complexité
<strong>linéaire</strong>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">let</span> est_couplage el =</span>
<span id="cb30-2"><a href="#cb30-2"></a>    <span class="kw">let</span> n = nombre_sommets el <span class="kw">in</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>    <span class="kw">let</span> libres = <span class="dt">Array</span>.make n <span class="kw">true</span> <span class="kw">in</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>    <span class="kw">let</span> couplage = <span class="dt">ref</span> <span class="kw">true</span> <span class="kw">in</span></span>
<span id="cb30-5"><a href="#cb30-5"></a>    <span class="dt">List</span>.iter (<span class="kw">fun</span> (x,y) -&gt;</span>
<span id="cb30-6"><a href="#cb30-6"></a>        couplage := !couplage &amp;&amp; libres.(x) &amp;&amp; libres.(y);</span>
<span id="cb30-7"><a href="#cb30-7"></a>        libres.(x) &lt;- <span class="kw">false</span>; libres.(y) &lt;- <span class="kw">false</span>) el;</span>
<span id="cb30-8"><a href="#cb30-8"></a>    !couplage</span></code></pre></div>
<p></div> </div> </div></p>
<p>L’autre représentation est un tableau indiquant pour un sommet <span
class="math inline">\(i\)</span>, soit <code>Some j</code> quand on a
une arête <span class="math inline">\(\{i,j\}\)</span> dans le couplage
et <code>None</code> sinon. En effet, un couplage réalise une fonction
partielle involutive de <span class="math inline">\(A \rightarrow
A\)</span>.</p>
<p>Ainsi, le tableau
<code>[| Some 3; Some 4; None; Some 0; Some 1 |]</code> permet de
représenter le couplage <code>[ (0,3); (1,4) ]</code> en considérant que
les sommets sont dans <span class="math inline">\([|0;4|]\)</span>.</p>
<div class="ui message blue">
<div class="header">
Question 22
</div>
<p>Écrire des fonctions permettant de passer d’une représentation à une
autre :</p>
<ul>
<li><code>couplage_liste_vers_tab : (int * int) list -&gt; int option array</code></li>
<li><code>couplage_tab_vers_liste : bool array -&gt; int option array -&gt; (int * int) list</code>
ici, on a besoin de connaitre les sources pour choisir comment placer
les arêtes.</li>
</ul>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">let</span> couplage_liste_vers_tab l =</span>
<span id="cb31-2"><a href="#cb31-2"></a>    <span class="kw">let</span> n = nombre_sommets l <span class="kw">in</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>    <span class="kw">let</span> couplage = <span class="dt">Array</span>.make n <span class="dt">None</span> <span class="kw">in</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>    <span class="dt">List</span>.iter (<span class="kw">fun</span> (a,b) -&gt;</span>
<span id="cb31-5"><a href="#cb31-5"></a>        couplage.(a) &lt;- <span class="dt">Some</span> b;</span>
<span id="cb31-6"><a href="#cb31-6"></a>        couplage.(b) &lt;- <span class="dt">Some</span> a) l;</span>
<span id="cb31-7"><a href="#cb31-7"></a>    couplage</span>
<span id="cb31-8"><a href="#cb31-8"></a></span>
<span id="cb31-9"><a href="#cb31-9"></a><span class="kw">let</span> couplage_tab_vers_liste sources couplage =</span>
<span id="cb31-10"><a href="#cb31-10"></a>    <span class="kw">let</span> cpl_aretes = <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb31-11"><a href="#cb31-11"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length sources <span class="kw">in</span></span>
<span id="cb31-12"><a href="#cb31-12"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb31-13"><a href="#cb31-13"></a>        <span class="kw">if</span> sources.(i)</span>
<span id="cb31-14"><a href="#cb31-14"></a>        <span class="kw">then</span> <span class="kw">match</span> couplage.(i) <span class="kw">with</span></span>
<span id="cb31-15"><a href="#cb31-15"></a>             | <span class="dt">None</span> -&gt; ()</span>
<span id="cb31-16"><a href="#cb31-16"></a>             | <span class="dt">Some</span> j -&gt; cpl_aretes := (i,j) :: !cpl_aretes</span>
<span id="cb31-17"><a href="#cb31-17"></a>    <span class="kw">done</span>;</span>
<span id="cb31-18"><a href="#cb31-18"></a>    !cpl_aretes</span></code></pre></div>
<p></div> </div> </div></p>
<p>On va définir ici le graphe résiduel associé à un couplage de manière
implicite avec une fonction permettant de décider si une arête <span
class="math inline">\(x \rightarrow y\)</span> est dans le graphe
résiduel.</p>
<p><strong>Attention</strong> il peut il y avoir des arêtes <span
class="math inline">\(x \rightarrow z\)</span> quand <span
class="math inline">\((x, y)\)</span> est dans le couplage.</p>
<div class="ui message blue">
<div class="header">
Question 23
</div>
<p>Écrire une fonction</p>
<p><code>arete_residuelle : bool array -&gt; int option array -&gt; int -&gt; int -&gt; bool</code></p>
<p>qui permet, en appeleant
<code>arete_residuelle sources couplage x y</code> permet de décider si
<span class="math inline">\(x \rightarrow y\)</span> est dans le graphe
résiduel.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">let</span> arete_residuelle sources couplage x y =</span>
<span id="cb32-2"><a href="#cb32-2"></a>    <span class="kw">if</span> sources.(x)</span>
<span id="cb32-3"><a href="#cb32-3"></a>    <span class="kw">then</span> couplage.(x) &lt;&gt; <span class="dt">Some</span> y</span>
<span id="cb32-4"><a href="#cb32-4"></a>    <span class="kw">else</span> couplage.(x) = <span class="dt">Some</span> y</span></code></pre></div>
<p></div> </div> </div></p>
<p>Pour chercher un chemin augmentant, on va commencer par effectuer un
parcours en profondeur récursif dans un graphe avec une notion d’arête
implicite, une fonction comme <code>arete_residuelle</code>, et on va
remplir un tableau de prédécesseur où <span
class="math inline">\(x\)</span> est le prédécesseur de <span
class="math inline">\(y\)</span> si c’est le DFS depuis <span
class="math inline">\(x\)</span> qui a appelé le DFS depuis <span
class="math inline">\(y\)</span>.</p>
<p><strong>Dans toute la suite, on suppose que le prédécesseur de <span
class="math inline">\(x\)</span> est <span
class="math inline">\(x\)</span> lui-même quand on a lancé le DFS
initialement depuis le sommet <span
class="math inline">\(x\)</span>.</strong></p>
<div class="ui message blue">
<div class="header">
Question 24
</div>
<p>Écrire une fonction</p>
<p><code>dfs : int list array -&gt; (int -&gt; int -&gt; bool) -&gt; int option array -&gt; int -&gt; unit</code></p>
<p>telle que <code>dfs g est_arete pred x</code> effectue un DFS depuis
le sommet <code>x</code> dans le graphe donné sous forme de listes
d’adjacence par <code>g</code>, avec une fonction <code>est_arete</code>
permettant de tester si une arête est à considérer dans le parcours et
en remplissant le tableau des prédécesseurs <code>pred</code>, qui est
un <code>int option array</code> car la valeur vaut <code>None</code>
tant que le sommet n’est pas découvert.</p>
<p><em>Rappel</em> : on a spécifié que <code>pred.(x)</code> valait
<code>Some x</code> si <code>x</code> était un des sommets initiaux sur
lesquels on a commencé le DFS.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">let</span> <span class="kw">rec</span> dfs_impl g est_arete <span class="dt">pred</span> x =</span>
<span id="cb33-2"><a href="#cb33-2"></a>    <span class="dt">List</span>.iter (<span class="kw">fun</span> y -&gt;</span>
<span id="cb33-3"><a href="#cb33-3"></a>        <span class="kw">if</span> <span class="dt">pred</span>.(y) = <span class="dt">None</span> &amp;&amp; est_arete x y</span>
<span id="cb33-4"><a href="#cb33-4"></a>        <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb33-5"><a href="#cb33-5"></a>            <span class="dt">pred</span>.(y) &lt;- <span class="dt">Some</span> x;</span>
<span id="cb33-6"><a href="#cb33-6"></a>            dfs_impl g est_arete <span class="dt">pred</span> y</span>
<span id="cb33-7"><a href="#cb33-7"></a>        <span class="kw">end</span>)</span>
<span id="cb33-8"><a href="#cb33-8"></a>        g.(x)</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 25
</div>
<p>Écrire une fonction</p>
<p><code>remonte : int option array -&gt; int -&gt; int list</code></p>
<p>telle que <code>remonte pred x</code> renvoie la liste des sommets
allant du point de départ d’un DFS ayant rempli <code>pred</code>
jusqu’à x en remontant la relation de prédecesseurs.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">let</span> remonte <span class="dt">pred</span> x =</span>
<span id="cb34-2"><a href="#cb34-2"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux <span class="dt">pred</span> y acc =</span>
<span id="cb34-3"><a href="#cb34-3"></a>        <span class="kw">match</span> <span class="dt">pred</span>.(y) <span class="kw">with</span></span>
<span id="cb34-4"><a href="#cb34-4"></a>        | <span class="dt">None</span> -&gt; <span class="dt">failwith</span> <span class="st">&quot;Impossible&quot;</span></span>
<span id="cb34-5"><a href="#cb34-5"></a>        | <span class="dt">Some</span> x <span class="kw">when</span> x = y -&gt; y::acc</span>
<span id="cb34-6"><a href="#cb34-6"></a>        | <span class="dt">Some</span> x -&gt; aux <span class="dt">pred</span> x (y::acc)</span>
<span id="cb34-7"><a href="#cb34-7"></a>    <span class="kw">in</span></span>
<span id="cb34-8"><a href="#cb34-8"></a>    aux <span class="dt">pred</span> x []</span></code></pre></div>
<p></div> </div> </div></p>
<p>On considère qu’on a effectué un DFS dans le graphe résiduel associé
à un couplage depuis un sommet et on cherche maintenant à écrire une
fonction qui permet déterminer s’il existe un chemin depuis ce sommet
vers un sommet <strong>libre</strong> dans les cibles, i.e. les sommets
<strong>qui ne sont pas des sources</strong>.</p>
<div class="ui message blue">
<div class="header">
Question 26
</div>
<p>Écrire une fonction</p>
<p><code>cherche_chemin : int option array -&gt; bool array -&gt; int option array -&gt; int -&gt; int list option</code></p>
<p>telle que <code>cherche_chemin pred sources couplage depart</code>
renvoie <code>Some phi</code> si <code>phi</code> est la liste des
sommets visités dans un chemin du graphe résiduel de <code>depart</code>
un sommet cible <strong>libre</strong> pour <code>couplage</code> et
<code>None</code> sinon.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">let</span> cherche_chemin <span class="dt">pred</span> sources couplage depart =</span>
<span id="cb35-2"><a href="#cb35-2"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux i =</span>
<span id="cb35-3"><a href="#cb35-3"></a>        <span class="kw">if</span> i = <span class="dt">Array</span>.length sources</span>
<span id="cb35-4"><a href="#cb35-4"></a>        <span class="kw">then</span> <span class="dt">None</span></span>
<span id="cb35-5"><a href="#cb35-5"></a>        <span class="kw">else</span> <span class="kw">if</span> <span class="dt">not</span> sources.(i) &amp;&amp; couplage.(i) = <span class="dt">None</span> </span>
<span id="cb35-6"><a href="#cb35-6"></a>                                &amp;&amp; <span class="dt">pred</span>.(i) &lt;&gt; <span class="dt">None</span></span>
<span id="cb35-7"><a href="#cb35-7"></a>             <span class="kw">then</span> <span class="kw">let</span> phi = remonte <span class="dt">pred</span> i <span class="kw">in</span></span>
<span id="cb35-8"><a href="#cb35-8"></a>                  <span class="kw">if</span> <span class="dt">List</span>.hd phi = depart</span>
<span id="cb35-9"><a href="#cb35-9"></a>                  <span class="kw">then</span> <span class="dt">Some</span> phi</span>
<span id="cb35-10"><a href="#cb35-10"></a>                  <span class="kw">else</span> aux (i+<span class="dv">1</span>)</span>
<span id="cb35-11"><a href="#cb35-11"></a>             <span class="kw">else</span> aux (i+<span class="dv">1</span>)</span>
<span id="cb35-12"><a href="#cb35-12"></a>    <span class="kw">in</span></span>
<span id="cb35-13"><a href="#cb35-13"></a>    aux <span class="dv">0</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 27
</div>
<p>Écrire une fonction</p>
<p><code>chemin_augmentant : int list array -&gt; bool array -&gt; int option array -&gt; int -&gt; int list option</code></p>
<p>telle que <code>chemin_augmentant g sources couplage depart</code>
renvoie <code>Some phi</code> où <code>phi</code> est la liste des
sommets d’un chemin augmentant issu de la source <code>depart</code> (et
donc arrivant nécessairement dans un sommet cible
<strong>libre</strong>).</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">let</span> chemin_augmentant g sources couplage depart =</span>
<span id="cb36-2"><a href="#cb36-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length g <span class="kw">in</span></span>
<span id="cb36-3"><a href="#cb36-3"></a>    <span class="kw">let</span> <span class="dt">pred</span> = <span class="dt">Array</span>.make n <span class="dt">None</span> <span class="kw">in</span></span>
<span id="cb36-4"><a href="#cb36-4"></a>    <span class="dt">pred</span>.(depart) &lt;- <span class="dt">Some</span> depart;</span>
<span id="cb36-5"><a href="#cb36-5"></a>    dfs_impl g (arete_residuelle sources couplage) <span class="dt">pred</span> depart;</span>
<span id="cb36-6"><a href="#cb36-6"></a>    cherche_chemin <span class="dt">pred</span> sources couplage depart</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 28
</div>
<p>Écrire une fonction</p>
<p><code>bascule_chemin : int option array -&gt; int list -&gt; unit</code></p>
<p>telle que <code>bascule_chemin couplage chemin</code> où
<code>chemin</code> est un chemin augmentant pour le couplage, va faire
la bascule de toutes les arêtes de <code>chemin</code> : celles dans le
couplage sont enlevées et celles qui n’y sont pas sont rajoutées.</p>
<p><strong>Indice</strong> : seule la parité permet de déterminer celles
qui y sont dans la mesure où on a un chemin augmentant.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">let</span> <span class="kw">rec</span> bascule_chemin couplage chemin =</span>
<span id="cb37-2"><a href="#cb37-2"></a>    <span class="kw">match</span> chemin <span class="kw">with</span></span>
<span id="cb37-3"><a href="#cb37-3"></a>    | s::t::q -&gt; couplage.(s) &lt;- <span class="dt">Some</span> t; couplage.(t) &lt;- <span class="dt">Some</span> s; bascule_chemin couplage q</span>
<span id="cb37-4"><a href="#cb37-4"></a>    | [] -&gt; ()</span>
<span id="cb37-5"><a href="#cb37-5"></a>    | [_] -&gt; <span class="dt">failwith</span> <span class="st">&quot;Le chemin est forcément de longueur impaire&quot;</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question 29
</div>
<p>En déduire une fonction,</p>
<p><code>couplage_maximal : (int * int) list -&gt; (int * int) list</code></p>
<p>telle que <code>couplage_maximal aretes</code>, où
<code>aretes</code> est un graphe biparti donné sous forme d’une liste
d’arêtes, renvoie un couplage maximal sous la forme d’une liste
d’arêtes.</p>
<p>Pour cela, on va itérer sur chaque sommet source en cherchant un
chemin augmentant depuis celui-ci et en le basculant. Quand on aura
traité toutes les sources, on est certain qu’il n’y a plus de chemin
augmentant.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">let</span> couplage_maximal l =</span>
<span id="cb38-2"><a href="#cb38-2"></a>    <span class="kw">let</span> g, sources = graphe_biparti l <span class="kw">in</span></span>
<span id="cb38-3"><a href="#cb38-3"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length g <span class="kw">in</span></span>
<span id="cb38-4"><a href="#cb38-4"></a>    <span class="kw">let</span> couplage = <span class="dt">Array</span>.make n <span class="dt">None</span> <span class="kw">in</span></span>
<span id="cb38-5"><a href="#cb38-5"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb38-6"><a href="#cb38-6"></a>        <span class="kw">if</span> sources.(i) &amp;&amp; couplage.(i) = <span class="dt">None</span></span>
<span id="cb38-7"><a href="#cb38-7"></a>        <span class="kw">then</span> <span class="kw">match</span> chemin_augmentant g sources couplage i <span class="kw">with</span></span>
<span id="cb38-8"><a href="#cb38-8"></a>           | <span class="dt">None</span> -&gt; ()</span>
<span id="cb38-9"><a href="#cb38-9"></a>           | <span class="dt">Some</span> ch -&gt; bascule_chemin couplage ch</span>
<span id="cb38-10"><a href="#cb38-10"></a>    <span class="kw">done</span>;</span>
<span id="cb38-11"><a href="#cb38-11"></a>    couplage_tab_vers_liste sources couplage</span></code></pre></div>
<p></div> </div> </div></p>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
