<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Arbres</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Arbres
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:arbres-binaires"><span>1</span> Arbres binaires</a><div class="menu"><a class="item" href="#sec:définition-inductive"><div class="ui label">1.1</div> Définition inductive</a><a class="item" href="#sec:vocabulaire"><div class="ui label">1.2</div> Vocabulaire</a><a class="item" href="#sec:implémentations"><div class="ui label">1.3</div> Implémentations</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:en-ocaml"><i class="circle icon"></i> En <code>OCaml</code></a><a style="font-size:0.6em" class="item" href="#sec:en-c"><i class="circle icon"></i> En <code>C</code></a></div><a class="item" href="#sec:arbres-binaires-stricts"><div class="ui label">1.4</div> Arbres binaires stricts</a><a class="item" href="#sec:arbres-binaires-complets"><div class="ui label">1.5</div> Arbres binaires complets</a></div></div><div class="item header"> <a href="#sec:arbres-1"><span>2</span> Arbres</a><div class="menu"><a class="item" href="#sec:définition"><div class="ui label">2.1</div> Définition</a><a class="item" href="#sec:implémentation"><div class="ui label">2.2</div> Implémentation</a><a class="item" href="#sec:représentation-par-un-arbre-binaire"><div class="ui label">2.3</div> Représentation par un arbre binaire</a><a class="item" href="#sec:applications"><div class="ui label">2.4</div> Applications</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:arbres-dexpressions"><i class="circle icon"></i> Arbres d’expressions</a><a style="font-size:0.6em" class="item" href="#sec:arbres-préfixes-ou-tries"><i class="circle icon"></i> Arbres préfixes ou tries</a></div></div></div><div class="item header"> <a href="#sec:parcours"><span>3</span> Parcours</a><div class="menu"><a class="item" href="#sec:parcours-récursif-dun-arbre-binaire"><div class="ui label">3.1</div> Parcours récursif d’un arbre binaire</a><a class="item" href="#sec:parcours-impératifs"><div class="ui label">3.2</div> Parcours impératifs</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:cadre-général"><i class="circle icon"></i> Cadre général</a><a style="font-size:0.6em" class="item" href="#sec:cas-du-parcours-en-profondeur"><i class="circle icon"></i> Cas du parcours en profondeur</a><a style="font-size:0.6em" class="item" href="#sec:cas-du-parcours-en-largeur"><i class="circle icon"></i> Cas du parcours en largeur</a></div><a class="item" href="#sec:parcours-darbres"><div class="ui label">3.3</div> Parcours d’arbres</a></div></div><div class="item header"> <a href="#sec:arbres-binaires-de-recherche"><span>4</span> Arbres binaires de recherche</a><div class="menu"><a class="item" href="#sec:objectif"><div class="ui label">4.1</div> Objectif</a><a class="item" href="#sec:définition-1"><div class="ui label">4.2</div> Définition</a><a class="item" href="#sec:opérations"><div class="ui label">4.3</div> Opérations</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:minimum-et-maximum"><i class="circle icon"></i> Minimum et maximum</a><a style="font-size:0.6em" class="item" href="#sec:recherche-dun-élément"><i class="circle icon"></i> Recherche d’un élément</a><a style="font-size:0.6em" class="item" href="#sec:insertion-dun-élément"><i class="circle icon"></i> Insertion d’un élément</a><a style="font-size:0.6em" class="item" href="#sec:suppression-dun-élément"><i class="circle icon"></i> Suppression d’un élément</a></div><a class="item" href="#sec:équilibrage"><div class="ui label">4.4</div> Équilibrage</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:principe-et-approche-naïve"><i class="circle icon"></i> Principe et approche naïve</a><a style="font-size:0.6em" class="item" href="#sec:arbres-2-3"><i class="circle icon"></i> Arbres 2-3</a><a style="font-size:0.6em" class="item" href="#sec:arbres-rouges-et-noirs"><i class="circle icon"></i> Arbres rouges et noirs</a></div><a class="item" href="#sec:implémentation-dun-dictionnaire"><div class="ui label">4.5</div> Implémentation d’un dictionnaire</a></div></div><div class="item header"> <a href="#sec:tas"><span>5</span> Tas</a><div class="menu"><a class="item" href="#sec:présentation"><div class="ui label">5.1</div> Présentation</a><a class="item" href="#sec:implémentation-1"><div class="ui label">5.2</div> Implémentation</a><a class="item" href="#sec:application-aux-files-de-priorité"><div class="ui label">5.3</div> Application aux files de priorité</a></div></div><div class="item header"> <a href="#sec:tp"><span>6</span> TP</a><div class="menu"><a class="item" href="#sec:arbres-en-ocaml"><div class="ui label">6.1</div> Arbres en <code>OCaml</code></a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:premières-fonctions"><i class="circle icon"></i> Premières fonctions</a><a style="font-size:0.6em" class="item" href="#sec:parcours-1"><i class="circle icon"></i> Parcours</a><a style="font-size:0.6em" class="item" href="#sec:arbres-binaires-stricts-1"><i class="circle icon"></i> Arbres binaires stricts</a><a style="font-size:0.6em" class="item" href="#sec:dessin-darbres"><i class="circle icon"></i> Dessin d’arbres</a><a style="font-size:0.6em" class="item" href="#sec:génération-aléatoire-darbres"><i class="circle icon"></i> Génération aléatoire d’arbres</a></div><a class="item" href="#sec:arbres-non-binaires-tries"><div class="ui label">6.2</div> Arbres non binaires, tries</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:arbres-non-binaires"><i class="circle icon"></i> Arbres non binaires</a><a style="font-size:0.6em" class="item" href="#sec:représentation-par-des-arbres-binaires"><i class="circle icon"></i> Représentation par des arbres binaires</a></div><a class="item" href="#sec:tries"><div class="ui label">6.3</div> Tries</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:premières-manipulations"><i class="circle icon"></i> Premières manipulations</a><a style="font-size:0.6em" class="item" href="#sec:ajout-dun-mot-à-un-trie"><i class="circle icon"></i> Ajout d’un mot à un trie</a></div><a class="item" href="#sec:arbres-binaires-en-c-abr-arbres-rouges-et-noirs"><div class="ui label">6.4</div> Arbres binaires en <code>C</code>, ABR, arbres rouges et noirs</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:arbres-binaires-en-c"><i class="circle icon"></i> Arbres binaires en <code>C</code></a><a style="font-size:0.6em" class="item" href="#sec:arbres-binaires-de-recherche-1"><i class="circle icon"></i> Arbres binaires de recherche</a><a style="font-size:0.6em" class="item" href="#sec:arbres-rouges-et-noirs-1"><i class="circle icon"></i> Arbres rouges et noirs</a></div></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Arbres
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Arbres     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_programmation_imperative.jpg"> </div></p>
<h1 data-number="1" id="sec:arbres-binaires"><span class="header-section-number">1</span> Arbres binaires</h1>
<h2 data-number="1.1" id="sec:définition-inductive"><span class="header-section-number">1.1</span> Définition inductive</h2>
<p><div class="ui message"><div class="header">Définition</div> Un arbre binaire étiqueté par <span class="math inline">\(\mathcal{E}\)</span> est :</p>
<ul>
<li>soit vide, et on le note alors <span class="math inline">\(\text{nil}\)</span> ou <span class="math inline">\(\perp\)</span></li>
<li>soit un triplet <span class="math inline">\((g,x,d)\)</span> où <span class="math inline">\(x \in \mathcal{E}\)</span> et <span class="math inline">\(g\)</span> et <span class="math inline">\(d\)</span> sont des arbres binaires. </div></li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div>Cette définition inductive ressemble à la définition des listes.</p>
<p>On peut la formaliser en introduisant <span class="math inline">\(T_b(\mathcal{E})\)</span> l’ensemble des arbres étiquetés par <span class="math inline">\(\mathcal{E}\)</span>. C’est le <strong>plus petit ensemble</strong> tel que :</p>
<ul>
<li><span class="math inline">\(\text{nil} \in T_b(\mathcal{E})\)</span></li>
<li><span class="math inline">\(\forall x\in \mathcal{E}, \forall g, d \in T_b(\mathcal{E}), (g,x,d) \in T_b(\mathcal{E})\)</span></li>
</ul>
<p>Les conséquences de la précision <strong>plus petit ensemble</strong> sont importantes :</p>
<ul>
<li>les arbres sont nécessairement des expressions finis, c’est-à-dire qu’il ne comportent qu’un nombre finis de constructions. C’est automatique car l’ensemble des arbres finis vérifie les conditions précédentes ;</li>
<li>pour tout triplet <span class="math inline">\((g,x,d)\)</span> il ne peut exister qu’un arbre, sinon, en enlevant un arbre en double on vérifierait encore les deux conditions précédentes.</li>
</ul>
<p>On en déduit directement la notion de preuve par <strong>induction structurelle</strong> sur les arbres : <span class="math display">\[
\forall a \in T_b(\mathcal{E}), P(a)
\iff \begin{cases}
P(\text{nil}) \\
\forall x \in \mathcal{E}, \forall g, d \in T_b(\mathcal{E}),
P(g) \wedge P(d) \Rightarrow P(g,x,d)
\end{cases}
\]</span></p>
<p>Cette induction correspond à un pseudo principe de récurrence qui nous permettra de faire les preuves.</p>
<p>Pour démontrer cette inégalité, il suffit de vérifier que <span class="math inline">\(T_P = \{ t \in T_b(\mathcal{E}), P(t) \}\)</span> vérifie les relations de la définition inductive et <span class="math inline">\(T_P \subset T_b(\mathcal{E})\)</span> et par minimalité, on a bien <span class="math inline">\(T_P = T_b(\mathcal{E})\)</span>.</div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si <span class="math inline">\(\mathcal{E} = \N\)</span>, les éléments suivants sont des arbres :</p>
<ul>
<li><span class="math inline">\(\text{nil}\)</span></li>
<li><span class="math inline">\((\text{nil}, 2, \text{nil})\)</span></li>
<li><span class="math inline">\(( (\text{nil}, 1, \text{nil}), 2, \text{nil} )\)</span></li>
</ul>
</div>
<p>On adoptera une représentation graphique très naturelle pour les arbres binaires où un nœud <span class="math inline">\((g,x,d)\)</span> sera représenté par <img src="assets/pics/inline_001.png" /></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Les trois arbres précédentes sont donc représentés par :</p>
<p><span class="math inline">\(\text{nil}\)</span></p>
<p><img src="assets/pics/inline_002.png" /></p>
<p><img src="assets/pics/inline_003.png" /></p>
<p>Afin d’alléger la notation, on omettra <span class="math inline">\(\text{nil}\)</span>, sauf pour l’arbre vide. On fera cependant attention à conserver les arêtes donnant sur <span class="math inline">\(\text{nil}\)</span> pour ne pas confondre <span class="math inline">\((\text{nil}, 1, \text{nil}(\text{nil}, 2, \text{nil}))\)</span> et <span class="math inline">\(( (\text{nil}, 2, \text{nil}), 1, \text{nil} )\)</span>. Ainsi on représentera les arbres précédents par :</p>
<p><img src="assets/pics/inline_004.png" /><br />
<img src="assets/pics/inline_005.png" /></p>
</div>
<h2 data-number="1.2" id="sec:vocabulaire"><span class="header-section-number">1.2</span> Vocabulaire</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(a\)</span> un arbre binaire. Les arbres non vides présents dans <span class="math inline">\(a\)</span> sont appelés les <strong>nœuds</strong> de <span class="math inline">\(a\)</span>. Parmi ceux-ci on distingue ceux qui sont de la forme <span class="math inline">\((nil,x,nil)\)</span>. appelés des <strong>feuilles</strong>. Les nœuds qui ne sont pas des feuilles sont appelés des <strong>nœuds internes</strong>. Le nœud <span class="math inline">\(a\)</span> lui-même est appelé la racine de l’arbre. On note <span class="math inline">\(N(a)\)</span> les nœuds de <span class="math inline">\(a\)</span>.</p>
<p>Si <span class="math inline">\(n \in N(a)\)</span> n’est pas pas la racine, il est le fils gauche ou le fils droit d’un unique nœud appelé le <strong>père</strong> de <span class="math inline">\(x\)</span>.</p>
<p>Si <span class="math inline">\(n \in N(a)\)</span>, on appelle <strong>sous-arbre</strong> de <span class="math inline">\(a\)</span> l’arbre dont <span class="math inline">\(n\)</span> est la racine. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>En partant de la définition inductive, il y a une identification entre un sous-arbre et sa racine. Mais afin de raisonner, on distinguera un nœud en tant qu’emplacement au sein d’un arbre et le sous-arbre lui-même.</div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(a\)</span> un arbre binaire.</p>
<ul>
<li>On appelle <strong>taille</strong> de <span class="math inline">\(a\)</span>, et on note <span class="math inline">\(|a|\)</span> le nombre de nœuds de <span class="math inline">\(a\)</span>.</li>
<li>On appelle <strong>hauteur</strong> de <span class="math inline">\(a\)</span> l’entier <span class="math display">\[
h(a) = \begin{cases} -1 &amp; \text{ si } a = \text{nil} \\
1 + \max(h(g), h(d)) &amp; \text{ si } a = (g,x,d) \end{cases}
\]</span></li>
</ul>
<p></div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(a\)</span> un arbre binaire et <span class="math inline">\(n \in N(a)\)</span>. On appelle <strong>profondeur</strong> de <span class="math inline">\(n\)</span> l’unique entier <span class="math inline">\(p(a)\)</span> tel qu’il existe une suite finie <span class="math inline">\((n_0, n_1, \dots, n_{p(a)})\)</span> de <span class="math inline">\(n\)</span> vérifiant :</p>
<ul>
<li><span class="math inline">\(n_0\)</span> est la racine de <span class="math inline">\(a\)</span></li>
<li><span class="math inline">\(n_{p(a)} = n\)</span></li>
<li>pour tout <span class="math inline">\(i\)</span>, <span class="math inline">\(n_i\)</span> est le père de <span class="math inline">\(n_{i+1}\)</span></li>
</ul>
<p>Cette suite finie est le <strong>chemin</strong> de la racine à <span class="math inline">\(n\)</span>. Il est nécessairement unique car chaque nœud autre que la racine a un unique père. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(a\)</span> un arbre, si <span class="math inline">\(a\)</span> est non vide, alors <span class="math inline">\(h(a) = \max_{n \in N(a)} p(n)\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> Par induction structurelle sur <span class="math inline">\(a\)</span>.</p>
<ul>
<li><strong>Initialisation</strong> Si <span class="math inline">\(a = \text{nil}\)</span> la prémisse est fausse, donc l’implication est trivialement vérifiée.</li>
<li><strong>Hérédité</strong> Supposons la propriété vérifiée pour deux arbres <span class="math inline">\(g\)</span> et <span class="math inline">\(d\)</span>, soit <span class="math inline">\(x \in \mathcal{E}\)</span>, on va montrer qu’elle est vérifiée pour <span class="math inline">\(a = (g,x,d)\)</span>. On a quatre cas pour le couple <span class="math inline">\((g,d)\)</span> :
<ul>
<li>Soit <span class="math inline">\(g \neq \text{nil}\)</span> et <span class="math inline">\(d \neq \text{nil}\)</span>. Dans ce cas, par hypothèse <span class="math inline">\(h(g) = \max_{n \in N(g)} p_g(n)\)</span> où <span class="math inline">\(p_g\)</span> est la profondeur de <span class="math inline">\(n\)</span> en tant que nœud de l’arbre <span class="math inline">\(g\)</span>. Or, mis à part la racine de <span class="math inline">\(a\)</span>, le chemin menant dans <span class="math inline">\(a\)</span> au nœud <span class="math inline">\(n\)</span> est dans <span class="math inline">\(g\)</span>. On a donc directement <span class="math inline">\(p_g(n) = p(n) - 1\)</span>. Ainsi <span class="math inline">\(h(g) = \max_{n \in N(g)} p(n) - 1\)</span>. De même, <span class="math inline">\(h(d) = max_{n \in N(d)} p(n) - 1\)</span>. On a <span class="math display">\[h(a) = 1 + \max(h(g),h(d)) = \max(\max_{n\in N(g)} p(n), \max_{n \in
\N(d)} p(n))\]</span> Or, le seul nœud de <span class="math inline">\(a\)</span> qui n’est ni dans <span class="math inline">\(g\)</span> ni dans <span class="math inline">\(d\)</span> est sa racine, qui est de profondeur nulle donc <span class="math inline">\(h(a) = \max_{n \in N(a)} p(n)\)</span>.</li>
<li>Soit <span class="math inline">\(g = \text{nil}\)</span> et <span class="math inline">\(d \neq \text{nil}\)</span>. Ainsi <span class="math inline">\(h(g) = -1\)</span> et donc <span class="math inline">\(h(a) = 1 + h(d) = \max_{n \in N(d)} p(n)\)</span> par l’analyse précédente. On conclut donc avec la propriété voulue.</li>
<li>Soit <span class="math inline">\(g \neq \text{nil}\)</span> et <span class="math inline">\(d = \text{nil}\)</span>. Cas symétrique du précédent.</li>
<li>Soit <span class="math inline">\(g = d = \text{nil}\)</span>. Auquel cas, <span class="math inline">\(h(a) = 0\)</span> qui est bien la profondeur de son unique nœud.</li>
</ul></li>
</ul>
<p>On a bien montré la propriété voulue par induction structurelle. </div> </div></p>
<h2 data-number="1.3" id="sec:implémentations"><span class="header-section-number">1.3</span> Implémentations</h2>
<h3 data-number="1.3.1" id="sec:en-ocaml"><span class="header-section-number">1.3.1</span> En <code>OCaml</code></h3>
<p>En <code>OCaml</code>, on traduit directement la définition inductive par un type récursif :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> &#39;a arbre = Noeud <span class="kw">of</span> &#39;a arbre * &#39;a * &#39;a arbre | Nil</span></code></pre></div>
<p></div></p>
<p>On pourra alors définir des fonctions récursives sur les arbres par induction structurelle à l’aide d’un filtrage.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">let</span> <span class="kw">rec</span> taille a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>    | Nil -&gt; <span class="dv">0</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    | Noeud(g,x,d) -&gt; <span class="dv">1</span> + taille g + taille d</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">let</span> <span class="kw">rec</span> hauteur a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    | Nil -&gt; <span class="dv">-1</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    | Noeud(g, x, d) -&gt; <span class="dv">1</span> + <span class="dt">max</span> (hauteur g) (hauteur d)</span></code></pre></div>
<p></div></p>
<h3 data-number="1.3.2" id="sec:en-c"><span class="header-section-number">1.3.2</span> En <code>C</code></h3>
<h2 data-number="1.4" id="sec:arbres-binaires-stricts"><span class="header-section-number">1.4</span> Arbres binaires stricts</h2>
<p><div class="ui message"><div class="header">Définition</div> Un arbre binaire est dit <strong>strict</strong> lorsqu’aucun de ses nœuds n’a qu’un fils vide. </div></p>
<p>Cela revient à dire que les seules les feuilles ont des fils vides. On peut donc omettre l’arbre vide et ne garder que les feuilles à la place.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>L’arbre de gauche ici est un arbre binaire strict alors que ce n’est pas le cas de l’arbre de droite :</p>
<p><center><div class="ui image center"><img src="assets/pics/arbrestricts.png" /></div></center></p>
<p></div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(a\)</span> un arbre binaire strict non vide. Si <span class="math inline">\(a\)</span> a <span class="math inline">\(n\)</span> nœuds internes, alors il a <span class="math inline">\(n+1\)</span> feuilles.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> Par induction structurelle :</p>
<ul>
<li><strong>Initialisation</strong> Si <span class="math inline">\(a\)</span> a <span class="math inline">\(0\)</span> nœud interne, c’est une feuille et on a directement la relation.</li>
<li><strong>Hérédité</strong> Supposons que la propriété soit vraie pour des arbres <span class="math inline">\(g\)</span> et <span class="math inline">\(d\)</span>, et soit <span class="math inline">\(a = (g,x,d)\)</span> un arbre dont ce sont les fils. On note <span class="math inline">\(n_i(t)\)</span> le nombre de nœuds internes et <span class="math inline">\(n_f(t)\)</span> le nombre de feuilles de l’arbre <span class="math inline">\(t\)</span>. On a <span class="math inline">\(n_i(a) = 1 + n_i(g) + n_i(d)\)</span> et <span class="math inline">\(n_f(a) = n_f(g) + n_f(d) = 2 + n_i(g) + n_i(d) = 1 + n_i(a)\)</span>. La propriété est démontrée pour <span class="math inline">\(a\)</span>. </div> </div></li>
</ul>
<p>Cela permet naturellement de considérer des arbres où les feuilles et les nœuds internes ont deux types différents d’étiquettes.</p>
<p>L’exemple classique d’un tel arbre est celui des expressions arithmétiques :</p>
<ul>
<li>les nœuds internes sont étiquetés par des opérateurs binaires</li>
<li>les feuilles sont étiquetées par des nombres.</li>
</ul>
<p>En <code>OCaml</code>, on peut ainsi représenter un tel arbre par le type récursif :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">type</span> (&#39;a, &#39;b) arbre_bin = Feuille <span class="kw">of</span> &#39;a </span>
<span id="cb3-2"><a href="#cb3-2"></a>    | Noeud <span class="kw">of</span> (&#39;a, &#39;b) arbre_bin * &#39;b * (&#39;a, &#39;b) arbre_bin</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>On ne peut plus représenter l’arbre vide avec ce type.</div></p>
<p>Et pour les expressions, on pourra ainsi définir un type pour les opérateurs et écrire :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">type</span> operator = Plus | Times | Minus | Divides</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">let</span> e = Noeud(Feuille <span class="dv">2</span>, Plus, Noeud(Feuille <span class="dv">3</span>, Mult, Feuille <span class="dv">4</span>))</span></code></pre></div>
<p></div></p>
<p>L’évaluation de telles expressions est étudiée dans le TP si dessous.</p>
<h2 data-number="1.5" id="sec:arbres-binaires-complets"><span class="header-section-number">1.5</span> Arbres binaires complets</h2>
<p><div class="ui message"><div class="header">Définition</div> Un arbre binaire dont tous les niveaux sont plein sauf éventuellement le dernier est dit <strong>complet</strong>. Si son dernier niveau est également plein, on dit qu’il est <strong>parfait</strong>. </div></p>
<p>On peut représenter un arbre complet dans un tableau niveau par niveau en partant de la racine.</p>
<p>Si on place les indices comme étiquettes on aura, par exemple :</p>
<p><center><div class="ui image center"><img src="assets/pics/arbrecomplet.png" /></div></center></p>
<p>Et on pourra donc le représenter par le tableau des étiquettes dans cet ordre d’énumération.</p>
<p>On remarque que :</p>
<ul>
<li>le nœud <span class="math inline">\(0\)</span> est toujours la racine</li>
<li>si on considère un nœud <span class="math inline">\(i\)</span>, son fils gauche est le nœud <span class="math inline">\(2 i + 1\)</span> et son fils droit est le nœud <span class="math inline">\(2 i + 2\)</span>.</li>
<li>le fils gauche de <span class="math inline">\(i+1\)</span> est <span class="math inline">\(2 (i+1) + 1 = 2i + 3 &gt; 2 i + 2\)</span>. On est bien directement après.</li>
<li>le <span class="math inline">\(k\)</span>ème nœud du niveau <span class="math inline">\(l\)</span>, en commençant à numéroter à <span class="math inline">\(0\)</span>, a pour indices <span class="math inline">\(\sum_{j=0}^{l-1} 2^j + k = 2^l - 1 + k\)</span>.</li>
<li>si <span class="math inline">\(i &gt; 0\)</span>, son père est le nœud <span class="math inline">\(\left\lfloor \frac{i-1}{2} \right\rfloor\)</span>.</li>
</ul>
<p>On peut donc, avec cette représentation, manipuler assez simplement un arbre binaire <strong>à plat </strong>.</p>
<h1 data-number="2" id="sec:arbres-1"><span class="header-section-number">2</span> Arbres</h1>
<h2 data-number="2.1" id="sec:définition"><span class="header-section-number">2.1</span> Définition</h2>
<p>On étend directement la définition inductive des arbres binaires au cas où les nœuds plus d’éléments.</p>
<p><div class="ui message"><div class="header">Définition</div> Un arbre étiqueté par <span class="math inline">\(\mathcal{E}\)</span> est un couple <span class="math inline">\((x,f)\)</span> où <span class="math inline">\(x \in \mathcal{E}\)</span> et <span class="math inline">\(f\)</span> une suite <strong>finie</strong> d’arbres. </div></p>
<p>On étend naturellement le vocabulaire des arbres binaires :</p>
<ul>
<li>le nœud de tête d’un arbre, en fin de compte sa <em>valeur</em>, est appelé sa racine</li>
<li>les éléments de <span class="math inline">\(f\)</span> sont appelés les fils du nœuds</li>
<li>si <span class="math inline">\(f\)</span> est vide, on dit que le nœud est une <strong>feuille</strong>, sinon, on dit que c’est un nœud interne.</li>
<li><span class="math inline">\(|f|\)</span>, le nombre d’éléments de <span class="math inline">\(f\)</span>, est appelé l’<strong>arité</strong> du nœud. Les feuilles sont donc les nœuds zéroaire.</li>
<li>une suite finie d’arbres, ou plus généralement un ensemble d’arbres, est appelé une <strong>fôret</strong>.</li>
</ul>
<p>Si on note <span class="math inline">\(T(\mathcal{E})\)</span> l’ensemble des arbres étiquetés par <span class="math inline">\(\mathcal{E}\)</span>, on a <span class="math display">\[
\forall x \in \mathcal{E}, \forall n \in \N, \forall a_1, \dots, a_n 
\in T(\mathcal{E}),
(x, (a_1, \dots, a_n)) \in T(\mathcal{E})
\]</span></p>
<p><strong>Attention</strong> contrairement à ce que peut laisser entendre la formule précédente, il est tout à fait possible que <span class="math inline">\(n = 0\)</span> ce qui correspond à la suite finie vide et donc à une feuille. On perd ici la possibilité de représenter un arbre vide.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Un arbre binaire est un arbre dont les nœuds sont soit unaires soit binaires. On remarque en disant cela qu’on perd une information : la position gauche ou droite de l’unique fils d’un nœud unaire.</p>
<p>Comme pour les arbres binaires stricts, on pourra être amenés à considérer des arbres dont les nœuds internes et les feuilles sont étiquettés par des arbres</div></p>
<h2 data-number="2.2" id="sec:implémentation"><span class="header-section-number">2.2</span> Implémentation</h2>
<p>L’implémentation d’un arbre repose sur l’implémentation d’une suite finie. Celle-ci peut être faite par un tableau ou par une liste chaînée.</p>
<p>On retrouve alors des implementations différentes des arbres mais qui sont, au fond, très proches.</p>
<p>En <code>OCaml</code>, on pourra alors avoir les deux implémentations suivantes :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">type</span> &#39;a arbre_l = { etiquette : &#39;a; enfants : &#39;a arbre_l <span class="dt">list</span> }</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">type</span> &#39;a arbre_a = { etiquette : &#39;a; enfants : &#39;a arbre_a <span class="dt">array</span> }</span></code></pre></div>
<p></div></p>
<p>On va alors avoir des programmes à la présentation assez différente suivant le type choisi. Voici, par exemple, les deux implémentations du calcul de la taille d’un arbre.</p>
<p>Avec des listes et aucune fonction du module <code>List</code>, on écrit souvent une fonction récursive sur les arbres et une fonction récursive sur les forêts.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">let</span> <span class="kw">rec</span> taille_arbre a =</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="dv">1</span> + taille_foret a.enfants</span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="kw">and</span> taille_foret l = <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>        | [] -&gt; <span class="dv">0</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>        | t::q -&gt; taille_arbre t + taille_foret q</span></code></pre></div>
<p></div></p>
<p>On peut aussi utiliser directement <code>fold_left</code> et <code>map</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">let</span> <span class="kw">rec</span> taille_arbre a = </span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="dv">1</span> + <span class="dt">List</span>.fold_left (+) <span class="dv">0</span> (<span class="dt">List</span>.map taille_arbre a.enfants)</span></code></pre></div>
<p></div></p>
<p>Avec l’autre représentation, on procédera avec un mélange de fonction récursive et de boucles. Cela n’est pas sans rappeler ce qui a été fait pour le backtracking.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">let</span> <span class="kw">rec</span> taille_arbre a =</span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="kw">let</span> t = <span class="dt">ref</span> <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> <span class="dt">Array</span>.length a.enfants - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>        t := !t + taille_arbre a.enfants.(i)</span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="kw">done</span>;</span>
<span id="cb8-6"><a href="#cb8-6"></a>    !t</span></code></pre></div>
<p></div></p>
<h2 data-number="2.3" id="sec:représentation-par-un-arbre-binaire"><span class="header-section-number">2.3</span> Représentation par un arbre binaire</h2>
<p>Pour des raisons d’efficacité ou de réutilisation de programmes existants, on peut vouloir représenter un arbre comme un arbre binaire.</p>
<p>On va définir une application : <span class="math inline">\(\text{bin} : T(\mathcal{E}) \rightarrow T_b(\mathcal{E} \cup \{ \star \})\)</span> ainsi : <span class="math inline">\(\text{bin}(x, ()) = (\text{nil},x,\text{nil})\)</span>, <span class="math inline">\(\text{bin}(x, (a)) = (\text{bin}(a),x,\text{nil})\)</span> et pour un nœud d’arité strictement plus grande que 1 : <center><div class="ui image center"><img src="assets/pics/tobin.png" /></div></center></p>
<p>où <span class="math inline">\(a&#39;_i = \text{bin}(a_i)\)</span>. Les nœuds rouges sont des nœuds ayant une étiquette spéciale <span class="math inline">\(\star\)</span> telle que <span class="math inline">\(\star \not \in \mathcal{E}\)</span>.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>L’arbre suivant :</p>
<p><center><div class="ui image center"><img src="assets/pics/exampleconv1.png" /></div></center></p>
<p>sera alors représenté par l’arbre binaire :</p>
<p><center><div class="ui image center"><img src="assets/pics/exampleconv2.png" /></div></center></p>
</div>
<h2 data-number="2.4" id="sec:applications"><span class="header-section-number">2.4</span> Applications</h2>
<h3 data-number="2.4.1" id="sec:arbres-dexpressions"><span class="header-section-number">2.4.1</span> Arbres d’expressions</h3>
<p>On a déjà vu l’utilisation des arbres binaires pour représenter des expressions arithmétiques avec des opérateurs unaires ou binaires. On généralise naturellement cela à des expressions dont les opérateurs sont d’arité quelconque.</p>
<p>C’est ainsi qu’on représente un programme en mémoire, on parle d’arbre syntaxique.</p>
<h3 data-number="2.4.2" id="sec:arbres-préfixes-ou-tries"><span class="header-section-number">2.4.2</span> Arbres préfixes ou tries</h3>
<p>Un <em>arbre préfixe</em> ou <em>trie</em> est un arbre permettant de représenter un ensemble de mots. On étiquette les arêtes par des caractères et les nœuds par un booléen indiquant si la suite des étiquettes qui mène de la racine à ce nœud est un mot.</p>
<p>Par exemple, le trie :</p>
<p><center><div class="ui image center"><img src="assets/pics/trie1.png" /></div></center></p>
<p>permet de représenter l’ensemble de mots : bar, barbe, art, ami, abri, abricot, abonne.</p>
<p>Afin de représenter un tel arbre, il est nécessaire d’avoir une étiquette sur les arêtes, le plus simple pour cela est de remplacer la liste des enfants par une liste de couples (étiquette, enfant) ainsi :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">type</span> trie = {</span>
<span id="cb9-2"><a href="#cb9-2"></a>    mot : <span class="dt">bool</span>;</span>
<span id="cb9-3"><a href="#cb9-3"></a>    enfants : (<span class="dt">char</span> * trie) <span class="dt">list</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>    }</span></code></pre></div>
<p></div></p>
<p>Les fonctions de manipulations de ce type de donnée sont étudiées dans le TP <strong>TODO</strong>.</p>
<h1 data-number="3" id="sec:parcours"><span class="header-section-number">3</span> Parcours</h1>
<h2 data-number="3.1" id="sec:parcours-récursif-dun-arbre-binaire"><span class="header-section-number">3.1</span> Parcours récursif d’un arbre binaire</h2>
<p>On a déjà vu dans les paragraphes précédent ce qui constitue le cœur du parcours d’un arbre :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">let</span> <span class="kw">rec</span> parcours a = </span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>    | Nil -&gt; ()</span>
<span id="cb10-4"><a href="#cb10-4"></a>    | Noeud(g, x, d) -&gt; </span>
<span id="cb10-5"><a href="#cb10-5"></a>        parcours g;</span>
<span id="cb10-6"><a href="#cb10-6"></a>        parcours d</span></code></pre></div>
<p></div></p>
<p>Cette fonction ne fait rien, mais elle va parcourir chacun des nœuds de l’arbre. Si on veut effectuer un traitement sur le nœud, on peut le faire à trois moments :</p>
<p><center><div class="ui image center"><img src="assets/pics/parcourstraitements.png" /></div></center></p>
<ul>
<li>Avant l’appel à <code>parcours g</code>, on parle de <em>traitement préfixe</em></li>
<li>Entre les deux appels, on parle de <em>traitement infixe</em></li>
<li>Après l’appel à <code>parcours g</code>, on parle de <em>traitement postfixe</em></li>
</ul>
<p>On représente ici l’ordre dans lequel on va effectuer chacun de ces trois traitements selon le code couleur : rouge pour préfixe, bleu pour infixe et vert pour postfixe. On a également indiqué, pour les premiers traitements, l’ordre dans lequel ils sont effectués par des numéros.</p>
<p><center><div class="ui image center"><img src="assets/pics/parcoursrec.png" /></div></center></p>
<p>Pour illustrer ces traitements, on peut rajouter trois arguments au parcours :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">let</span> <span class="kw">rec</span> parcours prefixe infixe postfixe a =</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    | Nil -&gt; ()</span>
<span id="cb11-4"><a href="#cb11-4"></a>    | Noeud(g, x, d) -&gt;</span>
<span id="cb11-5"><a href="#cb11-5"></a>        prefixe a;</span>
<span id="cb11-6"><a href="#cb11-6"></a>        parcours g;</span>
<span id="cb11-7"><a href="#cb11-7"></a>        infixe a;</span>
<span id="cb11-8"><a href="#cb11-8"></a>        parcours d;</span>
<span id="cb11-9"><a href="#cb11-9"></a>        postfixe a</span></code></pre></div>
<p></div></p>
<p>On peut, par exemple, définir les deux fonctions suivante :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">let</span> idle a = () <span class="co">(* ne fait rien *)</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="kw">let</span> print a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    | Nil -&gt; <span class="dt">failwith</span> <span class="st">&quot;Vide&quot;</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>    | Noeud(_,x,_) -&gt; <span class="dt">print_char</span> a </span></code></pre></div>
<p></div></p>
<p>On peut alors observer les nœuds affichés sur l’arbre précédent selon les traitements effectués :</p>
<ul>
<li><code>parcours print idle idle a</code> : <strong>abdejkvwcfg</strong> on suit uniquement les arêtes rouges</li>
<li><code>parcours idle print idle a</code> : <em>dbejvkwafcg</em> on suit uniquement les arêtes bleues</li>
<li><code>parcours idle idle print a</code> : djvwkebfgca on suit uniquement les arêtes vertes</li>
<li><code>parcours print print print a</code> : <strong>abd</strong><em>d</em>d<em>b</em><strong>ej</strong><em>j</em>j<em>e</em><strong>kv</strong><em>v</em>v<em>k</em><strong>w</strong><em>w</em>wkeb… on suit toutes les arêtes</li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div>Si on considère un arbre d’expression comme :</p>
<p><center><div class="ui image center"><img src="assets/pics/arbreexpr.png" /></div></center></p>
<p>On va alors obtenir en affichant à chaque traitement la suite : <span class="math inline">\(+222+\times333\times444\times +\)</span>. Chaque nombre <span class="math inline">\(n\)</span> étant une feuille, on va observer l’affichage de <span class="math inline">\(nnn\)</span> qu’on peut réduire à <span class="math inline">\(n\)</span>. Pour les opérateurs, si on remplace le premier affichage par <span class="math inline">\((\)</span> et le dernier par <span class="math inline">\()\)</span>. En procédant ainsi, on affiche <span class="math inline">\((2+(3\times 4))\)</span> et on ainsi retrouvé l’écriture bien parenthésée de l’expression.</div></p>
<p><div class="ui message"><div class="header">Définition</div> L’ordre dans lequel on effectue un traitement <em>préfixe</em> dans un parcours sur les nœuds d’un arbre est appelé l’ordre <em>préfixe</em> sur les nœuds.</p>
<p>On définit, de même, l’ordre <em>infixe</em> et l’ordre <em>postfixe</em>. </div></p>
<h2 data-number="3.2" id="sec:parcours-impératifs"><span class="header-section-number">3.2</span> Parcours impératifs</h2>
<h3 data-number="3.2.1" id="sec:cadre-général"><span class="header-section-number">3.2.1</span> Cadre général</h3>
<p>On va condisérer une structure de donnée abstraite qui généralise les piles et les files et permettre de représenter un ensemble de tâches à traiter. Pour cela, on dispose d’un type paramétrique <code>'a t</code> et de l’interface :</p>
<ul>
<li><code>cree : unit -&gt; 'a t</code> crée un ensemble de tâches</li>
<li><code>ajoute : 'a t -&gt; 'a -&gt; unit</code> ajoute une nouvelle tâche à traiter</li>
<li><code>retire : 'a t -&gt; 'a</code> retire une tâche de l’ensemble des tâches à traiter</li>
<li><code>est_vide : 'a t -&gt; bool</code> renvoie un booléen indiquant si l’ensemble de tâches est vide</li>
</ul>
<p>On a ainsi vu deux possibles implémentations, qui sont elles-mêmes des structures abstraites mais un peu moins abstraites que celle-ci :</p>
<ul>
<li>les piles pour lesquelles on retire le dernier élément ajouté</li>
<li>les files pour lesquelles on retire l’élément le plus anciennement ajouté</li>
</ul>
<p>On écrire un parcours impératif générique :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">let</span> parcours traitement a = </span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="kw">let</span> avisiter = cree () <span class="kw">in</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>    ajoute avisiter a;</span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="kw">while</span> <span class="dt">not</span> (est_vide avisiter) <span class="kw">do</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>        <span class="kw">let</span> a = retire avisiter <span class="kw">in</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>        <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>        | Nil -&gt; ()</span>
<span id="cb13-8"><a href="#cb13-8"></a>        | Noeud(g, _, d) -&gt; traitement a;</span>
<span id="cb13-9"><a href="#cb13-9"></a>                            ajoute avisiter g;</span>
<span id="cb13-10"><a href="#cb13-10"></a>                            ajoute avisiter d</span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="kw">done</span></span></code></pre></div>
<p></div></p>
<h3 data-number="3.2.2" id="sec:cas-du-parcours-en-profondeur"><span class="header-section-number">3.2.2</span> Cas du parcours en profondeur</h3>
<p>Dans le cas où on utilise une pile, on retrouve essentiellement le parcours récursif précédent avec quelques changements :</p>
<ul>
<li>on empile ici d’abord <code>g</code> puis <code>d</code>, donc on va à droite avant d’aller à gauche. Il suffit de permuter les deux ajouts pour retrouver l’ordre précédent</li>
<li>on effectue un unique traitement préfixe</li>
<li>si on considère la pile d’appels récursifs du parcours récursif, on constate que le nombre de structure pile est majoré par la hauteur de l’arbre. Ici, on va potentiellement ajouter tous les nœuds sur la pile, donc, on a une complexité en espace en <span class="math inline">\(O(|a|)\)</span> plutôt qu’en <span class="math inline">\(O(h(a))\)</span>.</li>
</ul>
<p>On parle de <strong>parcours en profondeur</strong> ou depth-first search (DFS) en anglais.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on considère l’arbre suivant :</p>
<p><center><div class="ui image center"><img src="assets/pics/exparcours.png" /></div></center></p>
<p>En ignorant les arbres vides, par exemple en ne les ajoutant pas, on va avoir le déroulement suivant du parcours :</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">avisiter</th>
<th style="text-align: center;">etiquette traitée</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(1 \rightarrow\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(2, 3 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(2, 5, 6 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(2, 5 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(6\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(2, 7 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(5\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(2 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(7\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(4 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(4\)</span></td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="3.2.3" id="sec:cas-du-parcours-en-largeur"><span class="header-section-number">3.2.3</span> Cas du parcours en largeur</h3>
<p>Dans le cas où on utilise une file, on obtient un parcours appelé le <strong>parcours en largeur</strong> en breadth-first search (BFS) en anglais.</p>
<p>Dans ce parcours, on va visiter les nœuds <em>niveau par niveau</em> en partant de la racine jusqu’aux feuilles de plus grande profondeur.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on considère l’arbre suivant :</p>
<p><center><div class="ui image center"><img src="assets/pics/exparcours.png" /></div></center></p>
<p>En ignorant les arbres vides, par exemple en ne les ajoutant pas, on va avoir le déroulement suivant du parcours :</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">avisiter</th>
<th style="text-align: center;">etiquette traitée</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 1 \rightarrow\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 3, 2 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 4, 3 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 6, 5, 4 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 6, 5 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(4\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 7, 6 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(5\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 7 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(6\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(7\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Ce parcours est particulièrement intéressant quand on cherche une information avec la plus petite profondeur possible. Par exemple, dans le cas de la recherche d’une solution à un problème, on peut vouloir tester les petites solutions avant les plus grandes.</p>
<p>Pour des problèmes d’énumération, c’est également intéressant, car on va obtenir des éléments par ordre croissant de la longueur du chemin depuis la racine. Par exemple, pour les tries, on en déduit les mots par ordre croissant de longueur.</p>
<h2 data-number="3.3" id="sec:parcours-darbres"><span class="header-section-number">3.3</span> Parcours d’arbres</h2>
<p>Pour des arbres, on va suivre les mêmes principes. La différence va se situer au niveau de l’implémentation car il faudra alors manipuler des listes ou des tableaux d’enfants.</p>
<p>Notons qu’on a déjà vu un tel problème quand on a résolu des problèmes par backtracking. En effet, avec le backtracking, on a un arbre implicite des positions partielles dont les enfants sont les mouvements possibles vers de nouvelles positions.</p>
<h1 data-number="4" id="sec:arbres-binaires-de-recherche"><span class="header-section-number">4</span> Arbres binaires de recherche</h1>
<h2 data-number="4.1" id="sec:objectif"><span class="header-section-number">4.1</span> Objectif</h2>
<p>On souhaite ici réaliser une structure efficace d’ensembles finis. Pour cela, on cherche à définir une structure immuable <code>'a ensemble</code> muni de quatre opérations</p>
<ul>
<li><code>ensemble_vide : 'a ensemble</code> l’ensemble vide</li>
<li><code>ajoute : 'a ensemble -&gt; 'a -&gt; 'a ensemble</code> rajoute un élément à un ensemble et renvoie le nouvel ensemble</li>
<li><code>supprime : 'a ensemble -&gt; 'a -&gt; 'a ensemble</code> retire un élément à un ensemble et renvoie le nouvel ensemble</li>
<li><code>contient : 'a ensemble -&gt; 'a -&gt; bool</code> teste si l’ensemble contient un élément</li>
<li><code>cardinal : 'a ensemble -&gt; int</code> renvoie le nombre d’éléments de l’ensemble</li>
</ul>
<p>Notons qu’on pourra souvent relacher la contrainte naturelle des ensembles en permettant d’ajouter plusieurs fois un même élément.</p>
<p>Une implémentation possible de cette structure serait d’utiliser des listes ou des tableaux triés, on aurait alors des opérations en <span class="math inline">\(O(n)\)</span> pour manipuler <span class="math inline">\(n\)</span> éléments (<span class="math inline">\(O(log_2 n)\)</span> en optimisant la recherche avec une recherche dichotomique).</p>
<p>Ici, on présente une implémentation rendant possible une complexité en <span class="math inline">\(O(log_2 n)\)</span> pour chaque opération sous certaines hypothèses dont on montrera qu’elles peuvent être satisfaites dans un second temps.</p>
<h2 data-number="4.2" id="sec:définition-1"><span class="header-section-number">4.2</span> Définition</h2>
<p><div class="ui message"><div class="header">Définition</div> On dit qu’un arbre <span class="math inline">\(a\)</span> étiquetté par <span class="math inline">\(X\)</span>, muni d’une relation d’ordre total, est un <strong>arbre binaire de recherche</strong> (abr) lorsque :</p>
<ul>
<li>soit <span class="math inline">\(a = \text{nil}\)</span></li>
<li>soit <span class="math inline">\(a = (g, x, d)\)</span> où <span class="math inline">\(g\)</span> et <span class="math inline">\(d\)</span> sont des arbres binaires de recherches et de plus <span class="math display">\[
\max_{y \in g} e(y) \le x \le \min_{y \in d} e(d)
\]</span> où <span class="math inline">\(e(y)\)</span> est l’étiquette du nœud <span class="math inline">\(y\)</span>. </div></li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div>* Tout sous-arbre d’un arbre binaire de recherche est un arbre binaire de recherche. * Pour un ensemble donné d’étiquettes il n’y a pas unicité de l’arbre binaire de recherche: voir ci-après.</div></p>
<p>Exemples d’abr :</p>
<p><center><div class="ui image center"><img src="assets/pics/abrrem1.png" /></div></center></p>
<p><div class="ui message orange"><div class="header">Remarque</div>La propriété caractéristique des ABR n’est pas locale c’est-à-dire tester si chaque nœud a une étiquette supérieure à son fils gauche et inférieure à son fils droit ne suffit pas.</p>
<p><center><div class="ui image center"><img src="assets/pics/pasabrex.png" /></div></center></p>
<p></div></p>
<h2 data-number="4.3" id="sec:opérations"><span class="header-section-number">4.3</span> Opérations</h2>
<h3 data-number="4.3.1" id="sec:minimum-et-maximum"><span class="header-section-number">4.3.1</span> Minimum et maximum</h3>
<p>On peut obtenir la valeur minimale et maximale d’un abr en effectuant un parcours le long de la branche la plus à gauche ou de la branche la plus à droite.</p>
<p>En effet, si l’arbre est <span class="math inline">\((g,x,d)\)</span> : soit <span class="math inline">\(g\)</span> est vide et <span class="math inline">\(x \le \min d\)</span> est le minimum, soit <span class="math inline">\(g\)</span> est non vide et on a alors <span class="math inline">\(\min g \le \max g \le x\)</span> donc le minimum de <span class="math inline">\(g\)</span> est celui de l’arbre.</p>
<p>On en déduit le programme suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">let</span> <span class="kw">rec</span> minimum a =</span>
<span id="cb14-2"><a href="#cb14-2"></a>    <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>    | Nil -&gt; <span class="dt">failwith</span> <span class="st">&quot;vide&quot;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    | Noeud(Nil, x, _) -&gt; x</span>
<span id="cb14-5"><a href="#cb14-5"></a>    | Noeud(g, _, _) -&gt; minimum g</span></code></pre></div>
<p></div></p>
<p>On remarque que pour parcourir cette branche, on est en <span class="math inline">\(O(h(a))\)</span> où <span class="math inline">\(a\)</span> est l’arbre considéré.</p>
<p>!susubsection(Test si un arbre est un abr) Pour tester si un arbre est bien un arbre binaire de recherche on doit connaitre la valeur maximum de l’arbre gauche et minimum de l’arbre droit et tester si l’étiquette de chaque nœud <span class="math inline">\(n\)</span> vérifie <span class="math display">\[\max _{\eta\in A_g}\limits e(\eta)\leq e(n)\leq \min _{\eta\in A_d}\limits e(\eta )\]</span> On peut écrire une procédure qui indique si l’arbre est un arbre binaire de recherche et les valeurs maximum et minimum de l’arbre (puisqu’on doit les calculer…)</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">let</span> <span class="kw">rec</span> abr_test a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>| Nil -&gt; <span class="dt">failwith</span> <span class="st">&quot;Arbre vide&quot;</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>| Noeud(Nil,n,Nil) -&gt; (<span class="kw">true</span>, n, n)</span>
<span id="cb15-4"><a href="#cb15-4"></a>| Noeud(Nil,n,d) -&gt; <span class="kw">let</span> bd, md, Md = abr_test d <span class="kw">in</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>    (bd &amp;&amp; n &lt; md, <span class="dt">min</span> n md, <span class="dt">max</span> n Md)</span>
<span id="cb15-6"><a href="#cb15-6"></a>| Noeud(g,n,Nil) -&gt; <span class="kw">let</span> bg, mg, Mg = abr_test g <span class="kw">in</span></span>
<span id="cb15-7"><a href="#cb15-7"></a>    (bg &amp;&amp; n &gt;= Mg, <span class="dt">min</span> n mg, <span class="dt">max</span> n Mg)</span>
<span id="cb15-8"><a href="#cb15-8"></a>| Noeud(g,n,d) -&gt;</span>
<span id="cb15-9"><a href="#cb15-9"></a>    <span class="kw">let</span> bg, mg, Mg = abr_test g <span class="kw">in</span></span>
<span id="cb15-10"><a href="#cb15-10"></a>    <span class="kw">let</span> bd, md, Md = abr_test d <span class="kw">in</span></span>
<span id="cb15-11"><a href="#cb15-11"></a>    (bg &amp;&amp; n &gt;= Mg &amp;&amp; n &lt; md, <span class="dt">min</span> n (<span class="dt">min</span> mg md), <span class="dt">max</span> n (<span class="dt">max</span> Mg Md))</span></code></pre></div>
<p></div></p>
<p>Ici on a fait le choix de ne rien associer à l’arbre vide et de le traiter en amont au niveau des nœuds. Cela permet de ne pas imposer de contraintes sur le type des étiquettes comme cela aurait été le cas en mettant des valeurs ad hoc dans le cas de l’arbre vide (typiquement <span class="math inline">\(\pm \infty\)</span>).</p>
<p><div class="ui message orange"><div class="header">Remarque</div>On rajoute des fonctions permettant de manipuler facilement ces données et on obtient alors un algorithme de test plus concis : <div class="ui segment code"></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">let</span> valeur a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>    | <span class="dt">None</span> -&gt; <span class="dt">failwith</span> <span class="st">&quot;None n&#39;a pas de valeur&quot;</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>    | <span class="dt">Some</span> x -&gt; x</span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="kw">let</span> opt_bin f a b = <span class="kw">match</span> a, b <span class="kw">with</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>    | <span class="dt">None</span>, _ -&gt; b</span>
<span id="cb16-7"><a href="#cb16-7"></a>    | _, <span class="dt">None</span> -&gt; a</span>
<span id="cb16-8"><a href="#cb16-8"></a>    | <span class="dt">Some</span> a, <span class="dt">Some</span> b -&gt; <span class="dt">Some</span> (f a b)</span>
<span id="cb16-9"><a href="#cb16-9"></a></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="kw">let</span> omax = opt_bin <span class="dt">max</span></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="kw">let</span> omin = opt_bin <span class="dt">min</span></span>
<span id="cb16-12"><a href="#cb16-12"></a></span>
<span id="cb16-13"><a href="#cb16-13"></a><span class="kw">let</span> abr_test a =</span>
<span id="cb16-14"><a href="#cb16-14"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb16-15"><a href="#cb16-15"></a>        | Nil -&gt; (<span class="kw">true</span>, <span class="dt">None</span>, <span class="dt">None</span>)</span>
<span id="cb16-16"><a href="#cb16-16"></a>        | Noeud(g,n,d) -&gt;</span>
<span id="cb16-17"><a href="#cb16-17"></a>            <span class="kw">let</span> bg, mg, Mg = aux g <span class="kw">in</span></span>
<span id="cb16-18"><a href="#cb16-18"></a>            <span class="kw">let</span> bd, md, Md = aux d <span class="kw">in</span></span>
<span id="cb16-19"><a href="#cb16-19"></a>            (bg &amp;&amp; (Mg = <span class="dt">None</span> || n &gt;= valeur Mg) </span>
<span id="cb16-20"><a href="#cb16-20"></a>                &amp;&amp; (md = <span class="dt">None</span> || n &lt; valeur md),</span>
<span id="cb16-21"><a href="#cb16-21"></a>            omin (<span class="dt">Some</span> n) (omin mg md),</span>
<span id="cb16-22"><a href="#cb16-22"></a>            omax (<span class="dt">Some</span> n) (omax Mg Md))</span>
<span id="cb16-23"><a href="#cb16-23"></a>    <span class="kw">in</span> <span class="kw">let</span> est_abr, min_abr, max_abr = aux a <span class="kw">in</span></span>
<span id="cb16-24"><a href="#cb16-24"></a>    (est_abr, valeur min_abr, valeur max_abr)</span></code></pre></div>
<p></div> </div></p>
<p>On verra en exercice qu’une lecture infixe permet de conclure également.</p>
<h3 data-number="4.3.2" id="sec:recherche-dun-élément"><span class="header-section-number">4.3.2</span> Recherche d’un élément</h3>
<p>Comme on leur nom l’indique, la recherche est adaptée à ce type d’arbres. Le modèle par adjonction s’applique et donc la hauteur moyenne d’un arbre binaire de recherche est un <span class="math inline">\(\bigcirc (\log_2(n))\)</span>.On peut construire la fonction de recherche:</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">let</span> <span class="kw">rec</span> recherche x a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>  |Nil -&gt; <span class="kw">false</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>  |Noeud(gauche,n,droite) <span class="kw">when</span> x=n -&gt; <span class="kw">true</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>  |Noeud(gauche,n,droite) <span class="kw">when</span> x&gt;n -&gt; recherche x droite</span>
<span id="cb17-5"><a href="#cb17-5"></a>  |Noeud(gauche,n,droite)  -&gt; recherche x gauche</span></code></pre></div>
<p></div></p>
<h3 data-number="4.3.3" id="sec:insertion-dun-élément"><span class="header-section-number">4.3.3</span> Insertion d’un élément</h3>
<p>Étant donné un arbre binaire de recherche <span class="math inline">\(a\)</span> et une étiquette <span class="math inline">\(x\)</span>, on veut construire un nouvel arbre binaire de recherche contenant les étiquettes des nœuds de <span class="math inline">\(a\)</span> et <span class="math inline">\(x\)</span>. Il n’y a bien sur pas unicité de la solution… Dans un arbre binaire de recherche, l’opération se décompose en une étape de recherche, qui renvoie des informations sur la place où doit être inséré le nouvel élément, suivie de l’adjonction proprement dite.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">let</span> <span class="kw">rec</span> insere x a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>  | Nil -&gt; Noeud(Nil,x,Nil)</span>
<span id="cb18-3"><a href="#cb18-3"></a>  | Noeud(gauche,n,droite) <span class="kw">when</span> x&gt;n -&gt;  N(gauche,n,insere x droite)</span>
<span id="cb18-4"><a href="#cb18-4"></a>  | Noeud(gauche,n,droite) -&gt; N(insere x gauche,n,droite)</span></code></pre></div>
<p></div></p>
<p>On compare <span class="math inline">\(x\)</span> à la racine pour déterminer s’il faut l’ajouter dans le sous-arbre gauche ou le sous-arbre droit, et l’on rappelle la procédure récursivement. Le dernier appel récursif se fait sur un arbre vide et l’on crée alors à cette place le nœud d’étiquette <span class="math inline">\(x\)</span>. Le nouvel arbre est reconstruit de proche en proche depuis cette branche vers la racine, sans modifier les branches non explorées. Les anciens nœuds ne sont pas modifiés et l’ancien arbre reste donc disponible.</p>
<p>Construction par insertion successive de l’ABR pour les éléments 5, 9, 1, 20 , 4, 7 , 17 , 12 : <center><div class="ui image center"><img src="assets/pics/insertionabr.png" /></div></center></p>
<h3 data-number="4.3.4" id="sec:suppression-dun-élément"><span class="header-section-number">4.3.4</span> Suppression d’un élément</h3>
<p>Le problème de la suppression d’un élément (ou plutôt de sa première occurrence) d’un arbre binaire de recherche est plus compliqué. On peut le décomposer en:</p>
<ul>
<li>Recherche de l’élément</li>
<li>Suppression</li>
<li>Recomposition de l’arbre</li>
</ul>
<p>Le nœud à supprimer est la racine d’un sous-arbre de l’arbre binaire de recherche. Commençons par considérer le problème de la suppression de la racine <span class="math inline">\(z\)</span> d’un arbre binaire de recherche.</p>
<ul>
<li>Si les deux branches issues de <span class="math inline">\(z\)</span> sont vides, on supprime et c’est fini (cas (a) de la figure <span class="math inline">\(z=13\)</span>).</li>
<li>Si l’une des deux branches issues <span class="math inline">\(z\)</span> est vide, on se contente de garder l’autre branche. On conserve ainsi un arbre binaire de recherche (cas (b) de la figure <span class="math inline">\(z=16\)</span>).</li>
<li>Si les deux branches sont non vides, soit <span class="math inline">\(y\)</span> l’élément le plus à gauche du sous-arbre droit <span class="math inline">\(A_d\)</span> de <span class="math inline">\(z\)</span>. On a <span class="math inline">\(y &gt; z\)</span> par la propriété des ABR.</li>
</ul>
<p>Remarquons que <span class="math inline">\(y\)</span> ne peut avoir de fils gauche car sinon il ne serait pas le plus à gauche de <span class="math inline">\(A_d\)</span>.</p>
<p>On peut donc le supprimer et le reporter en lieu et place de <span class="math inline">\(z\)</span> : on obtient alors un nouvel arbre qui est un arbre binaire de recherche. En effet :</p>
<ul>
<li>La branche droite est un arbre binaire de recherche (on a supprimé un nœud sans fils gauche) et l’étiquette de la racine est, par construction, inférieure aux étiquettes des nœuds de cette branche.</li>
<li>La branche gauche est un arbre binaire de recherche (on n’y a pas touché) et la nouvelle étiquette de la racine <span class="math inline">\(y\)</span> est supérieure ou égale à <span class="math inline">\(z\)</span> qui majorait les étiquettes des nœuds de la branche gauche.</li>
</ul>
<p>(cas (c) de la figure <span class="math inline">\(z=5\)</span> et <span class="math inline">\(y=6\)</span>). La localisation de <span class="math inline">\(y\)</span> est facile : c’est nécessairement l’élément le plus à gauche de <span class="math inline">\(A_d\)</span>.</p>
<p>Les trois cas de suppression : <center><div class="ui image center"><img src="assets/pics/suppression.png" /></div></center></p>
<p>On en déduit le programme suivant : <div class="ui segment code"></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">let</span> <span class="kw">rec</span> supprime a x =</span>
<span id="cb19-2"><a href="#cb19-2"></a>    <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    | Nil -&gt; Nil</span>
<span id="cb19-4"><a href="#cb19-4"></a>    | Noeud(g, y, d) <span class="kw">when</span> y &lt; x -&gt;</span>
<span id="cb19-5"><a href="#cb19-5"></a>        Noeud(g, y, supprime d x)</span>
<span id="cb19-6"><a href="#cb19-6"></a>    | Noeud(g, y, d) <span class="kw">when</span> y &gt; x -&gt;</span>
<span id="cb19-7"><a href="#cb19-7"></a>        Noeud(supprime g x, y, d)</span>
<span id="cb19-8"><a href="#cb19-8"></a>    <span class="co">(* à partir d&#39;ici l&#39;etiquette est forcement x *)</span></span>
<span id="cb19-9"><a href="#cb19-9"></a>    | Noeud(Nil, _, Nil) -&gt; Nil</span>
<span id="cb19-10"><a href="#cb19-10"></a>    | Noeud(Nil, _, d) -&gt; d</span>
<span id="cb19-11"><a href="#cb19-11"></a>    | Noeud(g, _, Nil) -&gt; g</span>
<span id="cb19-12"><a href="#cb19-12"></a>    | Noeud(g, x, d) -&gt;</span>
<span id="cb19-13"><a href="#cb19-13"></a>        <span class="kw">let</span> y = minimum d <span class="kw">in</span></span>
<span id="cb19-14"><a href="#cb19-14"></a>        Noeud(g, y, supprime d y)</span></code></pre></div>
<p></div></p>
<h2 data-number="4.4" id="sec:équilibrage"><span class="header-section-number">4.4</span> Équilibrage</h2>
<h3 data-number="4.4.1" id="sec:principe-et-approche-naïve"><span class="header-section-number">4.4.1</span> Principe et approche naïve</h3>
<p>Les opérations précédentes sont toutes en <span class="math inline">\(O(h(a))\)</span>, or on sait que <span class="math inline">\(h(a) \le |a| \le 2^{h(a)} - 1\)</span> donc <span class="math inline">\(\log_2 (|a| + 1) \le h(a) \le |a|\)</span>. On aimerait se rapprocher au plus de <span class="math inline">\(\log_2 |a|\)</span> et pour cela, il faut que l’arbre soit le plus proche possible d’un arbre parfait. On parle alors d’équilibrage.</p>
<p>Une approche naïve consiste à extraire les valeurs dans l’ordre croissant à l’aide d’un parcours infixe puis à reconstruire un arbre équilibré par dichotomie : on place la valeur médiane à la racine et on construit récursivement les sous-arbres gauche et droite.</p>
<h3 data-number="4.4.2" id="sec:arbres-2-3"><span class="header-section-number">4.4.2</span> Arbres 2-3</h3>
<p><div class="ui message"><div class="header">Définition</div> Un arbre 2-3 est un arbre étiqueté contenant des nœuds de deux types :</p>
<ul>
<li>des nœuds binaires <span class="math inline">\(N(g,x,d)\)</span> où <span class="math inline">\(g,d\)</span> sont des arbres et <span class="math inline">\(x\)</span> une étiquette tel que <span class="math inline">\(\max g \le x \le \min d\)</span> (c’est la même condition que les ABR) ;</li>
<li>des nœuds ternaires <span class="math inline">\(M(g,x,m,y,d)\)</span> où <span class="math inline">\(g,m,d\)</span> sont des arbres 2-3 et <span class="math inline">\(x,y\)</span> sont des étiquettes telles que : <span class="math inline">\(\max g \le x \le \min m \le \max m \le y \le \min d\)</span>.</li>
</ul>
<p>et parfaitement équilibré : tous les chemins de la racine à une feuille ont même longueur. </div></p>
<p>Un nœud ternaire contient donc un fils central dont les valeurs sont comprises entre ses deux étiquettes.</p>
<p>Voici un exemple d’arbre 2-3 :</p>
<p><center><div class="ui image center"><img src="assets/pics/arbre23ex.png" /></div></center></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Un arbre 2-3 à <span class="math inline">\(n\)</span> nœuds est de hauteur au plus <span class="math inline">\(\lfloor \log_2 n \rfloor\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> Les nœuds ternaires rendent l’arbre compact. Le maximum de hauteur correspond donc au cas où il ne contient que des nœuds binaires sauf sur son dernier niveau, un tel arbre est bien de hauteur <span class="math inline">\(\lfloor \log_2 n \rfloor\)</span>. </div> </div></p>
<p><strong>Recherche</strong></p>
<p>Pour rechercher un élément <span class="math inline">\(x\)</span> on adapte l’algorithme des ABRs :</p>
<ul>
<li>pour un noeud binaire <span class="math inline">\(N(g,y,d)\)</span>
<ul>
<li>si <span class="math inline">\(x &lt; y\)</span> on cherche dans <span class="math inline">\(g\)</span>;</li>
<li>si <span class="math inline">\(x = y\)</span> on a trouvé le nœud voulu;</li>
<li>si <span class="math inline">\(x &gt; y\)</span> on cherche dans <span class="math inline">\(d\)</span>.</li>
</ul></li>
<li>pour un noeud ternaire <span class="math inline">\(M(g,y,m,z,d)\)</span>
<ul>
<li>si <span class="math inline">\(x &lt; y\)</span> on cherche dans <span class="math inline">\(g\)</span>;</li>
<li>si <span class="math inline">\(x = y\)</span> ou <span class="math inline">\(x = z\)</span> on a trouvé le nœud voulu;</li>
<li>si <span class="math inline">\(z &gt; x &gt; y\)</span> on cherche dans <span class="math inline">\(m\)</span>;</li>
<li>si <span class="math inline">\(z &lt; x\)</span> on cherche dans <span class="math inline">\(d\)</span>.</li>
</ul></li>
</ul>
<p>La complexité de cet algorithme est donc encore en <span class="math inline">\(O(h)\)</span> où <span class="math inline">\(h\)</span> est la hauteur de l’arbre. En tenant compte de la remarque précédente, elle est en <span class="math inline">\(O(\log n)\)</span>.</p>
<p><strong>Insertion</strong></p>
<p>Pour insérer un élément <span class="math inline">\(x\)</span> dans un arbre 2-3, on va temporairement enrichir sa structure par des nœuds quaternaires satisfaisant les même requêtes sur les clés que les nœuds binaires et ternaires.</p>
<p>Pour insérer on effectue alors une recherche qui nous amène au dernier nœud avant les feuilles. On transforme alors ce nœud en augmentant son arité et en plaçant <span class="math inline">\(x\)</span> à la bonne position par rapport aux étiquettes qu’il contient.</p>
<p>Exemples : * 1 dans <center><div class="ui image center"><img src="assets/pics/a23_ins1.png" /></div></center></p>
<p>donne <center><div class="ui image center"><img src="assets/pics/a23_ins1b.png" /></div></center></p>
<ul>
<li>8 dans <center><div class="ui image center"><img src="assets/pics/a23_ins8.png" /></div></center></li>
</ul>
<p>donne <center><div class="ui image center"><img src="assets/pics/a23_ins8b.png" /></div></center></p>
<p>Maintenant on va supprimer les nœuds quaternaires en les faisant remonter, au pire, jusqu’à la racine pour laquelle on peut faire l’opération suivante : <center><div class="ui image center"><img src="assets/pics/a23_ins_a.png" /></div></center></p>
<p><span class="math inline">\(\rightarrow\)</span> <center><div class="ui image center"><img src="assets/pics/a23_ins_b.png" /></div></center></p>
<p>Voici tous les cas de transformations selon le type du père et la position du nœud quaternaire : * fils gauche d’un binaire : <center><div class="ui image center"><img src="assets/pics/a23_ins_4_a.png" /></div></center></p>
<p><span class="math inline">\(\rightarrow\)</span> <center><div class="ui image center"><img src="assets/pics/a23_ins_4_b.png" /></div></center></p>
<ul>
<li>fils droit d’un binaire : <center><div class="ui image center"><img src="assets/pics/a23_ins_4_c.png" /></div></center></li>
</ul>
<p><span class="math inline">\(\rightarrow\)</span> <center><div class="ui image center"><img src="assets/pics/a23_ins_4_d.png" /></div></center></p>
<ul>
<li>fils gauche d’un ternaire : <center><div class="ui image center"><img src="assets/pics/a23_ins_4_e.png" /></div></center></li>
</ul>
<p><span class="math inline">\(\rightarrow\)</span> <center><div class="ui image center"><img src="assets/pics/a23_ins_4_f.png" /></div></center></p>
<ul>
<li>fils central d’un ternaire : <center><div class="ui image center"><img src="assets/pics/a23_ins_4_g.png" /></div></center></li>
</ul>
<p><span class="math inline">\(\rightarrow\)</span> <center><div class="ui image center"><img src="assets/pics/a23_ins_4_h.png" /></div></center></p>
<ul>
<li>fils droit d’un ternaire : <center><div class="ui image center"><img src="assets/pics/a23_ins_4_i.png" /></div></center></li>
</ul>
<p><span class="math inline">\(\rightarrow\)</span> <center><div class="ui image center"><img src="assets/pics/a23_ins_4_j.png" /></div></center></p>
<p>On observe rapidement que toutes ces transformations préservent la position des sous-arbres vis-à-vis des étiquettes des nœuds. Ainsi, au final on aura obtenu un arbre 2-3.</p>
<p><strong>Remarque sur l’implémentation</strong></p>
<p>Les arbres 2-3 sont simples à comprendre mais complexes à programmer :</p>
<ul>
<li>beaucoup de cas à traiter, notamment en fonction des parents ;</li>
<li>des nœuds intermédiaires 2-3-4 qui demandent d’avoir un type de travail et un type final.</li>
</ul>
<p>On va voir dans un dernier temps des arbres quasiment équivalent à ceux-ci mais bien plus simples à programmer.</p>
<h3 data-number="4.4.3" id="sec:arbres-rouges-et-noirs"><span class="header-section-number">4.4.3</span> Arbres rouges et noirs</h3>
<p>On va transformer un arbre 2-3 en ABR en transformant les nœuds ternaires ainsi :</p>
<p><center><div class="ui image center"><img src="assets/pics/arn_23.png" /></div></center></p>
<p><span class="math inline">\(\rightarrow\)</span> <center><div class="ui image center"><img src="assets/pics/arn_23rn.png" /></div></center></p>
<p>Afin de se souvenir que le nœud <span class="math inline">\(a\)</span> provient de cette séparation, on le marque en rouge. Ici on a également marqué l’arête gauche en rouge mais on l’omettra dans la suite.</p>
<p>Quelles remarques :</p>
<ul>
<li>la racine est noire et les feuilles sont noires ;</li>
<li>le fils gauche d’un nœud est toujours noir ;</li>
<li>il ne peut exister d’arêtes liant deux nœuds rouges car par construction les nœuds rouges sont toujours entourés de nœuds noirs ;</li>
<li>les chemins d’une feuille à la racine dans l’arbre 2-3 sont tous de même taille, à chacun des nœuds de l’arbre 2-3 correspond un nœud noir, on en déduit donc que tous les chemins de la racine aux feuilles contiennent le même nombre de nœud noirs.</li>
</ul>
<p>Réciproquement un arbre ABR dont les nœuds peuvent avoir ces deux couleurs et qui vérifie ces propriétés est appelé un arbre rouge et noir.</p>
<p>En fait, on a une bijection entre les arbres 2-3 et les arbres rouges et noirs ainsi définis.</p>
<p>La proposition suivante permet de voir que les arbres rouges et noirs sont de bons ABRs :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>La hauteur d’un arbre rouge et noir est au maximum égale au double de la hauteur de l’arbre 2-3 qui lui est associé.</p>
<p>Ainsi tout arbre rouge et noir de taille <span class="math inline">\(n\)</span> est de hauteur <span class="math inline">\(O(\log n)\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> La hauteur n’augmente que par séparation des nœuds ternaires. Or, il ne peut il y en avoir plus que la hauteur de l’arbre 2-3. </div> </div></p>
<p>Pour l’insertion d’un nœud, on va déstabiliser la coloration en mettant trop de nœuds rouges, puis on va rétablir les contraintes en remontant vers la racine. Cela rappelle l’élimination des nœuds quartenaires des arbres 2-3. Mettre des nœuds rouges à l’avantage de préserver l’equilibrage noir.</p>
<p>Pour rétablir les couleurs, on va alors utiliser une succession de deux opérations élémentaires : les rotations et la bascule.</p>
<p><strong>Rotations</strong></p>
<p>On définit les deux rotations gauche et droite, duales l’une de l’autre, ainsi : <center><div class="ui image center"><img src="assets/pics/arn_rot.png" /></div></center></p>
<p>Ici, on a utilisé la couleur bleue pour représenter la couleur du nœud de départ qui peut être soit rouge soit noire mais va être préservée.</p>
<p>Les rotations permettent donc de faire pencher des nœuds rouges à droite ou à gauche.</p>
<p>On remarque que la hauteur en nœuds noirs de l’arbre n’a pas changé.</p>
<p>On peut passer d’une des trois représentations convenables des nœuds quaternaires à une autre à l’aide de rotations : <center><div class="ui image center"><img src="assets/pics/arn_rot2.png" /></div></center></p>
<p><strong>Bascule</strong></p>
<p>Une autre opération importante dans les arbres rouges et noirs est le bascule qui permet de faire remonter les défauts de coloration vers la racine tout en préservant l’équilibre en nœuds noirs :</p>
<p><center><div class="ui image center"><img src="assets/pics/arn_bascule.png" /></div></center></p>
<p>Si on effectue une bascule directement sur la racine de l’arbre consideré, on finit par la noircir ce qui augmente de un la profondeur noire de chaque feuille mais ne change pas l’équilibrage global.</p>
<p><strong>Insertion</strong></p>
<p>Selon les remarque précédente, on ne va pas hésiter à perdre la propriété des arbres rouges et noirs temporairement. De toutes les propriétés de ces arbres, c’est surement le fait qu’ils soient parfaitement équilibrés en nœuds noirs qui est le plus dur à assurer. On ne va donc pas toucher à cette propriété : on va insérer des nœuds rouges sous une feuille.</p>
<p>En faisant cela on risque d’avoir deux types de problèmes :</p>
<ul>
<li>des arêtes rouge-rouge ;</li>
<li>des fils gauches rouges.</li>
</ul>
<p>On va alors traiter les différents cas d’insertion et voir comment on peut les ajuster pour obtenir des arbres rouges et noirs.</p>
<p><strong>Insertion dans un nœud issu d’un nœud binaire</strong></p>
<p>Un nœud noir issu d’un nœud binaire a nécessairement ses deux fils qui sont vides ou non vides simultanément, car ils proviennent directement de la structure parfaitement équilibré des arbres 2-3.</p>
<p>On a alors les deux cas suivants d’insertion : <center><div class="ui image center"><img src="assets/pics/arn_ins_bin.png" /></div></center></p>
<p><center><div class="ui image center"><img src="assets/pics/arn_ins2.png" /></div></center></p>
<p>Dans les deux cas on se ramène à un nœud ternaire directement.</p>
<p><strong>Insertion dans un nœud issu d’un nœud ternaire</strong></p>
<p>On a trois cas d’insertions selon la position de la nouvelle valeur par rapport aux nœuds deux valeurs du nœud ternaire.</p>
<p>Supposons que l’on insère <span class="math inline">\(z\)</span> dans l’arbre : <center><div class="ui image center"><img src="assets/pics/arn_tern_a.png" /></div></center></p>
<ul>
<li><p>Si <span class="math inline">\(x \le y \le z\)</span> : <center><div class="ui image center"><img src="assets/pics/arn_tern_d1.png" /></div></center></p></li>
<li><p>Si <span class="math inline">\(z \le x \le y\)</span> : <center><div class="ui image center"><img src="assets/pics/arn_tern_g1.png" /></div></center></p></li>
<li><p>Si <span class="math inline">\(x \le z \le y\)</span> : <center><div class="ui image center"><img src="assets/pics/arn_ins_m1.png" /></div></center></p></li>
</ul>
<p>Ici, on ne peut pas rétablir tout de suite la structure mais on peut faire remonter le problème jusqu’à la racine, quitte à faire une bascule finale qui va la noircir. On va donc partir d’un des trois problèmes précédents mais supposer qu’il se situe sur un nœud quelconque avec des sous-arbres rouges et noirs <span class="math inline">\(t_1, t_2, t_3\)</span> et <span class="math inline">\(t_4\)</span>.</p>
<p><center><div class="ui image center"><img src="assets/pics/arn_tern_d1b.png" /></div></center></p>
<p><center><div class="ui image center"><img src="assets/pics/arn_tern_g1b.png" /></div></center></p>
<p><center><div class="ui image center"><img src="assets/pics/arn_ins_m1b.png" /></div></center></p>
<p>On remarque qu’on effectue essentiellement les mêmes opérations, et quitte à les inhiber quand on ne peut pas les appliquer, on peut se dire que pour insérer <span class="math inline">\(z\)</span> dans l’arbre <span class="math inline">\(a\)</span>, on le rajoute récursivement à gauche ou à droite, on obtient ainsi <span class="math inline">\(a&#39;\)</span> et on effectue alors</p>
<p><span class="math display">\[
(\text{bascule}^? \circ \text{rot\_gauche}^? \circ \text{rot\_droite}^?)(a&#39;)
\]</span></p>
<p>où ici, <span class="math inline">\(\text{op}^?\)</span> signifie qu’on effectue l’opération uniquement si elle s’applique :</p>
<ul>
<li>pour une rotation droite, il faut que le fils gauche soit rouge et le fils droit noir, pour ne pas tomber dans le cas d’une bascule</li>
<li>pour une rotation gauche, il faut que le fils droit et le fils droit du fils droit soient rouges</li>
<li>pour une bascule, que les deux fils soient rouges</li>
</ul>
<p><strong>Implémentation</strong></p>
<p>On commence par définir le type des arbres rouges et noirs :</p>
<p><div>   <div class="ui top attached tabular menu code">   <a class="active item" data-tab="ocaml-233">ocaml</a>   <a class="item" data-tab="c-233">c</a>   <a class="item" data-tab="python-233">python</a> </div> <div class="ui bottom attached active tab segment code" data-tab="ocaml-233"></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> couleur = R | N</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a arn = Nil | Noeud <span class="kw">of</span> couleur * &#39;a arn * &#39;a * &#39;a arn</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="c-233"></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="python-233"></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>ERROR: src<span class="op">/</span>structuresdonnees<span class="op">/</span>..<span class="op">/</span>..<span class="op">/</span>snippets<span class="op">/</span>structures<span class="op">/</span>arn.py does <span class="kw">not</span> exist</span></code></pre></div>
<p></div> </div></p>
<p>On définit ensuite des fonctions qui nous seront utiles vue la remarque précédente pour tester les couleurs à gauche et à droite :</p>
<p><div>   <div class="ui top attached tabular menu code">   <a class="active item" data-tab="ocaml-238">ocaml</a>   <a class="item" data-tab="c-238">c</a>   <a class="item" data-tab="python-238">python</a> </div> <div class="ui bottom attached active tab segment code" data-tab="ocaml-238"></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> gauche a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    | Nil -&gt; <span class="dt">failwith</span> <span class="st">&quot;Invalide&quot;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    | Noeud(_,g,_,_) -&gt; g</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> droite a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    | Nil -&gt; <span class="dt">failwith</span> <span class="st">&quot;Invalide&quot;</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    | Noeud(_,_,_,d) -&gt; d</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> couleur a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    | Nil -&gt; N</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    | Noeud(c,_,_,_) -&gt; c</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rouge a = couleur a = R</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> noir a = <span class="dt">not</span> (rouge a)</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="c-238"></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="python-238"></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>ERROR: src<span class="op">/</span>structuresdonnees<span class="op">/</span>..<span class="op">/</span>..<span class="op">/</span>snippets<span class="op">/</span>structures<span class="op">/</span>arn.py does <span class="kw">not</span> exist</span></code></pre></div>
<p></div> </div></p>
<p>On implémente alors les rotations et la bascule avec le filtrage.</p>
<p><div>   <div class="ui top attached tabular menu code">   <a class="active item" data-tab="ocaml-243">ocaml</a>   <a class="item" data-tab="c-243">c</a>   <a class="item" data-tab="python-243">python</a> </div> <div class="ui bottom attached active tab segment code" data-tab="ocaml-243"></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rotation_gauche a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    | Noeud(c,t1,x,Noeud(R,t2,y,t3)) -&gt; </span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>            Noeud(c,Noeud(R,t1,x,t2),y,t3)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="dt">failwith</span> <span class="st">&quot;Invalide&quot;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rotation_droite a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    | Noeud(c,Noeud(R,t1,x,t2),y,t3)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>        -&gt; Noeud(c,t1,x,Noeud(R,t2,y,t3))</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="dt">failwith</span> <span class="st">&quot;Invalide&quot;</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> bascule a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    | Noeud(N,Noeud(R,t1,x,t2),y,Noeud(R,t3,z,t4))</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>        -&gt; Noeud(R,Noeud(N,t1,x,t2),y,Noeud(N,t3,z,t4))</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="dt">failwith</span> <span class="st">&quot;Invalide&quot;</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> noircit a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    | Noeud(_,g,x,d) -&gt; Noeud(N,g,x,d)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    | Nil -&gt; Nil</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="c-243"></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="python-243"></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>ERROR: src<span class="op">/</span>structuresdonnees<span class="op">/</span>..<span class="op">/</span>..<span class="op">/</span>snippets<span class="op">/</span>structures<span class="op">/</span>arn.py does <span class="kw">not</span> exist</span></code></pre></div>
<p></div> </div></p>
<p>Puis, les versions optionnelles qui ne s’effectuent que si c’est nécessaire :</p>
<p><div>   <div class="ui top attached tabular menu code">   <a class="active item" data-tab="ocaml-248">ocaml</a>   <a class="item" data-tab="c-248">c</a>   <a class="item" data-tab="python-248">python</a> </div> <div class="ui bottom attached active tab segment code" data-tab="ocaml-248"></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> essai_rotgauche a =</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> rouge (droite a) &amp;&amp; rouge (droite (droite a))</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> rotation_gauche a <span class="kw">else</span> a</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> essai_rotdroite a =</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> rouge (gauche a) &amp;&amp; noir (droite a)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> rotation_droite a <span class="kw">else</span> a</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> essai_bascule a =</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> rouge (gauche a) &amp;&amp; rouge (droite a)</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> bascule a <span class="kw">else</span> a</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="c-248"></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="python-248"></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>ERROR: src<span class="op">/</span>structuresdonnees<span class="op">/</span>..<span class="op">/</span>..<span class="op">/</span>snippets<span class="op">/</span>structures<span class="op">/</span>arn.py does <span class="kw">not</span> exist</span></code></pre></div>
<p></div> </div></p>
<p>On peut alors réaliser l’insertion récursivement :</p>
<p><div>   <div class="ui top attached tabular menu code">   <a class="active item" data-tab="ocaml-253">ocaml</a>   <a class="item" data-tab="c-253">c</a>   <a class="item" data-tab="python-253">python</a> </div> <div class="ui bottom attached active tab segment code" data-tab="ocaml-253"></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> insere a x =</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux a =</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>        | Nil -&gt; Noeud(R,Nil,x,Nil)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>        | Noeud(c,g,y,d) -&gt;</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> a&#39; = </span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>                <span class="kw">if</span> x &lt; y</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> Noeud(c,aux g,y,d)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>                <span class="kw">else</span> Noeud(c,g,y,aux d)</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">in</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>            essai_bascule</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>                (essai_rotgauche</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>                    (essai_rotdroite a&#39;))</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> noircit (aux a)</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="c-253"></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="python-253"></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>ERROR: src<span class="op">/</span>structuresdonnees<span class="op">/</span>..<span class="op">/</span>..<span class="op">/</span>snippets<span class="op">/</span>structures<span class="op">/</span>arn.py does <span class="kw">not</span> exist</span></code></pre></div>
<p></div> </div></p>
<h2 data-number="4.5" id="sec:implémentation-dun-dictionnaire"><span class="header-section-number">4.5</span> Implémentation d’un dictionnaire</h2>
<h1 data-number="5" id="sec:tas"><span class="header-section-number">5</span> Tas</h1>
<h2 data-number="5.1" id="sec:présentation"><span class="header-section-number">5.1</span> Présentation</h2>
<h2 data-number="5.2" id="sec:implémentation-1"><span class="header-section-number">5.2</span> Implémentation</h2>
<h2 data-number="5.3" id="sec:application-aux-files-de-priorité"><span class="header-section-number">5.3</span> Application aux files de priorité</h2>
<h1 data-number="6" id="sec:tp"><span class="header-section-number">6</span> TP</h1>
<h2 data-number="6.1" id="sec:arbres-en-ocaml"><span class="header-section-number">6.1</span> Arbres en <code>OCaml</code></h2>
<h3 data-number="6.1.1" id="sec:premières-fonctions"><span class="header-section-number">6.1.1</span> Premières fonctions</h3>
<p>On va considérer le type des arbres binaires <code>'a arbre</code> défini par :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">type</span> &#39;a arbre = Nil | Noeud <span class="kw">of</span> &#39;a arbre * &#39;a * &#39;a arbre</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb36-1"><a href="#cb36-1"></a><span class="co">(* Calcule le nombre de noeuds de a *)</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="kw">let</span> taille (a : &#39;a arbre) : <span class="dt">int</span></span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="co">(* Calcule la hauteur de a *)</span></span>
<span id="cb36-4"><a href="#cb36-4"></a><span class="kw">let</span> hauteur (a : &#39;a arbre) : <span class="dt">int</span></span>
<span id="cb36-5"><a href="#cb36-5"></a><span class="co">(* Indique si a est réduit à une feuille *)</span></span>
<span id="cb36-6"><a href="#cb36-6"></a><span class="kw">let</span> feuille (a : &#39;a arbre) : <span class="dt">bool</span></span></code></pre></div>
<p></div></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">let</span> <span class="kw">rec</span> taille a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb37-2"><a href="#cb37-2"></a>    | Nil -&gt; <span class="dv">0</span></span>
<span id="cb37-3"><a href="#cb37-3"></a>    | Noeud(g,x,d) -&gt; <span class="dv">1</span> + taille g + taille d</span>
<span id="cb37-4"><a href="#cb37-4"></a></span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="kw">let</span> <span class="kw">rec</span> hauteur a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb37-6"><a href="#cb37-6"></a>    | Nil -&gt; <span class="dv">-1</span></span>
<span id="cb37-7"><a href="#cb37-7"></a>    | Noeud(g,x,d) -&gt;</span>
<span id="cb37-8"><a href="#cb37-8"></a>            <span class="dv">1</span> + <span class="dt">max</span> (hauteur g) (hauteur d)</span>
<span id="cb37-9"><a href="#cb37-9"></a></span>
<span id="cb37-10"><a href="#cb37-10"></a><span class="kw">let</span> feuille a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb37-11"><a href="#cb37-11"></a>    | Nil -&gt; <span class="kw">false</span></span>
<span id="cb37-12"><a href="#cb37-12"></a>    | Noeud(g, x, d) -&gt; g = Nil &amp;&amp; d = Nil</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>sous_arbres</code> qui renvoie la liste des sous-arbres non vides d’un arbre.</p>
<p>En déduire des fonctions <code>noeuds</code>, <code>feuilles</code> et <code>noeuds_internes</code> qui renvoient la liste des étiquettes des <code>noeuds</code> correspondants.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">let</span> <span class="kw">rec</span> sous_arbres a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb38-2"><a href="#cb38-2"></a>    | Nil -&gt; []</span>
<span id="cb38-3"><a href="#cb38-3"></a>    | Noeud(g, x, d) -&gt;</span>
<span id="cb38-4"><a href="#cb38-4"></a>       a :: (sous_arbres g @ sous_arbres d)</span>
<span id="cb38-5"><a href="#cb38-5"></a></span>
<span id="cb38-6"><a href="#cb38-6"></a><span class="kw">let</span> <span class="kw">rec</span> noeuds a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb38-7"><a href="#cb38-7"></a>    | Nil -&gt; []</span>
<span id="cb38-8"><a href="#cb38-8"></a>    | Noeud(g, x, d) -&gt;</span>
<span id="cb38-9"><a href="#cb38-9"></a>        x :: (noeuds g @ noeuds d)</span>
<span id="cb38-10"><a href="#cb38-10"></a></span>
<span id="cb38-11"><a href="#cb38-11"></a><span class="kw">let</span> <span class="kw">rec</span> feuilles a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb38-12"><a href="#cb38-12"></a>    | Nil -&gt; []</span>
<span id="cb38-13"><a href="#cb38-13"></a>    | Noeud(g, x, d) -&gt;</span>
<span id="cb38-14"><a href="#cb38-14"></a>        <span class="kw">if</span> feuille a <span class="kw">then</span> [x]</span>
<span id="cb38-15"><a href="#cb38-15"></a>        <span class="kw">else</span> feuilles g @ feuilles d</span>
<span id="cb38-16"><a href="#cb38-16"></a></span>
<span id="cb38-17"><a href="#cb38-17"></a><span class="kw">let</span> <span class="kw">rec</span> noeuds_internes a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb38-18"><a href="#cb38-18"></a>    | Nil -&gt; []</span>
<span id="cb38-19"><a href="#cb38-19"></a>    | Noeud(Nil, _, Nil) -&gt; []</span>
<span id="cb38-20"><a href="#cb38-20"></a>    | Noeud(g, x, d) -&gt;</span>
<span id="cb38-21"><a href="#cb38-21"></a>        x :: (noeuds_internes g @ noeuds_internes d)</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>Pour accéder à un nœud de l’arbre, on descend en partant de la racine et en allant à gauche ou à droite. On peut donc représenter un tel chemin par une liste de déplacements :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">type</span> deplacement = Gauche | Droite</span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="kw">type</span> chemin = deplacement <span class="dt">list</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>chemin_noeud : 'a arbre -&gt; chemin -&gt; 'a option</code> qui renvoie l’étiquette d’un nœud donné par son chemin. On utilise un type <code>option</code> en cas de chemin invalide.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">type</span> deplacement = Gauche | Droite</span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="kw">type</span> chemin = deplacement <span class="dt">list</span></span>
<span id="cb40-3"><a href="#cb40-3"></a></span>
<span id="cb40-4"><a href="#cb40-4"></a><span class="kw">let</span> <span class="kw">rec</span> chemin_noeud a l =</span>
<span id="cb40-5"><a href="#cb40-5"></a>    <span class="kw">match</span> a, l <span class="kw">with</span></span>
<span id="cb40-6"><a href="#cb40-6"></a>    | Nil, _ -&gt; <span class="dt">None</span></span>
<span id="cb40-7"><a href="#cb40-7"></a>    | Noeud(g,x,d), Gauche::q -&gt; chemin_noeud g q</span>
<span id="cb40-8"><a href="#cb40-8"></a>    | Noeud(g,x,d), Droite::q -&gt; chemin_noeud d q</span>
<span id="cb40-9"><a href="#cb40-9"></a>    | Noeud(g,x,d), [] -&gt; <span class="dt">Some</span> x</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h3 data-number="6.1.2" id="sec:parcours-1"><span class="header-section-number">6.1.2</span> Parcours</h3>
<p>Sur le même modèle que l’exploration par <em>backtracking</em>, on va réaliser un parcours en profondeur d’un arbre en explorant à gauche puis à droite ses sous-arbres de manière récursives. Chaque nœud est donc vu trois fois :</p>
<ul>
<li>une première fois quand on le découvre avant d’explorer son sous-arbre gauche</li>
<li>entre les deux explorations</li>
<li>enfin quand on a fini d’explorer son sous-arbre droit.</li>
</ul>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions <code>affiche_avant</code>, <code>affiche_milieu</code> et <code>affiche_apres</code> qui parcourt et affiche les étiquettes d’un <code>string arbre</code> selon les trois cas précédents. <em>Note: il s’agit essentiellement du même code à une ligne près</em>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb41"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb41-1"><a href="#cb41-1"></a><span class="kw">let</span> <span class="kw">rec</span> affiche_avant a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb41-2"><a href="#cb41-2"></a>    | Nil -&gt; ()</span>
<span id="cb41-3"><a href="#cb41-3"></a>    | Noeud(g,x,d) -&gt;</span>
<span id="cb41-4"><a href="#cb41-4"></a>            <span class="dt">print_string</span> x;</span>
<span id="cb41-5"><a href="#cb41-5"></a>            affiche_avant g;</span>
<span id="cb41-6"><a href="#cb41-6"></a>            affiche_avant d</span>
<span id="cb41-7"><a href="#cb41-7"></a></span>
<span id="cb41-8"><a href="#cb41-8"></a></span>
<span id="cb41-9"><a href="#cb41-9"></a><span class="kw">let</span> <span class="kw">rec</span> affiche_milieu a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb41-10"><a href="#cb41-10"></a>    | Nil -&gt; ()</span>
<span id="cb41-11"><a href="#cb41-11"></a>    | Noeud(g,x,d) -&gt;</span>
<span id="cb41-12"><a href="#cb41-12"></a>            affiche_milieu g;</span>
<span id="cb41-13"><a href="#cb41-13"></a>            <span class="dt">print_string</span> x;</span>
<span id="cb41-14"><a href="#cb41-14"></a>            affiche_milieu d</span>
<span id="cb41-15"><a href="#cb41-15"></a></span>
<span id="cb41-16"><a href="#cb41-16"></a></span>
<span id="cb41-17"><a href="#cb41-17"></a><span class="kw">let</span> <span class="kw">rec</span> affiche_apres a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb41-18"><a href="#cb41-18"></a>    | Nil -&gt; ()</span>
<span id="cb41-19"><a href="#cb41-19"></a>    | Noeud(g,x,d) -&gt;</span>
<span id="cb41-20"><a href="#cb41-20"></a>            affiche_apres g;</span>
<span id="cb41-21"><a href="#cb41-21"></a>            affiche_apres d;</span>
<span id="cb41-22"><a href="#cb41-22"></a>            <span class="dt">print_string</span> x</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>On peut représenter une expression arithmétique comme <span class="math inline">\((2+3)\times 4\)</span> en tant qu’arbre avec des opérations pour les nœuds internes et des valeurs pour les feuilles. Quitte à utiliser des <code>string</code> dans les deux cas, qu’obtient-on sur une telle expression avec les trois opérations précédentes ?</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">let</span> <span class="kw">rec</span> evalue a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb42-2"><a href="#cb42-2"></a>    | Nil -&gt; <span class="dt">failwith</span> <span class="st">&quot;Vide&quot;</span></span>
<span id="cb42-3"><a href="#cb42-3"></a>    | Noeud(Nil,x,Nil) -&gt; <span class="dt">int_of_string</span> x</span>
<span id="cb42-4"><a href="#cb42-4"></a>    | Noeud(g, x, d) -&gt;</span>
<span id="cb42-5"><a href="#cb42-5"></a>            <span class="kw">let</span> eg = evalue g <span class="kw">in</span></span>
<span id="cb42-6"><a href="#cb42-6"></a>            <span class="kw">let</span> ed = evalue d <span class="kw">in</span></span>
<span id="cb42-7"><a href="#cb42-7"></a>            <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb42-8"><a href="#cb42-8"></a>            | <span class="st">&quot;+&quot;</span> -&gt; eg + ed</span>
<span id="cb42-9"><a href="#cb42-9"></a>            | <span class="st">&quot;*&quot;</span> -&gt; eg * ed</span>
<span id="cb42-10"><a href="#cb42-10"></a>            | _ -&gt; <span class="dt">failwith</span> <span class="st">&quot;Ope inconnue&quot;</span></span></code></pre></div>
<p></div></p>
<p>L’appel à <code>affiche_avant</code> sur l’expression <span class="math inline">\((2+3)\times 4\)</span> va afficher <code>*+234</code>.</p>
<p>L’appel à <code>affiche_milieu</code> sur l’expression <span class="math inline">\((2+3)\times 4\)</span> va afficher <code>2+3*4</code>.</p>
<p>L’appel à <code>affiche_apres</code> sur l’expression <span class="math inline">\((2+3)\times 4\)</span> va afficher <code>23+4*</code>.</p>
<p>On retrouve ainsi les notions préfixes, infixes et postfixes d’une expression arithmétique. </div> </div></p>
<p>On redonne ici l’implémentation d’une pile et d’une file en <code>OCaml</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb43-1"><a href="#cb43-1"></a><span class="kw">let</span> pile_creer () = <span class="dt">ref</span> []</span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="kw">let</span> pile_empile p x = p := x :: !p</span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="kw">let</span> pile_depile p =</span>
<span id="cb43-4"><a href="#cb43-4"></a>    <span class="kw">match</span> !p <span class="kw">with</span></span>
<span id="cb43-5"><a href="#cb43-5"></a>    | [] -&gt; <span class="dt">failwith</span> <span class="st">&quot;Pile vide&quot;</span></span>
<span id="cb43-6"><a href="#cb43-6"></a>    | x::q -&gt; p := q; x</span>
<span id="cb43-7"><a href="#cb43-7"></a><span class="kw">let</span> pile_est_vide p = !p = []</span>
<span id="cb43-8"><a href="#cb43-8"></a></span>
<span id="cb43-9"><a href="#cb43-9"></a><span class="kw">let</span> file_creer () = (pile_creer (), pile_creer ())</span>
<span id="cb43-10"><a href="#cb43-10"></a><span class="kw">let</span> file_bascule (pin, pout) = pout := <span class="dt">List</span>.rev !pin; pin := []</span>
<span id="cb43-11"><a href="#cb43-11"></a><span class="kw">let</span> file_enfile (pin, pout) x = pile_empile pin x</span>
<span id="cb43-12"><a href="#cb43-12"></a><span class="kw">let</span> file_defile (pin, pout) =</span>
<span id="cb43-13"><a href="#cb43-13"></a>    <span class="kw">if</span> pile_est_vide pout </span>
<span id="cb43-14"><a href="#cb43-14"></a>    <span class="kw">then</span> file_bascule (pin, pout);</span>
<span id="cb43-15"><a href="#cb43-15"></a>    pile_depile pout</span>
<span id="cb43-16"><a href="#cb43-16"></a><span class="kw">let</span> file_est_vide (pin, pout) = pile_est_vide pin &amp;&amp; pile_est_vide pout</span></code></pre></div>
<p></div></p>
<p>Ces deux structures de données ont la même interface mais deux comportements différents. On va utiliser un unique type pour les représenter afin de permettre à une fonction d’utiliser soit une pile soit une file.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb44"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb44-1"><a href="#cb44-1"></a><span class="kw">type</span> (&#39;a, &#39;b) taches = {</span>
<span id="cb44-2"><a href="#cb44-2"></a>    creation : <span class="dt">unit</span> -&gt; &#39;a;</span>
<span id="cb44-3"><a href="#cb44-3"></a>    ajouter : &#39;a -&gt; &#39;b -&gt; <span class="dt">unit</span>;</span>
<span id="cb44-4"><a href="#cb44-4"></a>    retirer : &#39;a -&gt; &#39;b;</span>
<span id="cb44-5"><a href="#cb44-5"></a>    est_vide : &#39;a -&gt; <span class="dt">bool</span></span>
<span id="cb44-6"><a href="#cb44-6"></a>}</span>
<span id="cb44-7"><a href="#cb44-7"></a></span>
<span id="cb44-8"><a href="#cb44-8"></a><span class="kw">let</span> taches_pile = {</span>
<span id="cb44-9"><a href="#cb44-9"></a>    creation = pile_creer;</span>
<span id="cb44-10"><a href="#cb44-10"></a>    ajouter = pile_empile;</span>
<span id="cb44-11"><a href="#cb44-11"></a>    retirer = pile_depile;</span>
<span id="cb44-12"><a href="#cb44-12"></a>    est_vide = pile_est_vide</span>
<span id="cb44-13"><a href="#cb44-13"></a>    }</span>
<span id="cb44-14"><a href="#cb44-14"></a></span>
<span id="cb44-15"><a href="#cb44-15"></a><span class="kw">let</span> taches_file = {</span>
<span id="cb44-16"><a href="#cb44-16"></a>    creation = file_creer;</span>
<span id="cb44-17"><a href="#cb44-17"></a>    ajouter = file_enfile;</span>
<span id="cb44-18"><a href="#cb44-18"></a>    retirer = file_defile;</span>
<span id="cb44-19"><a href="#cb44-19"></a>    est_vide = file_est_vide</span>
<span id="cb44-20"><a href="#cb44-20"></a>    }</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Ici, on a une limitation du système de types. On aimerait paramètrer <code>taches</code> par <code>('a 'b, 'a)</code> où <code>'b</code> est un type paramètré, ainsi on aurait soit <code>('a pile, 'a)</code> où <code>('a file, 'a)</code> comme pour les deux case. Cependant, ce n’est pas possible, les types génériques ne sont pas paramètriques. C’est pour cela qu’on a un <code>('a, 'b)</code> sans avoir de lien apparent entre <code>'a</code> et <code>'b</code>.</div></p>
<p>On pourra alors écrire une fonction prenant un gestionnaire de tâches en paramètre :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb45"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb45-1"><a href="#cb45-1"></a><span class="kw">let</span> f t a =</span>
<span id="cb45-2"><a href="#cb45-2"></a>    <span class="kw">let</span> a_traiter = t.creation () <span class="kw">in</span></span>
<span id="cb45-3"><a href="#cb45-3"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> <span class="dt">Array</span>.length a - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb45-4"><a href="#cb45-4"></a>        t.ajouter a_traiter a.(i)</span>
<span id="cb45-5"><a href="#cb45-5"></a>    <span class="kw">done</span>;</span>
<span id="cb45-6"><a href="#cb45-6"></a>    <span class="kw">while</span> <span class="dt">not</span> (t.est_vide a_traiter) <span class="kw">do</span></span>
<span id="cb45-7"><a href="#cb45-7"></a>        <span class="dt">print_int</span> (t.retirer a_traiter)</span>
<span id="cb45-8"><a href="#cb45-8"></a>    <span class="kw">done</span></span></code></pre></div>
<p></div></p>
<p>Ainsi <code>f taches_pile [|1;2;3|]</code> va afficher <code>321</code> et <code>f taches_file [|1;2;3|]</code> va afficher <code>123</code>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>En déduire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb46"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb46-1"><a href="#cb46-1"></a>parcours : (&#39;a, &#39;b arbre) taches -&gt; &#39;b arbre -&gt; <span class="dt">unit</span></span></code></pre></div>
<p></div> qui effectue un parcours de l’arbre en affichant les étiquettes des nœuds visités dans l’ordre induit par le gestionnaire de tâches passé en paramètre.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb47"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">let</span> parcours t a =</span>
<span id="cb47-2"><a href="#cb47-2"></a>    <span class="kw">let</span> avisiter = t.creation () <span class="kw">in</span></span>
<span id="cb47-3"><a href="#cb47-3"></a>    t.ajouter avisiter a;</span>
<span id="cb47-4"><a href="#cb47-4"></a>    <span class="kw">while</span> <span class="dt">not</span> (t.est_vide avisiter) <span class="kw">do</span></span>
<span id="cb47-5"><a href="#cb47-5"></a>        <span class="kw">match</span> t.retirer avisiter <span class="kw">with</span></span>
<span id="cb47-6"><a href="#cb47-6"></a>        | Nil -&gt; ()</span>
<span id="cb47-7"><a href="#cb47-7"></a>        | Noeud(g,x,d) -&gt;</span>
<span id="cb47-8"><a href="#cb47-8"></a>                <span class="dt">print_int</span> x;</span>
<span id="cb47-9"><a href="#cb47-9"></a>                t.ajouter avisiter g;</span>
<span id="cb47-10"><a href="#cb47-10"></a>                t.ajouter visiter d</span>
<span id="cb47-11"><a href="#cb47-11"></a>    <span class="kw">done</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h3 data-number="6.1.3" id="sec:arbres-binaires-stricts-1"><span class="header-section-number">6.1.3</span> Arbres binaires stricts</h3>
<p>Pour représenter des arbres dont les nœuds ont tous deux fils non vides, on va utiliser le type</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb48"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb48-1"><a href="#cb48-1"></a><span class="kw">type</span> (&#39;a, &#39;b) arbre_bin = Feuille <span class="kw">of</span> &#39;a </span>
<span id="cb48-2"><a href="#cb48-2"></a>    | NoeudI <span class="kw">of</span> (&#39;a, &#39;b) arbre_bin * &#39;b * (&#39;a, &#39;b) arbre_bin</span></code></pre></div>
<p></div></p>
<p>Ce type permet de représenter naturellement des expressions arithmétiques comme :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb49"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb49-1"><a href="#cb49-1"></a>NoeudI(NoeudI( Feuille <span class="dv">2</span>, <span class="ch">&#39;+&#39;</span>, Feuille <span class="dv">3</span>), <span class="ch">&#39;*&#39;</span>, Feuille <span class="dv">5</span>)</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>evalue : (int, char) arbre_bin -&gt; int</code> qui évalue une telle expression.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb50-1"><a href="#cb50-1"></a><span class="kw">let</span> <span class="kw">rec</span> evalue a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb50-2"><a href="#cb50-2"></a>    | Feuille n -&gt; n</span>
<span id="cb50-3"><a href="#cb50-3"></a>    | NoeudI(g, x, d) -&gt;</span>
<span id="cb50-4"><a href="#cb50-4"></a>            <span class="kw">let</span> eg = evalue g <span class="kw">in</span></span>
<span id="cb50-5"><a href="#cb50-5"></a>            <span class="kw">let</span> ed = evalue d <span class="kw">in</span></span>
<span id="cb50-6"><a href="#cb50-6"></a>            <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb50-7"><a href="#cb50-7"></a>            | <span class="ch">&#39;+&#39;</span> -&gt; eg + ed</span>
<span id="cb50-8"><a href="#cb50-8"></a>            | <span class="ch">&#39;*&#39;</span> -&gt; eg * ed</span>
<span id="cb50-9"><a href="#cb50-9"></a>            | _ -&gt; <span class="dt">failwith</span> <span class="st">&quot;Ope inconnue&quot;</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>Si on considère le type <div class="ui segment code"></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb51-1"><a href="#cb51-1"></a><span class="kw">type</span> (&#39;a, &#39;b) etiquette = F <span class="kw">of</span> &#39;a | N <span class="kw">of</span> &#39;b</span></code></pre></div>
<p></div></p>
<p>On peut passer d’un <code>('a, 'b) arbre_bin</code> à un <code>('a, 'b) etiquette arbre</code> et, dans certains cas, d’un <code>('a, 'b) etiquette arbre</code> à un <code>('a, 'b) arbre_bin</code>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire ainsi deux fonctions de conversion :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb52"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb52-1"><a href="#cb52-1"></a>arbre_bin_vers_arbre : (&#39;a, &#39;b) arbre_bin -&gt; (&#39;a, &#39;b) etiquette arbre</span>
<span id="cb52-2"><a href="#cb52-2"></a>arbre_vers_arbre_bin : (&#39;a, &#39;b) etiquette arbre -&gt; (&#39;a, &#39;b) arbre_bin <span class="dt">option</span></span></code></pre></div>
<p></div></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb53"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb53-1"><a href="#cb53-1"></a><span class="kw">let</span> <span class="kw">rec</span> arbre_bin_vers_arbre a =</span>
<span id="cb53-2"><a href="#cb53-2"></a>    <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb53-3"><a href="#cb53-3"></a>    | Feuille n -&gt; Noeud(Nil, F n, Nil)</span>
<span id="cb53-4"><a href="#cb53-4"></a>    | NoeudI(g, x, d) -&gt; Noeud(arbre_bin_vers_arbre g,</span>
<span id="cb53-5"><a href="#cb53-5"></a>                            N x,</span>
<span id="cb53-6"><a href="#cb53-6"></a>                            arbre_bin_vers_arbre d)</span>
<span id="cb53-7"><a href="#cb53-7"></a></span>
<span id="cb53-8"><a href="#cb53-8"></a><span class="kw">let</span> <span class="kw">rec</span> arbre_vers_arbre_bin a =</span>
<span id="cb53-9"><a href="#cb53-9"></a>    <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb53-10"><a href="#cb53-10"></a>    | Noeud(Nil, F f, Nil) -&gt; Feuille f</span>
<span id="cb53-11"><a href="#cb53-11"></a>    | Noeud(g, N x, d) -&gt; <span class="kw">begin</span></span>
<span id="cb53-12"><a href="#cb53-12"></a>            <span class="kw">match</span> arbre_vers_arbre_bin g, arbre_vers_arbre_bin d <span class="kw">with</span></span>
<span id="cb53-13"><a href="#cb53-13"></a>            | <span class="dt">Some</span> g&#39;, <span class="dt">Some</span> d&#39; -&gt; NoeudI(g&#39;, x, d&#39;)</span>
<span id="cb53-14"><a href="#cb53-14"></a>            | _ -&gt; <span class="dt">None</span></span>
<span id="cb53-15"><a href="#cb53-15"></a>        <span class="kw">end</span></span>
<span id="cb53-16"><a href="#cb53-16"></a>    | _ -&gt; <span class="dt">None</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h3 data-number="6.1.4" id="sec:dessin-darbres"><span class="header-section-number">6.1.4</span> Dessin d’arbres</h3>
<p>On va réaliser dans cette partie une fonction de dessin d’arbres avec <code>graphics</code>. L’idée est de placer la racine et de dessiner les sous-arbres gauche et droit en dessous. Pour cela, il va falloir connaitre la taille de ces sous-arbres en pixels.</p>
<p>On pourra consulter la documentation de <code>graphics</code> ici : <a href="http://pauillac.inria.fr/~remy/poly/ocaml/htmlman/libref/Graphics.html">Graphics</a></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>pixels : int arbre -&gt; int * int</code> qui renvoie un couple <code>(largeur, racine)</code> où <code>largeur</code> est la largeur en pixels d’un arbre dans son affichage et <code>racine</code> l’abscisse de la racine dans cet affichage.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb54"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb54-1"><a href="#cb54-1"></a><span class="kw">let</span> rnoeud = <span class="dv">5</span> <span class="co">(* Le rayon du noeud *)</span></span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="kw">let</span> marge = <span class="dv">2</span> <span class="co">(* la marge autour du noeud *)</span></span>
<span id="cb54-3"><a href="#cb54-3"></a></span>
<span id="cb54-4"><a href="#cb54-4"></a><span class="kw">let</span> <span class="kw">rec</span> pixels a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb54-5"><a href="#cb54-5"></a>    | Nil -&gt; <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb54-6"><a href="#cb54-6"></a>    | Noeud(g, _, d) -&gt; </span>
<span id="cb54-7"><a href="#cb54-7"></a>            <span class="kw">let</span> lg, _ = pixels g <span class="kw">in</span></span>
<span id="cb54-8"><a href="#cb54-8"></a>            <span class="kw">let</span> ld, _ = pixels d <span class="kw">in</span></span>
<span id="cb54-9"><a href="#cb54-9"></a>            lg + ld + <span class="dv">2</span>*(marge + rnoeud), lg + marge + rnoeud</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>En déduire une fonction <code>dessine : int arbre -&gt; int -&gt; int -&gt; unit</code> tel que <code>dessine a x y</code> dessine l’arbre <span class="math inline">\(a\)</span> en plaçant la racine en <span class="math inline">\((x, y)\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb55-1"><a href="#cb55-1"></a><span class="kw">let</span> <span class="kw">rec</span> dessine a x y =</span>
<span id="cb55-2"><a href="#cb55-2"></a>    <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb55-3"><a href="#cb55-3"></a>    | Nil -&gt; ()</span>
<span id="cb55-4"><a href="#cb55-4"></a>    | Noeud(g, e, d) -&gt;</span>
<span id="cb55-5"><a href="#cb55-5"></a>            <span class="co">(* On précalcule les tailles des sous-arbres *)</span></span>
<span id="cb55-6"><a href="#cb55-6"></a>            <span class="kw">let</span> lg, rg = pixels g <span class="kw">in</span></span>
<span id="cb55-7"><a href="#cb55-7"></a>            <span class="kw">let</span> _, rd = pixels d <span class="kw">in</span></span>
<span id="cb55-8"><a href="#cb55-8"></a>            <span class="co">(* position de la racine gauche relativement à (x,y) *)</span></span>
<span id="cb55-9"><a href="#cb55-9"></a>            <span class="kw">let</span> v_rg = x - lg - marge - rnoeud + rg <span class="kw">in</span></span>
<span id="cb55-10"><a href="#cb55-10"></a>            <span class="co">(* position de la racine droite relative (x, y) *)</span></span>
<span id="cb55-11"><a href="#cb55-11"></a>            <span class="kw">let</span> v_rd = x + marge + rnoeud + rd <span class="kw">in</span></span>
<span id="cb55-12"><a href="#cb55-12"></a>            <span class="kw">let</span> dec_y = y - <span class="dv">2</span> * rnoeud - marge <span class="kw">in</span></span>
<span id="cb55-13"><a href="#cb55-13"></a></span>
<span id="cb55-14"><a href="#cb55-14"></a>            moveto x y; lineto v_rg dec_y;</span>
<span id="cb55-15"><a href="#cb55-15"></a>            moveto x y; lineto v_rd dec_y;</span>
<span id="cb55-16"><a href="#cb55-16"></a>            fill_circle x y rnoeud;</span>
<span id="cb55-17"><a href="#cb55-17"></a></span>
<span id="cb55-18"><a href="#cb55-18"></a>            moveto (x-tw/<span class="dv">2</span>) (y-th/<span class="dv">2</span>);</span>
<span id="cb55-19"><a href="#cb55-19"></a>            set_color white;</span>
<span id="cb55-20"><a href="#cb55-20"></a>            draw_string e;</span>
<span id="cb55-21"><a href="#cb55-21"></a>            set_color black;</span>
<span id="cb55-22"><a href="#cb55-22"></a></span>
<span id="cb55-23"><a href="#cb55-23"></a>            dessine g v_rg dec_y;</span>
<span id="cb55-24"><a href="#cb55-24"></a>            dessine d v_rd dec_y</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h3 data-number="6.1.5" id="sec:génération-aléatoire-darbres"><span class="header-section-number">6.1.5</span> Génération aléatoire d’arbres</h3>
<p>Dans cette partie, ce qui nous intéresse est de générer aléatoirement des arbres pour en observer la structure. Les étiquettes ne sont pas pertinentes, on pourra donc au choix, soit considérer des <code>unit arbre</code>, soit redéfinir un type d’arbre non étiquettés.</p>
<p>On va réaliser ici deux modèles de génération aléatoire d’arbres. Le premier modèle consiste, pour générer un arbre de <span class="math inline">\(n\)</span> nœuds, à choisir aléatoirement <span class="math inline">\(k\)</span> dans <span class="math inline">\(\range{0}{n}\)</span>, à générer aléatoirement un arbre <span class="math inline">\(g\)</span> à <span class="math inline">\(k\)</span> nœuds et un arbre <span class="math inline">\(d\)</span> à <span class="math inline">\(n-k\)</span> nœuds puis à renvoyer l’arbre <code>Noeud(g, (), d)</code>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Implémenter ce modèle avec une fonction <code>genere_arbre_1 : int -&gt; unit arbre</code>.</p>
<p>Tester votre fonction, notamment avec l’affichage de la partie précédente.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb56"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb56-1"><a href="#cb56-1"></a><span class="kw">let</span> <span class="kw">rec</span> genere_arbre_1 n = </span>
<span id="cb56-2"><a href="#cb56-2"></a>    <span class="kw">if</span> n = <span class="dv">0</span></span>
<span id="cb56-3"><a href="#cb56-3"></a>    <span class="kw">then</span> Nil</span>
<span id="cb56-4"><a href="#cb56-4"></a>    <span class="kw">else</span> <span class="kw">if</span> n = <span class="dv">1</span> <span class="kw">then</span> Noeud(Nil, (), Nil)</span>
<span id="cb56-5"><a href="#cb56-5"></a>    <span class="kw">else</span> <span class="kw">let</span> k = <span class="dt">Random</span>.<span class="dt">int</span> (n<span class="dv">-1</span>) <span class="kw">in</span></span>
<span id="cb56-6"><a href="#cb56-6"></a>        Noeud(genere_arbre_1  k, (), </span>
<span id="cb56-7"><a href="#cb56-7"></a>            genere_arbre_1  (n<span class="dv">-1</span>-k))</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>Pour le deuxième modèle, on va choisir un sous-arbre vide uniformément et le remplacer par un nœud.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>chemins_vides : 'a arbre -&gt; chemin list</code> qui étant donné un arbre renvoie la liste des chemins permettant d’aboutir à un sous-arbre vide.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb57"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb57-1"><a href="#cb57-1"></a><span class="kw">let</span> chemins_vide a =</span>
<span id="cb57-2"><a href="#cb57-2"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux a l =</span>
<span id="cb57-3"><a href="#cb57-3"></a>        <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb57-4"><a href="#cb57-4"></a>        | Nil -&gt; [ <span class="dt">List</span>.rev l ]</span>
<span id="cb57-5"><a href="#cb57-5"></a>        | Noeud(g, _, d) -&gt; </span>
<span id="cb57-6"><a href="#cb57-6"></a>              aux g (Gauche::l)</span>
<span id="cb57-7"><a href="#cb57-7"></a>            @ aux d (Droite::l)</span>
<span id="cb57-8"><a href="#cb57-8"></a>    <span class="kw">in</span> aux a []</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>remplit : 'a arbre -&gt; chemin -&gt; 'a arbre</code> qui remplace un sous-arbre vide donnée par son chemin par un nœud.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb58"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb58-1"><a href="#cb58-1"></a><span class="kw">let</span> <span class="kw">rec</span> remplit a c =</span>
<span id="cb58-2"><a href="#cb58-2"></a>    <span class="kw">match</span> a, c <span class="kw">with</span></span>
<span id="cb58-3"><a href="#cb58-3"></a>    | Nil, [] -&gt; Noeud(Nil, (), Nil)</span>
<span id="cb58-4"><a href="#cb58-4"></a>    | Noeud(g,x,d), Gauche::q -&gt; </span>
<span id="cb58-5"><a href="#cb58-5"></a>            Noeud(remplit g q, x, d)</span>
<span id="cb58-6"><a href="#cb58-6"></a>    | Noeud(g,x,d), Droite::q -&gt; </span>
<span id="cb58-7"><a href="#cb58-7"></a>            Noeud(g, x, remplit d q)</span>
<span id="cb58-8"><a href="#cb58-8"></a>    | _ -&gt; <span class="dt">failwith</span> <span class="st">&quot;Error&quot;</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>En déduire une fonction <code>genere_arbres_2 : int -&gt; unit arbre</code> qui prend un entier <code>n</code> et construit un arbre à <span class="math inline">\(n\)</span> nœuds en partant de l’arbre vide et en réalisant <span class="math inline">\(n\)</span> remplacement d’un arbre vide par un nœuds, le choix de l’arbre vide se faisant uniformément.</p>
<p><em>Note :</em> on pourra utilser <code>List.nth</code> et <code>Random.int</code> Voir par exemple <a href="https://ocaml.org/api/Random.html">Random</a></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb59"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb59-1"><a href="#cb59-1"></a><span class="kw">let</span> <span class="kw">rec</span> genere_arbre_2 n =</span>
<span id="cb59-2"><a href="#cb59-2"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> Nil</span>
<span id="cb59-3"><a href="#cb59-3"></a>    <span class="kw">else</span> </span>
<span id="cb59-4"><a href="#cb59-4"></a>        <span class="kw">let</span> a = genere_arbre_2 (n<span class="dv">-1</span>) <span class="kw">in</span></span>
<span id="cb59-5"><a href="#cb59-5"></a>        <span class="kw">let</span> l = chemins_vide a <span class="kw">in</span></span>
<span id="cb59-6"><a href="#cb59-6"></a>        <span class="kw">let</span> k = <span class="dt">Random</span>.<span class="dt">int</span> (<span class="dt">List</span>.length l) <span class="kw">in</span></span>
<span id="cb59-7"><a href="#cb59-7"></a>        <span class="kw">let</span> ch = <span class="dt">List</span>.nth l k <span class="kw">in</span></span>
<span id="cb59-8"><a href="#cb59-8"></a>        remplit a ch</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h2 data-number="6.2" id="sec:arbres-non-binaires-tries"><span class="header-section-number">6.2</span> Arbres non binaires, tries</h2>
<h3 data-number="6.2.1" id="sec:arbres-non-binaires"><span class="header-section-number">6.2.1</span> Arbres non binaires</h3>
<p>On va considérer ici les arbres d’arité quelconque avec des listes d’enfants pour les nœuds.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb60"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb60-1"><a href="#cb60-1"></a><span class="kw">type</span> &#39;a arbre = { etiquette : &#39;a; enfants : &#39;a arbre <span class="dt">list</span> }</span></code></pre></div>
<p></div></p>
<p>Afin d’effectuer des tests, on pourra considérer l’arbre suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb61"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb61-1"><a href="#cb61-1"></a><span class="kw">let</span> t = { etiquette = <span class="dv">1</span>;</span>
<span id="cb61-2"><a href="#cb61-2"></a>    enfants = [ </span>
<span id="cb61-3"><a href="#cb61-3"></a>        { etiquette = <span class="dv">2</span>; enfants = [</span>
<span id="cb61-4"><a href="#cb61-4"></a>            { etiquette = <span class="dv">5</span>; enfants = [] }</span>
<span id="cb61-5"><a href="#cb61-5"></a>            ] };</span>
<span id="cb61-6"><a href="#cb61-6"></a>        { etiquette = <span class="dv">3</span>; enfants = [</span>
<span id="cb61-7"><a href="#cb61-7"></a>            { etiquette = <span class="dv">6</span>; enfants = [</span>
<span id="cb61-8"><a href="#cb61-8"></a>                { etiquette = <span class="dv">10</span> ; enfants = []}</span>
<span id="cb61-9"><a href="#cb61-9"></a>            ]};</span>
<span id="cb61-10"><a href="#cb61-10"></a>            { etiquette = <span class="dv">7</span>; enfants = []}</span>
<span id="cb61-11"><a href="#cb61-11"></a>        ] };</span>
<span id="cb61-12"><a href="#cb61-12"></a>        { etiquette = <span class="dv">4</span>; enfants = [</span>
<span id="cb61-13"><a href="#cb61-13"></a>                { etiquette = <span class="dv">8</span>; enfants = []};</span>
<span id="cb61-14"><a href="#cb61-14"></a>                { etiquette = <span class="dv">9</span>; enfants = []}</span>
<span id="cb61-15"><a href="#cb61-15"></a>        ] }</span>
<span id="cb61-16"><a href="#cb61-16"></a>    ] }</span></code></pre></div>
<p></div></p>
<p>qui correspond à la représentation :</p>
<p><center><div class="ui image center"><img src="assets/pics/tpexarbre.png" /></div></center></p>
<p>Comme présenté dans ce chapitre, on peut réaliser des fonctions mutuellement récursives pour travailler avec ces arbres et sur la forêt induite par les enfants d’un nœud :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb62"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb62-1"><a href="#cb62-1"></a><span class="kw">let</span> <span class="kw">rec</span> taille_arbre a =</span>
<span id="cb62-2"><a href="#cb62-2"></a>    <span class="dv">1</span> + taille_foret a.enfants</span>
<span id="cb62-3"><a href="#cb62-3"></a>    <span class="kw">and</span> taille_foret l = <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb62-4"><a href="#cb62-4"></a>        | [] -&gt; <span class="dv">0</span></span>
<span id="cb62-5"><a href="#cb62-5"></a>        | t::q -&gt; taille_arbre t + taille_foret q</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>hauteur_arbre : 'a arbre -&gt; int</code> qui calcule la hauteur d’un arbre sur le modèle de la fonction précédente. On fera attention au fait qu’il n’est pas possible de représenter l’arbre vide mais la forêt vide jouera le même rôle vis-à-vis de <span class="math inline">\(-1\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb63"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb63-1"><a href="#cb63-1"></a><span class="kw">let</span> <span class="kw">rec</span> hauteur_arbre a =</span>
<span id="cb63-2"><a href="#cb63-2"></a>    <span class="dv">1</span> + hauteur_foret a.enfants</span>
<span id="cb63-3"><a href="#cb63-3"></a>    <span class="kw">and</span> hauteur_foret l = <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb63-4"><a href="#cb63-4"></a>    | [] -&gt; <span class="dv">-1</span></span>
<span id="cb63-5"><a href="#cb63-5"></a>    | t::q -&gt; <span class="dt">max</span> (hauteur_arbre t) (hauteur_foret q)</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>A l’aide d’un parcours récursif, écrire une fonction <code>affiche_etiquettes : int tree -&gt; unit</code> qui affiche toutes les étiquettes d’un <code>int tree</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb64"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb64-1"><a href="#cb64-1"></a><span class="kw">let</span> <span class="kw">rec</span> affiche_etiquettes a =</span>
<span id="cb64-2"><a href="#cb64-2"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span> a.etiquette;</span>
<span id="cb64-3"><a href="#cb64-3"></a>    affiche_foret a.enfants</span>
<span id="cb64-4"><a href="#cb64-4"></a>    <span class="kw">and</span> affiche_foret l = <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb64-5"><a href="#cb64-5"></a>        | [] -&gt; ()</span>
<span id="cb64-6"><a href="#cb64-6"></a>        | t::q -&gt; affiche_etiquettes t; affiche_foret q</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h3 data-number="6.2.2" id="sec:représentation-par-des-arbres-binaires"><span class="header-section-number">6.2.2</span> Représentation par des arbres binaires</h3>
<p>On va maintenant revenir ici sur la représentation d’un <code>'a arbre</code> en tant qu’arbre binaire. Pour cela, on va avoir besoin d’étiquettes factices pour les nouveaux nœuds qui ne servent qu’à supporter la structure des nœuds d’arité <span class="math inline">\(&gt;2\)</span>. On va ainsi les représenter par des <code>a option arbre_bin</code> où l’étiquette sera celle des nœuds factices.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb65"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb65-1"><a href="#cb65-1"></a><span class="kw">type</span> &#39;a arbre_bin = Noeud <span class="kw">of</span> &#39;a arbre_bin * &#39;a * &#39;a arbre_bin | Nil</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>On va commencer par écrire une fonction <code>peigne : 'a option arbre_bin list -&gt; 'a option arbre_bin</code> qui va transformer une forêt d’arbres binaires en sa représentation en peigne à l’aide de nœuds d’étiquettes <code>None</code>.</p>
<p><strong>Note</strong> Dans le cas où la liste est vide, on renverra l’arbre vide et si c’est un singleton, on renverra directement l’arbre qu’il contient.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb66"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb66-1"><a href="#cb66-1"></a><span class="kw">let</span> <span class="kw">rec</span> peigne l =</span>
<span id="cb66-2"><a href="#cb66-2"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb66-3"><a href="#cb66-3"></a>    | [] -&gt; Nil</span>
<span id="cb66-4"><a href="#cb66-4"></a>    | [x] -&gt; x</span>
<span id="cb66-5"><a href="#cb66-5"></a>    | a::q -&gt; Noeud(a, <span class="dt">None</span>, peigne q)</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>convert : 'a arbre -&gt; 'a option arbre_bin</code> qui va réaliser la conversion vue en classe.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb67"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb67-1"><a href="#cb67-1"></a><span class="kw">let</span> <span class="kw">rec</span> convert a =</span>
<span id="cb67-2"><a href="#cb67-2"></a>    <span class="kw">match</span> a.enfants <span class="kw">with</span></span>
<span id="cb67-3"><a href="#cb67-3"></a>    | [] -&gt; Noeud (Nil, <span class="dt">Some</span> a.etiquette, Nil)</span>
<span id="cb67-4"><a href="#cb67-4"></a>    | a1::q -&gt; Noeud(convert a1, <span class="dt">Some</span> a.etiquette, </span>
<span id="cb67-5"><a href="#cb67-5"></a>                        peigne (<span class="dt">List</span>.map convert q))</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>Afin de tester votre fonction, on vous donne une fonction d’affichage textuel d’un tel arbre :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb68"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb68-1"><a href="#cb68-1"></a><span class="kw">let</span> <span class="kw">rec</span> print_arbre_bin pref t =</span>
<span id="cb68-2"><a href="#cb68-2"></a>    <span class="kw">match</span> t <span class="kw">with</span></span>
<span id="cb68-3"><a href="#cb68-3"></a>    | Nil -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%snil</span><span class="ch">\n</span><span class="st">%!&quot;</span> pref</span>
<span id="cb68-4"><a href="#cb68-4"></a>    | Noeud(g,x,d) -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%s%s</span><span class="ch">\n</span><span class="st">%!&quot;</span> pref </span>
<span id="cb68-5"><a href="#cb68-5"></a>                (<span class="kw">match</span> x <span class="kw">with</span> <span class="dt">None</span> -&gt; <span class="st">&quot;*&quot;</span> | <span class="dt">Some</span> n -&gt; <span class="dt">string_of_int</span> n);</span>
<span id="cb68-6"><a href="#cb68-6"></a>        print_arbre_bin (<span class="dt">String</span>.make (<span class="dt">String</span>.length pref) <span class="ch">&#39; &#39;</span> </span>
<span id="cb68-7"><a href="#cb68-7"></a>                        ^ <span class="st">&quot;|&quot;</span> ^ <span class="dt">String</span>.make <span class="dv">5</span> <span class="ch">&#39;-&#39;</span>) g;</span>
<span id="cb68-8"><a href="#cb68-8"></a>        print_arbre_bin (<span class="dt">String</span>.make (<span class="dt">String</span>.length pref) <span class="ch">&#39; &#39;</span> </span>
<span id="cb68-9"><a href="#cb68-9"></a>                        ^ <span class="st">&quot;|&quot;</span> ^ <span class="dt">String</span>.make <span class="dv">5</span> <span class="ch">&#39;-&#39;</span>) d</span></code></pre></div>
<p></div></p>
<p>L’affichage doit correspondre à la représentation suivante :</p>
<p><center><div class="ui image center"><img src="assets/pics/tpexarbrebin.png" /></div></center></p>
<h2 data-number="6.3" id="sec:tries"><span class="header-section-number">6.3</span> Tries</h2>
<p>On va reprendre les tries vus plus haut pour représenter un ensemble de mots. Pour cela, on réutilise le type :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb69"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb69-1"><a href="#cb69-1"></a><span class="kw">type</span> trie = {</span>
<span id="cb69-2"><a href="#cb69-2"></a>    mot : <span class="dt">bool</span>;</span>
<span id="cb69-3"><a href="#cb69-3"></a>    enfants : (<span class="dt">char</span> * trie) <span class="dt">list</span></span>
<span id="cb69-4"><a href="#cb69-4"></a>    }</span></code></pre></div>
<p></div></p>
<h3 data-number="6.3.1" id="sec:premières-manipulations"><span class="header-section-number">6.3.1</span> Premières manipulations</h3>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>taille : trie -&gt; int</code> qui renvoie le nombre de nœuds d’un trie et une fonction <code>nb_mots : trie -&gt; int</code> qui renvoie le nombre de mots d’un trie. On s’inspirera directement des fonctions de la première partie du TP.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb70"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb70-1"><a href="#cb70-1"></a><span class="kw">let</span> <span class="kw">rec</span> taille a = </span>
<span id="cb70-2"><a href="#cb70-2"></a>    <span class="dv">1</span> + taille_foret a.enfants</span>
<span id="cb70-3"><a href="#cb70-3"></a>    <span class="kw">and</span> taille_foret l = <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb70-4"><a href="#cb70-4"></a>        | [] -&gt; <span class="dv">0</span></span>
<span id="cb70-5"><a href="#cb70-5"></a>        | (_, t) :: q -&gt; taille t + taille_foret q</span>
<span id="cb70-6"><a href="#cb70-6"></a></span>
<span id="cb70-7"><a href="#cb70-7"></a><span class="kw">let</span> <span class="kw">rec</span> nb_mots a = </span>
<span id="cb70-8"><a href="#cb70-8"></a>    (<span class="kw">if</span> a.mot <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>) + nb_mots_foret a.enfants</span>
<span id="cb70-9"><a href="#cb70-9"></a>    <span class="kw">and</span> nb_mots_foret l = <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb70-10"><a href="#cb70-10"></a>        | [] -&gt; <span class="dv">0</span></span>
<span id="cb70-11"><a href="#cb70-11"></a>        | (_, t) :: q -&gt; nb_mots t + nb_mots_foret q</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>trie_apres_char</code> tel que l’appel à <code>trie_apres_char l c</code> va renvoyer <code>Some t'</code> si il y a un couple <code>(c, t')</code> dans la liste <code>l</code> et <code>None</code> sinon. On pourra s’en servir avec <code>trie_apres_char t.enfants c</code> pour trouver le trie potentiel dont l’arête est étiquetée par <code>c</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb71"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb71-1"><a href="#cb71-1"></a><span class="kw">let</span> <span class="kw">rec</span> trie_apres_char (l:(<span class="dt">char</span> * trie) <span class="dt">list</span>) (c:<span class="dt">char</span>) =</span>
<span id="cb71-2"><a href="#cb71-2"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb71-3"><a href="#cb71-3"></a>    | [] -&gt; <span class="dt">None</span></span>
<span id="cb71-4"><a href="#cb71-4"></a>    | (c&#39;,t)::q -&gt; <span class="kw">if</span> c = c&#39; <span class="kw">then</span> <span class="dt">Some</span> t <span class="kw">else</span> trie_apres_char q c</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>En déduire une fonction <code>contient : trie -&gt; string -&gt; bool</code> qui teste si un mot est présent dans le trie.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb72"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb72-1"><a href="#cb72-1"></a><span class="kw">let</span> contient (t:trie) (s:<span class="dt">string</span>) : <span class="dt">bool</span> =</span>
<span id="cb72-2"><a href="#cb72-2"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux t i =</span>
<span id="cb72-3"><a href="#cb72-3"></a>        <span class="kw">if</span> i = <span class="dt">String</span>.length s</span>
<span id="cb72-4"><a href="#cb72-4"></a>        <span class="kw">then</span> t.mot</span>
<span id="cb72-5"><a href="#cb72-5"></a>        <span class="kw">else</span> <span class="kw">match</span> trie_apres_char t.enfants s.[i] <span class="kw">with</span></span>
<span id="cb72-6"><a href="#cb72-6"></a>            | <span class="dt">None</span> -&gt; <span class="kw">false</span></span>
<span id="cb72-7"><a href="#cb72-7"></a>            | <span class="dt">Some</span> t&#39; -&gt; aux t&#39; (i+<span class="dv">1</span>)</span>
<span id="cb72-8"><a href="#cb72-8"></a>    <span class="kw">in</span> aux t <span class="dv">0</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>enumere : trie -&gt; string list</code> qui renvoie tous les mots contenus dans un trie par un parcours récursif.</p>
<p><em>Indication</em> : on pourra utiliser :</p>
<ul>
<li><code>List.concat</code> pour passer d’une liste de listes à la concaténée de ses éléments. Ainsi <code>List.concat [ [1;2]; [3]; [4;5] ]</code> va renvoyer <code>[1;2;3;4;5]</code>.</li>
<li><code>String.make 1 c</code> transforme le caractère <code>c</code> en chaîne de caractère</li>
<li>On rappelle que <code>^</code> permet de concaténer deux chaînes.</li>
</ul>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb73"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb73-1"><a href="#cb73-1"></a><span class="kw">let</span> enumere (t:trie) =</span>
<span id="cb73-2"><a href="#cb73-2"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux t acc = </span>
<span id="cb73-3"><a href="#cb73-3"></a>        <span class="kw">let</span> l = <span class="dt">List</span>.concat (<span class="dt">List</span>.map (<span class="kw">fun</span> (c,t&#39;) -&gt; </span>
<span id="cb73-4"><a href="#cb73-4"></a>                aux t&#39; (acc ^ <span class="dt">String</span>.make <span class="dv">1</span> c)) t.enfants) <span class="kw">in</span></span>
<span id="cb73-5"><a href="#cb73-5"></a>        <span class="kw">if</span> t.mot <span class="kw">then</span> acc :: l <span class="kw">else</span> l</span>
<span id="cb73-6"><a href="#cb73-6"></a>    <span class="kw">in</span> aux t <span class="st">&quot;&quot;</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h3 data-number="6.3.2" id="sec:ajout-dun-mot-à-un-trie"><span class="header-section-number">6.3.2</span> Ajout d’un mot à un trie</h3>
<p>Pour effectuer l’ajout d’un mot à un trie, on va commencer par écrire une fonction qui étant donné une chaîne de caractére <code>s</code> <span class="math inline">\(= &quot;c_0 \dots c_{n-1}&quot;\)</span> et un entier <span class="math inline">\(i\le n\)</span> va renvoyer le trie <code>t</code> correspondant à la branche</p>
<p><center><div class="ui image center"><img src="assets/pics/exsuffixe.png" /></div></center></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>écrire la fonction <code>suffixe : int -&gt; string -&gt; trie</code></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb74"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb74-1"><a href="#cb74-1"></a><span class="kw">let</span> <span class="kw">rec</span> suffixe (i:<span class="dt">int</span>) (s:<span class="dt">string</span>) : trie =</span>
<span id="cb74-2"><a href="#cb74-2"></a>    <span class="kw">let</span> n = <span class="dt">String</span>.length s <span class="kw">in</span></span>
<span id="cb74-3"><a href="#cb74-3"></a>    <span class="kw">if</span> i = n</span>
<span id="cb74-4"><a href="#cb74-4"></a>    <span class="kw">then</span> { mot = <span class="kw">true</span>; enfants = [] }</span>
<span id="cb74-5"><a href="#cb74-5"></a>    <span class="kw">else</span> { mot = <span class="kw">false</span>; enfants = [ (s.[i], suffixe (i+<span class="dv">1</span>) s) ] }</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>avec_trie_pour_char : (char * trie) list -&gt; char -&gt; trie -&gt; (char * trie) list</code> telle que <code>avec_trie_pour_char l c t</code> va renvoyer la liste obtenue en remplacant <code>(c,t')</code> par <code>(c,t)</code> dans <code>l</code> si un tel couple est présent, ou en ajoutant le couple <code>(c,t)</code> sinon à la fin.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb75"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb75-1"><a href="#cb75-1"></a><span class="kw">let</span> <span class="kw">rec</span> avec_trie_pour_char l c t =</span>
<span id="cb75-2"><a href="#cb75-2"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb75-3"><a href="#cb75-3"></a>    | [] -&gt; [ (c, t) ]</span>
<span id="cb75-4"><a href="#cb75-4"></a>    | (c&#39;, t&#39;) :: q -&gt; <span class="kw">if</span> c = c&#39; <span class="kw">then</span> (c, t) :: q <span class="kw">else</span> (c&#39;, t&#39;) :: avec_trie_pour_char q c t</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>ajoute : trie -&gt; string -&gt; trie</code> qui renvoie le trie obtenu en ajoutant un nouveau mot.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb76"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb76-1"><a href="#cb76-1"></a><span class="kw">let</span> ajoute t s =</span>
<span id="cb76-2"><a href="#cb76-2"></a>    <span class="kw">let</span> n = <span class="dt">String</span>.length s <span class="kw">in</span></span>
<span id="cb76-3"><a href="#cb76-3"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux t i =</span>
<span id="cb76-4"><a href="#cb76-4"></a>        <span class="kw">if</span> i = n</span>
<span id="cb76-5"><a href="#cb76-5"></a>        <span class="kw">then</span> { t <span class="kw">with</span> mot = <span class="kw">true</span> }</span>
<span id="cb76-6"><a href="#cb76-6"></a>        <span class="kw">else</span> <span class="kw">let</span> t&#39; = <span class="kw">match</span> trie_apres_char t.enfants s.[i] <span class="kw">with</span></span>
<span id="cb76-7"><a href="#cb76-7"></a>                    | <span class="dt">None</span> -&gt; suffixe (i+<span class="dv">1</span>) s</span>
<span id="cb76-8"><a href="#cb76-8"></a>                    | <span class="dt">Some</span> t&#39; -&gt; aux t&#39; (i+<span class="dv">1</span>) <span class="kw">in</span></span>
<span id="cb76-9"><a href="#cb76-9"></a>            { t <span class="kw">with</span> enfants = avec_trie_pour_char t.enfants s.[i] t&#39; }</span>
<span id="cb76-10"><a href="#cb76-10"></a>    <span class="kw">in</span> aux t <span class="dv">0</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>On va utiliser la fonction précédente pour retrouver le trie donné en début de partie.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb77"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb77-1"><a href="#cb77-1"></a><span class="kw">let</span> <span class="kw">rec</span> trie_of_list l = <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb77-2"><a href="#cb77-2"></a>    | [] -&gt; { mot = <span class="kw">false</span>; enfants = [] }</span>
<span id="cb77-3"><a href="#cb77-3"></a>    | s::q -&gt; ajoute (trie_of_list q) s</span></code></pre></div>
<p></div></p>
<p>On va maintenant récupérer une grande liste de mots dans le fichier <code>wordlist</code> récupérable à l’adresse https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt à raison d’un mot par ligne :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb78"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb78-1"><a href="#cb78-1"></a><span class="kw">let</span> wordlist = <span class="kw">let</span> <span class="kw">rec</span> lit_fichier f =</span>
<span id="cb78-2"><a href="#cb78-2"></a>        <span class="kw">try</span></span>
<span id="cb78-3"><a href="#cb78-3"></a>            <span class="kw">let</span> s = <span class="dt">input_line</span> f <span class="kw">in</span></span>
<span id="cb78-4"><a href="#cb78-4"></a>                s :: lit_fichier f</span>
<span id="cb78-5"><a href="#cb78-5"></a>            <span class="kw">with</span> <span class="dt">End_of_file</span> -&gt; []</span>
<span id="cb78-6"><a href="#cb78-6"></a>        <span class="kw">in</span></span>
<span id="cb78-7"><a href="#cb78-7"></a>        lit_fichier (<span class="dt">open_in</span> <span class="st">&quot;wordlist&quot;</span>)</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>En déduire un trie permettant de représenter cette wordlist et comparez :</p>
<ul>
<li>Le nombre de caractère total</li>
<li>Le nombre de nœuds du trie</li>
</ul>
<p>Que peut-on en déduire ?</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb79"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb79-1"><a href="#cb79-1"></a><span class="kw">let</span> taille_totale = <span class="dt">List</span>.fold_left (+) <span class="dv">0</span> (<span class="dt">List</span>.map <span class="dt">String</span>.length wordlist) <span class="kw">in</span></span>
<span id="cb79-2"><a href="#cb79-2"></a>taille_totale, taille (trie_of_list wordlist)</span></code></pre></div>
<p></div></p>
<p>On voit qu’on 595775 caractères au total pour 229239 nœuds. Attention cependant à ne pas sous-estimer la taille d’un nœud qui dépasse très largement celle d’un caractère. Cependant, le trie apporte la possibilité de chercher un mot <span class="math inline">\(m\)</span> en <span class="math inline">\(O(|m|)\)</span> et donc indépendamment du nombre de mots. </div> </div></p>
<h2 data-number="6.4" id="sec:arbres-binaires-en-c-abr-arbres-rouges-et-noirs"><span class="header-section-number">6.4</span> Arbres binaires en <code>C</code>, ABR, arbres rouges et noirs</h2>
<h3 data-number="6.4.1" id="sec:arbres-binaires-en-c"><span class="header-section-number">6.4.1</span> Arbres binaires en <code>C</code></h3>
<p>En <code>C</code>, un nœud d’un arbre binaire va avoir exactement la même structure qu’un maillon d’une liste doublement chaînée : une valeur et deux pointeurs vers d’autres nœuds, ici ce ne sont pas <code>suivant</code> et <code>precedent</code> mais <code>gauche</code> et <code>droite</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb80"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb80-1"><a href="#cb80-1"></a><span class="kw">struct</span> noeud <span class="op">{</span></span>
<span id="cb80-2"><a href="#cb80-2"></a>    <span class="kw">struct</span> noeud <span class="op">*</span>gauche<span class="op">;</span></span>
<span id="cb80-3"><a href="#cb80-3"></a>    <span class="kw">struct</span> noeud <span class="op">*</span>droite<span class="op">;</span></span>
<span id="cb80-4"><a href="#cb80-4"></a>    <span class="dt">int</span> valeur<span class="op">;</span></span>
<span id="cb80-5"><a href="#cb80-5"></a><span class="op">};</span></span>
<span id="cb80-6"><a href="#cb80-6"></a></span>
<span id="cb80-7"><a href="#cb80-7"></a><span class="kw">typedef</span> <span class="kw">struct</span> noeud <span class="op">*</span>arbre<span class="op">;</span></span></code></pre></div>
<p></div></p>
<p>Comme pour les listes, l’arbre vide sera représenté par le pointeur <code>NULL</code>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>arbre cree_feuille(int x)</code> qui alloue et crée une feuille de valeur <code>x</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb81"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb81-1"><a href="#cb81-1"></a>arbre cree_feuille<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb81-2"><a href="#cb81-2"></a><span class="op">{</span></span>
<span id="cb81-3"><a href="#cb81-3"></a>    arbre n <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> noeud<span class="op">));</span></span>
<span id="cb81-4"><a href="#cb81-4"></a>    n<span class="op">-&gt;</span>valeur <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb81-5"><a href="#cb81-5"></a>    n<span class="op">-&gt;</span>gauche <span class="op">=</span> n<span class="op">-&gt;</span>droite <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb81-6"><a href="#cb81-6"></a>    <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb81-7"><a href="#cb81-7"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>En déduire, une représentation en <code>C</code> de l’arbre :</p>
<p><center><div class="ui image center"><img src="assets/pics/exemple_arbre_tpc.png" /></div></center></p>
<p>Pour cela, on vous suggère de créer autant de feuilles que de nœuds et d’effectuer les liens ensuite avec les pointeurs.</p>
<p>Cet arbre nous servira d’exemple pour vérifier les fonctions suivantes.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb82"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb82-1"><a href="#cb82-1"></a>    arbre n5 <span class="op">=</span> cree_feuille<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb82-2"><a href="#cb82-2"></a>    arbre n1 <span class="op">=</span> cree_feuille<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb82-3"><a href="#cb82-3"></a>    arbre n4 <span class="op">=</span> cree_feuille<span class="op">(</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb82-4"><a href="#cb82-4"></a>    arbre n9 <span class="op">=</span> cree_feuille<span class="op">(</span><span class="dv">9</span><span class="op">);</span></span>
<span id="cb82-5"><a href="#cb82-5"></a>    arbre n7 <span class="op">=</span> cree_feuille<span class="op">(</span><span class="dv">7</span><span class="op">);</span></span>
<span id="cb82-6"><a href="#cb82-6"></a>    arbre n20 <span class="op">=</span> cree_feuille<span class="op">(</span><span class="dv">20</span><span class="op">);</span></span>
<span id="cb82-7"><a href="#cb82-7"></a>    arbre n17 <span class="op">=</span> cree_feuille<span class="op">(</span><span class="dv">17</span><span class="op">);</span></span>
<span id="cb82-8"><a href="#cb82-8"></a>    n5<span class="op">-&gt;</span>gauche <span class="op">=</span> n1<span class="op">;</span></span>
<span id="cb82-9"><a href="#cb82-9"></a>    n1<span class="op">-&gt;</span>droite <span class="op">=</span> n4<span class="op">;</span></span>
<span id="cb82-10"><a href="#cb82-10"></a>    n5<span class="op">-&gt;</span>droite <span class="op">=</span> n9<span class="op">;</span></span>
<span id="cb82-11"><a href="#cb82-11"></a>    n9<span class="op">-&gt;</span>gauche <span class="op">=</span> n7<span class="op">;</span></span>
<span id="cb82-12"><a href="#cb82-12"></a>    n9<span class="op">-&gt;</span>droite <span class="op">=</span> n20<span class="op">;</span></span>
<span id="cb82-13"><a href="#cb82-13"></a>    n20<span class="op">-&gt;</span>gauche <span class="op">=</span> n17<span class="op">;</span></span>
<span id="cb82-14"><a href="#cb82-14"></a></span>
<span id="cb82-15"><a href="#cb82-15"></a>    arbre a <span class="op">=</span> n5<span class="op">;</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>int taille(arbre a)</code> qui renvoie le nombre de nœuds d’un arbre binaire.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb83"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb83-1"><a href="#cb83-1"></a><span class="dt">int</span> taille<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb83-2"><a href="#cb83-2"></a><span class="op">{</span></span>
<span id="cb83-3"><a href="#cb83-3"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">==</span> NULL<span class="op">)</span></span>
<span id="cb83-4"><a href="#cb83-4"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb83-5"><a href="#cb83-5"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> taille<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">)</span> <span class="op">+</span> taille<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">);</span></span>
<span id="cb83-6"><a href="#cb83-6"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>int hauteur(arbre a)</code> qui renvoie la hauteur d’un arbre binaire.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb84"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb84-1"><a href="#cb84-1"></a><span class="dt">int</span> max<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span></span>
<span id="cb84-2"><a href="#cb84-2"></a><span class="op">{</span></span>
<span id="cb84-3"><a href="#cb84-3"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">&gt;</span> b<span class="op">)</span> <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb84-4"><a href="#cb84-4"></a>    <span class="cf">else</span> <span class="cf">return</span> b<span class="op">;</span></span>
<span id="cb84-5"><a href="#cb84-5"></a><span class="op">}</span></span>
<span id="cb84-6"><a href="#cb84-6"></a></span>
<span id="cb84-7"><a href="#cb84-7"></a><span class="dt">int</span> hauteur<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb84-8"><a href="#cb84-8"></a><span class="op">{</span></span>
<span id="cb84-9"><a href="#cb84-9"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">==</span> NULL<span class="op">)</span></span>
<span id="cb84-10"><a href="#cb84-10"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb84-11"><a href="#cb84-11"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> max<span class="op">(</span>hauteur<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">),</span> hauteur<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">));</span></span>
<span id="cb84-12"><a href="#cb84-12"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions <code>void affiche_prefixe(arbre a)</code>, <code>affiche_infixe</code> et <code>affiche_postfixe</code> qui affiche les valeurs des nœuds de l’arbre <code>a</code> selon le traitement correspondant dans un parcours.</p>
<p>Écrire une fonction <code>void affiche(arbre a)</code> qui, à l’aide des trois traitements, permet d’afficher un arbre avec des triplets comme nœuds. Par exemple, pour l’arbre précédent, on pourra afficher :</p>
<pre><code>((nil,1,(nil,4,nil)),5,((nil,7,nil),9,((nil,17,nil),20,nil)))</code></pre>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb86"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb86-1"><a href="#cb86-1"></a><span class="dt">void</span> affiche_prefixe<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb86-2"><a href="#cb86-2"></a><span class="op">{</span></span>
<span id="cb86-3"><a href="#cb86-3"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb86-4"><a href="#cb86-4"></a>    <span class="op">{</span></span>
<span id="cb86-5"><a href="#cb86-5"></a>        printf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> a<span class="op">-&gt;</span>valeur<span class="op">);</span></span>
<span id="cb86-6"><a href="#cb86-6"></a>        affiche_prefixe<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">);</span></span>
<span id="cb86-7"><a href="#cb86-7"></a>        affiche_prefixe<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">);</span></span>
<span id="cb86-8"><a href="#cb86-8"></a>    <span class="op">}</span></span>
<span id="cb86-9"><a href="#cb86-9"></a><span class="op">}</span></span>
<span id="cb86-10"><a href="#cb86-10"></a></span>
<span id="cb86-11"><a href="#cb86-11"></a><span class="dt">void</span> affiche_infixe<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb86-12"><a href="#cb86-12"></a><span class="op">{</span></span>
<span id="cb86-13"><a href="#cb86-13"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb86-14"><a href="#cb86-14"></a>    <span class="op">{</span></span>
<span id="cb86-15"><a href="#cb86-15"></a>        affiche_infixe<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">);</span></span>
<span id="cb86-16"><a href="#cb86-16"></a>        printf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> a<span class="op">-&gt;</span>valeur<span class="op">);</span></span>
<span id="cb86-17"><a href="#cb86-17"></a>        affiche_infixe<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">);</span></span>
<span id="cb86-18"><a href="#cb86-18"></a>    <span class="op">}</span></span>
<span id="cb86-19"><a href="#cb86-19"></a><span class="op">}</span></span>
<span id="cb86-20"><a href="#cb86-20"></a></span>
<span id="cb86-21"><a href="#cb86-21"></a><span class="dt">void</span> affiche_postfixe<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb86-22"><a href="#cb86-22"></a><span class="op">{</span></span>
<span id="cb86-23"><a href="#cb86-23"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb86-24"><a href="#cb86-24"></a>    <span class="op">{</span></span>
<span id="cb86-25"><a href="#cb86-25"></a>        affiche_postfixe<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">);</span></span>
<span id="cb86-26"><a href="#cb86-26"></a>        affiche_postfixe<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">);</span></span>
<span id="cb86-27"><a href="#cb86-27"></a>        printf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> a<span class="op">-&gt;</span>valeur<span class="op">);</span></span>
<span id="cb86-28"><a href="#cb86-28"></a>    <span class="op">}</span></span>
<span id="cb86-29"><a href="#cb86-29"></a><span class="op">}</span></span>
<span id="cb86-30"><a href="#cb86-30"></a></span>
<span id="cb86-31"><a href="#cb86-31"></a><span class="dt">void</span> affiche<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb86-32"><a href="#cb86-32"></a><span class="op">{</span></span>
<span id="cb86-33"><a href="#cb86-33"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb86-34"><a href="#cb86-34"></a>    <span class="op">{</span></span>
<span id="cb86-35"><a href="#cb86-35"></a>        printf<span class="op">(</span><span class="st">&quot;(&quot;</span><span class="op">);</span></span>
<span id="cb86-36"><a href="#cb86-36"></a>        affiche<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">);</span></span>
<span id="cb86-37"><a href="#cb86-37"></a>        printf<span class="op">(</span><span class="st">&quot;,%d,&quot;</span><span class="op">,</span> a<span class="op">-&gt;</span>valeur<span class="op">);</span></span>
<span id="cb86-38"><a href="#cb86-38"></a>        affiche<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">);</span></span>
<span id="cb86-39"><a href="#cb86-39"></a>        printf<span class="op">(</span><span class="st">&quot;)&quot;</span><span class="op">);</span></span>
<span id="cb86-40"><a href="#cb86-40"></a>    <span class="op">}</span> <span class="cf">else</span> printf<span class="op">(</span><span class="st">&quot;nil&quot;</span><span class="op">);</span></span>
<span id="cb86-41"><a href="#cb86-41"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p><em>(Optionnel en première lecture)</em> À l’aide d’une file dans un tableau de longueur <span class="math inline">\(|a|\)</span>, réalisez une fonction <code>void affiche_largeur(arbre a)</code> qui affiche les valeurs des nœuds de l’arbre <code>a</code> lors d’un parcours en largeur.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb87"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb87-1"><a href="#cb87-1"></a><span class="dt">void</span> affiche_largeur<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb87-2"><a href="#cb87-2"></a><span class="op">{</span></span>
<span id="cb87-3"><a href="#cb87-3"></a>    arbre <span class="op">*</span>file <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>arbre<span class="op">)</span> <span class="op">*</span> taille<span class="op">(</span>a<span class="op">));</span></span>
<span id="cb87-4"><a href="#cb87-4"></a>    file<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb87-5"><a href="#cb87-5"></a>    <span class="dt">int</span> debut <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb87-6"><a href="#cb87-6"></a>    <span class="dt">int</span> fin <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb87-7"><a href="#cb87-7"></a>    <span class="cf">while</span><span class="op">(</span>fin <span class="op">&gt;</span> debut<span class="op">)</span></span>
<span id="cb87-8"><a href="#cb87-8"></a>    <span class="op">{</span></span>
<span id="cb87-9"><a href="#cb87-9"></a>        arbre r <span class="op">=</span> file<span class="op">[</span>debut<span class="op">];</span></span>
<span id="cb87-10"><a href="#cb87-10"></a>        debut<span class="op">++;</span></span>
<span id="cb87-11"><a href="#cb87-11"></a>        printf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> r<span class="op">-&gt;</span>valeur<span class="op">);</span></span>
<span id="cb87-12"><a href="#cb87-12"></a>        <span class="cf">if</span><span class="op">(</span>r<span class="op">-&gt;</span>gauche <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb87-13"><a href="#cb87-13"></a>        <span class="op">{</span></span>
<span id="cb87-14"><a href="#cb87-14"></a>            file<span class="op">[</span>fin<span class="op">]</span> <span class="op">=</span> r<span class="op">-&gt;</span>gauche<span class="op">;</span></span>
<span id="cb87-15"><a href="#cb87-15"></a>            fin<span class="op">++;</span></span>
<span id="cb87-16"><a href="#cb87-16"></a>        <span class="op">}</span></span>
<span id="cb87-17"><a href="#cb87-17"></a>        <span class="cf">if</span><span class="op">(</span>r<span class="op">-&gt;</span>droite <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb87-18"><a href="#cb87-18"></a>        <span class="op">{</span></span>
<span id="cb87-19"><a href="#cb87-19"></a>            file<span class="op">[</span>fin<span class="op">]</span> <span class="op">=</span> r<span class="op">-&gt;</span>droite<span class="op">;</span></span>
<span id="cb87-20"><a href="#cb87-20"></a>            fin<span class="op">++;</span></span>
<span id="cb87-21"><a href="#cb87-21"></a>        <span class="op">}</span></span>
<span id="cb87-22"><a href="#cb87-22"></a>    <span class="op">}</span></span>
<span id="cb87-23"><a href="#cb87-23"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>void libere(arbre a)</code> qui libère tous les nœuds de l’arbre <code>a</code>. On fera attention à l’ordre des libérations avec <code>free</code> par rapport aux déréférencements de structure (les <code>-&gt;</code>).</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb88"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb88-1"><a href="#cb88-1"></a><span class="dt">void</span> libere<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb88-2"><a href="#cb88-2"></a><span class="op">{</span></span>
<span id="cb88-3"><a href="#cb88-3"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb88-4"><a href="#cb88-4"></a>    <span class="op">{</span></span>
<span id="cb88-5"><a href="#cb88-5"></a>        libere<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">);</span></span>
<span id="cb88-6"><a href="#cb88-6"></a>        libere<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">);</span></span>
<span id="cb88-7"><a href="#cb88-7"></a>        free<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb88-8"><a href="#cb88-8"></a>    <span class="op">}</span></span>
<span id="cb88-9"><a href="#cb88-9"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h3 data-number="6.4.2" id="sec:arbres-binaires-de-recherche-1"><span class="header-section-number">6.4.2</span> Arbres binaires de recherche</h3>
<p>On conserve le type précédent, mais on considère maintenant qu’on a des arbres binaires de recherche.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>arbre recherche(arbre a, int x)</code> qui renvoie le premier nœud rencontré d’étiquette <code>x</code> dans un ABR ou <code>NULL</code> s’il n’est pas présent.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb89"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb89-1"><a href="#cb89-1"></a>arbre recherche<span class="op">(</span>arbre a<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb89-2"><a href="#cb89-2"></a><span class="op">{</span></span>
<span id="cb89-3"><a href="#cb89-3"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">==</span> NULL<span class="op">)</span></span>
<span id="cb89-4"><a href="#cb89-4"></a>        <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb89-5"><a href="#cb89-5"></a>    <span class="cf">if</span> <span class="op">(</span>a<span class="op">-&gt;</span>valeur <span class="op">==</span> x<span class="op">)</span></span>
<span id="cb89-6"><a href="#cb89-6"></a>        <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb89-7"><a href="#cb89-7"></a>    <span class="cf">if</span> <span class="op">(</span>a<span class="op">-&gt;</span>valeur <span class="op">&lt;</span> x<span class="op">)</span></span>
<span id="cb89-8"><a href="#cb89-8"></a>        <span class="cf">return</span> recherche<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb89-9"><a href="#cb89-9"></a>    <span class="cf">return</span> recherche<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb89-10"><a href="#cb89-10"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>arbre insere(arbre a, int x)</code> qui renvoie la racine de l’ABR obtenu en insérant une nouvelle feuille d’étiquette <code>x</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb90"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb90-1"><a href="#cb90-1"></a>arbre insere<span class="op">(</span>arbre a<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb90-2"><a href="#cb90-2"></a><span class="op">{</span></span>
<span id="cb90-3"><a href="#cb90-3"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">==</span> NULL<span class="op">)</span></span>
<span id="cb90-4"><a href="#cb90-4"></a>        <span class="cf">return</span> cree_feuille<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb90-5"><a href="#cb90-5"></a></span>
<span id="cb90-6"><a href="#cb90-6"></a>    <span class="cf">if</span> <span class="op">(</span>a<span class="op">-&gt;</span>valeur <span class="op">&gt;=</span> x<span class="op">)</span></span>
<span id="cb90-7"><a href="#cb90-7"></a>    <span class="op">{</span></span>
<span id="cb90-8"><a href="#cb90-8"></a>        a<span class="op">-&gt;</span>gauche <span class="op">=</span> insere<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb90-9"><a href="#cb90-9"></a>    <span class="op">}</span></span>
<span id="cb90-10"><a href="#cb90-10"></a>    <span class="cf">else</span></span>
<span id="cb90-11"><a href="#cb90-11"></a>    <span class="op">{</span></span>
<span id="cb90-12"><a href="#cb90-12"></a>        a<span class="op">-&gt;</span>droite <span class="op">=</span> insere<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb90-13"><a href="#cb90-13"></a>    <span class="op">}</span></span>
<span id="cb90-14"><a href="#cb90-14"></a></span>
<span id="cb90-15"><a href="#cb90-15"></a>    <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb90-16"><a href="#cb90-16"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>arbre minimum(arbre a)</code> qui renvoie le nœud de valeur minimale de <code>a</code> en allant le plus à gauche dans l’arbre <code>a</code>. On supposera <code>a</code> non vide.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb91"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb91-1"><a href="#cb91-1"></a>arbre minimum<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb91-2"><a href="#cb91-2"></a><span class="op">{</span></span>
<span id="cb91-3"><a href="#cb91-3"></a>    <span class="cf">if</span> <span class="op">(</span>a<span class="op">-&gt;</span>gauche <span class="op">==</span> NULL<span class="op">)</span></span>
<span id="cb91-4"><a href="#cb91-4"></a>        <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb91-5"><a href="#cb91-5"></a>    <span class="cf">return</span> minimum<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">);</span></span>
<span id="cb91-6"><a href="#cb91-6"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p><em>(Optionnel en première lecture)</em> Écrire une fonction <code>arbre supprime(arbre a, int x)</code> qui renvoie la racine de l’ABR obtenu en supprimant le premier nœud rencontré d’étiquette <code>x</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb92"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb92-1"><a href="#cb92-1"></a>arbre supprime<span class="op">(</span>arbre a<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb92-2"><a href="#cb92-2"></a><span class="op">{</span></span>
<span id="cb92-3"><a href="#cb92-3"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">==</span> NULL<span class="op">)</span></span>
<span id="cb92-4"><a href="#cb92-4"></a>        <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb92-5"><a href="#cb92-5"></a>    <span class="cf">if</span> <span class="op">(</span>a<span class="op">-&gt;</span>valeur <span class="op">==</span> x<span class="op">)</span></span>
<span id="cb92-6"><a href="#cb92-6"></a>    <span class="op">{</span></span>
<span id="cb92-7"><a href="#cb92-7"></a>        <span class="cf">if</span> <span class="op">(</span>a<span class="op">-&gt;</span>gauche <span class="op">==</span> NULL <span class="op">&amp;&amp;</span> a<span class="op">-&gt;</span>droite <span class="op">==</span> NULL<span class="op">)</span></span>
<span id="cb92-8"><a href="#cb92-8"></a>        <span class="op">{</span></span>
<span id="cb92-9"><a href="#cb92-9"></a>            free<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb92-10"><a href="#cb92-10"></a>            <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb92-11"><a href="#cb92-11"></a>        <span class="op">}</span></span>
<span id="cb92-12"><a href="#cb92-12"></a>        arbre min_a <span class="op">=</span> minimum<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb92-13"><a href="#cb92-13"></a>        <span class="cf">if</span> <span class="op">(</span>min_a <span class="op">==</span> a<span class="op">)</span></span>
<span id="cb92-14"><a href="#cb92-14"></a>        <span class="op">{</span></span>
<span id="cb92-15"><a href="#cb92-15"></a>            arbre a_p <span class="op">=</span> a<span class="op">-&gt;</span>droite<span class="op">;</span></span>
<span id="cb92-16"><a href="#cb92-16"></a>            free<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb92-17"><a href="#cb92-17"></a>            <span class="cf">return</span> a_p<span class="op">;</span></span>
<span id="cb92-18"><a href="#cb92-18"></a>        <span class="op">}</span></span>
<span id="cb92-19"><a href="#cb92-19"></a>        <span class="dt">int</span> min_a_valeur <span class="op">=</span> min_a<span class="op">-&gt;</span>valeur<span class="op">;</span></span>
<span id="cb92-20"><a href="#cb92-20"></a>        supprime<span class="op">(</span>a<span class="op">,</span> min_a_valeur<span class="op">);</span></span>
<span id="cb92-21"><a href="#cb92-21"></a>        a<span class="op">-&gt;</span>valeur <span class="op">=</span> min_a_valeur<span class="op">;</span></span>
<span id="cb92-22"><a href="#cb92-22"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb92-23"><a href="#cb92-23"></a>        <span class="cf">if</span> <span class="op">(</span>a<span class="op">-&gt;</span>valeur <span class="op">&gt;</span> x<span class="op">)</span></span>
<span id="cb92-24"><a href="#cb92-24"></a>            a<span class="op">-&gt;</span>gauche <span class="op">=</span> supprime<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb92-25"><a href="#cb92-25"></a>        <span class="cf">else</span></span>
<span id="cb92-26"><a href="#cb92-26"></a>            a<span class="op">-&gt;</span>droite <span class="op">=</span> supprime<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb92-27"><a href="#cb92-27"></a>    <span class="op">}</span></span>
<span id="cb92-28"><a href="#cb92-28"></a></span>
<span id="cb92-29"><a href="#cb92-29"></a>    <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb92-30"><a href="#cb92-30"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h3 data-number="6.4.3" id="sec:arbres-rouges-et-noirs-1"><span class="header-section-number">6.4.3</span> Arbres rouges et noirs</h3>
<p>On va rajouter un champ au type précédent pour indiquer la couleur d’un nœud :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb93"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb93-1"><a href="#cb93-1"></a><span class="kw">struct</span> noeud <span class="op">{</span></span>
<span id="cb93-2"><a href="#cb93-2"></a>    <span class="kw">struct</span> noeud <span class="op">*</span>gauche<span class="op">;</span></span>
<span id="cb93-3"><a href="#cb93-3"></a>    <span class="kw">struct</span> noeud <span class="op">*</span>droite<span class="op">;</span></span>
<span id="cb93-4"><a href="#cb93-4"></a>    <span class="dt">bool</span> rouge<span class="op">;</span></span>
<span id="cb93-5"><a href="#cb93-5"></a>    <span class="dt">int</span> valeur<span class="op">;</span></span>
<span id="cb93-6"><a href="#cb93-6"></a><span class="op">};</span></span>
<span id="cb93-7"><a href="#cb93-7"></a><span class="kw">typedef</span> <span class="kw">struct</span> noeud <span class="op">*</span>arbre<span class="op">;</span></span></code></pre></div>
<p></div></p>
<p>On vous conseille ici de copier le fichier précédent et de faire un nouveau programme.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Reprendre <code>cree_feuille</code> pour que les feuilles soient rouges par défaut.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb94"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb94-1"><a href="#cb94-1"></a>arbre cree_noeud<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb94-2"><a href="#cb94-2"></a><span class="op">{</span></span>
<span id="cb94-3"><a href="#cb94-3"></a>    arbre n <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> noeud<span class="op">));</span></span>
<span id="cb94-4"><a href="#cb94-4"></a>    n<span class="op">-&gt;</span>valeur <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb94-5"><a href="#cb94-5"></a>    n<span class="op">-&gt;</span>rouge <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb94-6"><a href="#cb94-6"></a>    n<span class="op">-&gt;</span>gauche <span class="op">=</span> n<span class="op">-&gt;</span>droite <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb94-7"><a href="#cb94-7"></a>    <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb94-8"><a href="#cb94-8"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions <code>arbre rotation_droite(arbre a)</code>, <code>arbre rotation_gauche(arbre a)</code> et <code>arbre bascule(arbre a)</code> qui effectuent une des trois opérations en renvoyant la nouvelle racine.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb95"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb95-1"><a href="#cb95-1"></a>arbre rotation_droite<span class="op">(</span>arbre x<span class="op">)</span></span>
<span id="cb95-2"><a href="#cb95-2"></a><span class="op">{</span></span>
<span id="cb95-3"><a href="#cb95-3"></a>    arbre y <span class="op">=</span> x<span class="op">-&gt;</span>gauche<span class="op">;</span></span>
<span id="cb95-4"><a href="#cb95-4"></a>    x<span class="op">-&gt;</span>gauche <span class="op">=</span> y<span class="op">-&gt;</span>droite<span class="op">;</span></span>
<span id="cb95-5"><a href="#cb95-5"></a>    y<span class="op">-&gt;</span>droite <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb95-6"><a href="#cb95-6"></a>    y<span class="op">-&gt;</span>rouge <span class="op">=</span> x<span class="op">-&gt;</span>rouge<span class="op">;</span></span>
<span id="cb95-7"><a href="#cb95-7"></a>    x<span class="op">-&gt;</span>rouge <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb95-8"><a href="#cb95-8"></a>    <span class="cf">return</span> y<span class="op">;</span></span>
<span id="cb95-9"><a href="#cb95-9"></a><span class="op">}</span></span>
<span id="cb95-10"><a href="#cb95-10"></a></span>
<span id="cb95-11"><a href="#cb95-11"></a>arbre rotation_gauche<span class="op">(</span>arbre y<span class="op">)</span></span>
<span id="cb95-12"><a href="#cb95-12"></a><span class="op">{</span></span>
<span id="cb95-13"><a href="#cb95-13"></a>    arbre x <span class="op">=</span> y<span class="op">-&gt;</span>droite<span class="op">;</span></span>
<span id="cb95-14"><a href="#cb95-14"></a>    y<span class="op">-&gt;</span>droite <span class="op">=</span> x<span class="op">-&gt;</span>gauche<span class="op">;</span></span>
<span id="cb95-15"><a href="#cb95-15"></a>    x<span class="op">-&gt;</span>gauche <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb95-16"><a href="#cb95-16"></a>    x<span class="op">-&gt;</span>rouge <span class="op">=</span> y<span class="op">-&gt;</span>rouge<span class="op">;</span></span>
<span id="cb95-17"><a href="#cb95-17"></a>    y<span class="op">-&gt;</span>rouge <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb95-18"><a href="#cb95-18"></a>    <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb95-19"><a href="#cb95-19"></a><span class="op">}</span></span>
<span id="cb95-20"><a href="#cb95-20"></a></span>
<span id="cb95-21"><a href="#cb95-21"></a>arbre bascule<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb95-22"><a href="#cb95-22"></a><span class="op">{</span></span>
<span id="cb95-23"><a href="#cb95-23"></a>    a<span class="op">-&gt;</span>rouge <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb95-24"><a href="#cb95-24"></a>    a<span class="op">-&gt;</span>gauche<span class="op">-&gt;</span>rouge <span class="op">=</span> false<span class="op">;</span></span>
<span id="cb95-25"><a href="#cb95-25"></a>    a<span class="op">-&gt;</span>droite<span class="op">-&gt;</span>rouge <span class="op">=</span> false<span class="op">;</span></span>
<span id="cb95-26"><a href="#cb95-26"></a>    <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb95-27"><a href="#cb95-27"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions utilitaires <code>bool rouge(arbre a)</code> et <code>bool noir(arbre a)</code> qui teste la couleur de la racine. On fera attention au fait que l’arbre vide est noir.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb96"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb96-1"><a href="#cb96-1"></a><span class="dt">bool</span> rouge<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb96-2"><a href="#cb96-2"></a><span class="op">{</span></span>
<span id="cb96-3"><a href="#cb96-3"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">==</span> NULL<span class="op">)</span> <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb96-4"><a href="#cb96-4"></a>    <span class="cf">return</span> a<span class="op">-&gt;</span>rouge<span class="op">;</span></span>
<span id="cb96-5"><a href="#cb96-5"></a><span class="op">}</span></span>
<span id="cb96-6"><a href="#cb96-6"></a></span>
<span id="cb96-7"><a href="#cb96-7"></a><span class="dt">bool</span> noir<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb96-8"><a href="#cb96-8"></a><span class="op">{</span></span>
<span id="cb96-9"><a href="#cb96-9"></a>    <span class="cf">return</span> <span class="op">!</span>rouge<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb96-10"><a href="#cb96-10"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions <code>arbre essai_rotgauche(arbre a)</code>, <code>essai_rotdroite</code> et <code>essai_bascule</code> qui n’effectuent ces opérations que dans les cas nécessaires pour l’insertion.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb97"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb97-1"><a href="#cb97-1"></a>arbre essai_bascule<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb97-2"><a href="#cb97-2"></a><span class="op">{</span></span>
<span id="cb97-3"><a href="#cb97-3"></a>    <span class="cf">if</span><span class="op">(</span>rouge<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">)</span> <span class="op">&amp;&amp;</span> rouge<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">))</span></span>
<span id="cb97-4"><a href="#cb97-4"></a>        <span class="cf">return</span> bascule<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb97-5"><a href="#cb97-5"></a>    <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb97-6"><a href="#cb97-6"></a><span class="op">}</span></span>
<span id="cb97-7"><a href="#cb97-7"></a></span>
<span id="cb97-8"><a href="#cb97-8"></a>arbre essai_rotgauche<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb97-9"><a href="#cb97-9"></a><span class="op">{</span></span>
<span id="cb97-10"><a href="#cb97-10"></a>    <span class="cf">if</span><span class="op">(</span>rouge<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">)</span> <span class="op">&amp;&amp;</span> rouge<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">-&gt;</span>droite<span class="op">))</span></span>
<span id="cb97-11"><a href="#cb97-11"></a>        <span class="cf">return</span> rotation_gauche<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb97-12"><a href="#cb97-12"></a>    <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb97-13"><a href="#cb97-13"></a><span class="op">}</span></span>
<span id="cb97-14"><a href="#cb97-14"></a></span>
<span id="cb97-15"><a href="#cb97-15"></a>arbre essai_rotdroite<span class="op">(</span>arbre a<span class="op">)</span></span>
<span id="cb97-16"><a href="#cb97-16"></a><span class="op">{</span></span>
<span id="cb97-17"><a href="#cb97-17"></a>    <span class="cf">if</span><span class="op">(</span>rouge<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">)</span> <span class="op">&amp;&amp;</span> noir<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">))</span></span>
<span id="cb97-18"><a href="#cb97-18"></a>        <span class="cf">return</span> rotation_droite<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb97-19"><a href="#cb97-19"></a>    <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb97-20"><a href="#cb97-20"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>En déduire une fonction <code>arbre insere(arbre a, int x)</code> qui effectue l’insertion dans un arbre rouge et noir. On pourra définir une fonction auxiliaire <code>arbre insere_aux(arbre a, int x)</code> qui effectue l’insertion et qu’on appellera dans <code>insere</code> avant de faire le noircissement final de la racine.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb98"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb98-1"><a href="#cb98-1"></a>arbre insere_aux<span class="op">(</span>arbre a<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb98-2"><a href="#cb98-2"></a><span class="op">{</span></span>
<span id="cb98-3"><a href="#cb98-3"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">==</span> NULL<span class="op">)</span></span>
<span id="cb98-4"><a href="#cb98-4"></a>        <span class="cf">return</span> cree_noeud<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb98-5"><a href="#cb98-5"></a>    <span class="cf">if</span> <span class="op">(</span>a<span class="op">-&gt;</span>valeur <span class="op">&gt;</span> x<span class="op">)</span></span>
<span id="cb98-6"><a href="#cb98-6"></a>        a<span class="op">-&gt;</span>gauche <span class="op">=</span> insere_aux<span class="op">(</span>a<span class="op">-&gt;</span>gauche<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb98-7"><a href="#cb98-7"></a>    <span class="cf">else</span></span>
<span id="cb98-8"><a href="#cb98-8"></a>        a<span class="op">-&gt;</span>droite <span class="op">=</span> insere_aux<span class="op">(</span>a<span class="op">-&gt;</span>droite<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb98-9"><a href="#cb98-9"></a>    <span class="cf">return</span> essai_bascule<span class="op">(</span>essai_rotgauche<span class="op">(</span>essai_rotdroite<span class="op">(</span>a<span class="op">)));</span></span>
<span id="cb98-10"><a href="#cb98-10"></a><span class="op">}</span></span>
<span id="cb98-11"><a href="#cb98-11"></a></span>
<span id="cb98-12"><a href="#cb98-12"></a>arbre insere<span class="op">(</span>arbre a<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb98-13"><a href="#cb98-13"></a><span class="op">{</span></span>
<span id="cb98-14"><a href="#cb98-14"></a>    arbre a2 <span class="op">=</span> insere_aux<span class="op">(</span>a<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb98-15"><a href="#cb98-15"></a>    a2<span class="op">-&gt;</span>rouge <span class="op">=</span> false<span class="op">;</span></span>
<span id="cb98-16"><a href="#cb98-16"></a>    <span class="cf">return</span> a2<span class="op">;</span></span>
<span id="cb98-17"><a href="#cb98-17"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
