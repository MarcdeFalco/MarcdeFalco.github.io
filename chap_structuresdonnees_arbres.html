<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Arbres</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Arbres
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:arbres-binaires"><span>1</span> Arbres binaires</a><div class="menu"><a class="item" href="#sec:définition-inductive"><div class="ui label">1.1</div> Définition inductive</a><a class="item" href="#sec:vocabulaire"><div class="ui label">1.2</div> Vocabulaire</a></div></div><div class="item header"> <a href="#sec:tp---arbres-en-ocaml"><span>2</span> TP - Arbres en <code>OCaml</code></a><div class="menu"><a class="item" href="#sec:premières-fonctions"><div class="ui label">2.1</div> Premières fonctions</a><a class="item" href="#sec:parcours"><div class="ui label">2.2</div> Parcours</a><a class="item" href="#sec:arbres-binaires-stricts"><div class="ui label">2.3</div> Arbres binaires stricts</a><a class="item" href="#sec:dessin-darbres"><div class="ui label">2.4</div> Dessin d’arbres</a><a class="item" href="#sec:génération-aléatoire-darbres"><div class="ui label">2.5</div> Génération aléatoire d’arbres</a></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Arbres
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Arbres     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_programmation_imperative.jpg"> </div></p>
<h1 data-number="1" id="sec:arbres-binaires"><span class="header-section-number">1</span> Arbres binaires</h1>
<h2 data-number="1.1" id="sec:définition-inductive"><span class="header-section-number">1.1</span> Définition inductive</h2>
<p><div class="ui message"><div class="header">Définition</div> Un arbre binaire étiqueté par <span class="math inline">\(\mathcal{E}\)</span> est :</p>
<ul>
<li>soit vide, et on le note alors <span class="math inline">\(\text{nil}\)</span> ou <span class="math inline">\(\perp\)</span></li>
<li>soit un triplet <span class="math inline">\((g,x,d)\)</span> où <span class="math inline">\(x \in \mathcal{E}\)</span> et <span class="math inline">\(g\)</span> et <span class="math inline">\(d\)</span> sont des arbres binaires. </div></li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div>Cette définition inductive ressemble à la définition des listes.</p>
<p>On peut la formaliser en introduisant <span class="math inline">\(T_b(\mathcal{E})\)</span> l’ensemble des arbres étiquetés par <span class="math inline">\(\mathcal{E}\)</span>. C’est le <strong>plus petit ensemble</strong> tel que :</p>
<ul>
<li><span class="math inline">\(\text{nil} \in T_b(\mathcal{E})\)</span></li>
<li><span class="math inline">\(\forall x\in \mathcal{E}, \forall g, d \in T_b(\mathcal{E}), (g,x,d) \in T_b(\mathcal{E})\)</span></li>
</ul>
<p>Les conséquences de la précision <strong>plus petit ensemble</strong> sont importantes :</p>
<ul>
<li>les arbres sont nécessairement des expressions finis, c’est-à-dire qu’il ne comportent qu’un nombre finis de constructions. C’est automatique car l’ensemble des arbres finis vérifie les conditions précédentes ;</li>
<li>pour tout triplet <span class="math inline">\((g,x,d)\)</span> il ne peut exister qu’un arbre, sinon, en enlevant un arbre en double on vérifierait encore les deux conditions précédentes.</li>
</ul>
<p>On en déduit directement la notion de preuve par <strong>induction structurelle</strong> sur les arbres : <span class="math display">\[
\forall a \in T_b(\mathcal{E}), P(a)
\iff \begin{cases}
P(\text{nil}) \\
\forall x \in \mathcal{E}, \forall g, d \in T_b(\mathcal{E}),
P(g) \wedge P(d) \Rightarrow P(g,x,d)
\end{cases}
\]</span></p>
<p>Cette induction correspond à un pseudo principe de récurrence qui nous permettra de faire les preuves.</p>
<p>Pour démontrer cette inégalité, il suffit de vérifier que <span class="math inline">\(T_P = \{ t \in T_b(\mathcal{E}), P(t) \}\)</span> vérifie les relations de la définition inductive et <span class="math inline">\(T_P \subset T_b(\mathcal{E})\)</span> et par minimalité, on a bien <span class="math inline">\(T_P = T_b(\mathcal{E})\)</span>.</div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si <span class="math inline">\(\mathcal{E} = \N\)</span>, les éléments suivants sont des arbres :</p>
<ul>
<li><span class="math inline">\(\text{nil}\)</span></li>
<li><span class="math inline">\((\text{nil}, 2, \text{nil})\)</span></li>
<li><span class="math inline">\(( (\text{nil}, 1, \text{nil}), 2, \text{nil} )\)</span></li>
</ul>
</div>
<p>On adoptera une représentation graphique très naturelle pour les arbres binaires où un nœud <span class="math inline">\((g,x,d)\)</span> sera représenté par <img src="assets/pics/inline_001.png" /></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Les trois arbres précédentes sont donc représentés par :</p>
<p><span class="math inline">\(\text{nil}\)</span></p>
<p><img src="assets/pics/inline_002.png" /></p>
<p><img src="assets/pics/inline_003.png" /></p>
<p>Afin d’alléger la notation, on omettra <span class="math inline">\(\text{nil}\)</span>, sauf pour l’arbre vide. On fera cependant attention à conserver les arêtes donnant sur <span class="math inline">\(\text{nil}\)</span> pour ne pas confondre <span class="math inline">\((\text{nil}, 1, \text{nil}(\text{nil}, 2, \text{nil}))\)</span> et <span class="math inline">\(( (\text{nil}, 2, \text{nil}), 1, \text{nil} )\)</span>. Ainsi on représentera les arbres précédents par :</p>
<p><img src="assets/pics/inline_004.png" /><br />
<img src="assets/pics/inline_005.png" /></p>
</div>
<h2 data-number="1.2" id="sec:vocabulaire"><span class="header-section-number">1.2</span> Vocabulaire</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(a\)</span> un arbre binaire. Les arbres non vides présents dans <span class="math inline">\(a\)</span> sont appelés les <strong>nœuds</strong> de <span class="math inline">\(a\)</span>. Parmi ceux-ci on distingue ceux qui sont de la forme <span class="math inline">\((nil,x,nil)\)</span>. appelés des <strong>feuilles</strong>. Les nœuds qui ne sont pas des feuilles sont appelés des <strong>nœuds internes</strong>. Le nœud <span class="math inline">\(a\)</span> lui-même est appelé la racine de l’arbre. On note <span class="math inline">\(N(a)\)</span> les nœuds de <span class="math inline">\(a\)</span>.</p>
<p>Si <span class="math inline">\(n \in N(a)\)</span> n’est pas pas la racine, il est le fils gauche ou le fils droit d’un unique nœud appelé le <strong>père</strong> de <span class="math inline">\(x\)</span>.</p>
<p>Si <span class="math inline">\(n \in N(a)\)</span>, on appelle <strong>sous-arbre</strong> de <span class="math inline">\(a\)</span> l’arbre dont <span class="math inline">\(n\)</span> est la racine. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>En partant de la définition inductive, il y a une identification entre un sous-arbre et sa racine. Mais afin de raisonner, on distinguera un nœud en tant qu’emplacement au sein d’un arbre et le sous-arbre lui-même.</div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(a\)</span> un arbre binaire.</p>
<ul>
<li>On appelle <strong>taille</strong> de <span class="math inline">\(a\)</span>, et on note <span class="math inline">\(|a|\)</span> le nombre de nœuds de <span class="math inline">\(a\)</span>.</li>
<li>On appelle <strong>hauteur</strong> de <span class="math inline">\(a\)</span> l’entier <span class="math display">\[
h(a) = \begin{cases} -1 &amp; \text{ si } a = \text{nil} \\
1 + \max(h(g), h(d)) &amp; \text{ si } a = (g,x,d) \end{cases}
\]</span></li>
</ul>
<p></div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(a\)</span> un arbre binaire et <span class="math inline">\(n \in N(a)\)</span>. On appelle <strong>profondeur</strong> de <span class="math inline">\(n\)</span> l’unique entier <span class="math inline">\(p(a)\)</span> tel qu’il existe une suite finie <span class="math inline">\((n_0, n_1, \dots, n_{p(a)})\)</span> de <span class="math inline">\(n\)</span> vérifiant :</p>
<ul>
<li><span class="math inline">\(n_0\)</span> est la racine de <span class="math inline">\(a\)</span></li>
<li><span class="math inline">\(n_{p(a)} = n\)</span></li>
<li>pour tout <span class="math inline">\(i\)</span>, <span class="math inline">\(n_i\)</span> est le père de <span class="math inline">\(n_{i+1}\)</span></li>
</ul>
<p>Cette suite finie est le <strong>chemin</strong> de la racine à <span class="math inline">\(n\)</span>. Il est nécessairement unique car chaque nœud autre que la racine a un unique père. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(a\)</span> un arbre, si <span class="math inline">\(a\)</span> est non vide, alors <span class="math inline">\(h(a) = \max_{n \in N(a)} p(n)\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> Par induction structurelle sur <span class="math inline">\(a\)</span>.</p>
<ul>
<li><strong>Initialisation</strong> Si <span class="math inline">\(a = \text{nil}\)</span> la prémisse est fausse, donc l’implication est trivialement vérifiée.</li>
<li><strong>Hérédité</strong> Supposons la propriété vérifiée pour deux arbres <span class="math inline">\(g\)</span> et <span class="math inline">\(d\)</span>, soit <span class="math inline">\(x \in \mathcal{E}\)</span>, on va montrer qu’elle est vérifiée pour <span class="math inline">\(a = (g,x,d)\)</span>. On a quatre cas pour le couple <span class="math inline">\((g,d)\)</span> :
<ul>
<li>Soit <span class="math inline">\(g \neq \text{nil}\)</span> et <span class="math inline">\(d \neq \text{nil}\)</span>. Dans ce cas, par hypothèse <span class="math inline">\(h(g) = \max_{n \in N(g)} p_g(n)\)</span> où <span class="math inline">\(p_g\)</span> est la profondeur de <span class="math inline">\(n\)</span> en tant que nœud de l’arbre <span class="math inline">\(g\)</span>. Or, mis à part la racine de <span class="math inline">\(a\)</span>, le chemin menant dans <span class="math inline">\(a\)</span> au nœud <span class="math inline">\(n\)</span> est dans <span class="math inline">\(g\)</span>. On a donc directement <span class="math inline">\(p_g(n) = p(n) - 1\)</span>. Ainsi <span class="math inline">\(h(g) = \max_{n \in N(g)} p(n) - 1\)</span>. De même, <span class="math inline">\(h(d) = max_{n \in N(d)} p(n) - 1\)</span>. On a <span class="math display">\[h(a) = 1 + \max(h(g),h(d)) = \max(\max_{n\in N(g)} p(n), \max_{n \in
\N(d)} p(n))\]</span> Or, le seul nœud de <span class="math inline">\(a\)</span> qui n’est ni dans <span class="math inline">\(g\)</span> ni dans <span class="math inline">\(d\)</span> est sa racine, qui est de profondeur nulle donc <span class="math inline">\(h(a) = \max_{n \in N(a)} p(n)\)</span>.</li>
<li>Soit <span class="math inline">\(g = \text{nil}\)</span> et <span class="math inline">\(d \neq \text{nil}\)</span>. Ainsi <span class="math inline">\(h(g) = -1\)</span> et donc <span class="math inline">\(h(a) = 1 + h(d) = \max_{n \in N(d)} p(n)\)</span> par l’analyse précédente. On conclut donc avec la propriété voulue.</li>
<li>Soit <span class="math inline">\(g \neq \text{nil}\)</span> et <span class="math inline">\(d = \text{nil}\)</span>. Cas symétrique du précédent.</li>
<li>Soit <span class="math inline">\(g = d = \text{nil}\)</span>. Auquel cas, <span class="math inline">\(h(a) = 0\)</span> qui est bien la profondeur de son unique nœud.</li>
</ul></li>
</ul>
<p>On a bien montré la propriété voulue par induction structurelle. </div> </div></p>
<h1 data-number="2" id="sec:tp---arbres-en-ocaml"><span class="header-section-number">2</span> TP - Arbres en <code>OCaml</code></h1>
<h2 data-number="2.1" id="sec:premières-fonctions"><span class="header-section-number">2.1</span> Premières fonctions</h2>
<p>On va considérer le type des arbres binaires <code>'a arbre</code> défini par :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> &#39;a arbre = Nil | Noeud <span class="kw">of</span> &#39;a arbre * &#39;a * &#39;a arbre</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">(* Calcule le nombre de noeuds de a *)</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">let</span> taille (a : &#39;a arbre) : <span class="dt">int</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">(* Calcule la hauteur de a *)</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">let</span> hauteur (a : &#39;a arbre) : <span class="dt">int</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">(* Indique si a est réduit à une feuille *)</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="kw">let</span> feuille (a : &#39;a arbre) : <span class="dt">bool</span></span></code></pre></div>
<p></div></p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>sous_arbres</code> qui renvoie la liste des sous-arbres non vides d’un arbre.</p>
<p>En déduire des fonctions <code>noeuds</code>, <code>feuilles</code> et <code>noeuds_internes</code> qui renvoient la liste des étiquettes des <code>noeuds</code> correspondants.</p>
</div>
<p>Pour accéder à un nœud de l’arbre, on descend en partant de la racine et en allant à gauche ou à droite. On peut donc représenter un tel chemin par une liste de déplacements :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">type</span> deplacement = Gauche | Droite</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">type</span> chemin = deplacement <span class="dt">list</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>chemin_noeud : 'a arbre -&gt; chemin -&gt; 'a option</code> qui renvoie l’étiquette d’un nœud donné par son chemin. On utilise un type <code>option</code> en cas de chemin invalide.</p>
</div>
<h2 data-number="2.2" id="sec:parcours"><span class="header-section-number">2.2</span> Parcours</h2>
<p>Sur le même modèle que l’exploration par <em>backtracking</em>, on va réaliser un parcours en profondeur d’un arbre en explorant à gauche puis à droite ses sous-arbres de manière récursives. Chaque nœud est donc vu trois fois :</p>
<ul>
<li>une première fois quand on le découvre avant d’explorer son sous-arbre gauche</li>
<li>entre les deux explorations</li>
<li>enfin quand on a fini d’explorer son sous-arbre droit.</li>
</ul>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions <code>affiche_avant</code>, <code>affiche_milieu</code> et <code>affiche_apres</code> qui parcourt et affiche les étiquettes d’un <code>string arbre</code> selon les trois cas précédents. <em>Note: il s’agit essentiellement du même code à une ligne près</em>.</p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>On peut représenter une expression arithmétique comme <span class="math inline">\((2+3)\times 4\)</span> en tant qu’arbre avec des opérations pour les nœuds internes et des valeurs pour les feuilles. Quitte à utiliser des <code>string</code> dans les deux cas, qu’obtient-on sur une telle expression avec les trois opérations précédentes ?</p>
</div>
<p>On redonne ici l’implémentation d’une pile et d’une file en <code>OCaml</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">let</span> pile_creer () = <span class="dt">ref</span> []</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">let</span> pile_empile p x = p := x :: !p</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">let</span> pile_depile p =</span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="kw">match</span> !p <span class="kw">with</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>    | [] -&gt; <span class="dt">failwith</span> <span class="st">&quot;Pile vide&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>    | x::q -&gt; p := q; x</span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="kw">let</span> pile_est_vide p = !p = []</span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="kw">let</span> file_creer () = (pile_creer (), pile_creer ())</span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="kw">let</span> file_bascule (pin, pout) = pout := <span class="dt">List</span>.rev !pin; pin := []</span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="kw">let</span> file_enfile (pin, pout) x = pile_empile pin x</span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="kw">let</span> file_defile (pin, pout) =</span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="kw">if</span> pile_est_vide pout </span>
<span id="cb4-14"><a href="#cb4-14"></a>    <span class="kw">then</span> file_bascule (pin, pout);</span>
<span id="cb4-15"><a href="#cb4-15"></a>    pile_depile pout</span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="kw">let</span> file_est_vide (pin, pout) = pile_est_vide pin &amp;&amp; pile_est_vide pout</span></code></pre></div>
<p></div></p>
<p>Ces deux structures de données ont la même interface mais deux comportements différents. On va utiliser un unique type pour les représenter afin de permettre à une fonction d’utiliser soit une pile soit une file.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">type</span> (&#39;a, &#39;b) taches = {</span>
<span id="cb5-2"><a href="#cb5-2"></a>    creation : <span class="dt">unit</span> -&gt; &#39;a;</span>
<span id="cb5-3"><a href="#cb5-3"></a>    ajouter : &#39;a -&gt; &#39;b -&gt; <span class="dt">unit</span>;</span>
<span id="cb5-4"><a href="#cb5-4"></a>    retirer : &#39;a -&gt; &#39;b;</span>
<span id="cb5-5"><a href="#cb5-5"></a>    est_vide : &#39;a -&gt; <span class="dt">bool</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>}</span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="kw">let</span> taches_pile = {</span>
<span id="cb5-9"><a href="#cb5-9"></a>    creation = pile_creer;</span>
<span id="cb5-10"><a href="#cb5-10"></a>    ajouter = pile_empile;</span>
<span id="cb5-11"><a href="#cb5-11"></a>    retirer = pile_depile;</span>
<span id="cb5-12"><a href="#cb5-12"></a>    est_vide = pile_est_vide</span>
<span id="cb5-13"><a href="#cb5-13"></a>    }</span>
<span id="cb5-14"><a href="#cb5-14"></a></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="kw">let</span> taches_file = {</span>
<span id="cb5-16"><a href="#cb5-16"></a>    creation = file_creer;</span>
<span id="cb5-17"><a href="#cb5-17"></a>    ajouter = file_enfile;</span>
<span id="cb5-18"><a href="#cb5-18"></a>    retirer = file_defile;</span>
<span id="cb5-19"><a href="#cb5-19"></a>    est_vide = file_est_vide</span>
<span id="cb5-20"><a href="#cb5-20"></a>    }</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Ici, on a une limitation du système de types. On aimerait paramètrer <code>taches</code> par <code>('a 'b, 'a)</code> où <code>'b</code> est un type paramètré, ainsi on aurait soit <code>('a pile, 'a)</code> où <code>('a file, 'a)</code> comme pour les deux case. Cependant, ce n’est pas possible, les types génériques ne sont pas paramètriques. C’est pour cela qu’on a un <code>('a, 'b)</code> sans avoir de lien apparent entre <code>'a</code> et <code>'b</code>.</div></p>
<p>On pourra alors écrire une fonction prenant un gestionnaire de tâches en paramètre :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">let</span> f t a =</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="kw">let</span> a_traiter = t.creation () <span class="kw">in</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> <span class="dt">Array</span>.length a - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>        t.ajouter a_traiter a.(i)</span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="kw">done</span>;</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="kw">while</span> <span class="dt">not</span> (t.est_vide a_traiter) <span class="kw">do</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>        <span class="dt">print_int</span> (t.retirer a_traiter)</span>
<span id="cb6-8"><a href="#cb6-8"></a>    <span class="kw">done</span></span></code></pre></div>
<p></div></p>
<p>Ainsi <code>f taches_pile [|1;2;3|]</code> va afficher <code>321</code> et <code>f taches_file [|1;2;3|]</code> va afficher <code>123</code>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>En déduire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1"></a>parcours : (&#39;a, &#39;b) taches -&gt; &#39;b arbre -&gt; <span class="dt">unit</span></span></code></pre></div>
<p></div> qui effectue un parcours de l’arbre en affichant les étiquettes des nœuds visités dans l’ordre induit par le gestionnaire de tâches passé en paramètre.</p>
</div>
<h2 data-number="2.3" id="sec:arbres-binaires-stricts"><span class="header-section-number">2.3</span> Arbres binaires stricts</h2>
<p>Pour représenter des arbres dont les nœuds ont tous deux fils non vides, on va utiliser le type</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">type</span> (&#39;a, &#39;b) arbre_bin = Feuille <span class="kw">of</span> &#39;a </span>
<span id="cb8-2"><a href="#cb8-2"></a>    | NoeudI <span class="kw">of</span> (&#39;a, &#39;b) arbre_bin * &#39;b * (&#39;a, &#39;b) arbre_bin</span></code></pre></div>
<p></div></p>
<p>Ce type permet de représenter naturellement des expressions arithmétiques comme :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1"></a>NoeudI(NoeudI( Feuille <span class="dv">2</span>, <span class="ch">&#39;+&#39;</span>, Feuille <span class="dv">3</span>), <span class="ch">&#39;*&#39;</span>, Feuille <span class="dv">5</span>)</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>evalue : (int, char) arbre_bin -&gt; int</code> qui évalue une telle expression.</p>
</div>
<p>Si on considère le type <div class="ui segment code"></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">type</span> (&#39;a, &#39;b) etiquette = F <span class="kw">of</span> &#39;a | N <span class="kw">of</span> &#39;b</span></code></pre></div>
<p></div></p>
<p>On peut passer d’un <code>('a, 'b) arbre_bin</code> à un <code>('a, 'b) etiquette arbre</code> et, dans certains cas, d’un <code>('a, 'b) etiquette arbre</code> à un <code>('a, 'b) arbre_bin</code>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire ainsi deux fonctions de conversion :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1"></a>arbre_bin_vers_arbre : (&#39;a, &#39;b) arbre_bin -&gt; (&#39;a, &#39;b) etiquette arbre</span>
<span id="cb11-2"><a href="#cb11-2"></a>arbre_vers_arbre_bin : (&#39;a, &#39;b) etiquette arbre -&gt; (&#39;a, &#39;b) arbre_bin <span class="dt">option</span></span></code></pre></div>
<p></div></p>
</div>
<h2 data-number="2.4" id="sec:dessin-darbres"><span class="header-section-number">2.4</span> Dessin d’arbres</h2>
<p>On va réaliser dans cette partie une fonction de dessin d’arbres avec <code>graphics</code>. L’idée est de placer la racine et de dessiner les sous-arbres gauche et droit en dessous. Pour cela, il va falloir connaitre la taille de ces sous-arbres en pixels.</p>
<p>On pourra consulter la documentation de <code>graphics</code> ici : <a href="http://pauillac.inria.fr/~remy/poly/ocaml/htmlman/libref/Graphics.html">Graphics</a></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>largeur_pixels : int arbre -&gt; int</code> qui estime la largeur en pixels d’un arbre dans son affichage.</p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>En déduire une fonction <code>dessine : int arbre -&gt; int -&gt; int -&gt; unit</code> tel que <code>dessine a x y</code> dessine l’arbre <span class="math inline">\(a\)</span> en plaçant la racine en <span class="math inline">\((x, y)\)</span>.</p>
</div>
<h2 data-number="2.5" id="sec:génération-aléatoire-darbres"><span class="header-section-number">2.5</span> Génération aléatoire d’arbres</h2>
<p>Dans cette partie, ce qui nous intéresse est de générer aléatoirement des arbres pour en observer la structure. Les étiquettes ne sont pas pertinentes, on pourra donc au choix, soit considérer des <code>unit arbre</code>, soit redéfinir un type d’arbre non étiquettés.</p>
<p>On va réaliser ici deux modèles de génération aléatoire d’arbres. Le premier modèle consiste, pour générer un arbre de <span class="math inline">\(n\)</span> nœuds, à choisir aléatoirement <span class="math inline">\(k\)</span> dans <span class="math inline">\(\range{0}{n}\)</span>, à générer aléatoirement un arbre <span class="math inline">\(g\)</span> à <span class="math inline">\(k\)</span> nœuds et un arbre <span class="math inline">\(d\)</span> à <span class="math inline">\(n-k\)</span> nœuds puis à renvoyer l’arbre <code>Noeud(g, (), d)</code>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Implémenter ce modèle avec une fonction <code>genere_arbre_1 : int -&gt; unit arbre</code>.</p>
<p>Tester votre fonction, notamment avec l’affichage de la partie précédente.</p>
</div>
<p>Pour le deuxième modèle, on va choisir un sous-arbre vide uniformément et le remplacer par un nœud.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>chemins_vides : 'a arbre -&gt; chemin list</code> qui étant donné un arbre renvoie la liste des chemins permettant d’aboutir à un sous-arbre vide.</p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>remplit : 'a arbre -&gt; chemin -&gt; 'a arbre</code> qui remplace un sous-arbre vide donnée par son chemin par un nœud.</p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>En déduire une fonction <code>genere_arbres_2 : int -&gt; unit arbre</code> qui prend un entier <code>n</code> et construit un arbre à <span class="math inline">\(n\)</span> nœuds en partant de l’arbre vide et en réalisant <span class="math inline">\(n\)</span> remplacement d’un arbre vide par un nœuds, le choix de l’arbre vide se faisant uniformément.</p>
<p><em>Note :</em> on pourra utilser <code>List.nth</code> et <code>Random.int</code> Voir par exemple <a href="https://ocaml.org/api/Random.html">Random</a></p>
</div>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
