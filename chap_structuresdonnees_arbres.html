<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Informatique - structuresdonnees - arbres</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Informatique - structuresdonnees - arbres
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:arbres-binaires"><span>1</span> Arbres binaires</a><div class="menu"><a class="item" href="#sec:définition-inductive"><div class="ui label">1.1</div> Définition inductive</a><a class="item" href="#sec:vocabulaire"><div class="ui label">1.2</div> Vocabulaire</a><a class="item" href="#sec:implémentations"><div class="ui label">1.3</div> Implémentations</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:en-ocaml"><i class="circle icon"></i> En <code>OCaml</code></a><a style="font-size:0.6em" class="item" href="#sec:en-c"><i class="circle icon"></i> En <code>C</code></a></div><a class="item" href="#sec:arbres-binaires-stricts"><div class="ui label">1.4</div> Arbres binaires stricts</a><a class="item" href="#sec:arbres-binaires-complets"><div class="ui label">1.5</div> Arbres binaires complets</a></div></div><div class="item header"> <a href="#sec:arbres"><span>2</span> Arbres</a><div class="menu"><a class="item" href="#sec:définition"><div class="ui label">2.1</div> Définition</a><a class="item" href="#sec:implémentation"><div class="ui label">2.2</div> Implémentation</a><a class="item" href="#sec:représentation-par-un-arbre-binaire"><div class="ui label">2.3</div> Représentation par un arbre binaire</a><a class="item" href="#sec:applications"><div class="ui label">2.4</div> Applications</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:arbres-dexpressions"><i class="circle icon"></i> Arbres d’expressions</a><a style="font-size:0.6em" class="item" href="#sec:arbres-préfixes-ou-tries"><i class="circle icon"></i> Arbres préfixes ou tries</a></div></div></div><div class="item header"> <a href="#sec:parcours"><span>3</span> Parcours</a><div class="menu"><a class="item" href="#sec:parcours-récursif-dun-arbre-binaire"><div class="ui label">3.1</div> Parcours récursif d’un arbre binaire</a><a class="item" href="#sec:parcours-impératifs"><div class="ui label">3.2</div> Parcours impératifs</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:cadre-général"><i class="circle icon"></i> Cadre général</a><a style="font-size:0.6em" class="item" href="#sec:cas-du-parcours-en-profondeur"><i class="circle icon"></i> Cas du parcours en profondeur</a><a style="font-size:0.6em" class="item" href="#sec:cas-du-parcours-en-largeur"><i class="circle icon"></i> Cas du parcours en largeur</a></div><a class="item" href="#sec:parcours-darbres"><div class="ui label">3.3</div> Parcours d’arbres</a></div></div><div class="item header"> <a href="#sec:arbres-binaires-de-recherche"><span>4</span> Arbres binaires de recherche</a><div class="menu"><a class="item" href="#sec:objectif"><div class="ui label">4.1</div> Objectif</a><a class="item" href="#sec:définition-1"><div class="ui label">4.2</div> Définition</a><a class="item" href="#sec:opérations"><div class="ui label">4.3</div> Opérations</a><a class="item" href="#sec:équilibrage"><div class="ui label">4.4</div> Équilibrage</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:arbres-2-3"><i class="circle icon"></i> Arbres 2-3</a><a style="font-size:0.6em" class="item" href="#sec:arbres-rouges-et-noirs"><i class="circle icon"></i> Arbres rouges et noirs</a></div><a class="item" href="#sec:implémentation-dun-dictionnaire"><div class="ui label">4.5</div> Implémentation d’un dictionnaire</a></div></div><div class="item header"> <a href="#sec:tas"><span>5</span> Tas</a><div class="menu"><a class="item" href="#sec:présentation"><div class="ui label">5.1</div> Présentation</a><a class="item" href="#sec:implémentation-1"><div class="ui label">5.2</div> Implémentation</a><a class="item" href="#sec:application-aux-files-de-priorité"><div class="ui label">5.3</div> Application aux files de priorité</a></div></div><div class="item header"> <a href="#sec:tp---arbres-en-ocaml"><span>6</span> TP - Arbres en <code>OCaml</code></a><div class="menu"><a class="item" href="#sec:premières-fonctions"><div class="ui label">6.1</div> Premières fonctions</a><a class="item" href="#sec:parcours-1"><div class="ui label">6.2</div> Parcours</a><a class="item" href="#sec:arbres-binaires-stricts-1"><div class="ui label">6.3</div> Arbres binaires stricts</a><a class="item" href="#sec:dessin-darbres"><div class="ui label">6.4</div> Dessin d’arbres</a><a class="item" href="#sec:génération-aléatoire-darbres"><div class="ui label">6.5</div> Génération aléatoire d’arbres</a></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Informatique - structuresdonnees - arbres
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p>****## Arbres <div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Arbres     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_programmation_imperative.jpg"> </div></p>
<h1 data-number="1" id="sec:arbres-binaires"><span class="header-section-number">1</span> Arbres binaires</h1>
<h2 data-number="1.1" id="sec:définition-inductive"><span class="header-section-number">1.1</span> Définition inductive</h2>
<p><div class="ui message"><div class="header">Définition</div> Un arbre binaire étiqueté par <span class="math inline">\(\mathcal{E}\)</span> est :</p>
<ul>
<li>soit vide, et on le note alors <span class="math inline">\(\text{nil}\)</span> ou <span class="math inline">\(\perp\)</span></li>
<li>soit un triplet <span class="math inline">\((g,x,d)\)</span> où <span class="math inline">\(x \in \mathcal{E}\)</span> et <span class="math inline">\(g\)</span> et <span class="math inline">\(d\)</span> sont des arbres binaires. </div></li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div>Cette définition inductive ressemble à la définition des listes.</p>
<p>On peut la formaliser en introduisant <span class="math inline">\(T_b(\mathcal{E})\)</span> l’ensemble des arbres étiquetés par <span class="math inline">\(\mathcal{E}\)</span>. C’est le <strong>plus petit ensemble</strong> tel que :</p>
<ul>
<li><span class="math inline">\(\text{nil} \in T_b(\mathcal{E})\)</span></li>
<li><span class="math inline">\(\forall x\in \mathcal{E}, \forall g, d \in T_b(\mathcal{E}), (g,x,d) \in T_b(\mathcal{E})\)</span></li>
</ul>
<p>Les conséquences de la précision <strong>plus petit ensemble</strong> sont importantes :</p>
<ul>
<li>les arbres sont nécessairement des expressions finis, c’est-à-dire qu’il ne comportent qu’un nombre finis de constructions. C’est automatique car l’ensemble des arbres finis vérifie les conditions précédentes ;</li>
<li>pour tout triplet <span class="math inline">\((g,x,d)\)</span> il ne peut exister qu’un arbre, sinon, en enlevant un arbre en double on vérifierait encore les deux conditions précédentes.</li>
</ul>
<p>On en déduit directement la notion de preuve par <strong>induction structurelle</strong> sur les arbres : <span class="math display">\[
\forall a \in T_b(\mathcal{E}), P(a)
\iff \begin{cases}
P(\text{nil}) \\
\forall x \in \mathcal{E}, \forall g, d \in T_b(\mathcal{E}),
P(g) \wedge P(d) \Rightarrow P(g,x,d)
\end{cases}
\]</span></p>
<p>Cette induction correspond à un pseudo principe de récurrence qui nous permettra de faire les preuves.</p>
<p>Pour démontrer cette inégalité, il suffit de vérifier que <span class="math inline">\(T_P = \{ t \in T_b(\mathcal{E}), P(t) \}\)</span> vérifie les relations de la définition inductive et <span class="math inline">\(T_P \subset T_b(\mathcal{E})\)</span> et par minimalité, on a bien <span class="math inline">\(T_P = T_b(\mathcal{E})\)</span>.</div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si <span class="math inline">\(\mathcal{E} = \N\)</span>, les éléments suivants sont des arbres :</p>
<ul>
<li><span class="math inline">\(\text{nil}\)</span></li>
<li><span class="math inline">\((\text{nil}, 2, \text{nil})\)</span></li>
<li><span class="math inline">\(( (\text{nil}, 1, \text{nil}), 2, \text{nil} )\)</span></li>
</ul>
</div>
<p>On adoptera une représentation graphique très naturelle pour les arbres binaires où un nœud <span class="math inline">\((g,x,d)\)</span> sera représenté par <img src="assets/pics/inline_001.png" /></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Les trois arbres précédentes sont donc représentés par :</p>
<p><span class="math inline">\(\text{nil}\)</span></p>
<p><img src="assets/pics/inline_002.png" /></p>
<p><img src="assets/pics/inline_003.png" /></p>
<p>Afin d’alléger la notation, on omettra <span class="math inline">\(\text{nil}\)</span>, sauf pour l’arbre vide. On fera cependant attention à conserver les arêtes donnant sur <span class="math inline">\(\text{nil}\)</span> pour ne pas confondre <span class="math inline">\((\text{nil}, 1, \text{nil}(\text{nil}, 2, \text{nil}))\)</span> et <span class="math inline">\(( (\text{nil}, 2, \text{nil}), 1, \text{nil} )\)</span>. Ainsi on représentera les arbres précédents par :</p>
<p><img src="assets/pics/inline_004.png" /><br />
<img src="assets/pics/inline_005.png" /></p>
</div>
<h2 data-number="1.2" id="sec:vocabulaire"><span class="header-section-number">1.2</span> Vocabulaire</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(a\)</span> un arbre binaire. Les arbres non vides présents dans <span class="math inline">\(a\)</span> sont appelés les <strong>nœuds</strong> de <span class="math inline">\(a\)</span>. Parmi ceux-ci on distingue ceux qui sont de la forme <span class="math inline">\((nil,x,nil)\)</span>. appelés des <strong>feuilles</strong>. Les nœuds qui ne sont pas des feuilles sont appelés des <strong>nœuds internes</strong>. Le nœud <span class="math inline">\(a\)</span> lui-même est appelé la racine de l’arbre. On note <span class="math inline">\(N(a)\)</span> les nœuds de <span class="math inline">\(a\)</span>.</p>
<p>Si <span class="math inline">\(n \in N(a)\)</span> n’est pas pas la racine, il est le fils gauche ou le fils droit d’un unique nœud appelé le <strong>père</strong> de <span class="math inline">\(x\)</span>.</p>
<p>Si <span class="math inline">\(n \in N(a)\)</span>, on appelle <strong>sous-arbre</strong> de <span class="math inline">\(a\)</span> l’arbre dont <span class="math inline">\(n\)</span> est la racine. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>En partant de la définition inductive, il y a une identification entre un sous-arbre et sa racine. Mais afin de raisonner, on distinguera un nœud en tant qu’emplacement au sein d’un arbre et le sous-arbre lui-même.</div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(a\)</span> un arbre binaire.</p>
<ul>
<li>On appelle <strong>taille</strong> de <span class="math inline">\(a\)</span>, et on note <span class="math inline">\(|a|\)</span> le nombre de nœuds de <span class="math inline">\(a\)</span>.</li>
<li>On appelle <strong>hauteur</strong> de <span class="math inline">\(a\)</span> l’entier <span class="math display">\[
h(a) = \begin{cases} -1 &amp; \text{ si } a = \text{nil} \\
1 + \max(h(g), h(d)) &amp; \text{ si } a = (g,x,d) \end{cases}
\]</span></li>
</ul>
<p></div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(a\)</span> un arbre binaire et <span class="math inline">\(n \in N(a)\)</span>. On appelle <strong>profondeur</strong> de <span class="math inline">\(n\)</span> l’unique entier <span class="math inline">\(p(a)\)</span> tel qu’il existe une suite finie <span class="math inline">\((n_0, n_1, \dots, n_{p(a)})\)</span> de <span class="math inline">\(n\)</span> vérifiant :</p>
<ul>
<li><span class="math inline">\(n_0\)</span> est la racine de <span class="math inline">\(a\)</span></li>
<li><span class="math inline">\(n_{p(a)} = n\)</span></li>
<li>pour tout <span class="math inline">\(i\)</span>, <span class="math inline">\(n_i\)</span> est le père de <span class="math inline">\(n_{i+1}\)</span></li>
</ul>
<p>Cette suite finie est le <strong>chemin</strong> de la racine à <span class="math inline">\(n\)</span>. Il est nécessairement unique car chaque nœud autre que la racine a un unique père. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(a\)</span> un arbre, si <span class="math inline">\(a\)</span> est non vide, alors <span class="math inline">\(h(a) = \max_{n \in N(a)} p(n)\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> Par induction structurelle sur <span class="math inline">\(a\)</span>.</p>
<ul>
<li><strong>Initialisation</strong> Si <span class="math inline">\(a = \text{nil}\)</span> la prémisse est fausse, donc l’implication est trivialement vérifiée.</li>
<li><strong>Hérédité</strong> Supposons la propriété vérifiée pour deux arbres <span class="math inline">\(g\)</span> et <span class="math inline">\(d\)</span>, soit <span class="math inline">\(x \in \mathcal{E}\)</span>, on va montrer qu’elle est vérifiée pour <span class="math inline">\(a = (g,x,d)\)</span>. On a quatre cas pour le couple <span class="math inline">\((g,d)\)</span> :
<ul>
<li>Soit <span class="math inline">\(g \neq \text{nil}\)</span> et <span class="math inline">\(d \neq \text{nil}\)</span>. Dans ce cas, par hypothèse <span class="math inline">\(h(g) = \max_{n \in N(g)} p_g(n)\)</span> où <span class="math inline">\(p_g\)</span> est la profondeur de <span class="math inline">\(n\)</span> en tant que nœud de l’arbre <span class="math inline">\(g\)</span>. Or, mis à part la racine de <span class="math inline">\(a\)</span>, le chemin menant dans <span class="math inline">\(a\)</span> au nœud <span class="math inline">\(n\)</span> est dans <span class="math inline">\(g\)</span>. On a donc directement <span class="math inline">\(p_g(n) = p(n) - 1\)</span>. Ainsi <span class="math inline">\(h(g) = \max_{n \in N(g)} p(n) - 1\)</span>. De même, <span class="math inline">\(h(d) = max_{n \in N(d)} p(n) - 1\)</span>. On a <span class="math display">\[h(a) = 1 + \max(h(g),h(d)) = \max(\max_{n\in N(g)} p(n), \max_{n \in
\N(d)} p(n))\]</span> Or, le seul nœud de <span class="math inline">\(a\)</span> qui n’est ni dans <span class="math inline">\(g\)</span> ni dans <span class="math inline">\(d\)</span> est sa racine, qui est de profondeur nulle donc <span class="math inline">\(h(a) = \max_{n \in N(a)} p(n)\)</span>.</li>
<li>Soit <span class="math inline">\(g = \text{nil}\)</span> et <span class="math inline">\(d \neq \text{nil}\)</span>. Ainsi <span class="math inline">\(h(g) = -1\)</span> et donc <span class="math inline">\(h(a) = 1 + h(d) = \max_{n \in N(d)} p(n)\)</span> par l’analyse précédente. On conclut donc avec la propriété voulue.</li>
<li>Soit <span class="math inline">\(g \neq \text{nil}\)</span> et <span class="math inline">\(d = \text{nil}\)</span>. Cas symétrique du précédent.</li>
<li>Soit <span class="math inline">\(g = d = \text{nil}\)</span>. Auquel cas, <span class="math inline">\(h(a) = 0\)</span> qui est bien la profondeur de son unique nœud.</li>
</ul></li>
</ul>
<p>On a bien montré la propriété voulue par induction structurelle. </div> </div></p>
<h2 data-number="1.3" id="sec:implémentations"><span class="header-section-number">1.3</span> Implémentations</h2>
<h3 data-number="1.3.1" id="sec:en-ocaml"><span class="header-section-number">1.3.1</span> En <code>OCaml</code></h3>
<p>En <code>OCaml</code>, on traduit directement la définition inductive par un type récursif :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> &#39;a arbre = Noeud <span class="kw">of</span> &#39;a arbre * &#39;a * &#39;a arbre | Nil</span></code></pre></div>
<p></div></p>
<p>On pourra alors définir des fonctions récursives sur les arbres par induction structurelle à l’aide d’un filtrage.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">let</span> <span class="kw">rec</span> taille a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>    | Nil -&gt; <span class="dv">0</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    | Noeud(g,x,d) -&gt; <span class="dv">1</span> + taille g + taille d</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">let</span> <span class="kw">rec</span> hauteur a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    | Nil -&gt; <span class="dv">-1</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    | Noeud(g, x, d) -&gt; <span class="dv">1</span> + <span class="dt">max</span> (hauteur g) (hauteur d)</span></code></pre></div>
<p></div></p>
<h3 data-number="1.3.2" id="sec:en-c"><span class="header-section-number">1.3.2</span> En <code>C</code></h3>
<h2 data-number="1.4" id="sec:arbres-binaires-stricts"><span class="header-section-number">1.4</span> Arbres binaires stricts</h2>
<p><div class="ui message"><div class="header">Définition</div> Un arbre binaire est dit <strong>strict</strong> lorsqu’aucun de ses nœuds n’a qu’un fils vide. </div></p>
<p>Cela revient à dire que les seules les feuilles ont des fils vides. On peut donc omettre l’arbre vide et ne garder que les feuilles à la place.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>L’arbre de gauche ici est un arbre binaire strict alors que ce n’est pas le cas de l’arbre de droite :</p>
<p><center><div class="ui image center"><img src="assets/pics/arbrestricts.png" /></div></center></p>
<p></div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(a\)</span> un arbre binaire strict non vide. Si <span class="math inline">\(a\)</span> a <span class="math inline">\(n\)</span> nœuds internes, alors il a <span class="math inline">\(n+1\)</span> feuilles.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> Par induction structurelle :</p>
<ul>
<li><strong>Initialisation</strong> Si <span class="math inline">\(a\)</span> a <span class="math inline">\(0\)</span> nœud interne, c’est une feuille et on a directement la relation.</li>
<li><strong>Hérédité</strong> Supposons que la propriété soit vraie pour des arbres <span class="math inline">\(g\)</span> et <span class="math inline">\(d\)</span>, et soit <span class="math inline">\(a = (g,x,d)\)</span> un arbre dont ce sont les fils. On note <span class="math inline">\(n_i(t)\)</span> le nombre de nœuds internes et <span class="math inline">\(n_f(t)\)</span> le nombre de feuilles de l’arbre <span class="math inline">\(t\)</span>. On a <span class="math inline">\(n_i(a) = 1 + n_i(g) + n_i(d)\)</span> et <span class="math inline">\(n_f(a) = n_f(g) + n_f(d) = 2 + n_i(g) + n_i(d) = 1 + n_i(a)\)</span>. La propriété est démontrée pour <span class="math inline">\(a\)</span>. </div> </div></li>
</ul>
<p>Cela permet naturellement de considérer des arbres où les feuilles et les nœuds internes ont deux types différents d’étiquettes.</p>
<p>L’exemple classique d’un tel arbre est celui des expressions arithmétiques :</p>
<ul>
<li>les nœuds internes sont étiquetés par des opérateurs binaires</li>
<li>les feuilles sont étiquetées par des nombres.</li>
</ul>
<p>En <code>OCaml</code>, on peut ainsi représenter un tel arbre par le type récursif :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">type</span> (&#39;a, &#39;b) arbre_bin = Feuille <span class="kw">of</span> &#39;a </span>
<span id="cb3-2"><a href="#cb3-2"></a>    | Noeud <span class="kw">of</span> (&#39;a, &#39;b) arbre_bin * &#39;b * (&#39;a, &#39;b) arbre_bin</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>On ne peut plus représenter l’arbre vide avec ce type.</div></p>
<p>Et pour les expressions, on pourra ainsi définir un type pour les opérateurs et écrire :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">type</span> operator = Plus | Times | Minus | Divides</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">let</span> e = Noeud(Feuille <span class="dv">2</span>, Plus, Noeud(Feuille <span class="dv">3</span>, Mult, Feuille <span class="dv">4</span>))</span></code></pre></div>
<p></div></p>
<p>L’évaluation de telles expressions est étudiée dans le TP si dessous.</p>
<h2 data-number="1.5" id="sec:arbres-binaires-complets"><span class="header-section-number">1.5</span> Arbres binaires complets</h2>
<p><div class="ui message"><div class="header">Définition</div> Un arbre binaire dont tous les niveaux sont plein sauf éventuellement le dernier est dit <strong>complet</strong>. Si son dernier niveau est également plein, on dit qu’il est <strong>parfait</strong>. </div></p>
<p>On peut représenter un arbre complet dans un tableau niveau par niveau en partant de la racine.</p>
<p>Si on place les indices comme étiquettes on aura, par exemple :</p>
<p><center><div class="ui image center"><img src="assets/pics/arbrecomplet.png" /></div></center></p>
<p>Et on pourra donc le représenter par le tableau des étiquettes dans cet ordre d’énumération.</p>
<p>On remarque que :</p>
<ul>
<li>le nœud <span class="math inline">\(0\)</span> est toujours la racine</li>
<li>si on considère un nœud <span class="math inline">\(i\)</span>, son fils gauche est le nœud <span class="math inline">\(2 i + 1\)</span> et son fils droit est le nœud <span class="math inline">\(2 i + 2\)</span>.</li>
<li>le fils gauche de <span class="math inline">\(i+1\)</span> est <span class="math inline">\(2 (i+1) + 1 = 2i + 3 &gt; 2 i + 2\)</span>. On est bien directement après.</li>
<li>le <span class="math inline">\(k\)</span>ème nœud du niveau <span class="math inline">\(l\)</span>, en commençant à numéroter à <span class="math inline">\(0\)</span>, a pour indices <span class="math inline">\(\sum_{j=0}^{l-1} 2^j + k = 2^l - 1 + k\)</span>.</li>
<li>si <span class="math inline">\(i &gt; 0\)</span>, son père est le nœud <span class="math inline">\(\left\lfloor \frac{i-1}{2} \right\rfloor\)</span>.</li>
</ul>
<p>On peut donc, avec cette représentation, manipuler assez simplement un arbre binaire <strong>à plat </strong>.</p>
<h1 data-number="2" id="sec:arbres"><span class="header-section-number">2</span> Arbres</h1>
<h2 data-number="2.1" id="sec:définition"><span class="header-section-number">2.1</span> Définition</h2>
<p>On étend directement la définition inductive des arbres binaires au cas où les nœuds plus d’éléments.</p>
<p><div class="ui message"><div class="header">Définition</div> Un arbre étiqueté par <span class="math inline">\(\mathcal{E}\)</span> est un couple <span class="math inline">\((x,f)\)</span> où <span class="math inline">\(x \in \mathcal{E}\)</span> et <span class="math inline">\(f\)</span> une suite <strong>finie</strong> d’arbres. </div></p>
<p>On étend naturellement le vocabulaire des arbres binaires :</p>
<ul>
<li>le nœud de tête d’un arbre, en fin de compte sa <em>valeur</em>, est appelé sa racine</li>
<li>les éléments de <span class="math inline">\(f\)</span> sont appelés les fils du nœuds</li>
<li>si <span class="math inline">\(f\)</span> est vide, on dit que le nœud est une <strong>feuille</strong>, sinon, on dit que c’est un nœud interne.</li>
<li><span class="math inline">\(|f|\)</span>, le nombre d’éléments de <span class="math inline">\(f\)</span>, est appelé l’<strong>arité</strong> du nœud. Les feuilles sont donc les nœuds zéroaire.</li>
<li>une suite finie d’arbres, ou plus généralement un ensemble d’arbres, est appelé une <strong>fôret</strong>.</li>
</ul>
<p>Si on note <span class="math inline">\(T(\mathcal{E})\)</span> l’ensemble des arbres étiquetés par <span class="math inline">\(\mathcal{E}\)</span>, on a <span class="math display">\[
\forall x \in \mathcal{E}, \forall n \in \N, \forall a_1, \dots, a_n 
\in T(\mathcal{E}),
(x, (a_1, \dots, a_n)) \in T(\mathcal{E})
\]</span></p>
<p><strong>Attention</strong> contrairement à ce que peut laisser entendre la formule précédente, il est tout à fait possible que <span class="math inline">\(n = 0\)</span> ce qui correspond à la suite finie vide et donc à une feuille. On perd ici la possibilité de représenter un arbre vide.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Un arbre binaire est un arbre dont les nœuds sont soit unaires soit binaires. On remarque en disant cela qu’on perd une information : la position gauche ou droite de l’unique fils d’un nœud unaire.</p>
<p>Comme pour les arbres binaires stricts, on pourra être amenés à considérer des arbres dont les nœuds internes et les feuilles sont étiquettés par des arbres</div></p>
<h2 data-number="2.2" id="sec:implémentation"><span class="header-section-number">2.2</span> Implémentation</h2>
<p>L’implémentation d’un arbre repose sur l’implémentation d’une suite finie. Celle-ci peut être faite par un tableau ou par une liste chaînée.</p>
<p>On retrouve alors des implementations différentes des arbres mais qui sont, au fond, très proches.</p>
<p>En <code>OCaml</code>, on pourra alors avoir les deux implémentations suivantes :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">type</span> &#39;a arbre_l = { etiquette : &#39;a; enfants : &#39;a arbre_l <span class="dt">list</span> }</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">type</span> &#39;a arbre_a = { etiquette : &#39;a; enfants : &#39;a arbre_a <span class="dt">array</span> }</span></code></pre></div>
<p></div></p>
<p>On va alors avoir des programmes à la présentation assez différente suivant le type choisi. Voici, par exemple, les deux implémentations du calcul de la taille d’un arbre.</p>
<p>Avec des listes et aucune fonction du module <code>List</code>, on écrit souvent une fonction récursive sur les arbres et une fonction récursive sur les forêts.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">let</span> <span class="kw">rec</span> taille_arbre a =</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="dv">1</span> + taille_foret a.enfants</span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="kw">and</span> taille_foret l = <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>        | [] -&gt; <span class="dv">0</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>        | t::q -&gt; taille_arbre t + taille_foret q</span></code></pre></div>
<p></div></p>
<p>On peut aussi utiliser directement <code>fold_left</code> et <code>map</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">let</span> <span class="kw">rec</span> taille_arbre a = </span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="dv">1</span> + <span class="dt">List</span>.fold_left (+) <span class="dv">0</span> (<span class="dt">List</span>.map taille_arbre a.enfants)</span></code></pre></div>
<p></div></p>
<p>Avec l’autre représentation, on procédera avec un mélange de fonction récursive et de boucles. Cela n’est pas sans rappeler ce qui a été fait pour le backtracking.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">let</span> <span class="kw">rec</span> taille_arbre a =</span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="kw">let</span> t = <span class="dt">ref</span> <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> <span class="dt">Array</span>.length a.enfants - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>        t := !t + taille_arbre a.enfants.(i)</span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="kw">done</span>;</span>
<span id="cb8-6"><a href="#cb8-6"></a>    !t</span></code></pre></div>
<p></div></p>
<h2 data-number="2.3" id="sec:représentation-par-un-arbre-binaire"><span class="header-section-number">2.3</span> Représentation par un arbre binaire</h2>
<p>Pour des raisons d’efficacité ou de réutilisation de programmes existants, on peut vouloir représenter un arbre comme un arbre binaire.</p>
<p>On va définir une application : <span class="math inline">\(\text{bin} : T(\mathcal{E}) \rightarrow T_b(\mathcal{E} \cup \{ \star \})\)</span> ainsi : <span class="math inline">\(\text{bin}(x, ()) = (\text{nil},x,\text{nil})\)</span>, <span class="math inline">\(\text{bin}(x, (a)) = (\text{bin}(a),x,\text{nil})\)</span> et pour un nœud d’arité strictement plus grande que 1 : <center><div class="ui image center"><img src="assets/pics/tobin.png" /></div></center></p>
<p>où <span class="math inline">\(a&#39;_i = \text{bin}(a_i)\)</span>. Les nœuds rouges sont des nœuds ayant une étiquette spéciale <span class="math inline">\(\star\)</span> telle que <span class="math inline">\(\star \not \in \mathcal{E}\)</span>.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>L’arbre suivant :</p>
<p><center><div class="ui image center"><img src="assets/pics/exampleconv1.png" /></div></center></p>
<p>sera alors représenté par l’arbre binaire :</p>
<p><center><div class="ui image center"><img src="assets/pics/exampleconv2.png" /></div></center></p>
</div>
<h2 data-number="2.4" id="sec:applications"><span class="header-section-number">2.4</span> Applications</h2>
<h3 data-number="2.4.1" id="sec:arbres-dexpressions"><span class="header-section-number">2.4.1</span> Arbres d’expressions</h3>
<p>On a déjà vu l’utilisation des arbres binaires pour représenter des expressions arithmétiques avec des opérateurs unaires ou binaires. On généralise naturellement cela à des expressions dont les opérateurs sont d’arité quelconque.</p>
<p>C’est ainsi qu’on représente un programme en mémoire, on parle d’arbre syntaxique.</p>
<h3 data-number="2.4.2" id="sec:arbres-préfixes-ou-tries"><span class="header-section-number">2.4.2</span> Arbres préfixes ou tries</h3>
<p>Un <em>arbre préfixe</em> ou <em>trie</em> est un arbre permettant de représenter un ensemble de mots. On étiquette les arêtes par des caractères et les nœuds par un booléen indiquant si la suite des étiquettes qui mène de la racine à ce nœud est un mot.</p>
<p>Par exemple, le trie :</p>
<p><center><div class="ui image center"><img src="assets/pics/trie1.png" /></div></center></p>
<p>permet de représenter l’ensemble de mots : bar, barbe, art, ami, abri, abricot, abonne.</p>
<p>Afin de représenter un tel arbre, il est nécessaire d’avoir une étiquette sur les arêtes, le plus simple pour cela est de remplacer la liste des enfants par une liste de couples (étiquette, enfant) ainsi :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">type</span> trie = {</span>
<span id="cb9-2"><a href="#cb9-2"></a>    mot : <span class="dt">bool</span>;</span>
<span id="cb9-3"><a href="#cb9-3"></a>    enfants : (<span class="dt">char</span> * trie) <span class="dt">list</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>    }</span></code></pre></div>
<p></div></p>
<p>Les fonctions de manipulations de ce type de donnée sont étudiées dans le TP <strong>TODO</strong>.</p>
<h1 data-number="3" id="sec:parcours"><span class="header-section-number">3</span> Parcours</h1>
<h2 data-number="3.1" id="sec:parcours-récursif-dun-arbre-binaire"><span class="header-section-number">3.1</span> Parcours récursif d’un arbre binaire</h2>
<p>On a déjà vu dans les paragraphes précédent ce qui constitue le cœur du parcours d’un arbre :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">let</span> <span class="kw">rec</span> parcours a = </span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>    | Nil -&gt; ()</span>
<span id="cb10-4"><a href="#cb10-4"></a>    | Noeud(g, x, d) -&gt; </span>
<span id="cb10-5"><a href="#cb10-5"></a>        parcours g;</span>
<span id="cb10-6"><a href="#cb10-6"></a>        parcours d</span></code></pre></div>
<p></div></p>
<p>Cette fonction ne fait rien, mais elle va parcourir chacun des nœuds de l’arbre. Si on veut effectuer un traitement sur le nœud, on peut le faire à trois moments :</p>
<p><center><div class="ui image center"><img src="assets/pics/parcourstraitements.png" /></div></center></p>
<ul>
<li>Avant l’appel à <code>parcours g</code>, on parle de <em>traitement préfixe</em></li>
<li>Entre les deux appels, on parle de <em>traitement infixe</em></li>
<li>Avant l’appel à <code>parcours g</code>, on parle de <em>traitement préfixe</em></li>
</ul>
<p>On représente ici l’ordre dans lequel on va effectuer chacun de ces trois traitements selon le code couleur : rouge pour préfixe, bleu pour infixe et vert pour postfixe. On a également indiqué, pour les premiers traitements, l’ordre dans lequel ils sont effectués par des numéros.</p>
<p><center><div class="ui image center"><img src="assets/pics/parcoursrec.png" /></div></center></p>
<p>Pour illustrer ces traitements, on peut rajouter trois arguments au parcours :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">let</span> <span class="kw">rec</span> parcours prefixe infixe postfixe a =</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    | Nil -&gt; ()</span>
<span id="cb11-4"><a href="#cb11-4"></a>    | Noeud(g, x, d) -&gt;</span>
<span id="cb11-5"><a href="#cb11-5"></a>        prefixe a;</span>
<span id="cb11-6"><a href="#cb11-6"></a>        parcours g;</span>
<span id="cb11-7"><a href="#cb11-7"></a>        infixe a;</span>
<span id="cb11-8"><a href="#cb11-8"></a>        parcours d;</span>
<span id="cb11-9"><a href="#cb11-9"></a>        postfixe a</span></code></pre></div>
<p></div></p>
<p>On peut, par exemple, définir les deux fonctions suivante :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">let</span> idle a = () <span class="co">(* ne fait rien *)</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="kw">let</span> print a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    | Nil -&gt; <span class="dt">failwith</span> <span class="st">&quot;Vide&quot;</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>    | Noeud(_,x,_) -&gt; <span class="dt">print_char</span> a </span></code></pre></div>
<p></div></p>
<p>On peut alors observer les nœuds affichés sur l’arbre précédent selon les traitements effectués :</p>
<ul>
<li><code>parcours print idle idle a</code> : <strong>abdejkvwcfg</strong> on suit uniquement les arêtes rouges</li>
<li><code>parcours idle print idle a</code> : <em>dbejvkwafcg</em> on suit uniquement les arêtes bleues</li>
<li><code>parcours idle idle print a</code> : djvwkebfgca on suit uniquement les arêtes vertes</li>
<li><code>parcours print print print a</code> : <strong>abd</strong><em>d</em>d<em>b</em><strong>ej</strong><em>j</em>j<em>e</em><strong>kv</strong><em>v</em>v<em>k</em><strong>w</strong><em>w</em>wkeb… on suit toutes les arêtes</li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div>Si on considère un arbre d’expression comme :</p>
<p><center><div class="ui image center"><img src="assets/pics/arbreexpr.png" /></div></center></p>
<p>On va alors obtenir en affichant à chaque traitement la suite : <span class="math inline">\(+222+\times333\times444\times +\)</span>. Chaque nombre <span class="math inline">\(n\)</span> étant une feuille, on va observer l’affichage de <span class="math inline">\(nnn\)</span> qu’on peut réduire à <span class="math inline">\(n\)</span>. Pour les opérateurs, si on remplace le premier affichage par <span class="math inline">\((\)</span> et le dernier par <span class="math inline">\()\)</span>. En procédant ainsi, on affiche <span class="math inline">\((2+(3\times 4))\)</span> et on ainsi retrouvé l’écriture bien parenthésée de l’expression.</div></p>
<p><div class="ui message"><div class="header">Définition</div> L’ordre dans lequel on effectue un traitement <em>préfixe</em> dans un parcours sur les nœuds d’un arbre est appelé l’ordre <em>préfixe</em> sur les nœuds.</p>
<p>On définit, de même, l’ordre <em>infixe</em> et l’ordre <em>postfixe</em>. </div></p>
<h2 data-number="3.2" id="sec:parcours-impératifs"><span class="header-section-number">3.2</span> Parcours impératifs</h2>
<h3 data-number="3.2.1" id="sec:cadre-général"><span class="header-section-number">3.2.1</span> Cadre général</h3>
<p>On va condisérer une structure de donnée abstraite qui généralise les piles et les files et permettre de représenter un ensemble de tâches à traiter. Pour cela, on dispose d’un type paramétrique <code>'a t</code> et de l’interface :</p>
<ul>
<li><code>cree : unit -&gt; 'a t</code> crée un ensemble de tâches</li>
<li><code>ajoute : 'a t -&gt; 'a -&gt; unit</code> ajoute une nouvelle tâche à traiter</li>
<li><code>retire : 'a t -&gt; 'a</code> retire une tâche de l’ensemble des tâches à traiter</li>
<li><code>est_vide : 'a t -&gt; bool</code> renvoie un booléen indiquant si l’ensemble de tâches est vide</li>
</ul>
<p>On a ainsi vu deux possibles implémentations, qui sont elles-mêmes des structures abstraites mais un peu moins abstraites que celle-ci :</p>
<ul>
<li>les piles pour lesquelles on retire le dernier élément ajouté</li>
<li>les files pour lesquelles on retire l’élément le plus anciennement ajouté</li>
</ul>
<p>On écrire un parcours impératif générique :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">let</span> parcours traitement a = </span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="kw">let</span> avisiter = cree () <span class="kw">in</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>    ajoute avisiter a;</span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="kw">while</span> <span class="dt">not</span> (est_vide avisiter) <span class="kw">do</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>        <span class="kw">let</span> a = retire avisiter <span class="kw">in</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>        <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>        | Nil -&gt; ()</span>
<span id="cb13-8"><a href="#cb13-8"></a>        | Noeud(g, _, d) -&gt; traitement a;</span>
<span id="cb13-9"><a href="#cb13-9"></a>                            ajoute avisiter g;</span>
<span id="cb13-10"><a href="#cb13-10"></a>                            ajoute avisiter d</span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="kw">done</span></span></code></pre></div>
<p></div></p>
<h3 data-number="3.2.2" id="sec:cas-du-parcours-en-profondeur"><span class="header-section-number">3.2.2</span> Cas du parcours en profondeur</h3>
<p>Dans le cas où on utilise une pile, on retrouve essentiellement le parcours récursif précédent avec quelques changements :</p>
<ul>
<li>on empile ici d’abord <code>g</code> puis <code>d</code>, donc on va à droite avant d’aller à gauche. Il suffit de permuter les deux ajouts pour retrouver l’ordre précédent</li>
<li>on effectue un unique traitement préfixe</li>
<li>si on considère la pile d’appels récursifs du parcours récursif, on constate que le nombre de structure pile est majoré par la hauteur de l’arbre. Ici, on va potentiellement ajouter tous les nœuds sur la pile, donc, on a une complexité en espace en <span class="math inline">\(O(|a|)\)</span> plutôt qu’en <span class="math inline">\(O(h(a))\)</span>.</li>
</ul>
<p>On parle de <strong>parcours en profondeur</strong> ou depth-first search (DFS) en anglais.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on considère l’arbre suivant :</p>
<p><center><div class="ui image center"><img src="assets/pics/exparcours.png" /></div></center></p>
<p>En ignorant les arbres vides, par exemple en ne les ajoutant pas, on va avoir le déroulement suivant du parcours :</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">avisiter</th>
<th style="text-align: center;">etiquette traitée</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(1 \rightarrow\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(2, 3 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(2, 5, 6 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(2, 5 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(6\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(2, 7 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(5\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(2 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(7\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(4 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(4\)</span></td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="3.2.3" id="sec:cas-du-parcours-en-largeur"><span class="header-section-number">3.2.3</span> Cas du parcours en largeur</h3>
<p>Dans le cas où on utilise une file, on obtient un parcours appelé le <strong>parcours en largeur</strong> en breadth-first search (BFS) en anglais.</p>
<p>Dans ce parcours, on va visiter les nœuds <em>niveau par niveau</em> en partant de la racine jusqu’aux feuilles de plus grande profondeur.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on considère l’arbre suivant :</p>
<p><center><div class="ui image center"><img src="assets/pics/exparcours.png" /></div></center></p>
<p>En ignorant les arbres vides, par exemple en ne les ajoutant pas, on va avoir le déroulement suivant du parcours :</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">avisiter</th>
<th style="text-align: center;">etiquette traitée</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 1 \rightarrow\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 3, 2 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 4, 3 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 6, 5, 4 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 6, 5 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(4\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 7, 6 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(5\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\rightarrow 7 \rightarrow\)</span></td>
<td style="text-align: center;"><span class="math inline">\(6\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(7\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Ce parcours est particulièrement intéressant quand on cherche une information avec la plus petite profondeur possible. Par exemple, dans le cas de la recherche d’une solution à un problème, on peut vouloir tester les petites solutions avant les plus grandes.</p>
<p>Pour des problèmes d’énumération, c’est également intéressant, car on va obtenir des éléments par ordre croissant de la longueur du chemin depuis la racine. Par exemple, pour les tries, on en déduit les mots par ordre croissant de longueur.</p>
<h2 data-number="3.3" id="sec:parcours-darbres"><span class="header-section-number">3.3</span> Parcours d’arbres</h2>
<p>Pour des arbres, on va suivre les mêmes principes. La différence va se situer au niveau de l’implémentation car il faudra alors manipuler des listes ou des tableaux d’enfants.</p>
<p>Notons qu’on a déjà vu un tel problème quand on a résolu des problèmes par backtracking. En effet, avec le backtracking, on a un arbre implicite des positions partielles dont les enfants sont les mouvements possibles vers de nouvelles positions.</p>
<h1 data-number="4" id="sec:arbres-binaires-de-recherche"><span class="header-section-number">4</span> Arbres binaires de recherche</h1>
<h2 data-number="4.1" id="sec:objectif"><span class="header-section-number">4.1</span> Objectif</h2>
<h2 data-number="4.2" id="sec:définition-1"><span class="header-section-number">4.2</span> Définition</h2>
<h2 data-number="4.3" id="sec:opérations"><span class="header-section-number">4.3</span> Opérations</h2>
<h2 data-number="4.4" id="sec:équilibrage"><span class="header-section-number">4.4</span> Équilibrage</h2>
<h3 data-number="4.4.1" id="sec:arbres-2-3"><span class="header-section-number">4.4.1</span> Arbres 2-3</h3>
<h3 data-number="4.4.2" id="sec:arbres-rouges-et-noirs"><span class="header-section-number">4.4.2</span> Arbres rouges et noirs</h3>
<h2 data-number="4.5" id="sec:implémentation-dun-dictionnaire"><span class="header-section-number">4.5</span> Implémentation d’un dictionnaire</h2>
<h1 data-number="5" id="sec:tas"><span class="header-section-number">5</span> Tas</h1>
<h2 data-number="5.1" id="sec:présentation"><span class="header-section-number">5.1</span> Présentation</h2>
<h2 data-number="5.2" id="sec:implémentation-1"><span class="header-section-number">5.2</span> Implémentation</h2>
<h2 data-number="5.3" id="sec:application-aux-files-de-priorité"><span class="header-section-number">5.3</span> Application aux files de priorité</h2>
<h1 data-number="6" id="sec:tp---arbres-en-ocaml"><span class="header-section-number">6</span> TP - Arbres en <code>OCaml</code></h1>
<h2 data-number="6.1" id="sec:premières-fonctions"><span class="header-section-number">6.1</span> Premières fonctions</h2>
<p>On va considérer le type des arbres binaires <code>'a arbre</code> défini par :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">type</span> &#39;a arbre = Nil | Noeud <span class="kw">of</span> &#39;a arbre * &#39;a * &#39;a arbre</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1"></a><span class="co">(* Calcule le nombre de noeuds de a *)</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="kw">let</span> taille (a : &#39;a arbre) : <span class="dt">int</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="co">(* Calcule la hauteur de a *)</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="kw">let</span> hauteur (a : &#39;a arbre) : <span class="dt">int</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="co">(* Indique si a est réduit à une feuille *)</span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="kw">let</span> feuille (a : &#39;a arbre) : <span class="dt">bool</span></span></code></pre></div>
<p></div></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">let</span> <span class="kw">rec</span> taille a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>    | Nil -&gt; <span class="dv">0</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>    | Noeud(g,x,d) -&gt; <span class="dv">1</span> + taille g + taille d</span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="kw">let</span> <span class="kw">rec</span> hauteur a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>    | Nil -&gt; <span class="dv">-1</span></span>
<span id="cb16-7"><a href="#cb16-7"></a>    | Noeud(g,x,d) -&gt;</span>
<span id="cb16-8"><a href="#cb16-8"></a>            <span class="dv">1</span> + <span class="dt">max</span> (hauteur g) (hauteur d)</span>
<span id="cb16-9"><a href="#cb16-9"></a></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="kw">let</span> feuille a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb16-11"><a href="#cb16-11"></a>    | Nil -&gt; <span class="kw">false</span></span>
<span id="cb16-12"><a href="#cb16-12"></a>    | Noeud(g, x, d) -&gt; g = Nil &amp;&amp; d = Nil</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>sous_arbres</code> qui renvoie la liste des sous-arbres non vides d’un arbre.</p>
<p>En déduire des fonctions <code>noeuds</code>, <code>feuilles</code> et <code>noeuds_internes</code> qui renvoient la liste des étiquettes des <code>noeuds</code> correspondants.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">let</span> <span class="kw">rec</span> sous_arbres a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>    | Nil -&gt; []</span>
<span id="cb17-3"><a href="#cb17-3"></a>    | Noeud(g, x, d) -&gt;</span>
<span id="cb17-4"><a href="#cb17-4"></a>       a :: (sous_arbres g @ sous_arbres d)</span>
<span id="cb17-5"><a href="#cb17-5"></a></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="kw">let</span> <span class="kw">rec</span> noeuds a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>    | Nil -&gt; []</span>
<span id="cb17-8"><a href="#cb17-8"></a>    | Noeud(g, x, d) -&gt;</span>
<span id="cb17-9"><a href="#cb17-9"></a>        x :: (noeuds g @ noeuds d)</span>
<span id="cb17-10"><a href="#cb17-10"></a></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="kw">let</span> <span class="kw">rec</span> feuilles a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>    | Nil -&gt; []</span>
<span id="cb17-13"><a href="#cb17-13"></a>    | Noeud(g, x, d) -&gt;</span>
<span id="cb17-14"><a href="#cb17-14"></a>        <span class="kw">if</span> feuille a <span class="kw">then</span> [x]</span>
<span id="cb17-15"><a href="#cb17-15"></a>        <span class="kw">else</span> feuilles g @ feuilles d</span>
<span id="cb17-16"><a href="#cb17-16"></a></span>
<span id="cb17-17"><a href="#cb17-17"></a><span class="kw">let</span> <span class="kw">rec</span> noeuds_internes a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb17-18"><a href="#cb17-18"></a>    | Nil -&gt; []</span>
<span id="cb17-19"><a href="#cb17-19"></a>    | Noeud(Nil, _, Nil) -&gt; []</span>
<span id="cb17-20"><a href="#cb17-20"></a>    | Noeud(g, x, d) -&gt;</span>
<span id="cb17-21"><a href="#cb17-21"></a>        x :: (noeuds_internes g @ noeuds_internes d)</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>Pour accéder à un nœud de l’arbre, on descend en partant de la racine et en allant à gauche ou à droite. On peut donc représenter un tel chemin par une liste de déplacements :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">type</span> deplacement = Gauche | Droite</span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="kw">type</span> chemin = deplacement <span class="dt">list</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>chemin_noeud : 'a arbre -&gt; chemin -&gt; 'a option</code> qui renvoie l’étiquette d’un nœud donné par son chemin. On utilise un type <code>option</code> en cas de chemin invalide.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">type</span> deplacement = Gauche | Droite</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="kw">type</span> chemin = deplacement <span class="dt">list</span></span>
<span id="cb19-3"><a href="#cb19-3"></a></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="kw">let</span> <span class="kw">rec</span> chemin_noeud a l =</span>
<span id="cb19-5"><a href="#cb19-5"></a>    <span class="kw">match</span> a, l <span class="kw">with</span></span>
<span id="cb19-6"><a href="#cb19-6"></a>    | Nil, _ -&gt; <span class="dt">None</span></span>
<span id="cb19-7"><a href="#cb19-7"></a>    | Noeud(g,x,d), Gauche::q -&gt; chemin_noeud g q</span>
<span id="cb19-8"><a href="#cb19-8"></a>    | Noeud(g,x,d), Droite::q -&gt; chemin_noeud d q</span>
<span id="cb19-9"><a href="#cb19-9"></a>    | Noeud(g,x,d), [] -&gt; <span class="dt">Some</span> x</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h2 data-number="6.2" id="sec:parcours-1"><span class="header-section-number">6.2</span> Parcours</h2>
<p>Sur le même modèle que l’exploration par <em>backtracking</em>, on va réaliser un parcours en profondeur d’un arbre en explorant à gauche puis à droite ses sous-arbres de manière récursives. Chaque nœud est donc vu trois fois :</p>
<ul>
<li>une première fois quand on le découvre avant d’explorer son sous-arbre gauche</li>
<li>entre les deux explorations</li>
<li>enfin quand on a fini d’explorer son sous-arbre droit.</li>
</ul>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions <code>affiche_avant</code>, <code>affiche_milieu</code> et <code>affiche_apres</code> qui parcourt et affiche les étiquettes d’un <code>string arbre</code> selon les trois cas précédents. <em>Note: il s’agit essentiellement du même code à une ligne près</em>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">let</span> <span class="kw">rec</span> affiche_avant a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>    | Nil -&gt; ()</span>
<span id="cb20-3"><a href="#cb20-3"></a>    | Noeud(g,x,d) -&gt;</span>
<span id="cb20-4"><a href="#cb20-4"></a>            <span class="dt">print_string</span> x;</span>
<span id="cb20-5"><a href="#cb20-5"></a>            affiche_avant g;</span>
<span id="cb20-6"><a href="#cb20-6"></a>            affiche_avant d</span>
<span id="cb20-7"><a href="#cb20-7"></a></span>
<span id="cb20-8"><a href="#cb20-8"></a></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="kw">let</span> <span class="kw">rec</span> affiche_milieu a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb20-10"><a href="#cb20-10"></a>    | Nil -&gt; ()</span>
<span id="cb20-11"><a href="#cb20-11"></a>    | Noeud(g,x,d) -&gt;</span>
<span id="cb20-12"><a href="#cb20-12"></a>            affiche_milieu g;</span>
<span id="cb20-13"><a href="#cb20-13"></a>            <span class="dt">print_string</span> x;</span>
<span id="cb20-14"><a href="#cb20-14"></a>            affiche_milieu d</span>
<span id="cb20-15"><a href="#cb20-15"></a></span>
<span id="cb20-16"><a href="#cb20-16"></a></span>
<span id="cb20-17"><a href="#cb20-17"></a><span class="kw">let</span> <span class="kw">rec</span> affiche_apres a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb20-18"><a href="#cb20-18"></a>    | Nil -&gt; ()</span>
<span id="cb20-19"><a href="#cb20-19"></a>    | Noeud(g,x,d) -&gt;</span>
<span id="cb20-20"><a href="#cb20-20"></a>            affiche_apres g;</span>
<span id="cb20-21"><a href="#cb20-21"></a>            affiche_apres d;</span>
<span id="cb20-22"><a href="#cb20-22"></a>            <span class="dt">print_string</span> x</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>On peut représenter une expression arithmétique comme <span class="math inline">\((2+3)\times 4\)</span> en tant qu’arbre avec des opérations pour les nœuds internes et des valeurs pour les feuilles. Quitte à utiliser des <code>string</code> dans les deux cas, qu’obtient-on sur une telle expression avec les trois opérations précédentes ?</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">let</span> <span class="kw">rec</span> evalue a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>    | Nil -&gt; <span class="dt">failwith</span> <span class="st">&quot;Vide&quot;</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>    | Noeud(Nil,x,Nil) -&gt; <span class="dt">int_of_string</span> x</span>
<span id="cb21-4"><a href="#cb21-4"></a>    | Noeud(g, x, d) -&gt;</span>
<span id="cb21-5"><a href="#cb21-5"></a>            <span class="kw">let</span> eg = evalue g <span class="kw">in</span></span>
<span id="cb21-6"><a href="#cb21-6"></a>            <span class="kw">let</span> ed = evalue d <span class="kw">in</span></span>
<span id="cb21-7"><a href="#cb21-7"></a>            <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>            | <span class="st">&quot;+&quot;</span> -&gt; eg + ed</span>
<span id="cb21-9"><a href="#cb21-9"></a>            | <span class="st">&quot;*&quot;</span> -&gt; eg * ed</span>
<span id="cb21-10"><a href="#cb21-10"></a>            | _ -&gt; <span class="dt">failwith</span> <span class="st">&quot;Ope inconnue&quot;</span></span></code></pre></div>
<p></div></p>
<p>L’appel à <code>affiche_avant</code> sur l’expression <span class="math inline">\((2+3)\times 4\)</span> va afficher <code>*+234</code>.</p>
<p>L’appel à <code>affiche_milieu</code> sur l’expression <span class="math inline">\((2+3)\times 4\)</span> va afficher <code>2+3*4</code>.</p>
<p>L’appel à <code>affiche_apres</code> sur l’expression <span class="math inline">\((2+3)\times 4\)</span> va afficher <code>23+4*</code>.</p>
<p>On retrouve ainsi les notions préfixes, infixes et postfixes d’une expression arithmétique. </div> </div></p>
<p>On redonne ici l’implémentation d’une pile et d’une file en <code>OCaml</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">let</span> pile_creer () = <span class="dt">ref</span> []</span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="kw">let</span> pile_empile p x = p := x :: !p</span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="kw">let</span> pile_depile p =</span>
<span id="cb22-4"><a href="#cb22-4"></a>    <span class="kw">match</span> !p <span class="kw">with</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>    | [] -&gt; <span class="dt">failwith</span> <span class="st">&quot;Pile vide&quot;</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>    | x::q -&gt; p := q; x</span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="kw">let</span> pile_est_vide p = !p = []</span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="kw">let</span> file_creer () = (pile_creer (), pile_creer ())</span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="kw">let</span> file_bascule (pin, pout) = pout := <span class="dt">List</span>.rev !pin; pin := []</span>
<span id="cb22-11"><a href="#cb22-11"></a><span class="kw">let</span> file_enfile (pin, pout) x = pile_empile pin x</span>
<span id="cb22-12"><a href="#cb22-12"></a><span class="kw">let</span> file_defile (pin, pout) =</span>
<span id="cb22-13"><a href="#cb22-13"></a>    <span class="kw">if</span> pile_est_vide pout </span>
<span id="cb22-14"><a href="#cb22-14"></a>    <span class="kw">then</span> file_bascule (pin, pout);</span>
<span id="cb22-15"><a href="#cb22-15"></a>    pile_depile pout</span>
<span id="cb22-16"><a href="#cb22-16"></a><span class="kw">let</span> file_est_vide (pin, pout) = pile_est_vide pin &amp;&amp; pile_est_vide pout</span></code></pre></div>
<p></div></p>
<p>Ces deux structures de données ont la même interface mais deux comportements différents. On va utiliser un unique type pour les représenter afin de permettre à une fonction d’utiliser soit une pile soit une file.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">type</span> (&#39;a, &#39;b) taches = {</span>
<span id="cb23-2"><a href="#cb23-2"></a>    creation : <span class="dt">unit</span> -&gt; &#39;a;</span>
<span id="cb23-3"><a href="#cb23-3"></a>    ajouter : &#39;a -&gt; &#39;b -&gt; <span class="dt">unit</span>;</span>
<span id="cb23-4"><a href="#cb23-4"></a>    retirer : &#39;a -&gt; &#39;b;</span>
<span id="cb23-5"><a href="#cb23-5"></a>    est_vide : &#39;a -&gt; <span class="dt">bool</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>}</span>
<span id="cb23-7"><a href="#cb23-7"></a></span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="kw">let</span> taches_pile = {</span>
<span id="cb23-9"><a href="#cb23-9"></a>    creation = pile_creer;</span>
<span id="cb23-10"><a href="#cb23-10"></a>    ajouter = pile_empile;</span>
<span id="cb23-11"><a href="#cb23-11"></a>    retirer = pile_depile;</span>
<span id="cb23-12"><a href="#cb23-12"></a>    est_vide = pile_est_vide</span>
<span id="cb23-13"><a href="#cb23-13"></a>    }</span>
<span id="cb23-14"><a href="#cb23-14"></a></span>
<span id="cb23-15"><a href="#cb23-15"></a><span class="kw">let</span> taches_file = {</span>
<span id="cb23-16"><a href="#cb23-16"></a>    creation = file_creer;</span>
<span id="cb23-17"><a href="#cb23-17"></a>    ajouter = file_enfile;</span>
<span id="cb23-18"><a href="#cb23-18"></a>    retirer = file_defile;</span>
<span id="cb23-19"><a href="#cb23-19"></a>    est_vide = file_est_vide</span>
<span id="cb23-20"><a href="#cb23-20"></a>    }</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Ici, on a une limitation du système de types. On aimerait paramètrer <code>taches</code> par <code>('a 'b, 'a)</code> où <code>'b</code> est un type paramètré, ainsi on aurait soit <code>('a pile, 'a)</code> où <code>('a file, 'a)</code> comme pour les deux case. Cependant, ce n’est pas possible, les types génériques ne sont pas paramètriques. C’est pour cela qu’on a un <code>('a, 'b)</code> sans avoir de lien apparent entre <code>'a</code> et <code>'b</code>.</div></p>
<p>On pourra alors écrire une fonction prenant un gestionnaire de tâches en paramètre :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">let</span> f t a =</span>
<span id="cb24-2"><a href="#cb24-2"></a>    <span class="kw">let</span> a_traiter = t.creation () <span class="kw">in</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> <span class="dt">Array</span>.length a - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>        t.ajouter a_traiter a.(i)</span>
<span id="cb24-5"><a href="#cb24-5"></a>    <span class="kw">done</span>;</span>
<span id="cb24-6"><a href="#cb24-6"></a>    <span class="kw">while</span> <span class="dt">not</span> (t.est_vide a_traiter) <span class="kw">do</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>        <span class="dt">print_int</span> (t.retirer a_traiter)</span>
<span id="cb24-8"><a href="#cb24-8"></a>    <span class="kw">done</span></span></code></pre></div>
<p></div></p>
<p>Ainsi <code>f taches_pile [|1;2;3|]</code> va afficher <code>321</code> et <code>f taches_file [|1;2;3|]</code> va afficher <code>123</code>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>En déduire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb25-1"><a href="#cb25-1"></a>parcours : (&#39;a, &#39;b arbre) taches -&gt; &#39;b arbre -&gt; <span class="dt">unit</span></span></code></pre></div>
<p></div> qui effectue un parcours de l’arbre en affichant les étiquettes des nœuds visités dans l’ordre induit par le gestionnaire de tâches passé en paramètre.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">let</span> parcours t a =</span>
<span id="cb26-2"><a href="#cb26-2"></a>    <span class="kw">let</span> avisiter = t.creation () <span class="kw">in</span></span>
<span id="cb26-3"><a href="#cb26-3"></a>    t.ajouter avisiter a;</span>
<span id="cb26-4"><a href="#cb26-4"></a>    <span class="kw">while</span> <span class="dt">not</span> (t.est_vide avisiter) <span class="kw">do</span></span>
<span id="cb26-5"><a href="#cb26-5"></a>        <span class="kw">match</span> t.retirer avisiter <span class="kw">with</span></span>
<span id="cb26-6"><a href="#cb26-6"></a>        | Nil -&gt; ()</span>
<span id="cb26-7"><a href="#cb26-7"></a>        | Noeud(g,x,d) -&gt;</span>
<span id="cb26-8"><a href="#cb26-8"></a>                <span class="dt">print_int</span> x;</span>
<span id="cb26-9"><a href="#cb26-9"></a>                t.ajouter avisiter g;</span>
<span id="cb26-10"><a href="#cb26-10"></a>                t.ajouter visiter d</span>
<span id="cb26-11"><a href="#cb26-11"></a>    <span class="kw">done</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h2 data-number="6.3" id="sec:arbres-binaires-stricts-1"><span class="header-section-number">6.3</span> Arbres binaires stricts</h2>
<p>Pour représenter des arbres dont les nœuds ont tous deux fils non vides, on va utiliser le type</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">type</span> (&#39;a, &#39;b) arbre_bin = Feuille <span class="kw">of</span> &#39;a </span>
<span id="cb27-2"><a href="#cb27-2"></a>    | NoeudI <span class="kw">of</span> (&#39;a, &#39;b) arbre_bin * &#39;b * (&#39;a, &#39;b) arbre_bin</span></code></pre></div>
<p></div></p>
<p>Ce type permet de représenter naturellement des expressions arithmétiques comme :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb28-1"><a href="#cb28-1"></a>NoeudI(NoeudI( Feuille <span class="dv">2</span>, <span class="ch">&#39;+&#39;</span>, Feuille <span class="dv">3</span>), <span class="ch">&#39;*&#39;</span>, Feuille <span class="dv">5</span>)</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>evalue : (int, char) arbre_bin -&gt; int</code> qui évalue une telle expression.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">let</span> <span class="kw">rec</span> evalue a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>    | Feuille n -&gt; n</span>
<span id="cb29-3"><a href="#cb29-3"></a>    | NoeudI(g, x, d) -&gt;</span>
<span id="cb29-4"><a href="#cb29-4"></a>            <span class="kw">let</span> eg = evalue g <span class="kw">in</span></span>
<span id="cb29-5"><a href="#cb29-5"></a>            <span class="kw">let</span> ed = evalue d <span class="kw">in</span></span>
<span id="cb29-6"><a href="#cb29-6"></a>            <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb29-7"><a href="#cb29-7"></a>            | <span class="ch">&#39;+&#39;</span> -&gt; eg + ed</span>
<span id="cb29-8"><a href="#cb29-8"></a>            | <span class="ch">&#39;*&#39;</span> -&gt; eg * ed</span>
<span id="cb29-9"><a href="#cb29-9"></a>            | _ -&gt; <span class="dt">failwith</span> <span class="st">&quot;Ope inconnue&quot;</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>Si on considère le type <div class="ui segment code"></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">type</span> (&#39;a, &#39;b) etiquette = F <span class="kw">of</span> &#39;a | N <span class="kw">of</span> &#39;b</span></code></pre></div>
<p></div></p>
<p>On peut passer d’un <code>('a, 'b) arbre_bin</code> à un <code>('a, 'b) etiquette arbre</code> et, dans certains cas, d’un <code>('a, 'b) etiquette arbre</code> à un <code>('a, 'b) arbre_bin</code>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire ainsi deux fonctions de conversion :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb31-1"><a href="#cb31-1"></a>arbre_bin_vers_arbre : (&#39;a, &#39;b) arbre_bin -&gt; (&#39;a, &#39;b) etiquette arbre</span>
<span id="cb31-2"><a href="#cb31-2"></a>arbre_vers_arbre_bin : (&#39;a, &#39;b) etiquette arbre -&gt; (&#39;a, &#39;b) arbre_bin <span class="dt">option</span></span></code></pre></div>
<p></div></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">let</span> <span class="kw">rec</span> arbre_bin_vers_arbre a =</span>
<span id="cb32-2"><a href="#cb32-2"></a>    <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>    | Feuille n -&gt; Noeud(Nil, F n, Nil)</span>
<span id="cb32-4"><a href="#cb32-4"></a>    | NoeudI(g, x, d) -&gt; Noeud(arbre_bin_vers_arbre g,</span>
<span id="cb32-5"><a href="#cb32-5"></a>                            N x,</span>
<span id="cb32-6"><a href="#cb32-6"></a>                            arbre_bin_vers_arbre d)</span>
<span id="cb32-7"><a href="#cb32-7"></a></span>
<span id="cb32-8"><a href="#cb32-8"></a><span class="kw">let</span> <span class="kw">rec</span> arbre_vers_arbre_bin a =</span>
<span id="cb32-9"><a href="#cb32-9"></a>    <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb32-10"><a href="#cb32-10"></a>    | Noeud(Nil, F f, Nil) -&gt; Feuille f</span>
<span id="cb32-11"><a href="#cb32-11"></a>    | Noeud(g, N x, d) -&gt; <span class="kw">begin</span></span>
<span id="cb32-12"><a href="#cb32-12"></a>            <span class="kw">match</span> arbre_vers_arbre_bin g, arbre_vers_arbre_bin d <span class="kw">with</span></span>
<span id="cb32-13"><a href="#cb32-13"></a>            | <span class="dt">Some</span> g&#39;, <span class="dt">Some</span> d&#39; -&gt; NoeudI(g&#39;, x, d&#39;)</span>
<span id="cb32-14"><a href="#cb32-14"></a>            | _ -&gt; <span class="dt">None</span></span>
<span id="cb32-15"><a href="#cb32-15"></a>        <span class="kw">end</span></span>
<span id="cb32-16"><a href="#cb32-16"></a>    | _ -&gt; <span class="dt">None</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h2 data-number="6.4" id="sec:dessin-darbres"><span class="header-section-number">6.4</span> Dessin d’arbres</h2>
<p>On va réaliser dans cette partie une fonction de dessin d’arbres avec <code>graphics</code>. L’idée est de placer la racine et de dessiner les sous-arbres gauche et droit en dessous. Pour cela, il va falloir connaitre la taille de ces sous-arbres en pixels.</p>
<p>On pourra consulter la documentation de <code>graphics</code> ici : <a href="http://pauillac.inria.fr/~remy/poly/ocaml/htmlman/libref/Graphics.html">Graphics</a></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>pixels : int arbre -&gt; int * int</code> qui renvoie un couple <code>(largeur, racine)</code> où <code>largeur</code> est la largeur en pixels d’un arbre dans son affichage et <code>racine</code> l’abscisse de la racine dans cet affichage.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">let</span> rnoeud = <span class="dv">5</span> <span class="co">(* Le rayon du noeud *)</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="kw">let</span> marge = <span class="dv">2</span> <span class="co">(* la marge autour du noeud *)</span></span>
<span id="cb33-3"><a href="#cb33-3"></a></span>
<span id="cb33-4"><a href="#cb33-4"></a><span class="kw">let</span> <span class="kw">rec</span> pixels a = <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb33-5"><a href="#cb33-5"></a>    | Nil -&gt; <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb33-6"><a href="#cb33-6"></a>    | Noeud(g, _, d) -&gt; </span>
<span id="cb33-7"><a href="#cb33-7"></a>            <span class="kw">let</span> lg, _ = pixels g <span class="kw">in</span></span>
<span id="cb33-8"><a href="#cb33-8"></a>            <span class="kw">let</span> ld, _ = pixels d <span class="kw">in</span></span>
<span id="cb33-9"><a href="#cb33-9"></a>            lg + ld + <span class="dv">2</span>*(marge + rnoeud), lg + marge + rnoeud</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>En déduire une fonction <code>dessine : int arbre -&gt; int -&gt; int -&gt; unit</code> tel que <code>dessine a x y</code> dessine l’arbre <span class="math inline">\(a\)</span> en plaçant la racine en <span class="math inline">\((x, y)\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">let</span> <span class="kw">rec</span> dessine a x y =</span>
<span id="cb34-2"><a href="#cb34-2"></a>    <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb34-3"><a href="#cb34-3"></a>    | Nil -&gt; ()</span>
<span id="cb34-4"><a href="#cb34-4"></a>    | Noeud(g, e, d) -&gt;</span>
<span id="cb34-5"><a href="#cb34-5"></a>            <span class="co">(* On précalcule les tailles des sous-arbres *)</span></span>
<span id="cb34-6"><a href="#cb34-6"></a>            <span class="kw">let</span> lg, rg = pixels g <span class="kw">in</span></span>
<span id="cb34-7"><a href="#cb34-7"></a>            <span class="kw">let</span> _, rd = pixels d <span class="kw">in</span></span>
<span id="cb34-8"><a href="#cb34-8"></a>            <span class="co">(* position de la racine gauche relativement à (x,y) *)</span></span>
<span id="cb34-9"><a href="#cb34-9"></a>            <span class="kw">let</span> v_rg = x - lg - marge - rnoeud + rg <span class="kw">in</span></span>
<span id="cb34-10"><a href="#cb34-10"></a>            <span class="co">(* position de la racine droite relative (x, y) *)</span></span>
<span id="cb34-11"><a href="#cb34-11"></a>            <span class="kw">let</span> v_rd = x + marge + rnoeud + rd <span class="kw">in</span></span>
<span id="cb34-12"><a href="#cb34-12"></a>            <span class="kw">let</span> dec_y = y - <span class="dv">2</span> * rnoeud - marge <span class="kw">in</span></span>
<span id="cb34-13"><a href="#cb34-13"></a></span>
<span id="cb34-14"><a href="#cb34-14"></a>            moveto x y; lineto v_rg dec_y;</span>
<span id="cb34-15"><a href="#cb34-15"></a>            moveto x y; lineto v_rd dec_y;</span>
<span id="cb34-16"><a href="#cb34-16"></a>            fill_circle x y rnoeud;</span>
<span id="cb34-17"><a href="#cb34-17"></a></span>
<span id="cb34-18"><a href="#cb34-18"></a>            moveto (x-tw/<span class="dv">2</span>) (y-th/<span class="dv">2</span>);</span>
<span id="cb34-19"><a href="#cb34-19"></a>            set_color white;</span>
<span id="cb34-20"><a href="#cb34-20"></a>            draw_string e;</span>
<span id="cb34-21"><a href="#cb34-21"></a>            set_color black;</span>
<span id="cb34-22"><a href="#cb34-22"></a></span>
<span id="cb34-23"><a href="#cb34-23"></a>            dessine g v_rg dec_y;</span>
<span id="cb34-24"><a href="#cb34-24"></a>            dessine d v_rd dec_y</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h2 data-number="6.5" id="sec:génération-aléatoire-darbres"><span class="header-section-number">6.5</span> Génération aléatoire d’arbres</h2>
<p>Dans cette partie, ce qui nous intéresse est de générer aléatoirement des arbres pour en observer la structure. Les étiquettes ne sont pas pertinentes, on pourra donc au choix, soit considérer des <code>unit arbre</code>, soit redéfinir un type d’arbre non étiquettés.</p>
<p>On va réaliser ici deux modèles de génération aléatoire d’arbres. Le premier modèle consiste, pour générer un arbre de <span class="math inline">\(n\)</span> nœuds, à choisir aléatoirement <span class="math inline">\(k\)</span> dans <span class="math inline">\(\range{0}{n}\)</span>, à générer aléatoirement un arbre <span class="math inline">\(g\)</span> à <span class="math inline">\(k\)</span> nœuds et un arbre <span class="math inline">\(d\)</span> à <span class="math inline">\(n-k\)</span> nœuds puis à renvoyer l’arbre <code>Noeud(g, (), d)</code>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Implémenter ce modèle avec une fonction <code>genere_arbre_1 : int -&gt; unit arbre</code>.</p>
<p>Tester votre fonction, notamment avec l’affichage de la partie précédente.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">let</span> <span class="kw">rec</span> genere_arbre_1 n = </span>
<span id="cb35-2"><a href="#cb35-2"></a>    <span class="kw">if</span> n = <span class="dv">0</span></span>
<span id="cb35-3"><a href="#cb35-3"></a>    <span class="kw">then</span> Nil</span>
<span id="cb35-4"><a href="#cb35-4"></a>    <span class="kw">else</span> <span class="kw">if</span> n = <span class="dv">1</span> <span class="kw">then</span> Noeud(Nil, (), Nil)</span>
<span id="cb35-5"><a href="#cb35-5"></a>    <span class="kw">else</span> <span class="kw">let</span> k = <span class="dt">Random</span>.<span class="dt">int</span> (n<span class="dv">-1</span>) <span class="kw">in</span></span>
<span id="cb35-6"><a href="#cb35-6"></a>        Noeud(genere_arbre_1  k, (), </span>
<span id="cb35-7"><a href="#cb35-7"></a>            genere_arbre_1  (n<span class="dv">-1</span>-k))</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>Pour le deuxième modèle, on va choisir un sous-arbre vide uniformément et le remplacer par un nœud.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>chemins_vides : 'a arbre -&gt; chemin list</code> qui étant donné un arbre renvoie la liste des chemins permettant d’aboutir à un sous-arbre vide.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">let</span> chemins_vide a =</span>
<span id="cb36-2"><a href="#cb36-2"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux a l =</span>
<span id="cb36-3"><a href="#cb36-3"></a>        <span class="kw">match</span> a <span class="kw">with</span></span>
<span id="cb36-4"><a href="#cb36-4"></a>        | Nil -&gt; [ <span class="dt">List</span>.rev l ]</span>
<span id="cb36-5"><a href="#cb36-5"></a>        | Noeud(g, _, d) -&gt; </span>
<span id="cb36-6"><a href="#cb36-6"></a>              aux g (Gauche::l)</span>
<span id="cb36-7"><a href="#cb36-7"></a>            @ aux d (Droite::l)</span>
<span id="cb36-8"><a href="#cb36-8"></a>    <span class="kw">in</span> aux a []</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>remplit : 'a arbre -&gt; chemin -&gt; 'a arbre</code> qui remplace un sous-arbre vide donnée par son chemin par un nœud.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">let</span> <span class="kw">rec</span> remplit a c =</span>
<span id="cb37-2"><a href="#cb37-2"></a>    <span class="kw">match</span> a, c <span class="kw">with</span></span>
<span id="cb37-3"><a href="#cb37-3"></a>    | Nil, [] -&gt; Noeud(Nil, (), Nil)</span>
<span id="cb37-4"><a href="#cb37-4"></a>    | Noeud(g,x,d), Gauche::q -&gt; </span>
<span id="cb37-5"><a href="#cb37-5"></a>            Noeud(remplit g q, x, d)</span>
<span id="cb37-6"><a href="#cb37-6"></a>    | Noeud(g,x,d), Droite::q -&gt; </span>
<span id="cb37-7"><a href="#cb37-7"></a>            Noeud(g, x, remplit d q)</span>
<span id="cb37-8"><a href="#cb37-8"></a>    | _ -&gt; <span class="dt">failwith</span> <span class="st">&quot;Error&quot;</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>En déduire une fonction <code>genere_arbres_2 : int -&gt; unit arbre</code> qui prend un entier <code>n</code> et construit un arbre à <span class="math inline">\(n\)</span> nœuds en partant de l’arbre vide et en réalisant <span class="math inline">\(n\)</span> remplacement d’un arbre vide par un nœuds, le choix de l’arbre vide se faisant uniformément.</p>
<p><em>Note :</em> on pourra utilser <code>List.nth</code> et <code>Random.int</code> Voir par exemple <a href="https://ocaml.org/api/Random.html">Random</a></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">let</span> <span class="kw">rec</span> genere_arbre_2 n =</span>
<span id="cb38-2"><a href="#cb38-2"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> Nil</span>
<span id="cb38-3"><a href="#cb38-3"></a>    <span class="kw">else</span> </span>
<span id="cb38-4"><a href="#cb38-4"></a>        <span class="kw">let</span> a = genere_arbre_2 (n<span class="dv">-1</span>) <span class="kw">in</span></span>
<span id="cb38-5"><a href="#cb38-5"></a>        <span class="kw">let</span> l = chemins_vide a <span class="kw">in</span></span>
<span id="cb38-6"><a href="#cb38-6"></a>        <span class="kw">let</span> k = <span class="dt">Random</span>.<span class="dt">int</span> (<span class="dt">List</span>.length l) <span class="kw">in</span></span>
<span id="cb38-7"><a href="#cb38-7"></a>        <span class="kw">let</span> ch = <span class="dt">List</span>.nth l k <span class="kw">in</span></span>
<span id="cb38-8"><a href="#cb38-8"></a>        remplit a ch</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
