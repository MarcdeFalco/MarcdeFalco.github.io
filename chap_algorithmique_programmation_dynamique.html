<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Programmation dynamique</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

.ui.styled.accordion {
    width: 100% !important;
    font-size: 1rem !important;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\gO{\mathcal{O}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Programmation dynamique
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:exemple-fondateur-plus-court-chemin-dans-un-graphe-orienté-acyclique"><span>1</span> Exemple fondateur : plus court chemin dans un graphe orienté acyclique</a><div class="menu"></div></div><div class="item header"> <a href="#sec:principe-de-la-programmation-dynamique"><span>2</span> Principe de la programmation dynamique</a><div class="menu"><a class="item" href="#sec:problème-et-équation-de-bellman"><div class="ui label">2.1</div> Problème et équation de Bellman</a><a class="item" href="#sec:résolution-par-récurrence-naïve"><div class="ui label">2.2</div> Résolution par récurrence naïve</a><a class="item" href="#sec:mémoïsation-et-cache-dynamique"><div class="ui label">2.3</div> Mémoïsation et cache dynamique</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:ocaml-cacher-le-cache-dans-une-clôture"><i class="circle icon"></i> <code>OCaml</code>: Cacher le cache dans une clôture</a></div><a class="item" href="#sec:graphe-de-dépendances-et-tabulation"><div class="ui label">2.4</div> Graphe de dépendances et tabulation</a><a class="item" href="#sec:reconstruction"><div class="ui label">2.5</div> Reconstruction</a><a class="item" href="#sec:dimensionnalité-réelle"><div class="ui label">2.6</div> Dimensionnalité réelle</a><a class="item" href="#sec:complexité"><div class="ui label">2.7</div> Complexité</a><a class="item" href="#sec:déterminer-un-tri-topologique"><div class="ui label">2.8</div> Déterminer un tri topologique</a><a class="item" href="#sec:résumé"><div class="ui label">2.9</div> Résumé</a></div></div><div class="item header"> <a href="#sec:exemples"><span>3</span> Exemples</a><div class="menu"><a class="item" href="#sec:sous-séquence-contigüe-maximale"><div class="ui label">3.1</div> Sous-séquence contigüe maximale</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:notion-de-sous-problème-et-récurrence"><i class="circle icon"></i> Notion de sous-problème et récurrence</a><a style="font-size:0.6em" class="item" href="#sec:récurrence-naïve-et-mémoïsation"><i class="circle icon"></i> Récurrence naïve et mémoïsation</a><a style="font-size:0.6em" class="item" href="#sec:tabulation"><i class="circle icon"></i> Tabulation</a><a style="font-size:0.6em" class="item" href="#sec:reconstruction-1"><i class="circle icon"></i> Reconstruction</a></div><a class="item" href="#sec:chemins-monotones"><div class="ui label">3.2</div> Chemins monotones</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:notion-de-sous-problèmes-et-récurrence"><i class="circle icon"></i> Notion de sous-problèmes et récurrence</a><a style="font-size:0.6em" class="item" href="#sec:résolution-naïve-et-mémoïsation"><i class="circle icon"></i> Résolution naïve et mémoïsation</a><a style="font-size:0.6em" class="item" href="#sec:tabulation-1"><i class="circle icon"></i> Tabulation</a><a style="font-size:0.6em" class="item" href="#sec:reconstruction-2"><i class="circle icon"></i> Reconstruction</a><a style="font-size:0.6em" class="item" href="#sec:complexité-1"><i class="circle icon"></i> Complexité</a></div><a class="item" href="#sec:produit-de-matrices"><div class="ui label">3.3</div> Produit de matrices</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:notion-de-sous-problème-et-récurrence-1"><i class="circle icon"></i> Notion de sous-problème et récurrence</a><a style="font-size:0.6em" class="item" href="#sec:récurrence-naïve-et-mémoïsation-1"><i class="circle icon"></i> Récurrence naïve et mémoïsation</a><a style="font-size:0.6em" class="item" href="#sec:tabulation-2"><i class="circle icon"></i> Tabulation</a><a style="font-size:0.6em" class="item" href="#sec:reconstruction-3"><i class="circle icon"></i> Reconstruction</a></div><a class="item" href="#sec:plus-longue-sous-séquence-croissante"><div class="ui label">3.4</div> Plus longue sous-séquence croissante</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:notion-de-sous-problème-et-récurrence-2"><i class="circle icon"></i> Notion de sous-problème et récurrence</a><a style="font-size:0.6em" class="item" href="#sec:récurrence-naïve-et-mémoïsation-2"><i class="circle icon"></i> Récurrence naïve et mémoïsation</a><a style="font-size:0.6em" class="item" href="#sec:tabulation-3"><i class="circle icon"></i> Tabulation</a><a style="font-size:0.6em" class="item" href="#sec:reconstruction-4"><i class="circle icon"></i> Reconstruction</a></div><a class="item" href="#sec:distance-dédition"><div class="ui label">3.5</div> Distance d’édition</a><a class="item" href="#sec:plus-longue-sous-séquence-palindromique"><div class="ui label">3.6</div> Plus longue sous-séquence palindromique</a></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Programmation dynamique
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Programmation dynamique     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_algo_exacte.png"> </div></p>
<h1 data-number="1"
id="sec:exemple-fondateur-plus-court-chemin-dans-un-graphe-orienté-acyclique"><span
class="header-section-number">1</span> Exemple fondateur : plus court
chemin dans un graphe orienté acyclique</h1>
<h1 data-number="2"
id="sec:principe-de-la-programmation-dynamique"><span
class="header-section-number">2</span> Principe de la programmation
dynamique</h1>
<h2 data-number="2.1" id="sec:problème-et-équation-de-bellman"><span
class="header-section-number">2.1</span> Problème et équation de
Bellman</h2>
<p>On considère ici un cadre assez large où on cherche à calculer une
fonction <span class="math inline">\(f : E \rightarrow \R\)</span> où
est le domaine d’entrée et où on dispose :</p>
<ul>
<li>de valeurs connus pour <span class="math inline">\(E_0 \subset
E\)</span></li>
<li>d’une équation pour <span class="math inline">\(x \in E \backslash
E_0\)</span> permettant d’exprimer <span
class="math inline">\(f(x)\)</span> en fonction de <span
class="math inline">\(f(y)\)</span> pour <span class="math inline">\(y
\in \mathop{dep}(x)\)</span> où <span class="math inline">\(\mathop{dep}
: E \rightarrow \mathcal{P}(E)\)</span> est telle que toute chaîne de
<span class="math inline">\((a_1, a_2, ...,)\)</span> où <span
class="math inline">\(a_{i+1} \in \mathop{dep}(a_i)\)</span> est finie
et où pour toute chaîne de longueur maximale, le dernier élément <span
class="math inline">\(a_p \in E_0\)</span>.</li>
</ul>
<p>En fait, cela signifie que <span
class="math inline">\(\mathop{dep}\)</span> induit un graphe orienté
acyclique sur les sommets <span class="math inline">\(E\)</span> où
<span class="math inline">\(v_{-}(x) = \mathop{dep}(x)\)</span>.</p>
<p>Il s’agit donc d’une équation de récurrence dans le sens où on
exprime <span class="math inline">\(f(x)\)</span> en fonction d’autres
appels à <span class="math inline">\(f\)</span>. On parle de
sous-problèmes.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li>Fibonacci. Ici, c’est un exemple <em>jouet</em> uniquement présent
pour se concentrer sur l’équation. On a donc <span
class="math inline">\(F_0 = 0, F_1 = 1\)</span> et pour <span
class="math inline">\(n &gt; 1\)</span>, <span class="math inline">\(F_n
= F_{n-1} + F_{n-2}\)</span>.</li>
<li>Rendu de monnaie. On cherche à calculer <span
class="math inline">\(f(n)\)</span> le plus petit nombre de pièce pour
rendre la monnaie dans le système monétaire <span
class="math inline">\(S\)</span>. On a <span class="math inline">\(f(0)
= 0\)</span> et l’équation <span class="math display">\[
f(n) = 1 + \min \enscomp{ f(n-p) }{ p \in S, p \le n }
\]</span></li>
</ul>
</div>
<h2 data-number="2.2" id="sec:résolution-par-récurrence-naïve"><span
class="header-section-number">2.2</span> Résolution par récurrence
naïve</h2>
<p>On peut résoudre l’équation de récurrence naïvement par une fonction
récursive.</p>
<p>Comme on a pu le voir, par exemple avec Fibonacci, les récurrences
font rapidement apparaitre des arbres d’appels de taille
exponentielle.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On peut se poser la question de la différence avec la méthode diviser
pour régner. Dans diviser pour régner, les sous-problèmes ont un arbre
récursif d’appel sans partage possible.</p>
<p></div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li>Fibonacci. On a</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">let</span> <span class="kw">rec</span> fibo n =</span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="kw">if</span> n &lt;= <span class="dv">1</span> <span class="kw">then</span> n</span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="kw">else</span> fibo (n<span class="dv">-1</span>) + fibo (n<span class="dv">-2</span>)</span></code></pre></div>
<p></div></p>
<ul>
<li>Rendu de monnaie. On peut directement écrire :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">let</span> <span class="kw">rec</span> rendu s n =</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="kw">if</span> n = <span class="dv">0</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="kw">then</span> <span class="dv">0</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="kw">else</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>        <span class="kw">let</span> m = <span class="dt">ref</span> n <span class="kw">in</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>        <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> <span class="dt">Array</span>.length s - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>            <span class="kw">if</span> s.(i) &lt;= n</span>
<span id="cb2-8"><a href="#cb2-8"></a>            <span class="kw">then</span> m := <span class="dt">min</span> !m (rendu s (n - s.(i)))</span>
<span id="cb2-9"><a href="#cb2-9"></a>        <span class="kw">done</span>;</span>
<span id="cb2-10"><a href="#cb2-10"></a>        <span class="dv">1</span> + !m</span></code></pre></div>
<p></div></p>
</div>
<h2 data-number="2.3" id="sec:mémoïsation-et-cache-dynamique"><span
class="header-section-number">2.3</span> Mémoïsation et cache
dynamique</h2>
<p>Une manière d’améliorer la résolution par récurrence est d’utiliser
un cache d’appel, c’est-à-dire un dictionnaire dont les clés sont dans
<span class="math inline">\(E\)</span> et les valeurs dans <span
class="math inline">\(\R\)</span> : pour calculer <span
class="math inline">\(f(x)\)</span> on regarde si on a déjà une
correspondance dans le cache, auquel cas on renvoie cette valeur, sinon,
on calcule <span class="math inline">\(f(x)\)</span> avec la récurrence
(qui utilisera donc le cache), puis on rajoute une entrée dans le cache
pour <span class="math inline">\(x\)</span>.</p>
<p>On dit qu’on a <strong>mémoïsé</strong> la fonction <span
class="math inline">\(f\)</span>.</p>
<p>En procédant ainsi, on a linéarisé la récurrence et on effectue
uniquement les calculs nécessaires une seule fois.</p>
<p>Pour définir ce cache, on peut utiliser une table de hachage comme
celle fournit par le module <code>Hashtbl</code> en
<code>OCaml</code>.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li>Fibonacci.</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">let</span> fibo n =</span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="kw">let</span> cache = <span class="dt">Hashtbl</span>.create (n+<span class="dv">1</span>) <span class="kw">in</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="kw">let</span> <span class="kw">rec</span> fibo_aux n = </span>
<span id="cb3-4"><a href="#cb3-4"></a>        <span class="kw">try</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>            <span class="dt">Hashtbl</span>.find cache n</span>
<span id="cb3-6"><a href="#cb3-6"></a>        <span class="kw">with</span> <span class="dt">Not_found</span> -&gt;</span>
<span id="cb3-7"><a href="#cb3-7"></a>            <span class="kw">let</span> v =</span>
<span id="cb3-8"><a href="#cb3-8"></a>                <span class="kw">if</span> n &lt;= <span class="dv">1</span> <span class="kw">then</span> n</span>
<span id="cb3-9"><a href="#cb3-9"></a>                <span class="kw">else</span> fibo_aux (n<span class="dv">-1</span>) + fibo_aux (n<span class="dv">-2</span>)</span>
<span id="cb3-10"><a href="#cb3-10"></a>            <span class="kw">in</span> <span class="dt">Hashtbl</span>.add cache n v;</span>
<span id="cb3-11"><a href="#cb3-11"></a>            v</span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="kw">in</span> fibo_aux n</span></code></pre></div>
<p></div></p>
<ul>
<li>Rendu de monnaie.</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">let</span> rendu s n =</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="kw">let</span> cache = <span class="dt">Hashtbl</span>.create (n+<span class="dv">1</span>) <span class="kw">in</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="kw">let</span> <span class="kw">rec</span> rendu_aux n = </span>
<span id="cb4-4"><a href="#cb4-4"></a>        <span class="kw">try</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>            <span class="dt">Hashtbl</span>.find cache n</span>
<span id="cb4-6"><a href="#cb4-6"></a>        <span class="kw">with</span> <span class="dt">Not_found</span> -&gt;</span>
<span id="cb4-7"><a href="#cb4-7"></a>            <span class="kw">let</span> v =</span>
<span id="cb4-8"><a href="#cb4-8"></a>                <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>                <span class="kw">else</span> <span class="kw">let</span> m = <span class="dt">ref</span> n <span class="kw">in</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>                    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> <span class="dt">Array</span>.length s - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>                        <span class="kw">if</span> s.(i) &lt;= n</span>
<span id="cb4-12"><a href="#cb4-12"></a>                        <span class="kw">then</span> m := <span class="dt">min</span> !m (rendu s (n - s.(i)))</span>
<span id="cb4-13"><a href="#cb4-13"></a>                    <span class="kw">done</span>;</span>
<span id="cb4-14"><a href="#cb4-14"></a>                    <span class="dv">1</span> + !m</span>
<span id="cb4-15"><a href="#cb4-15"></a>            <span class="kw">in</span> <span class="dt">Hashtbl</span>.add cache n v;</span>
<span id="cb4-16"><a href="#cb4-16"></a>            v</span>
<span id="cb4-17"><a href="#cb4-17"></a>    <span class="kw">in</span> rendu_aux n</span></code></pre></div>
<p></div></p>
</div>
<p>On remarque que le code a toujours la même structure on part de</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">let</span> <span class="kw">rec</span> f x = expr</span></code></pre></div>
<p></div></p>
<p>et on passe à :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">let</span> f x =</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="co">(* ici n doit etre proche du nombre d&#39;appels *)</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="kw">let</span> cache = <span class="dt">Hashtbl</span>.create n <span class="kw">in</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="kw">let</span> <span class="kw">rec</span> f_aux x = </span>
<span id="cb6-5"><a href="#cb6-5"></a>        <span class="kw">try</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>            <span class="dt">Hashtbl</span>.find cache x</span>
<span id="cb6-7"><a href="#cb6-7"></a>        <span class="kw">with</span> <span class="dt">Not_found</span> -&gt;</span>
<span id="cb6-8"><a href="#cb6-8"></a>            <span class="kw">let</span> v = expr&#39; <span class="kw">in</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>            <span class="dt">Hashtbl</span>.add cache x v;</span>
<span id="cb6-10"><a href="#cb6-10"></a>            v</span>
<span id="cb6-11"><a href="#cb6-11"></a>    <span class="kw">in</span> f_aux x</span></code></pre></div>
<p></div></p>
<p>où <code>expr'</code> se déduit de <code>expr</code> en remplaçant
chaque appel à <code>f</code> par un appel à <code>f_aux</code>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il n’est pas possible d’effectuer cette transformation d’expression
directement depuis <code>OCaml</code> puisqu’il serait nécessaire
d’aller modifier le code de l’expression.</p>
<p></div></p>
<h3 data-number="2.3.1"
id="sec:ocaml-cacher-le-cache-dans-une-clôture"><span
class="header-section-number">2.3.1</span> <code>OCaml</code> : Cacher
le cache dans une clôture</h3>
<p>De la manière dont on a codé le cache, on va créer un nouveau cache à
chaque calcul de <span class="math inline">\(f(x)\)</span> et jeter
l’ancien. Il peut-être intéressant de conserver un cache entre plusieurs
appels. Pour cela, on peut utiliser la notion de clôture : une
<em>clôture</em> est la donnée d’une fonction et des valeurs connues au
moment de sa définition.</p>
<p>Ainsi, en écrivant plutôt :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">let</span> f =</span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="kw">let</span> cache = <span class="dt">Hashtbl</span>.create n <span class="kw">in</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="kw">let</span> <span class="kw">rec</span> f_aux x = </span>
<span id="cb7-4"><a href="#cb7-4"></a>        <span class="kw">try</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>            <span class="dt">Hashtbl</span>.find cache x</span>
<span id="cb7-6"><a href="#cb7-6"></a>        <span class="kw">with</span> <span class="dt">Not_found</span> -&gt;</span>
<span id="cb7-7"><a href="#cb7-7"></a>            <span class="kw">let</span> v = expr&#39; <span class="kw">in</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>            <span class="dt">Hashtbl</span>.add cache x v;</span>
<span id="cb7-9"><a href="#cb7-9"></a>            v</span>
<span id="cb7-10"><a href="#cb7-10"></a>    <span class="kw">in</span> f_aux</span></code></pre></div>
<p></div></p>
<p>On crée une fonction <code>f_aux</code> qui connait le
<code>cache</code> et peut l’utiliser et ce sera la valeur de
<code>f</code>. Quand on appelle <code>f x</code> puis <code>f y</code>,
on va en fait appeler <code>f_aux x</code> et <code>f_aux y</code> qui
connaissent et manipulent le même <code>cache</code>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On peut expliciter le fonction avec un <code>fun</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">let</span> f =</span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="kw">let</span> cache = <span class="dt">Hashtbl</span>.create n <span class="kw">in</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="kw">let</span> <span class="kw">rec</span> f_aux x = </span>
<span id="cb8-4"><a href="#cb8-4"></a>        <span class="kw">try</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>            <span class="dt">Hashtbl</span>.find cache x</span>
<span id="cb8-6"><a href="#cb8-6"></a>        <span class="kw">with</span> <span class="dt">Not_found</span> -&gt;</span>
<span id="cb8-7"><a href="#cb8-7"></a>            <span class="kw">let</span> v = expr&#39; <span class="kw">in</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>            <span class="dt">Hashtbl</span>.add cache x v;</span>
<span id="cb8-9"><a href="#cb8-9"></a>            v</span>
<span id="cb8-10"><a href="#cb8-10"></a>    <span class="kw">in</span> </span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span class="kw">fun</span> x -&gt; f_aux x</span></code></pre></div>
<p></div></p>
<p></div></p>
<h2 data-number="2.4" id="sec:graphe-de-dépendances-et-tabulation"><span
class="header-section-number">2.4</span> Graphe de dépendances et
tabulation</h2>
<p>Comme on a un graphe de dépendance entre sous-problèmes qui est
acyclique, on peut en déduire une tri topologique <span
class="math inline">\(x_0 &lt; x_1 &lt; \dots &lt; x_{n-1}\)</span> qui
garantit que si <span class="math inline">\(f(x_i)\)</span> a besoin
dans son calcul de la valeur <span
class="math inline">\(f(x_j)\)</span>, alors <span
class="math inline">\(j &lt; i\)</span>.</p>
<p>On peut alors créer un tableau de <span
class="math inline">\(n\)</span> cases où on place à la case <span
class="math inline">\(i\)</span> la valeur de <span
class="math inline">\(f(x_i)\)</span>.</p>
<p>Ce tableau peut se calculer par un remplissage par indice croissant.
On dit qu’on a <strong>tabuler</strong> le problème.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il s’agit ici d’une politique agressive de remplissage du cache de
memoïsation où on remplit le cache sans même savoir si on va utiliser
une valeur. Ce qu’on semble perdre en calculant <em>trop</em>, on le
regagne dans la simplicité de la gestion d’un tableau plutôt qu’une
table. Comme souvent, la question va être celle du compromis entre le
nombre de valeurs utiles pour le calcul de <span
class="math inline">\(f(x)\)</span> et le nombre de valeurs avant <span
class="math inline">\(x\)</span> dans le tri topologique considéré.</p>
<p></div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li>Fibonacci. Ici, on a directement l’ordre des entiers qui est un tri
topologique.</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">let</span> fibo n =</span>
<span id="cb9-2"><a href="#cb9-2"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="kw">else</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>        <span class="kw">let</span> t = <span class="dt">Array</span>.make (n+<span class="dv">1</span>) <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>        t.(<span class="dv">1</span>) &lt;- <span class="dv">1</span>;</span>
<span id="cb9-6"><a href="#cb9-6"></a>        <span class="kw">for</span> i = <span class="dv">2</span> <span class="kw">to</span> n <span class="kw">do</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>            t.(i) &lt;- t.(i<span class="dv">-1</span>) + t.(i<span class="dv">-2</span>)</span>
<span id="cb9-8"><a href="#cb9-8"></a>        <span class="kw">done</span>;</span>
<span id="cb9-9"><a href="#cb9-9"></a>        t.(n)</span></code></pre></div>
<p></div></p>
<ul>
<li>Rendu de monnaie.</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">let</span> rendu s n =</span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="kw">else</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>        <span class="kw">let</span> t = <span class="dt">Array</span>.make (n+<span class="dv">1</span>) <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>        <span class="kw">for</span> i = <span class="dv">1</span> <span class="kw">to</span> n <span class="kw">do</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>            <span class="kw">let</span> m = <span class="dt">ref</span> i <span class="kw">in</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>            <span class="kw">for</span> j = <span class="dv">0</span> <span class="kw">to</span> <span class="dt">Array</span>.length s - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>                <span class="kw">let</span> p = s.(j) <span class="kw">in</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>                <span class="kw">if</span> p &lt;= i</span>
<span id="cb10-10"><a href="#cb10-10"></a>                <span class="kw">then</span> m := <span class="dt">min</span> !m t.(i - p)</span>
<span id="cb10-11"><a href="#cb10-11"></a>            <span class="kw">done</span>;</span>
<span id="cb10-12"><a href="#cb10-12"></a>            t.(i) &lt;- <span class="dv">1</span> + !m</span>
<span id="cb10-13"><a href="#cb10-13"></a>        <span class="kw">done</span>;</span>
<span id="cb10-14"><a href="#cb10-14"></a>        t.(n)</span></code></pre></div>
<p></div></p>
</div>
<h2 data-number="2.5" id="sec:reconstruction"><span
class="header-section-number">2.5</span> Reconstruction</h2>
<p>La plupart des problèmes ne sont pas juste des problèmes de calcul
d’une valeur <span class="math inline">\(f(x)\)</span> mais des
problèmes où on considère un ensemble <span
class="math inline">\(F\)</span> de valeurs à construire avec une
fonction <span class="math inline">\(\Phi : E \rightarrow F\)</span> et
une fonction d’objectif <span class="math inline">\(\varphi : F
\rightarrow \R\)</span> et où <span class="math inline">\(f(x) =
\varphi(\Phi(x))\)</span>.</p>
<p>L’exemple principale est celui d’associer à tout <span
class="math inline">\(x \in E\)</span> un ensemble de solutions <span
class="math inline">\(\mathop{sol}(x) \subset F\)</span> et à chercher
la solution minimisant (ou maximisant) l’objectif :</p>
<p><span class="math display">\[
\Phi(x) = \mathop{argmin} \enscomp{ \varphi(y) }{ y \in \mathop{sol}(x)
}
\]</span></p>
<p><div class="ui message blue"><div class="header">Note</div></p>
<p>Unifier avec la présentation des gloutons</p>
<p></div></p>
<p>On a alors deux stratégies pour obtenir <span
class="math inline">\(\Phi(x)\)</span> quand on a trouvé comment
calculer <span class="math inline">\(f(x)\)</span>. La première consiste
à calculer <span class="math inline">\(\Phi\)</span> et <span
class="math inline">\(f\)</span> ensemble. Par exemple, dans le rendu de
monnaie, on sait qu’on calcule le minimum la pièce qui le réalise :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">let</span> rendu s n =</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> []</span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="kw">else</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>        <span class="kw">let</span> t = <span class="dt">Array</span>.make (n+<span class="dv">1</span>) <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>        <span class="kw">let</span> util = <span class="dt">Array</span>.make (n+<span class="dv">1</span>) (<span class="dv">-1</span>) <span class="kw">in</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>        <span class="kw">for</span> i = <span class="dv">1</span> <span class="kw">to</span> n <span class="kw">do</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>            <span class="kw">let</span> m = <span class="dt">ref</span> i <span class="kw">in</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>            <span class="kw">for</span> j = <span class="dv">0</span> <span class="kw">to</span> <span class="dt">Array</span>.length s - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>                <span class="kw">let</span> p = s.(j) <span class="kw">in</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>                <span class="kw">if</span> p &lt;= i &amp;&amp; t.(i-p) &lt; !m</span>
<span id="cb11-11"><a href="#cb11-11"></a>                <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>                    util.(i) &lt;- p; </span>
<span id="cb11-13"><a href="#cb11-13"></a>                    m := t.(i - p)</span>
<span id="cb11-14"><a href="#cb11-14"></a>                <span class="kw">end</span></span>
<span id="cb11-15"><a href="#cb11-15"></a>            <span class="kw">done</span>;</span>
<span id="cb11-16"><a href="#cb11-16"></a>            t.(i) &lt;- <span class="dv">1</span> + !m</span>
<span id="cb11-17"><a href="#cb11-17"></a>        <span class="kw">done</span>;</span>
<span id="cb11-18"><a href="#cb11-18"></a>        <span class="kw">let</span> <span class="kw">rec</span> rendu_expl n =</span>
<span id="cb11-19"><a href="#cb11-19"></a>            <span class="kw">if</span> n = <span class="dv">0</span> </span>
<span id="cb11-20"><a href="#cb11-20"></a>            <span class="kw">then</span> []</span>
<span id="cb11-21"><a href="#cb11-21"></a>            <span class="kw">else</span> <span class="kw">let</span> p = util.(n) <span class="kw">in</span></span>
<span id="cb11-22"><a href="#cb11-22"></a>                p :: rendu_expl (n-p)</span>
<span id="cb11-23"><a href="#cb11-23"></a>        <span class="kw">in</span> rendu_expl n</span></code></pre></div>
<p></div></p>
<p>Cependant, si on connait le tableau <code>t</code> complet, il est
facile de constater qu’on peut retrouver une pièce ayant réalisé le
minimum en cherchant <span class="math inline">\(p \le x\)</span> tel
que <span class="math inline">\(t.(x) = 1 + t.(x-p)\)</span>. On en
déduit une reconstruction de la solution uniquement avec les
valeurs.</p>
<p>Il est en général intéressant de faire cela, même si ce n’est pas
forcément efficace.</p>
<h2 data-number="2.6" id="sec:dimensionnalité-réelle"><span
class="header-section-number">2.6</span> Dimensionnalité réelle</h2>
<p>Dans de nombreux cas, le problème n’est pas exprimé sur l’entrée
<span class="math inline">\(E\)</span> mais sur un autre ensemble plus
petit. Par exemple, on peut chercher une valeur particulière à calculer
depuis un tableau et penser que l’entrée est donnée par la taille du
tableau, par exemple en raisonnant sur les préfixes, et, en fait, il est
nécessaire de considérer tous les sous-tableaux pour calculer la
solution. Ainsi, <span class="math inline">\(E\)</span> est alors les
couples d’indices <span class="math inline">\((i,j)\)</span> et on
retrouve le problème initial en considérant <span
class="math inline">\((0,n-1)\)</span> où <span
class="math inline">\(n\)</span> est la longueur du tableau.</p>
<p>Il n’est ainsi par rare d’avoir un problème portant sur un objet de
taille <span class="math inline">\(n\)</span> mais faisant apparaitre
des <span class="math inline">\(d\)</span>-uplets et donc avec une
taille réelle en <span class="math inline">\(n^d\)</span>.</p>
<h2 data-number="2.7" id="sec:complexité"><span
class="header-section-number">2.7</span> Complexité</h2>
<p>Une fois identifié la vraie entrée <span
class="math inline">\(E\)</span>, la complexité est en <span
class="math inline">\(O(|avant(x)|)\)</span> où <span
class="math inline">\(avant(x) = \enscomp{y \in E}{ y \le x}\)</span>
dans le tri topologique considéré.</p>
<p>Comme vu dans la partie précédente, on est le plus souvent en <span
class="math inline">\(O(n^d)\)</span> où <span
class="math inline">\(d\)</span> est la dimensionnalité réelle du
problème.</p>
<h2 data-number="2.8" id="sec:déterminer-un-tri-topologique"><span
class="header-section-number">2.8</span> Déterminer un tri
topologique</h2>
<p>Le plus souvent, on va tabuler le problème sur des tableaux à <span
class="math inline">\(d\)</span> dimensions. La question du tri
topologique revient alors à déterminer <span
class="math inline">\(d\)</span> boucles <code>for</code> pour remplir
dans le bon ordre.</p>
<p>Il peut être intéressant de réaliser un schéma pour visualiser les
dépendances et déterminer un ordre de remplissage.
<center><div class="ui image center"><img
src="assets/pics/remplissage.png" /></div></center></p>
<h2 data-number="2.9" id="sec:résumé"><span
class="header-section-number">2.9</span> Résumé</h2>
<p>Face à un problème qui semble soluble par programmation dynamique on
va donc :</p>
<ol type="1">
<li>Identifier la notion de problème et de sous-problèmes permettant
d’établir une équation de Bellman pour un <strong>calcul</strong>.</li>
</ol>
<p>Là, on a deux choix :</p>
<ol start="2" type="1">
<li>Résoudre l’équation de Bellman naïvement avec un cache de
mémoïsation.</li>
</ol>
<p>ou</p>
<ol start="2" type="1">
<li>Tabuler les résultats après avoir déduit un ordre de parcours
compatible avec les dépendances de l’équation.</li>
</ol>
<p>Puis,</p>
<ol start="3" type="1">
<li>On décore le code du calcul pour permettre de construire les objets
optimaux recherchés.</li>
</ol>
<p>Qu’on peut éventuellement faire directement depuis la table ou le
cache de calcul.</p>
<h1 data-number="3" id="sec:exemples"><span
class="header-section-number">3</span> Exemples</h1>
<p>Pour chacun de ces exemples, on cherchera à mettre en place une
solution par mémoïsation puis par tabulation, avec une reconstruction
directe ou indirecte.</p>
<h2 data-number="3.1" id="sec:sous-séquence-contigüe-maximale"><span
class="header-section-number">3.1</span> Sous-séquence contigüe
maximale</h2>
<p>On considère un tableau <span class="math inline">\(t\)</span> de
taille <span class="math inline">\(n\)</span> contenant des entiers et
on demande de trouver le couple <span
class="math inline">\((i,l)\)</span> tel que la somme <span
class="math display">\[
t[i] + \dots + t[i+l]
\]</span> soit la plus grande possible.</p>
<p>Si on considère le tableau :</p>
<table style="width:100%;">
<colgroup>
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="header">
<th>i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>t[i]</td>
<td>13</td>
<td>-3</td>
<td>-25</td>
<td>20</td>
<td>-3</td>
<td>-16</td>
<td>-23</td>
<td>18</td>
<td>20</td>
<td>-7</td>
<td>12</td>
<td>-5</td>
<td>-22</td>
<td>15</td>
<td>-4</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>La plus grande somme est <span class="math inline">\(t[7] + t[8] +
t[9] + t[10] = 43\)</span>.</p>
<h3 data-number="3.1.1"
id="sec:notion-de-sous-problème-et-récurrence"><span
class="header-section-number">3.1.1</span> Notion de sous-problème et
récurrence</h3>
<p>Ici, on va introduire un sous-problème différent qui est celui de
calculer <span class="math display">\[f(i) = \max_{i \le k &lt; n}
\sum_{j=i}^k t[j]\]</span> c’est-à-dire la plus grande somme démarrant
par <span class="math inline">\(t[i]\)</span>.</p>
<p>La connaissance d’une seule valeur de <span
class="math inline">\(f\)</span> ne sera pas suffisante pour déterminer
la plus grande somme quelconque. Cependant, il va suffir de calculer un
maximum des valeurs prises par <span
class="math inline">\(f\)</span>.</p>
<p>Pour le tableau précédent on obtient :</p>
<table style="width:100%;">
<colgroup>
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="header">
<th>i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>t[i]</td>
<td>13</td>
<td>-3</td>
<td>-25</td>
<td>20</td>
<td>-3</td>
<td>-16</td>
<td>-23</td>
<td>18</td>
<td>20</td>
<td>-7</td>
<td>12</td>
<td>-5</td>
<td>-22</td>
<td>15</td>
<td>-4</td>
<td>7</td>
</tr>
<tr class="even">
<td>f(i)</td>
<td>13</td>
<td>-3</td>
<td>-4</td>
<td>21</td>
<td>1</td>
<td>4</td>
<td>20</td>
<td>43</td>
<td>25</td>
<td>5</td>
<td>12</td>
<td>-5</td>
<td>-4</td>
<td>18</td>
<td>3</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>L’intérêt d’avoir rigidifié la somme en fixant un point de départ est
de pouvoir exprimer la relation suivante :</p>
<p><span class="math display">\[
f(n-1) = t[n-1] \qquad
\forall i &lt; n-1, f(i) = t[i] + \begin{cases} f(i+1) &amp; \text{si }
f(i+1) &gt; 0 \\
0 &amp; \text{sinon } \end{cases}
\]</span></p>
<p>Notons qu’on peut écrire aussi <span class="math inline">\(f(i) =
t[i] + max(f(i+1), 0)\)</span>.</p>
<h3 data-number="3.1.2" id="sec:récurrence-naïve-et-mémoïsation"><span
class="header-section-number">3.1.2</span> Récurrence naïve et
mémoïsation</h3>
<p>On écrit directement le programme résolvant cette récurrence :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">let</span> <span class="kw">rec</span> f t i =</span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="kw">if</span> i = n - <span class="dv">1</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    <span class="kw">then</span> t.(n<span class="dv">-1</span>)</span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="kw">else</span> t.(i) + <span class="dt">max</span> <span class="dv">0</span> (f t (i+<span class="dv">1</span>))</span></code></pre></div>
<p></div></p>
<p>On peut alors répondre au problème initial avec :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">let</span> maxsubarray t =</span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="kw">let</span> m = <span class="dt">ref</span> (f t <span class="dv">0</span>) <span class="kw">in</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="kw">for</span> i = <span class="dv">1</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>        m := <span class="dt">max</span> !m (f t i)</span>
<span id="cb13-6"><a href="#cb13-6"></a>    <span class="kw">done</span>;</span>
<span id="cb13-7"><a href="#cb13-7"></a>    !m</span></code></pre></div>
<p></div></p>
<p>On adapte directement le code vu précédemment pour ajouter un cache
de mémoïsation :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">let</span> cache = <span class="dt">Hashtbl</span>.create <span class="dv">42</span> <span class="co">(* taille quelconque ici *)</span></span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">let</span> <span class="kw">rec</span> f t i =</span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="kw">try</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>        <span class="dt">Hashtbl</span>.find cache i</span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="kw">with</span> <span class="dt">Not_found</span> -&gt;</span>
<span id="cb14-7"><a href="#cb14-7"></a>        <span class="kw">let</span> v = <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>            <span class="kw">if</span> i = n - <span class="dv">1</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>            <span class="kw">then</span> t.(n<span class="dv">-1</span>)</span>
<span id="cb14-10"><a href="#cb14-10"></a>            <span class="kw">else</span> t.(i) + <span class="dt">max</span> <span class="dv">0</span> (f t (i+<span class="dv">1</span>))</span>
<span id="cb14-11"><a href="#cb14-11"></a>        <span class="kw">in</span> <span class="dt">Hashtbl</span>.add cache i v; v</span></code></pre></div>
<p></div></p>
<p>En plaçant le cache en dehors de la fonction, on permet à
<code>maxsubarray</code> de ne pas recalculer les valeurs mais on rend
la fonction à usage unique : il faudrait vider le cache au début de
<code>maxsubarray</code>.</p>
<p>Il est beaucoup plus élégant de cacher le cache dans une clôture,
mais en faisant cela, on va se heurter au fait qu’il faut un cache
partagé entre les différentes valeurs de <span
class="math inline">\(i\)</span> mais commun à un <span
class="math inline">\(t\)</span> donné. L’astuce réside dans le fait de
<em>couper</em> la fonction en insérant la création du cache après le
paramètre <code>t</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">let</span> f t =</span>
<span id="cb15-2"><a href="#cb15-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>    <span class="kw">let</span> cache = <span class="dt">Hashtbl</span>.create (n+<span class="dv">1</span>) <span class="kw">in</span> <span class="co">(* ici on a une bonne valeur *)</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>    <span class="kw">let</span> <span class="kw">rec</span> f_aux i =</span>
<span id="cb15-5"><a href="#cb15-5"></a>        <span class="kw">try</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>            <span class="dt">Hashtbl</span>.find cache i</span>
<span id="cb15-7"><a href="#cb15-7"></a>        <span class="kw">with</span> <span class="dt">Not_found</span> -&gt;</span>
<span id="cb15-8"><a href="#cb15-8"></a>            <span class="kw">let</span> v = <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>                <span class="kw">if</span> i = n - <span class="dv">1</span></span>
<span id="cb15-10"><a href="#cb15-10"></a>                <span class="kw">then</span> t.(n<span class="dv">-1</span>)</span>
<span id="cb15-11"><a href="#cb15-11"></a>                <span class="kw">else</span> t.(i) + <span class="dt">max</span> <span class="dv">0</span> (f_aux (i+<span class="dv">1</span>))</span>
<span id="cb15-12"><a href="#cb15-12"></a>            <span class="kw">in</span> <span class="dt">Hashtbl</span>.add cache i v; v</span>
<span id="cb15-13"><a href="#cb15-13"></a>    <span class="kw">in</span> f_aux</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On finit sur <code>f_aux</code> qui renvoie une fonction
<code>int -&gt; int</code> mais on aurait pu écrire
<code>fun i -&gt; f_aux i</code> pour rendre la fonctionnelle plus
explicite.</p>
<p></div></p>
<h3 data-number="3.1.3" id="sec:tabulation"><span
class="header-section-number">3.1.3</span> Tabulation</h3>
<p>On tabule <code>f</code> directement en remplissant un tableau de
droite à gauche vu que <span class="math inline">\(f(i)\)</span> dépend
de <span class="math inline">\(f(i+1)\)</span> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">let</span> maxsubarray t =</span>
<span id="cb16-2"><a href="#cb16-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>    <span class="kw">let</span> f = <span class="dt">Array</span>.make n <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>    f.(n<span class="dv">-1</span>) &lt;- t.(n<span class="dv">-1</span>);</span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="kw">for</span> i = n<span class="dv">-2</span> <span class="kw">to</span> <span class="dv">0</span> <span class="kw">do</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>        f.(i) &lt;- t.(i) + <span class="dt">max</span> <span class="dv">0</span> f.(i+<span class="dv">1</span>)</span>
<span id="cb16-7"><a href="#cb16-7"></a>    <span class="kw">done</span>;</span>
<span id="cb16-8"><a href="#cb16-8"></a>    <span class="kw">let</span> m = <span class="dt">ref</span> t.(<span class="dv">0</span>) <span class="kw">in</span></span>
<span id="cb16-9"><a href="#cb16-9"></a>    <span class="kw">for</span> i = <span class="dv">1</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb16-10"><a href="#cb16-10"></a>        m := <span class="dt">max</span> !m f.(i)</span>
<span id="cb16-11"><a href="#cb16-11"></a>    <span class="kw">done</span>;</span>
<span id="cb16-12"><a href="#cb16-12"></a>    !m</span></code></pre></div>
<p></div></p>
<h3 data-number="3.1.4" id="sec:reconstruction-1"><span
class="header-section-number">3.1.4</span> Reconstruction</h3>
<p>Lorsqu’on effectue le calcul du maximum dans la fonction précédente,
il est direct de garder dans une variable l’indice où il se produit.
Cependant, en procédant ainsi, on ne peut pas en déduire facilement la
longueur de la somme. Pour ce faire, on va créer un nouveau tableau
indiquant à l’indice <span class="math inline">\(i\)</span> la longueur
de la plus grande somme commençant par <span
class="math inline">\(t[i]\)</span>.</p>
<p>En effet, si on note <span class="math inline">\(l(i)\)</span> où
<span class="math inline">\(f(i) = \sum_{k = i}^{i+l(i)} t[k]\)</span>
on a <span class="math inline">\(l(n-1) = 0\)</span> et</p>
<p><span class="math display">\[
\forall i &lt; n-1, l(i) = \begin{cases} 1+l(i) &amp; \text{si } f(i+1)
&gt; 0 \\
0 &amp; \text{sinon} \end{cases}
\]</span></p>
<p>Sur l’exemple précédent on va donc calculer les valeurs suivantes
:</p>
<table style="width:100%;">
<colgroup>
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="header">
<th>i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>t[i]</td>
<td>13</td>
<td>-3</td>
<td>-25</td>
<td>20</td>
<td>-3</td>
<td>-16</td>
<td>-23</td>
<td>18</td>
<td>20</td>
<td>-7</td>
<td>12</td>
<td>-5</td>
<td>-22</td>
<td>15</td>
<td>-4</td>
<td>7</td>
</tr>
<tr class="even">
<td>f(i)</td>
<td>13</td>
<td>-3</td>
<td>-4</td>
<td>21</td>
<td>1</td>
<td>4</td>
<td>20</td>
<td>43</td>
<td>25</td>
<td>5</td>
<td>12</td>
<td>-5</td>
<td>-4</td>
<td>18</td>
<td>3</td>
<td>7</td>
</tr>
<tr class="odd">
<td>l(i)</td>
<td>0</td>
<td>0</td>
<td>8</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Il n’y a alors plus qu’à lire le couple <span
class="math inline">\((i, l(i))\)</span> correspondant au maximum pour
<span class="math inline">\(f\)</span>.</p>
<p>On programme cela directement en décorant le programme précédent
:</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">let</span> maxsubarray t =</span>
<span id="cb17-2"><a href="#cb17-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    <span class="kw">let</span> f = <span class="dt">Array</span>.make n <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>    <span class="kw">let</span> l = <span class="dt">Array</span>.make n <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>    f.(n<span class="dv">-1</span>) &lt;- t.(n<span class="dv">-1</span>);</span>
<span id="cb17-6"><a href="#cb17-6"></a>    <span class="kw">for</span> i = n<span class="dv">-2</span> <span class="kw">to</span> <span class="dv">0</span> <span class="kw">do</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>        <span class="kw">if</span> f.(i+<span class="dv">1</span>) &gt; <span class="dv">0</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>        <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>            f.(i) &lt;- t.(i) + f.(i+<span class="dv">1</span>);</span>
<span id="cb17-10"><a href="#cb17-10"></a>            l.(i) &lt;- <span class="dv">1</span> + l.(i+<span class="dv">1</span>)</span>
<span id="cb17-11"><a href="#cb17-11"></a>        <span class="kw">end</span> <span class="kw">else</span> f.(i) &lt;- t.(i)</span>
<span id="cb17-12"><a href="#cb17-12"></a>    <span class="kw">done</span>;</span>
<span id="cb17-13"><a href="#cb17-13"></a>    <span class="kw">let</span> m = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb17-14"><a href="#cb17-14"></a>    <span class="kw">for</span> i = <span class="dv">1</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>        <span class="kw">if</span> f.(!m) &lt; f.(i)</span>
<span id="cb17-16"><a href="#cb17-16"></a>        <span class="kw">then</span> m := i</span>
<span id="cb17-17"><a href="#cb17-17"></a>    <span class="kw">done</span>;</span>
<span id="cb17-18"><a href="#cb17-18"></a>    !m, l.(!m)</span></code></pre></div>
<p></div></p>
<h2 data-number="3.2" id="sec:chemins-monotones"><span
class="header-section-number">3.2</span> Chemins monotones</h2>
<p>On considère ici le problème de la plus grande somme en partant du
sommet d’un triangle de nombres et descendant soit en bas à gauche ou en
bas à droite d’un cran.</p>
<pre><code>              75
             95 64
            17 47 82
           18 35 87 10
          20 04 82 47 65
         19 01 23 75 03 34
        88 02 77 73 07 63 67
       99 65 04 28 06 16 70 92
      41 41 26 56 83 40 80 70 33
     41 48 72 33 47 32 37 16 94 29
    53 71 44 65 25 43 91 52 97 51 14
   70 11 33 28 77 73 17 78 39 68 17 57
  91 71 52 38 17 14 91 43 58 50 27 29 48
 63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23</code></pre>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il s’agit des problèmes <a
href="https://projecteuler.net/problem=18">Project Euler 18</a> et <a
href="https://projecteuler.net/problem=67">Project Euler 67</a></p>
<p></div></p>
<p>Tout d’abord, on va représenter le problème sous la forme d’un
tableau de tableau, ligne par ligne, ainsi :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">let</span> t = [| </span>
<span id="cb19-2"><a href="#cb19-2"></a>   [| <span class="dv">75</span> |];</span>
<span id="cb19-3"><a href="#cb19-3"></a>   [| <span class="dv">95</span>; <span class="dv">64</span> |];</span>
<span id="cb19-4"><a href="#cb19-4"></a>   [| <span class="dv">17</span>; <span class="dv">47</span>; <span class="dv">82</span> |];</span>
<span id="cb19-5"><a href="#cb19-5"></a>   ... </span>
<span id="cb19-6"><a href="#cb19-6"></a>|]</span></code></pre></div>
<p></div></p>
<p>Ce tableau a <span class="math inline">\(n\)</span> lignes ayant de 1
à <span class="math inline">\(n\)</span> éléments. Les deux successeurs
de <code>t.(i).(j)</code> sont <code>t.(i+1).(j)</code> et
<code>t.(i+1).(j+1)</code>.</p>
<h3 data-number="3.2.1"
id="sec:notion-de-sous-problèmes-et-récurrence"><span
class="header-section-number">3.2.1</span> Notion de sous-problèmes et
récurrence</h3>
<p>Ici, on considère <span class="math inline">\(f(i,j)\)</span> la plus
grande somme à partir de la ième ligne et jème colonne. On a cherche
donc <span class="math inline">\(f(0,0)\)</span> pour répondre au
problème initial.</p>
<p>Sur la dernière ligne, pas le choix, on ne peut considérer que
l’élément lui-même, on a donc <span class="math inline">\(f(n-1, j) =
t.(n-1).(j)\)</span>.</p>
<p>Pour les autres éléments, il faut considérer les deux possibilités de
premier déplacement, en bas à gauche ou à droite, et prendre le choix
qui aboutit à la plus grande somme :</p>
<p><span class="math display">\[
\forall i \range{0}{n-2}, \forall j \in \range{0}{n-1},
f(i,j) = t.(i).(j) + \max( f(i+1, j), f(i+1, j+1) )
\]</span></p>
<p>Et ainsi, on a les dépendances <span
class="math inline">\(\mathop{dep}(i,j) = \{ (i+1, j), (i+1, j+1)
\}\)</span>.</p>
<h3 data-number="3.2.2" id="sec:résolution-naïve-et-mémoïsation"><span
class="header-section-number">3.2.2</span> Résolution naïve et
mémoïsation</h3>
<p>On implémente directement cette récurrence :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">let</span> <span class="kw">rec</span> maxpath t i j =</span>
<span id="cb20-2"><a href="#cb20-2"></a>    <span class="kw">if</span> i = <span class="dt">Array</span>.length t - <span class="dv">1</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>    <span class="kw">then</span> t.(i).(j)</span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="kw">else</span> t.(i).(j) + <span class="dt">max</span> (maxpath t (i+<span class="dv">1</span>) j)</span>
<span id="cb20-5"><a href="#cb20-5"></a>                         (maxpath t (i+<span class="dv">1</span>) (j+<span class="dv">1</span>)) </span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Pour lire le triangle depuis un fichier, on peut utiliser la fonction
suivante : <div class="ui segment code"></p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">let</span> lit_triangle f =</span>
<span id="cb21-2"><a href="#cb21-2"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux () =</span>
<span id="cb21-3"><a href="#cb21-3"></a>        <span class="kw">try</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>            <span class="kw">let</span> l = <span class="dt">input_line</span> f <span class="kw">in</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>            <span class="dt">Array</span>.of_list</span>
<span id="cb21-6"><a href="#cb21-6"></a>                (<span class="dt">List</span>.map <span class="dt">int_of_string</span></span>
<span id="cb21-7"><a href="#cb21-7"></a>                    (<span class="dt">String</span>.split_on_char <span class="ch">&#39; &#39;</span> l))</span>
<span id="cb21-8"><a href="#cb21-8"></a>            :: aux ()</span>
<span id="cb21-9"><a href="#cb21-9"></a>        <span class="kw">with</span> <span class="dt">End_of_file</span> -&gt; []</span>
<span id="cb21-10"><a href="#cb21-10"></a>    <span class="kw">in</span> <span class="dt">Array</span>.of_list (aux ())</span></code></pre></div>
<p></div></p>
<p></div></p>
<p>On modifie alors cette fonction assez rapidement pour utiliser la
mémoïsation. On prend garde notamment au fait que les clés sont
maintenant des couples d’indices <span
class="math inline">\((i,j)\)</span>.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">let</span> cache = <span class="dt">Hashtbl</span>.create <span class="dv">42</span></span>
<span id="cb22-2"><a href="#cb22-2"></a></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="kw">let</span> <span class="kw">rec</span> maxpath t i j =</span>
<span id="cb22-4"><a href="#cb22-4"></a>    <span class="kw">try</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>        <span class="dt">Hashtbl</span>.find cache (i,j)</span>
<span id="cb22-6"><a href="#cb22-6"></a>    <span class="kw">with</span> <span class="dt">Not_found</span> -&gt;</span>
<span id="cb22-7"><a href="#cb22-7"></a>        <span class="kw">let</span> v = <span class="kw">if</span> i = <span class="dt">Array</span>.length t - <span class="dv">1</span></span>
<span id="cb22-8"><a href="#cb22-8"></a>            <span class="kw">then</span> t.(i).(j)</span>
<span id="cb22-9"><a href="#cb22-9"></a>            <span class="kw">else</span> t.(i).(j) + <span class="dt">max</span> (maxpath t (i+<span class="dv">1</span>) j)</span>
<span id="cb22-10"><a href="#cb22-10"></a>                                 (maxpath t (i+<span class="dv">1</span>) (j+<span class="dv">1</span>)) </span>
<span id="cb22-11"><a href="#cb22-11"></a>        <span class="kw">in</span> <span class="dt">Hashtbl</span>.add cache (i,j) v; v</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Là encore, on peut cacher le dictionnaire dans une clôture pour créer
un cache par tableau <code>t</code>.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">let</span> maxpath t =</span>
<span id="cb23-2"><a href="#cb23-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    <span class="kw">let</span> cache = <span class="dt">Hashtbl</span>.create (n*n) <span class="kw">in</span></span>
<span id="cb23-4"><a href="#cb23-4"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux i j =</span>
<span id="cb23-5"><a href="#cb23-5"></a>        <span class="kw">try</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>            <span class="dt">Hashtbl</span>.find cache (i,j)</span>
<span id="cb23-7"><a href="#cb23-7"></a>        <span class="kw">with</span> <span class="dt">Not_found</span> -&gt;</span>
<span id="cb23-8"><a href="#cb23-8"></a>            <span class="kw">let</span> v = <span class="kw">if</span> i = <span class="dt">Array</span>.length t - <span class="dv">1</span></span>
<span id="cb23-9"><a href="#cb23-9"></a>                <span class="kw">then</span> t.(i).(j)</span>
<span id="cb23-10"><a href="#cb23-10"></a>                <span class="kw">else</span> t.(i).(j) + <span class="dt">max</span> (aux (i+<span class="dv">1</span>) j)</span>
<span id="cb23-11"><a href="#cb23-11"></a>                                     (aux (i+<span class="dv">1</span>) (j+<span class="dv">1</span>)) </span>
<span id="cb23-12"><a href="#cb23-12"></a>        <span class="kw">in</span> <span class="dt">Hashtbl</span>.add cache (i,j) v; v</span>
<span id="cb23-13"><a href="#cb23-13"></a>    <span class="kw">in</span> aux</span></code></pre></div>
<p></div></p>
<p></div></p>
<h3 data-number="3.2.3" id="sec:tabulation-1"><span
class="header-section-number">3.2.3</span> Tabulation</h3>
<p>On peut représenter le graphe de dépendances des sous problèmes :</p>
<p><center><div class="ui image center"><img
src="assets/pics/maxpathdep.png" /></div></center></p>
<p>On remarque assez naturellement qu’on peut obtenir un tri topologique
en traitant ce graphe du bas vers le haut. Ici, il suffit donc de
tabuler dans le même format triangulaire que <code>t</code> (ou dans une
matrice par simplicité) et de remplir <code>t.(i).(j)</code> par
<code>i</code> décroissant puis <code>j</code> croissant (ou
décroissant).</p>
<p>On en déduit alors le programme suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">let</span> maxpath t =</span>
<span id="cb24-2"><a href="#cb24-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>    <span class="kw">let</span> som = <span class="dt">Array</span>.make_matrix n n <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>    <span class="kw">for</span> j = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>        som.(n<span class="dv">-1</span>).(j) &lt;- t.(n<span class="dv">-1</span>).(j)</span>
<span id="cb24-6"><a href="#cb24-6"></a>    <span class="kw">done</span>;</span>
<span id="cb24-7"><a href="#cb24-7"></a>    <span class="kw">for</span> i = n<span class="dv">-2</span> <span class="kw">downto</span> <span class="dv">0</span> <span class="kw">do</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>        <span class="kw">for</span> j = <span class="dv">0</span> <span class="kw">to</span> i <span class="kw">do</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>            som.(i).(j) &lt;- t.(i).(j)</span>
<span id="cb24-10"><a href="#cb24-10"></a>                + <span class="dt">max</span> som.(i+<span class="dv">1</span>).(j) som.(i+<span class="dv">1</span>).(j+<span class="dv">1</span>)</span>
<span id="cb24-11"><a href="#cb24-11"></a>        <span class="kw">done</span></span>
<span id="cb24-12"><a href="#cb24-12"></a>    <span class="kw">done</span>;</span>
<span id="cb24-13"><a href="#cb24-13"></a>    som.(<span class="dv">0</span>).(<span class="dv">0</span>)</span></code></pre></div>
<p></div></p>
<h3 data-number="3.2.4" id="sec:reconstruction-2"><span
class="header-section-number">3.2.4</span> Reconstruction</h3>
<p>Pour reconstruire un chemin de plus grande somme, il suffit de se
souvenir des embranchements pris en calculant le maximum. Pour cela, on
construit de même un tableau (ou une matrice pour simplifier)
<code>choix</code> où <code>choix.(i).(j)</code> indique
<code>Gauche</code> ou <code>Droite</code>.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">type</span> choix = Gauche | Droite</span>
<span id="cb25-2"><a href="#cb25-2"></a></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="kw">let</span> maxpath t =</span>
<span id="cb25-4"><a href="#cb25-4"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>    <span class="kw">let</span> som = <span class="dt">Array</span>.make_matrix n n <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb25-6"><a href="#cb25-6"></a>    <span class="kw">let</span> ch = <span class="dt">Array</span>.make_matrix n n <span class="dt">None</span> <span class="kw">in</span></span>
<span id="cb25-7"><a href="#cb25-7"></a>    <span class="kw">for</span> j = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb25-8"><a href="#cb25-8"></a>        som.(n<span class="dv">-1</span>).(j) &lt;- t.(n<span class="dv">-1</span>).(j)</span>
<span id="cb25-9"><a href="#cb25-9"></a>    <span class="kw">done</span>;</span>
<span id="cb25-10"><a href="#cb25-10"></a>    <span class="kw">for</span> i = n<span class="dv">-2</span> <span class="kw">downto</span> <span class="dv">0</span> <span class="kw">do</span></span>
<span id="cb25-11"><a href="#cb25-11"></a>        <span class="kw">for</span> j = <span class="dv">0</span> <span class="kw">to</span> i <span class="kw">do</span></span>
<span id="cb25-12"><a href="#cb25-12"></a>            ch.(i).(j) &lt;- <span class="dt">Some</span> (<span class="kw">if</span> som.(i+<span class="dv">1</span>).(j) &gt; som.(i+<span class="dv">1</span>).(j+<span class="dv">1</span>)</span>
<span id="cb25-13"><a href="#cb25-13"></a>                          <span class="kw">then</span> Gauche <span class="kw">else</span> Droite);</span>
<span id="cb25-14"><a href="#cb25-14"></a>            som.(i).(j) &lt;- t.(i).(j)</span>
<span id="cb25-15"><a href="#cb25-15"></a>                + <span class="dt">max</span> som.(i+<span class="dv">1</span>).(j) som.(i+<span class="dv">1</span>).(j+<span class="dv">1</span>)</span>
<span id="cb25-16"><a href="#cb25-16"></a>        <span class="kw">done</span></span>
<span id="cb25-17"><a href="#cb25-17"></a>    <span class="kw">done</span>;</span>
<span id="cb25-18"><a href="#cb25-18"></a>    <span class="kw">let</span> <span class="kw">rec</span> chemin i j =</span>
<span id="cb25-19"><a href="#cb25-19"></a>        (i,j) :: <span class="kw">match</span> ch.(i).(j)</span>
<span id="cb25-20"><a href="#cb25-20"></a>        <span class="kw">with</span> <span class="dt">None</span> -&gt; [ ]</span>
<span id="cb25-21"><a href="#cb25-21"></a>        | <span class="dt">Some</span> Gauche -&gt; chemin (i+<span class="dv">1</span>) j</span>
<span id="cb25-22"><a href="#cb25-22"></a>        | <span class="dt">Some</span> Droite -&gt; chemin (i+<span class="dv">1</span>) (j+<span class="dv">1</span>)</span>
<span id="cb25-23"><a href="#cb25-23"></a>    <span class="kw">in</span> chemin <span class="dv">0</span> <span class="dv">0</span></span></code></pre></div>
<p></div></p>
<h3 data-number="3.2.5" id="sec:complexité-1"><span
class="header-section-number">3.2.5</span> Complexité</h3>
<p>Il faut explorer chaque case pour pouvoir conclure, donc on sait que
la complexité temporelle est au mieux en <span
class="math inline">\(O(n^2)\)</span> ce qui est atteint ici. Comme on a
utilisé des tableaux de mêmes dimensions pour la tabulation ou le cache,
on est également en <span class="math inline">\(O(n^2)\)</span> en
espace.</p>
<h2 data-number="3.3" id="sec:produit-de-matrices"><span
class="header-section-number">3.3</span> Produit de matrices</h2>
<p>On souhaite calculer un produit <span class="math inline">\(A_0 \dots
A_{n-1}\)</span> de matrices. Pour cela, on aimerait découper le calcul
en produit de deux matrices, cela revient à placer des parenthèses.</p>
<p>Le problème est qu’une multiplication matriciel effectue un nombre
d’opérations de l’ordre de <span class="math inline">\(m n p\)</span>
quand on multiplie une matrice <span
class="math inline">\((m,n)\)</span> et une matrice <span
class="math inline">\((n,p)\)</span>. Pour simplifier, on considèra que
la constante ici vaut <span class="math inline">\(1\)</span> et on
cherche le plus petit nombre d’opérations à effectuer.</p>
<h3 data-number="3.3.1"
id="sec:notion-de-sous-problème-et-récurrence-1"><span
class="header-section-number">3.3.1</span> Notion de sous-problème et
récurrence</h3>
<p>Tout d’abord, on remarque que si le produit <span
class="math inline">\(A_i A_{i+1}\)</span> est licite, alors <span
class="math inline">\(A_i\)</span> a autant de colonnes que <span
class="math inline">\(A_{i+1}\)</span> a de lignes. Il suffit donc ne
donner que le tableau des lignes et le nombre de colonne de <span
class="math inline">\(A_n\)</span>.</p>
<p>On considère donc le tableau <code>t</code> de <code>n+1</code>
valeurs où la matrice <span class="math inline">\(A_i\)</span> a
<code>t[i]</code> lignes <code>t[i+1]</code> colonnes.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on considère <span class="math inline">\(A_0 \dots A_5\)</span> de
dimensions respectives <span class="math inline">\((30,35), (35,15),
(15, 5), (5, 10), (10, 20)\)</span> et <span class="math inline">\((20,
25)\)</span>, on aura ainsi le tableau :</p>
<table style="width:57%;">
<colgroup>
<col style="width: 8%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="header">
<th>i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>t[i]</td>
<td>30</td>
<td>35</td>
<td>15</td>
<td>5</td>
<td>10</td>
<td>20</td>
<td>25</td>
</tr>
</tbody>
</table>
</div>
<p>Effectuer un produit et placer des parenthèses va naturellement
induire deux sous-problèmes portant sur des matrices rangées à la suite.
C’est pour cela qu’on introduit le problème du calcul de <span
class="math inline">\(f(i,j)\)</span> plus petit nombre d’opérations
pour multiplier les matrices <span class="math inline">\(A_i A_{i+1}
\dots A_j\)</span>.</p>
<p>Si <span class="math inline">\(i = j\)</span>, on n’a pas de
mulitplications à faire et on a directement <span
class="math inline">\(f(i,i) = 0\)</span>. Sinon, on va forcément faire
un produit <span class="math inline">\((A_i \dots A_k)(A_{k+1} \dots
A_j)\)</span> pour <span class="math inline">\(i \le k &lt; j\)</span>.
Il suffit d’effectuer le moins couteux :</p>
<p><span class="math display">\[
\forall i &lt; j,
f(i,j) = t[i]t[k+1]t[j+1] + \min_{i \le k &lt; j}
\left(
f(i,k) + f(k+1,j)
\right)
\]</span></p>
<h3 data-number="3.3.2" id="sec:récurrence-naïve-et-mémoïsation-1"><span
class="header-section-number">3.3.2</span> Récurrence naïve et
mémoïsation</h3>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">let</span> <span class="kw">rec</span> matmult t i j =</span>
<span id="cb26-2"><a href="#cb26-2"></a>    <span class="kw">if</span> i = j</span>
<span id="cb26-3"><a href="#cb26-3"></a>    <span class="kw">then</span> <span class="dv">0</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>    <span class="kw">else</span> <span class="kw">let</span> m = <span class="dt">ref</span> (t.(i) * t.(i+<span class="dv">1</span>) * t.(j+<span class="dv">1</span>) </span>
<span id="cb26-5"><a href="#cb26-5"></a>            + matmult t (i+<span class="dv">1</span>) j) <span class="kw">in</span></span>
<span id="cb26-6"><a href="#cb26-6"></a>        <span class="kw">for</span> k = i+<span class="dv">1</span> <span class="kw">to</span> j<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb26-7"><a href="#cb26-7"></a>            m := <span class="dt">min</span> !m </span>
<span id="cb26-8"><a href="#cb26-8"></a>                (t.(i) * t.(k+<span class="dv">1</span>) * t.(j+<span class="dv">1</span>)</span>
<span id="cb26-9"><a href="#cb26-9"></a>                    + matmult t i k + matmult t (k+<span class="dv">1</span>) j)</span>
<span id="cb26-10"><a href="#cb26-10"></a>        <span class="kw">done</span>;</span>
<span id="cb26-11"><a href="#cb26-11"></a>        !m</span></code></pre></div>
<p></div></p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">let</span> matmult t =</span>
<span id="cb27-2"><a href="#cb27-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb27-3"><a href="#cb27-3"></a>    <span class="kw">let</span> cache = <span class="dt">Hashtbl</span>.create (n*n) <span class="kw">in</span></span>
<span id="cb27-4"><a href="#cb27-4"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux i j =</span>
<span id="cb27-5"><a href="#cb27-5"></a>        <span class="kw">try</span> </span>
<span id="cb27-6"><a href="#cb27-6"></a>            <span class="dt">Hashtbl</span>.find cache (i,j)</span>
<span id="cb27-7"><a href="#cb27-7"></a>        <span class="kw">with</span> <span class="dt">Not_found</span> -&gt;</span>
<span id="cb27-8"><a href="#cb27-8"></a>            <span class="kw">let</span> v =  <span class="kw">if</span> i = j</span>
<span id="cb27-9"><a href="#cb27-9"></a>                <span class="kw">then</span> <span class="dv">0</span></span>
<span id="cb27-10"><a href="#cb27-10"></a>                <span class="kw">else</span> </span>
<span id="cb27-11"><a href="#cb27-11"></a>                    <span class="kw">let</span> m = <span class="dt">ref</span> (t.(i) * t.(i+<span class="dv">1</span>) * t.(j+<span class="dv">1</span>) </span>
<span id="cb27-12"><a href="#cb27-12"></a>                        + matmult t (i+<span class="dv">1</span>) j) <span class="kw">in</span></span>
<span id="cb27-13"><a href="#cb27-13"></a>                    <span class="kw">for</span> k = i+<span class="dv">1</span> <span class="kw">to</span> j<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb27-14"><a href="#cb27-14"></a>                        m := <span class="dt">min</span> !m </span>
<span id="cb27-15"><a href="#cb27-15"></a>                            (t.(i) * t.(k+<span class="dv">1</span>) * t.(j+<span class="dv">1</span>)</span>
<span id="cb27-16"><a href="#cb27-16"></a>                                + aux i k </span>
<span id="cb27-17"><a href="#cb27-17"></a>                                + aux (k+<span class="dv">1</span>) j)</span>
<span id="cb27-18"><a href="#cb27-18"></a>                    <span class="kw">done</span>;</span>
<span id="cb27-19"><a href="#cb27-19"></a>                    !m</span>
<span id="cb27-20"><a href="#cb27-20"></a>            <span class="kw">in</span> <span class="dt">Hashtbl</span>.add cache (i,j) v; v</span>
<span id="cb27-21"><a href="#cb27-21"></a>    <span class="kw">in</span> aux</span></code></pre></div>
<p></div></p>
<h3 data-number="3.3.3" id="sec:tabulation-2"><span
class="header-section-number">3.3.3</span> Tabulation</h3>
<p>Ici, il est plus simple de représenter le graphe de dépendance sur
une grille où chaque case représente un couple <span
class="math inline">\((i,j)\)</span>. Ainsi, dans l’exemple considéré,
les cases <span class="math inline">\((0,2), (1,2), (2,3)\)</span> et
<span class="math inline">\((3,4)\)</span> dépendent de <span
class="math inline">\((2,2)\)</span>. Ces relations de dépendance sont
indiqués sur le schéma suivant en rouge :</p>
<p><center><div class="ui image center"><img
src="assets/pics/remplissagemat.png" /></div></center></p>
<p>Pour trouver un tri topologique, il faut renverser ces dépendances :
pour calculer <span class="math inline">\((i,j)\)</span> on va avoir
besoin de toutes les cases au dessus et à gauche jusqu’à tomber sur la
diagonale. On peut donc remplir de haut en bas et de gauche à droite, ce
qui assure qu’à tout moment, lorsqu’on remplit une case, on a déjà
calculé ses dépendances :</p>
<p><center><div class="ui image center"><img
src="assets/pics/remplissagematordre.png" /></div></center></p>
<p>Cela correspond au programme suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">let</span> matmult t =</span>
<span id="cb28-2"><a href="#cb28-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>    <span class="kw">let</span> cout = <span class="dt">Array</span>.make_matrix (n<span class="dv">-1</span>) (n<span class="dv">-1</span>) <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb28-4"><a href="#cb28-4"></a>    <span class="kw">for</span> i = n<span class="dv">-2</span> <span class="kw">downto</span> <span class="dv">0</span> <span class="kw">do</span></span>
<span id="cb28-5"><a href="#cb28-5"></a>        <span class="kw">for</span> j = i+<span class="dv">1</span> <span class="kw">to</span> n<span class="dv">-2</span> <span class="kw">do</span></span>
<span id="cb28-6"><a href="#cb28-6"></a>            <span class="kw">let</span> m = <span class="dt">ref</span> (t.(i) * t.(i+<span class="dv">1</span>) * t.(j+<span class="dv">1</span>) </span>
<span id="cb28-7"><a href="#cb28-7"></a>                        + cout.(i+<span class="dv">1</span>).(j)) <span class="kw">in</span></span>
<span id="cb28-8"><a href="#cb28-8"></a>            <span class="kw">for</span> k = i+<span class="dv">1</span> <span class="kw">to</span> j<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb28-9"><a href="#cb28-9"></a>                m := <span class="dt">min</span> !m </span>
<span id="cb28-10"><a href="#cb28-10"></a>                    (t.(i) * t.(k+<span class="dv">1</span>) * t.(j+<span class="dv">1</span>)</span>
<span id="cb28-11"><a href="#cb28-11"></a>                        + cout.(i).(k) </span>
<span id="cb28-12"><a href="#cb28-12"></a>                        + cout.(k+<span class="dv">1</span>).(j))</span>
<span id="cb28-13"><a href="#cb28-13"></a>            <span class="kw">done</span>;</span>
<span id="cb28-14"><a href="#cb28-14"></a>            cout.(i).(j) &lt;- !m</span>
<span id="cb28-15"><a href="#cb28-15"></a>        <span class="kw">done</span></span>
<span id="cb28-16"><a href="#cb28-16"></a>    <span class="kw">done</span>;</span>
<span id="cb28-17"><a href="#cb28-17"></a>    cout.(<span class="dv">0</span>).(n<span class="dv">-2</span>)</span></code></pre></div>
<p></div></p>
<h3 data-number="3.3.4" id="sec:reconstruction-3"><span
class="header-section-number">3.3.4</span> Reconstruction</h3>
<p>Pour recontruire un parenthésage on va constuire un arbre en plaçant
dans un tableau l’arbre du calcul de <span class="math inline">\(A_i
\dots A_j\)</span> à la case <span
class="math inline">\((i,j)\)</span>.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">type</span> arbre = Feuille <span class="kw">of</span> <span class="dt">int</span> | Noeud <span class="kw">of</span> arbre * arbre</span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="kw">let</span> matmult t =</span>
<span id="cb29-4"><a href="#cb29-4"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb29-5"><a href="#cb29-5"></a>    <span class="kw">let</span> cout = <span class="dt">Array</span>.make_matrix (n<span class="dv">-1</span>) (n<span class="dv">-1</span>) <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb29-6"><a href="#cb29-6"></a>    <span class="kw">let</span> arbres = <span class="dt">Array</span>.make_matrix (n<span class="dv">-1</span>) (n<span class="dv">-1</span>) (Feuille (<span class="dv">-1</span>)) <span class="kw">in</span></span>
<span id="cb29-7"><a href="#cb29-7"></a>    <span class="kw">for</span> i = n<span class="dv">-2</span> <span class="kw">downto</span> <span class="dv">0</span> <span class="kw">do</span></span>
<span id="cb29-8"><a href="#cb29-8"></a>        arbres.(i).(i) &lt;- Feuille i;</span>
<span id="cb29-9"><a href="#cb29-9"></a>        <span class="kw">for</span> j = i+<span class="dv">1</span> <span class="kw">to</span> n<span class="dv">-2</span> <span class="kw">do</span></span>
<span id="cb29-10"><a href="#cb29-10"></a>            <span class="kw">let</span> m = <span class="dt">ref</span> (t.(i) * t.(i+<span class="dv">1</span>) * t.(j+<span class="dv">1</span>) </span>
<span id="cb29-11"><a href="#cb29-11"></a>                        + cout.(i+<span class="dv">1</span>).(j)) <span class="kw">in</span></span>
<span id="cb29-12"><a href="#cb29-12"></a>            <span class="kw">let</span> a = <span class="dt">ref</span> (Noeud(arbres.(i).(i), </span>
<span id="cb29-13"><a href="#cb29-13"></a>                               arbres.(i+<span class="dv">1</span>).(j))) <span class="kw">in</span></span>
<span id="cb29-14"><a href="#cb29-14"></a>            <span class="kw">for</span> k = i+<span class="dv">1</span> <span class="kw">to</span> j<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb29-15"><a href="#cb29-15"></a>                <span class="kw">let</span> v = t.(i) * t.(k+<span class="dv">1</span>) * t.(j+<span class="dv">1</span>)</span>
<span id="cb29-16"><a href="#cb29-16"></a>                        + cout.(i).(k) </span>
<span id="cb29-17"><a href="#cb29-17"></a>                        + cout.(k+<span class="dv">1</span>).(j)</span>
<span id="cb29-18"><a href="#cb29-18"></a>                <span class="kw">in</span></span>
<span id="cb29-19"><a href="#cb29-19"></a>                <span class="kw">if</span> v &lt; !m</span>
<span id="cb29-20"><a href="#cb29-20"></a>                <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb29-21"><a href="#cb29-21"></a>                    m := v;</span>
<span id="cb29-22"><a href="#cb29-22"></a>                    a := Noeud(arbres.(i).(k),</span>
<span id="cb29-23"><a href="#cb29-23"></a>                               arbres.(k+<span class="dv">1</span>).(j))</span>
<span id="cb29-24"><a href="#cb29-24"></a>                <span class="kw">end</span></span>
<span id="cb29-25"><a href="#cb29-25"></a>            <span class="kw">done</span>;</span>
<span id="cb29-26"><a href="#cb29-26"></a>            cout.(i).(j) &lt;- !m;</span>
<span id="cb29-27"><a href="#cb29-27"></a>            arbres.(i).(j) &lt;- !a</span>
<span id="cb29-28"><a href="#cb29-28"></a>        <span class="kw">done</span></span>
<span id="cb29-29"><a href="#cb29-29"></a>    <span class="kw">done</span>;</span>
<span id="cb29-30"><a href="#cb29-30"></a>    arbres.(<span class="dv">0</span>).(n<span class="dv">-2</span>)</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Dans l’exemple précédent on va renvoyer l’arbre
<center><div class="ui image center"><img
src="assets/pics/arbreproduitmat.png" /></div></center></p>
<p>qui correspond au produit <span
class="math inline">\((A_0(A_1A_2))((A_3A_4)A_5)\)</span>.</p>
</div>
<h2 data-number="3.4"
id="sec:plus-longue-sous-séquence-croissante"><span
class="header-section-number">3.4</span> Plus longue sous-séquence
croissante</h2>
<p>On se donne un tableau <span class="math inline">\(t\)</span> de
<span class="math inline">\(n\)</span> nombres entiers et on demande de
déterminer un <span class="math inline">\(p\)</span>-uplet <span
class="math inline">\((i_1,\dots,i_p)\)</span>, où <span
class="math inline">\(t(i_1) &lt; t(i_2) &lt; \dots &lt;
t(i_p)\)</span>, pour lequel <span class="math inline">\(p\)</span> est
maximal.</p>
<h3 data-number="3.4.1"
id="sec:notion-de-sous-problème-et-récurrence-2"><span
class="header-section-number">3.4.1</span> Notion de sous-problème et
récurrence</h3>
<p>On reprend ici directement ce qui avait été fait pour le premier
exemple : on considère <span class="math inline">\(f(i)\)</span> la
longueur du plus grand <span class="math inline">\(p\)</span>-uplet
<span class="math inline">\((i, i_2, \dots, i_p)\)</span> où <span
class="math inline">\(t(i) &lt; t(i_1) &lt; \dots &lt; t(i_p)\)</span>.
Autrement dit, on oblige la sous-séquence à commencer par <span
class="math inline">\(t(i)\)</span>.</p>
<p>On a donc <span class="math inline">\(f(n-1) = 1\)</span> car elle ne
peut contenir qu’une valeur. Ensuite, on considère <span
class="math inline">\(\Phi(i) = \enscomp{j}{j &gt; i \wedge t[j] &gt;
t[i]}\)</span> et on a</p>
<p><span class="math display">\[
\forall i &lt; n-1, f(i) = \begin{cases}
1 &amp; \text{si } \Phi(i) = \emptyset \\
1 + \max_{j \in \Phi(i)} f(j)  &amp; \text{sinon.}
\end{cases}
\]</span></p>
<h3 data-number="3.4.2" id="sec:récurrence-naïve-et-mémoïsation-2"><span
class="header-section-number">3.4.2</span> Récurrence naïve et
mémoïsation</h3>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">let</span> <span class="kw">rec</span> croissante t i =</span>
<span id="cb30-2"><a href="#cb30-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>    <span class="kw">if</span> i = n<span class="dv">-1</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>    <span class="kw">then</span> <span class="dv">1</span></span>
<span id="cb30-5"><a href="#cb30-5"></a>    <span class="kw">else</span> <span class="kw">let</span> m = <span class="dt">ref</span> <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb30-6"><a href="#cb30-6"></a>        <span class="kw">for</span> j = i+<span class="dv">1</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb30-7"><a href="#cb30-7"></a>            <span class="kw">if</span> t.(j) &gt; t.(i)</span>
<span id="cb30-8"><a href="#cb30-8"></a>            <span class="kw">then</span> m := <span class="dt">max</span> !m (<span class="dv">1</span> + croissante t j)</span>
<span id="cb30-9"><a href="#cb30-9"></a>        <span class="kw">done</span>;</span>
<span id="cb30-10"><a href="#cb30-10"></a>        !m</span></code></pre></div>
<p></div></p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">let</span> croissante t =</span>
<span id="cb31-2"><a href="#cb31-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>    <span class="kw">let</span> cache = <span class="dt">Hashtbl</span>.create n <span class="kw">in</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux i =</span>
<span id="cb31-5"><a href="#cb31-5"></a>        <span class="kw">try</span></span>
<span id="cb31-6"><a href="#cb31-6"></a>            <span class="dt">Hashtbl</span>.find cache i</span>
<span id="cb31-7"><a href="#cb31-7"></a>        <span class="kw">with</span> <span class="dt">Not_found</span> -&gt;</span>
<span id="cb31-8"><a href="#cb31-8"></a>            <span class="kw">let</span> v = <span class="kw">if</span> i = n<span class="dv">-1</span></span>
<span id="cb31-9"><a href="#cb31-9"></a>                    <span class="kw">then</span> <span class="dv">1</span></span>
<span id="cb31-10"><a href="#cb31-10"></a>                    <span class="kw">else</span> <span class="kw">let</span> m = <span class="dt">ref</span> <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb31-11"><a href="#cb31-11"></a>                        <span class="kw">for</span> j = i+<span class="dv">1</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb31-12"><a href="#cb31-12"></a>                            <span class="kw">if</span> t.(j) &gt; t.(i)</span>
<span id="cb31-13"><a href="#cb31-13"></a>                            <span class="kw">then</span> m := <span class="dt">max</span> !m (<span class="dv">1</span> + aux j)</span>
<span id="cb31-14"><a href="#cb31-14"></a>                        <span class="kw">done</span>;</span>
<span id="cb31-15"><a href="#cb31-15"></a>                    !m</span>
<span id="cb31-16"><a href="#cb31-16"></a>            <span class="kw">in</span> <span class="dt">Hashtbl</span>.add cache i v; v</span>
<span id="cb31-17"><a href="#cb31-17"></a>    <span class="kw">in</span> aux</span></code></pre></div>
<p></div></p>
<h3 data-number="3.4.3" id="sec:tabulation-3"><span
class="header-section-number">3.4.3</span> Tabulation</h3>
<p>On reprend ici aussi le même principe que pour la tabulation de la
sous-séquence maximale, c’est-à-dire qu’on va remplir de droite à
gauche.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">let</span> croissante t =</span>
<span id="cb32-2"><a href="#cb32-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>    <span class="kw">let</span> f = <span class="dt">Array</span>.make n <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>    <span class="kw">for</span> i = n<span class="dv">-2</span> <span class="kw">downto</span> <span class="dv">0</span> <span class="kw">do</span></span>
<span id="cb32-5"><a href="#cb32-5"></a>        <span class="kw">for</span> j = i+<span class="dv">1</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb32-6"><a href="#cb32-6"></a>            <span class="kw">if</span> t.(j) &gt; t.(i)</span>
<span id="cb32-7"><a href="#cb32-7"></a>            <span class="kw">then</span> f.(i) &lt;- <span class="dv">1</span> + f.(j)</span>
<span id="cb32-8"><a href="#cb32-8"></a>        <span class="kw">done</span></span>
<span id="cb32-9"><a href="#cb32-9"></a>    <span class="kw">done</span>;</span>
<span id="cb32-10"><a href="#cb32-10"></a>    f</span></code></pre></div>
<p></div></p>
<h3 data-number="3.4.4" id="sec:reconstruction-4"><span
class="header-section-number">3.4.4</span> Reconstruction</h3>
<p>On va conserver dans un tableau le suivant potentiel d’un indice dans
une plus grande sous-séquence croissante commençant par lui.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">let</span> croissante t =</span>
<span id="cb33-2"><a href="#cb33-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb33-3"><a href="#cb33-3"></a>    <span class="kw">let</span> f = <span class="dt">Array</span>.make n <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb33-4"><a href="#cb33-4"></a>    <span class="kw">let</span> suivant = <span class="dt">Array</span>.make n <span class="dt">None</span> <span class="kw">in</span></span>
<span id="cb33-5"><a href="#cb33-5"></a>    <span class="kw">for</span> i = n<span class="dv">-2</span> <span class="kw">downto</span> <span class="dv">0</span> <span class="kw">do</span></span>
<span id="cb33-6"><a href="#cb33-6"></a>        <span class="kw">for</span> j = i+<span class="dv">1</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb33-7"><a href="#cb33-7"></a>            <span class="kw">if</span> t.(j) &gt; t.(i) &amp;&amp; f.(i) &lt; <span class="dv">1</span> + f.(j)</span>
<span id="cb33-8"><a href="#cb33-8"></a>            <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb33-9"><a href="#cb33-9"></a>                f.(i) &lt;- <span class="dv">1</span> + f.(j);</span>
<span id="cb33-10"><a href="#cb33-10"></a>                suivant.(i) &lt;- <span class="dt">Some</span> j</span>
<span id="cb33-11"><a href="#cb33-11"></a>            <span class="kw">end</span></span>
<span id="cb33-12"><a href="#cb33-12"></a>        <span class="kw">done</span>;</span>
<span id="cb33-13"><a href="#cb33-13"></a>    <span class="kw">done</span>;</span>
<span id="cb33-14"><a href="#cb33-14"></a>    f, suivant</span>
<span id="cb33-15"><a href="#cb33-15"></a></span>
<span id="cb33-16"><a href="#cb33-16"></a><span class="kw">let</span> sous_sequence_croissante t =</span>
<span id="cb33-17"><a href="#cb33-17"></a>    <span class="kw">let</span> f, suivant = croissante t <span class="kw">in</span></span>
<span id="cb33-18"><a href="#cb33-18"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length t <span class="kw">in</span></span>
<span id="cb33-19"><a href="#cb33-19"></a>    <span class="kw">let</span> mi = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb33-20"><a href="#cb33-20"></a>    <span class="kw">for</span> i = <span class="dv">1</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb33-21"><a href="#cb33-21"></a>        <span class="kw">if</span> f.(i) &gt; f.(!mi)</span>
<span id="cb33-22"><a href="#cb33-22"></a>        <span class="kw">then</span> mi := i</span>
<span id="cb33-23"><a href="#cb33-23"></a>    <span class="kw">done</span>;</span>
<span id="cb33-24"><a href="#cb33-24"></a>    <span class="kw">let</span> seq = <span class="dt">ref</span> [ !mi ] <span class="kw">in</span></span>
<span id="cb33-25"><a href="#cb33-25"></a>    <span class="kw">while</span> suivant.(!mi) &lt;&gt; <span class="dt">None</span> <span class="kw">do</span></span>
<span id="cb33-26"><a href="#cb33-26"></a>        mi := Option.get suivant.(!mi);</span>
<span id="cb33-27"><a href="#cb33-27"></a>        seq := !mi :: !seq</span>
<span id="cb33-28"><a href="#cb33-28"></a>    <span class="kw">done</span>;</span>
<span id="cb33-29"><a href="#cb33-29"></a>    <span class="dt">List</span>.rev !seq</span></code></pre></div>
<p></div></p>
<h2 data-number="3.5" id="sec:distance-dédition"><span
class="header-section-number">3.5</span> Distance d’édition</h2>
<p>Étant donné deux chaînes de caractères (on pourra considérer des pour
simplifier) <span class="math inline">\(A\)</span> et <span
class="math inline">\(B\)</span> de longueurs respectives <span
class="math inline">\(n\)</span> et <span
class="math inline">\(m\)</span>, on veut transformer la chaîne <span
class="math inline">\(A\)</span> en la chaîne <span
class="math inline">\(B\)</span> en effectuant un minimum d’opérations
parmi celles-ci :</p>
<ul>
<li>supprimer un caractère n’importe où</li>
<li>insérer un nouveau caractère n’importe où</li>
<li>changer un caractère en n’importe quel autre.</li>
</ul>
<p>Ce nombre d’opération est appelée la distance d’édition de <span
class="math inline">\(A\)</span> à <span
class="math inline">\(B\)</span>. Écrire un algorithme permettant de la
calculer.</p>
<p>Par exemple : chien <span class="math inline">\(\rightarrow\)</span>
chen <span class="math inline">\(\rightarrow\)</span> chan <span
class="math inline">\(\rightarrow\)</span> chat</p>
<h2 data-number="3.6"
id="sec:plus-longue-sous-séquence-palindromique"><span
class="header-section-number">3.6</span> Plus longue sous-séquence
palindromique</h2>
<p>On se donne une chaine de caractère et on cherche la plus longue
chaine extraite qui soit un palindrome.</p>
<p>Par exemple, dans <code>abracadabra</code> il y a
<code>aradara</code> comme plus long palindrome extrait.</p>
<p>Déterminer une plus longue sous-séquence palindromique d’une chaine
de caractères.</p>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
