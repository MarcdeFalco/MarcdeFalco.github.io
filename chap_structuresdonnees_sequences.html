<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Séquences et ses implémentations : tableaux, listes chaînées</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Séquences et ses implémentations : tableaux, listes chaînées
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:structure-abstraite-séquence-ou-liste"><span>1</span> Structure abstraite séquence ou liste</a><div class="menu"></div></div><div class="item header"> <a href="#sec:implémentations"><span>2</span> Implémentations</a><div class="menu"></div></div><div class="item header"> <a href="#sec:implémentations-concrètes-des-listes-chaînées"><span>3</span> Implémentations concrètes des Listes chaînées</a><div class="menu"><a class="item" href="#sec:en-c"><div class="ui label">3.1</div> En <code>C</code></a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:représentation-et-type"><i class="circle icon"></i> Représentation et type</a><a style="font-size:0.6em" class="item" href="#sec:constructeur"><i class="circle icon"></i> Constructeur</a><a style="font-size:0.6em" class="item" href="#sec:destructeur"><i class="circle icon"></i> Destructeur</a><a style="font-size:0.6em" class="item" href="#sec:ajout-et-suppression-en-tête"><i class="circle icon"></i> Ajout et suppression en tête</a><a style="font-size:0.6em" class="item" href="#sec:longueur-de-la-liste"><i class="circle icon"></i> Longueur de la liste</a><a style="font-size:0.6em" class="item" href="#sec:accès-au-nième-maillon-de-la-liste"><i class="circle icon"></i> Accès au nième maillon de la liste</a><a style="font-size:0.6em" class="item" href="#sec:ajoutsuppression-ailleurs-quen-tête"><i class="circle icon"></i> Ajout/Suppression ailleurs qu’en tête</a><a style="font-size:0.6em" class="item" href="#sec:autres-implémentations"><i class="circle icon"></i> Autres implémentations</a></div><a class="item" href="#sec:en-ocaml"><div class="ui label">3.2</div> En <code>OCaml</code></a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:cas-des-a-list"><i class="circle icon"></i> Cas des <code>'a list</code></a><a style="font-size:0.6em" class="item" href="#sec:type-des-listes-chaînées"><i class="circle icon"></i> Type des listes chaînées</a><a style="font-size:0.6em" class="item" href="#sec:ajout-et-suppression-en-tête-1"><i class="circle icon"></i> Ajout et suppression en tête</a><a style="font-size:0.6em" class="item" href="#sec:exemple-de-parcours-sans-modification-calcul-de-la-longueur"><i class="circle icon"></i> Exemple de parcours sans modification : calcul de la longueur</a><a style="font-size:0.6em" class="item" href="#sec:exemple-de-parcours-avec-modification-ajout-dune-maillon-en-fin-de-liste"><i class="circle icon"></i> Exemple de parcours avec modification : ajout d’une maillon en fin de liste</a><a style="font-size:0.6em" class="item" href="#sec:raffinement-pour-permettre-lajout-à-la-fin-en-temps-constant"><i class="circle icon"></i> Raffinement pour permettre l’ajout à la fin en temps constant</a></div><a class="item" href="#sec:structure-de-la-mémoire"><div class="ui label">3.3</div> Structure de la mémoire</a></div></div><div class="item header"> <a href="#sec:travaux-pratiques"><span>4</span> Travaux pratiques</a><div class="menu"><a class="item" href="#sec:tableaux-non-statiques-et-tableaux-dynamiques"><div class="ui label">4.1</div> Tableaux non statiques et tableaux dynamiques</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:type-array"><i class="circle icon"></i> Type <code>array</code></a><a style="font-size:0.6em" class="item" href="#sec:allocation-initialisation-libération"><i class="circle icon"></i> Allocation, Initialisation, Libération</a><a style="font-size:0.6em" class="item" href="#sec:affichage-copie"><i class="circle icon"></i> Affichage, copie</a><a style="font-size:0.6em" class="item" href="#sec:implémentation-dune-pile-non-bornée"><i class="circle icon"></i> Implémentation d’une pile non bornée</a><a style="font-size:0.6em" class="item" href="#sec:tableaux-dynamiques"><i class="circle icon"></i> Tableaux dynamiques</a></div><a class="item" href="#sec:listes-chaînées"><div class="ui label">4.2</div> Listes chaînées</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:listes-simplement-chaînées"><i class="circle icon"></i> Listes simplement chaînées</a><a style="font-size:0.6em" class="item" href="#sec:listes-doublement-chaînées"><i class="circle icon"></i> Listes doublement chaînées</a></div></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Séquences et ses implémentations : tableaux, listes chaînées
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Séquences et ses implémentations : tableaux, listes chaînées     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_programmation_imperative.jpg"> </div></p>
<h1 data-number="1" id="sec:structure-abstraite-séquence-ou-liste"><span class="header-section-number">1</span> Structure abstraite séquence ou liste</h1>
<p>La structure abstraite <em>liste</em>, ou également <em>séquence</em> dans des contextes, comme en <code>OCaml</code>, où le terme <code>liste</code> fait références aux listes chaînées, est la structure la plus simple pour stocker des données.</p>
<p>Une <em>séquence</em> d’éléments de type <code>t</code> est un type <code>S(t)</code> dont les éléments représentent des valeurs du type <code>t</code> rangées séquentiellement dans un ordre, de la première à la dernière valeur. La vision logique la plus proche de cela est d’imaginer des cases ayant un indice, en commençant en général à l’indice 0, et contenant des valeurs.</p>
<h1 data-number="2" id="sec:implémentations"><span class="header-section-number">2</span> Implémentations</h1>
<h1 data-number="3" id="sec:implémentations-concrètes-des-listes-chaînées"><span class="header-section-number">3</span> Implémentations concrètes des Listes chaînées</h1>
<h2 data-number="3.1" id="sec:en-c"><span class="header-section-number">3.1</span> En <code>C</code></h2>
<h3 data-number="3.1.1" id="sec:représentation-et-type"><span class="header-section-number">3.1.1</span> Représentation et type</h3>
<p>Il existe de nombreuses possibilités d’implémentation des listes chaînées en <code>C</code>. On présente ici les opérations autour d’une implémentation et on discutera ensuite des alternatives.</p>
<p>Dans les limites du programme, on ne présente que des listes permettant de contenir un même type, ici des entiers.</p>
<p>Une liste est ainsi un pointeur sur un maillon et un maillon est un couple <code>(valeur, suivant)</code> représenté dans une <code>struct</code> où <code>suivant</code> pointe vers le prochain maillon de la chaîne. Le pointeur nul, de valeur <code>NULL</code>, permet ainsi de représenter la liste vide.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">struct</span> maillon <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="dt">int</span> valeur<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="kw">struct</span> maillon <span class="op">*</span>suivant<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="op">};</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">typedef</span> <span class="kw">struct</span> maillon maillon<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">typedef</span> maillon <span class="op">*</span>liste<span class="op">;</span></span></code></pre></div>
<p></div></p>
<p>On représentera graphiquement le pointeur nul par une croix et les maillons par des blocs contenant une valeur et un pointeur. Ainsi, le dernier maillon de la liste contient une croix. La liste <code>l</code> correspondant à la valeur qu’on pourrait noter <code>[1,2,3]</code> sera représentée ainsi :</p>
<p><center><div class="ui image center"><img src="assets/pics/exempleliste.png" /></div></center></p>
<h3 data-number="3.1.2" id="sec:constructeur"><span class="header-section-number">3.1.2</span> Constructeur</h3>
<p>On parle de constructeur pour des fonctions qui permettent d’allouer et d’initialiser une valeur d’une structure de donnée. Ici, comme les listes sont des pointeurs sur des maillons, il s’agit uniquement de créer un maillon. Pour cela, on va utiliser <code>malloc</code> pour allouer dynamiquement un nouveau maillon.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a>maillon <span class="op">*</span>maillon_creer<span class="op">(</span><span class="dt">int</span> valeur<span class="op">,</span> maillon <span class="op">*</span>suivant<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    maillon <span class="op">*</span>m <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>maillon<span class="op">));</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    m<span class="op">-&gt;</span>valeur <span class="op">=</span> valeur<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    m<span class="op">-&gt;</span>suivant <span class="op">=</span> suivant<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="cf">return</span> m<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>En fait, ce constructeur pourrait être découpé en deux parties : l’allocation qui va se charger de récupérer un emplacement mémoire pour le maillon et l’initialisation qui va attribuer des valeurs.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1"></a>maillon <span class="op">*</span>maillon_allouer<span class="op">()</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="cf">return</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>maillon<span class="op">));</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="op">}</span></span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="dt">void</span> maillon_initialiser<span class="op">(</span>maillon <span class="op">*</span>m<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">,</span> maillon <span class="op">*</span>suivant<span class="op">)</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    m<span class="op">-&gt;</span>valeur <span class="op">=</span> valeur<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    m<span class="op">-&gt;</span>suivant <span class="op">=</span> suivant<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="op">}</span></span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a>maillon <span class="op">*</span>maillon_creer<span class="op">(</span><span class="dt">int</span> valeur<span class="op">,</span> maillon <span class="op">*</span>suivant<span class="op">)</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="op">{</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>    maillon <span class="op">*</span>m <span class="op">=</span> maillon_allouer<span class="op">();</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>    maillon_initialiser<span class="op">(</span>m<span class="op">,</span> valeur<span class="op">,</span> suivant<span class="op">);</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>    <span class="cf">return</span> m<span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>On peut alors commencer à créer des listes en enchainant les maillons :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1"></a>maillon <span class="op">*</span>m1 <span class="op">=</span> creer_maillon<span class="op">(</span><span class="dv">1</span><span class="op">,</span> NULL<span class="op">);</span> <span class="co">// pas de suivant, c&#39;est le dernier maillon</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>maillon <span class="op">*</span>m2 <span class="op">=</span> creer_maillon<span class="op">(</span><span class="dv">2</span><span class="op">,</span> m1<span class="op">);</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>maillon <span class="op">*</span>m3 <span class="op">=</span> creer_maillon<span class="op">(</span><span class="dv">3</span><span class="op">,</span> m2<span class="op">);</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>liste l <span class="op">=</span> m3<span class="op">;</span> <span class="co">// la liste pointe sur le premier maillon</span></span></code></pre></div>
<p></div></p>
<p><center><div class="ui image center"><img src="assets/pics/creationliste.png" /></div></center></p>
<p>Comme le pointeur sur le premier maillon suffit ici, on aurait pu directement écrire :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1"></a>liste l <span class="op">=</span> creer_maillon<span class="op">(</span><span class="dv">3</span><span class="op">,</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>            creer_maillon<span class="op">(</span><span class="dv">2</span><span class="op">,</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>                creer_maillon<span class="op">(</span><span class="dv">1</span><span class="op">,</span> NULL<span class="op">)));</span></span></code></pre></div>
<p></div></p>
<h3 data-number="3.1.3" id="sec:destructeur"><span class="header-section-number">3.1.3</span> Destructeur</h3>
<p>Pour détruire un maillon, il suffit de libérer l’espace qu’on lui a attribué.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1"></a><span class="dt">void</span> maillon_detruire<span class="op">(</span>maillon <span class="op">*</span>m<span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    free<span class="op">(</span>m<span class="op">);</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Pour détruire une liste, on va par contre avoir besoin de parcourir l’ensemble des maillons qui la constitue. Comme pour les autres parcours, on a alors deux choix :</p>
<ul>
<li><strong>parcours récursif</strong> on a un cas de base quand la liste est vide et dans le cas général, un éventuel appel récursif sur le pointeur <code>suivant</code>.</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1"></a><span class="dt">void</span> liste_detruire<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="cf">if</span> <span class="op">(</span>l <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>        liste_detruire<span class="op">(</span>l<span class="op">-&gt;</span>suivant<span class="op">);</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>        maillon_detruire<span class="op">(</span>l<span class="op">);</span> <span class="co">// Attention à l&#39;ordre pour l-&gt;suivant </span></span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="op">}</span></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<ul>
<li><strong>parcours impératif</strong> on boucle tant que la liste est non nulle. On fait ici attention à ne pas accéder à <code>-&gt;suivant</code> après avoir libéré le maillon.</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1"></a><span class="dt">void</span> liste_detruire<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="cf">while</span> <span class="op">(</span>l <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>        liste suivante <span class="op">=</span> l<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>        maillon_detruire<span class="op">(</span>l<span class="op">);</span> </span>
<span id="cb8-7"><a href="#cb8-7"></a>        l <span class="op">=</span> suivante<span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="op">}</span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<h3 data-number="3.1.4" id="sec:ajout-et-suppression-en-tête"><span class="header-section-number">3.1.4</span> Ajout et suppression en tête</h3>
<p>Pour ajouter ou supprimer un maillon en tête de la liste, on va avoir besoin de modifier le pointeur vers le premier maillon. Pour cela, on a deux approches possibles :</p>
<ul>
<li>passer un pointeur vers la liste elle-même, c’est-à-dire un pointeur sur un pointeur sur un maillon, ce qui en <code>C</code> aura le type <code>maillon **</code>, qui s’écrit aussi <code>liste *</code>. On aura alors le prototype :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1"></a><span class="dt">void</span> liste_ajout_en_tete<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">);</span></span></code></pre></div>
<p></div></p>
<ul>
<li>renvoyer un pointeur vers le nouveau premier maillon. On aura alors le prototype :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1"></a>liste liste_ajout_en_tete<span class="op">(</span>liste l<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">);</span></span></code></pre></div>
<p></div></p>
<p>On présente ici les versions renvoyant une nouvelle liste :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1"></a>liste liste_ajout_en_tete<span class="op">(</span>liste l<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">)</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    maillon <span class="op">*</span>m <span class="op">=</span> maillon_creer<span class="op">(</span>valeur<span class="op">,</span> l<span class="op">);</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span class="cf">return</span> m<span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Si <code>l</code> est la liste précédente contenant <code>3,2,1</code> et qu’on ajoute <code>4</code> en tête, on va donc directement créer un nouveau maillon et renvoyer un pointeur vers celui-ci.</p>
<p><center><div class="ui image center"><img src="assets/pics/ajoutentete.png" /></div></center></p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1"></a>liste liste_suppr_en_tete<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    assert<span class="op">(</span>l <span class="op">!=</span> NULL<span class="op">);</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    liste queue <span class="op">=</span> l<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>    maillon_detruire<span class="op">(</span>l<span class="op">);</span> <span class="co">// Attention, on détruit juste le maillon, pas la liste</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>    <span class="cf">return</span> queue<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Si <code>l</code> est la liste précédente contenant <code>3,2,1</code> et qu’on supprime le maillon de tête, on va renvoyer un pointeur sur le second maillon. <strong>Attention</strong>, ici le pointeur initial <code>l</code> est devenu invalide.</p>
<p><center><div class="ui image center"><img src="assets/pics/supprentete.png" /></div></center></p>
<h3 data-number="3.1.5" id="sec:longueur-de-la-liste"><span class="header-section-number">3.1.5</span> Longueur de la liste</h3>
<p>On présente ici le calcul de la longueur comme exemple de parcours de la liste. C’est encore très proche du parcours effectué dans le destructeur.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1"></a><span class="dt">int</span> liste_longueur<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="dt">int</span> longueur <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="cf">while</span><span class="op">(</span>l <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>        longueur <span class="op">=</span> longueur <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>        l <span class="op">=</span> l<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>    <span class="op">}</span></span>
<span id="cb13-9"><a href="#cb13-9"></a>    <span class="cf">return</span> longueur<span class="op">;</span></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<h3 data-number="3.1.6" id="sec:accès-au-nième-maillon-de-la-liste"><span class="header-section-number">3.1.6</span> Accès au nième maillon de la liste</h3>
<p>On effectue un parcours similaire pour accéder au nième maillon.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1"></a>maillon <span class="op">*</span>liste_nieme<span class="op">(</span>liste l<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span class="cf">while</span><span class="op">(</span>n <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="op">{</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>        assert<span class="op">(</span>l <span class="op">!=</span> NULL<span class="op">);</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>        l <span class="op">=</span> l<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>        n <span class="op">=</span> n<span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>    <span class="op">}</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>    assert<span class="op">(</span>l <span class="op">!=</span> NULL<span class="op">);</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>    <span class="cf">return</span> l<span class="op">;</span></span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Toujours avec un programme similaire, on peut chercher un maillon avec sa valeur :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1"></a>maillon <span class="op">*</span>liste_recherche<span class="op">(</span>liste l<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>    <span class="cf">while</span><span class="op">(</span>l <span class="op">!=</span> NULL <span class="op">&amp;&amp;</span> l<span class="op">-&gt;</span>valeur <span class="op">!=</span> x<span class="op">)</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>    <span class="op">{</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>        l <span class="op">=</span> l<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>    <span class="op">}</span></span>
<span id="cb15-7"><a href="#cb15-7"></a>    <span class="cf">return</span> l<span class="op">;</span></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Ici, pas besoin d’asserts, en cas d’échec de la recherche, on renvoie un pointeur nul.</p>
<h3 data-number="3.1.7" id="sec:ajoutsuppression-ailleurs-quen-tête"><span class="header-section-number">3.1.7</span> Ajout/Suppression ailleurs qu’en tête</h3>
<p>Pour ajouter ou supprimer ailleurs qu’en tête, il est nécessaire de pouvoir repérer précisément un maillon. Pour cela, on peut le faire :</p>
<ul>
<li>par son indice, celui utilisé dans <code>liste_nieme</code> ;</li>
<li>par sa valeur, avec une recherche ;</li>
<li>ou encore directement par un pointeur sur le maillon.</li>
</ul>
<p>Une fois le maillon ajouté/supprimé, on peut procéder comme pour un ajout/suppression en tête, cependant il va falloir reconnecter le pointeur <code>suivant</code> du maillon précédent. Pour cela deux choix :</p>
<ul>
<li>soit on considère qu’on ajoute après, auquel cas on dispose du precédent</li>
<li>soit on considère qu’on ajoute avant/suprprime et pour cela on effectue une boucle pour déterminer le maillon précédent.</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1"></a><span class="dt">void</span> liste_ajout_apres<span class="op">(</span>liste l<span class="op">,</span> maillon <span class="op">*</span>m<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>    m<span class="op">-&gt;</span>suivant <span class="op">=</span> liste_ajout_en_tete<span class="op">(</span>m<span class="op">-&gt;</span>suivant<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="op">}</span></span>
<span id="cb16-5"><a href="#cb16-5"></a></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="dt">void</span> liste_ajout_avant<span class="op">(</span>liste l<span class="op">,</span> maillon <span class="op">*</span>m<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="op">{</span></span>
<span id="cb16-8"><a href="#cb16-8"></a>    liste prec <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb16-9"><a href="#cb16-9"></a></span>
<span id="cb16-10"><a href="#cb16-10"></a>    <span class="cf">while</span><span class="op">(</span>l <span class="op">!=</span> m<span class="op">)</span></span>
<span id="cb16-11"><a href="#cb16-11"></a>    <span class="op">{</span></span>
<span id="cb16-12"><a href="#cb16-12"></a>        assert<span class="op">(</span>l <span class="op">!=</span> NULL<span class="op">);</span></span>
<span id="cb16-13"><a href="#cb16-13"></a>        prec <span class="op">=</span> l<span class="op">;</span></span>
<span id="cb16-14"><a href="#cb16-14"></a>        l <span class="op">=</span> l<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb16-15"><a href="#cb16-15"></a>    <span class="op">}</span></span>
<span id="cb16-16"><a href="#cb16-16"></a>    prec<span class="op">-&gt;</span>suivant <span class="op">=</span> liste_ajout_en_tete<span class="op">(</span>m<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb16-17"><a href="#cb16-17"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Si on reprend la liste <code>l</code> contenant <code>3,2,1</code> et qu’on souhaite insérer la valeur <code>4</code> avant la valeur <code>1</code>, on va passer un pointeur <code>m</code> vers le maillon contenant <code>1</code> et effectuer un parcours jusqu’à avoir <code>prec</code> et <code>l</code> dans la configuration :</p>
<p><center><div class="ui image center"><img src="assets/pics/ajoutloin1.png" /></div></center></p>
<p>On dispose alors des pointeurs permettant de réaliser l’ajout :</p>
<p><center><div class="ui image center"><img src="assets/pics/ajoutloin2.png" /></div></center></p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1"></a><span class="dt">void</span> liste_suppr_non_en_tete<span class="op">(</span>liste l<span class="op">,</span> maillon <span class="op">*</span>m<span class="op">)</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    liste prec <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a></span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="cf">while</span><span class="op">(</span>l <span class="op">!=</span> m<span class="op">)</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>    <span class="op">{</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>        assert<span class="op">(</span>l <span class="op">!=</span> NULL<span class="op">);</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>        prec <span class="op">=</span> l<span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>        l <span class="op">=</span> l<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb17-10"><a href="#cb17-10"></a>    <span class="op">}</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>    prec<span class="op">-&gt;</span>suivant <span class="op">=</span> liste_suppr_en_tete<span class="op">(</span>m<span class="op">);</span></span>
<span id="cb17-12"><a href="#cb17-12"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>En fait, lorsqu’on regarde le parcours précédent, on remarque deux points :</p>
<ul>
<li>comme on a donné le maillon concerné, le parcours a uniquement pour but de repérer le maillon qui le précède ;</li>
<li>on pourrait se contenter d’utiliser uniquement un pointeur sur le maillon précédent lors du parcours car le maillon qui le suit est accessible avec <code>-&gt;suivant</code>.</li>
</ul>
<h3 data-number="3.1.8" id="sec:autres-implémentations"><span class="header-section-number">3.1.8</span> Autres implémentations</h3>
<p>Une autre implémentation standard consiste à <em>cacher</em> le pointeur sur le premier maillon, ce qui permet de donner également un pointeur sur le dernier maillon. En effet, le pointeur sur le dernier maillon permet de réaliser un ajout en fin de liste en <span class="math inline">\(O(1)\)</span> car il n’y a pas besoin de parcourir la liste pour faire cet ajout.</p>
<p>On obtient alors un type comme :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">struct</span> maillon <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>    <span class="dt">int</span> valeur<span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>    <span class="kw">struct</span> maillon <span class="op">*</span>suivant<span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="op">};</span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="kw">typedef</span> <span class="kw">struct</span> maillon maillon<span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6"></a></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="kw">struct</span> liste <span class="op">{</span></span>
<span id="cb18-8"><a href="#cb18-8"></a>    maillon <span class="op">*</span>premier<span class="op">;</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>    maillon <span class="op">*</span>dernier<span class="op">;</span></span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="op">};</span></span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="kw">typedef</span> <span class="kw">struct</span> liste liste<span class="op">;</span></span></code></pre></div>
<p></div></p>
<p>Cette implémentation est l’occasion de se poser la question sur la répartition entre pile et tas pour les données. On peut légitimement penser que les listes ici ne sont que des couples de pointeurs, et qu’ainsi les passer par copie est léger comparativement à la complexité induite par une allocation sur le tas.</p>
<h2 data-number="3.2" id="sec:en-ocaml"><span class="header-section-number">3.2</span> En <code>OCaml</code></h2>
<h3 data-number="3.2.1" id="sec:cas-des-a-list"><span class="header-section-number">3.2.1</span> Cas des <code>'a list</code></h3>
<p>Tout d’abord, il faut se rendre compte que le type par défaut</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a <span class="dt">list</span> = (::) <span class="kw">of</span> &#39;a * &#39;list | []</span></code></pre></div>
<p>fait intervenir des maillons et des pointeurs. La différence principale avec <code>C</code> est qu’on ne peut pas changer la valeur des pointeurs.</p>
<h3 data-number="3.2.2" id="sec:type-des-listes-chaînées"><span class="header-section-number">3.2.2</span> Type des listes chaînées</h3>
<p>Pour retrouver la richesse du type précédent, on peut définir un type comme :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">type</span> &#39;a maillon = {</span>
<span id="cb20-2"><a href="#cb20-2"></a>    <span class="kw">mutable</span> valeur : &#39;a;</span>
<span id="cb20-3"><a href="#cb20-3"></a>    <span class="kw">mutable</span> suivant : &#39;a liste</span>
<span id="cb20-4"><a href="#cb20-4"></a>} <span class="kw">and</span> &#39;a liste = Vide | Lien <span class="kw">of</span> &#39;a maillon</span></code></pre></div>
<p></div></p>
<p>Ici, le type est une traduction directe du type précédent. On remarque que les types sont mutuellement récursifs car un maillon contient une liste. Le type somme <code>'a liste</code> ressemble fortement à un pointeur qui peut être nul ou pointer sur un maillon. On remarque qu’on aurait pu aussi se contenter d’écrire le type suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">type</span> &#39;a maillon = {</span>
<span id="cb21-2"><a href="#cb21-2"></a>    <span class="kw">mutable</span> valeur : &#39;a;</span>
<span id="cb21-3"><a href="#cb21-3"></a>    <span class="kw">mutable</span> suivant : &#39;a maillon <span class="dt">option</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>}</span>
<span id="cb21-5"><a href="#cb21-5"></a></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="kw">type</span> &#39;a liste = &#39;a maillon <span class="dt">option</span></span></code></pre></div>
<p></div></p>
<p>Mais on va préférer le premier type qui a l’avantage de permettre de bien faire apparaitre la structure.</p>
<h3 data-number="3.2.3" id="sec:ajout-et-suppression-en-tête-1"><span class="header-section-number">3.2.3</span> Ajout et suppression en tête</h3>
<p>Pour rajouter un maillon en tête, on peut écrire :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">let</span> cons x l = Lien { valeur = x; suivant = l}</span></code></pre></div>
<p></div></p>
<p>On remarque que la fonction est beaucoup plus simple que celle en <code>C</code> car l’allocation est automatique et l’initialisation se fait naturellement dans la syntaxe. Cette fonction renvoie une nouvelle liste, on aurait pu aussi rajouter une référence pour les listes afin de permettre de les rendre modifiables, c’est la même discussion que dans la partie précédente.</p>
<p>La suppression en tête, cela revient à renvoyer la queue de la liste comme le fait <code>List.tl</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">let</span> tl l  = <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>    | Vide -&gt; <span class="dt">failwith</span> <span class="st">&quot;Liste vide&quot;</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    | Lien { valeur = _; suivant = q} -&gt; q</span></code></pre></div>
<p></div></p>
<p>On remarque le filtrage imbriqué <code>| Lien { valeur = t; suivant = q }</code> qui correspond au filtrage <code>| t :: q</code> du type <code>a list</code>.</p>
<h3 data-number="3.2.4" id="sec:exemple-de-parcours-sans-modification-calcul-de-la-longueur"><span class="header-section-number">3.2.4</span> Exemple de parcours sans modification : calcul de la longueur</h3>
<p>Vu les remarques précédentes, il n’est pas étonnant que le parcours d’une liste de manière récursive soit très proche de ce qu’on a déjà pu voir avec les listes de base.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">let</span> <span class="kw">rec</span> longueur l = <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb24-2"><a href="#cb24-2"></a>    | Vide -&gt; <span class="dv">0</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>    | Lien { valeur = _; suivant = q } -&gt; <span class="dv">1</span> + longueur q</span></code></pre></div>
<p></div></p>
<p>On en déduit de même une fonction renvoyant un maillon par son indice :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">let</span> <span class="kw">rec</span> nieme l n = <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>    | Vide -&gt; <span class="dt">failwith</span> <span class="st">&quot;Liste vide&quot;</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>    | Lien m -&gt; <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> m <span class="kw">else</span> nieme m.suivant (n<span class="dv">-1</span>)</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Il est possible de réecrire la fonction précédente en permettant à la fois de donner un nom, ici <code>m</code>, au maillon et de faire un filtrage sur ce qu’il contient. Pour cela, on utilise le mot clé <code>as</code> en <code>OCaml</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">let</span> <span class="kw">rec</span> nieme l n = <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>    | Vide -&gt; <span class="dt">failwith</span> <span class="st">&quot;Liste vide&quot;</span></span>
<span id="cb26-3"><a href="#cb26-3"></a>    | Lien ({ valeur=_; suivant = q} <span class="kw">as</span> m) -&gt; </span>
<span id="cb26-4"><a href="#cb26-4"></a>            <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> m <span class="kw">else</span> nieme q (n<span class="dv">-1</span>)</span></code></pre></div>
<p></div> </div></p>
<h3 data-number="3.2.5" id="sec:exemple-de-parcours-avec-modification-ajout-dune-maillon-en-fin-de-liste"><span class="header-section-number">3.2.5</span> Exemple de parcours avec modification : ajout d’une maillon en fin de liste</h3>
<p>On va montrer un exemple de modification de liste en rajoutant un maillon en fin d’une liste non vide. Ici, on effectue un parcours jusqu’à tomber sur le dernier maillon auquel on rajoute le nouveau à la suite.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">let</span> <span class="kw">rec</span> ajout_fin l x =</span>
<span id="cb27-2"><a href="#cb27-2"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb27-3"><a href="#cb27-3"></a>    | Vide -&gt; <span class="dt">failwith</span> <span class="st">&quot;Liste vide&quot;</span></span>
<span id="cb27-4"><a href="#cb27-4"></a>    | Lien m -&gt;</span>
<span id="cb27-5"><a href="#cb27-5"></a>        <span class="kw">if</span> m.suivant = Vide</span>
<span id="cb27-6"><a href="#cb27-6"></a>        <span class="kw">then</span> m.suivant &lt;- Lien { valeur = x; suivant = Vide }</span>
<span id="cb27-7"><a href="#cb27-7"></a>        <span class="kw">else</span> ajout_fin m.suivant x</span></code></pre></div>
<p></div></p>
<h3 data-number="3.2.6" id="sec:raffinement-pour-permettre-lajout-à-la-fin-en-temps-constant"><span class="header-section-number">3.2.6</span> Raffinement pour permettre l’ajout à la fin en temps constant</h3>
<p>Le programme précédent est à comparer au programme suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">let</span> <span class="kw">rec</span> ajout_fin l x =</span>
<span id="cb28-2"><a href="#cb28-2"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>    | [] -&gt; [x]</span>
<span id="cb28-4"><a href="#cb28-4"></a>    | t::q -&gt; t :: ajout_fin q x</span></code></pre></div>
<p></div></p>
<p>On n’a pas l’impression d’avoir vraiment gagné en expressivité ou en efficacité.</p>
<p>Cependant, on peut se dire qu’en changeant le type <code>'a liste</code> on peut tirer partie des maillons pour obtenir un ajout en fin de liste en temps constant. Le programme suivant présente une interface permettant de le faire.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">type</span> &#39;a maillon = {</span>
<span id="cb29-2"><a href="#cb29-2"></a>    <span class="kw">mutable</span> valeur : &#39;a;</span>
<span id="cb29-3"><a href="#cb29-3"></a>    <span class="kw">mutable</span> suivant : &#39;a maillon_ptr</span>
<span id="cb29-4"><a href="#cb29-4"></a>  }</span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="kw">and</span> &#39;a maillon_ptr = &#39;a maillon <span class="dt">option</span></span>
<span id="cb29-6"><a href="#cb29-6"></a><span class="kw">and</span> &#39;a liste = {</span>
<span id="cb29-7"><a href="#cb29-7"></a>      <span class="kw">mutable</span> premier : &#39;a maillon_ptr;</span>
<span id="cb29-8"><a href="#cb29-8"></a>      <span class="kw">mutable</span> dernier : &#39;a maillon_ptr</span>
<span id="cb29-9"><a href="#cb29-9"></a>  }</span>
<span id="cb29-10"><a href="#cb29-10"></a></span>
<span id="cb29-11"><a href="#cb29-11"></a><span class="kw">let</span> liste_vide () = { premier = <span class="dt">None</span>; dernier = <span class="dt">None</span> }</span>
<span id="cb29-12"><a href="#cb29-12"></a></span>
<span id="cb29-13"><a href="#cb29-13"></a><span class="kw">let</span> ajout_debut l x =</span>
<span id="cb29-14"><a href="#cb29-14"></a>    l.premier &lt;- <span class="dt">Some</span> { valeur = x; suivant = l.premier };</span>
<span id="cb29-15"><a href="#cb29-15"></a>    <span class="kw">if</span> l.dernier = <span class="dt">None</span></span>
<span id="cb29-16"><a href="#cb29-16"></a>    <span class="kw">then</span> l.dernier &lt;- l.premier</span>
<span id="cb29-17"><a href="#cb29-17"></a></span>
<span id="cb29-18"><a href="#cb29-18"></a><span class="kw">let</span> suppr_debut l =</span>
<span id="cb29-19"><a href="#cb29-19"></a>    <span class="kw">match</span> l.premier <span class="kw">with</span></span>
<span id="cb29-20"><a href="#cb29-20"></a>    | <span class="dt">None</span> -&gt; <span class="dt">failwith</span> <span class="st">&quot;Liste vide&quot;</span></span>
<span id="cb29-21"><a href="#cb29-21"></a>    | <span class="dt">Some</span> { valeur = _; suivant = l&#39; } -&gt;</span>
<span id="cb29-22"><a href="#cb29-22"></a>            l.premier &lt;- l&#39;</span>
<span id="cb29-23"><a href="#cb29-23"></a></span>
<span id="cb29-24"><a href="#cb29-24"></a><span class="kw">let</span> ajout_fin l x =</span>
<span id="cb29-25"><a href="#cb29-25"></a>    <span class="kw">let</span> m = { valeur = x; suivant = <span class="dt">None</span> } <span class="kw">in</span></span>
<span id="cb29-26"><a href="#cb29-26"></a>    (<span class="kw">match</span> l.dernier <span class="kw">with</span></span>
<span id="cb29-27"><a href="#cb29-27"></a>    | <span class="dt">Some</span> m&#39; -&gt; m&#39;.suivant &lt;- <span class="dt">Some</span> m</span>
<span id="cb29-28"><a href="#cb29-28"></a>    | <span class="dt">None</span> -&gt; () );</span>
<span id="cb29-29"><a href="#cb29-29"></a>    l.dernier &lt;- <span class="dt">Some</span> m;</span>
<span id="cb29-30"><a href="#cb29-30"></a>    <span class="kw">if</span> l.premier = <span class="dt">None</span></span>
<span id="cb29-31"><a href="#cb29-31"></a>    <span class="kw">then</span> l.premier &lt;- l.dernier</span></code></pre></div>
<p></div></p>
<p>Quelques remarques sur ce programme :</p>
<ul>
<li>comme on change directement <code>premier</code> et <code>dernier</code>, il est nécessaire de générer une nouvelle liste vide, ce qui est assuré ici par le paramètre <code>()</code> ;</li>
<li>les pointeurs sont représentés par des options dans des champs mutables ;</li>
<li>afin de préserver l’intégrité des deux pointeurs, on est obligé de gérer les cas où il n’y a qu’un seul maillon ;</li>
<li>attention à la priorité du cas de filtrage sur <code>;</code> qui oblige à mettre des parenthèses dans <code>ajout_fin</code>.</li>
</ul>
<h2 data-number="3.3" id="sec:structure-de-la-mémoire"><span class="header-section-number">3.3</span> Structure de la mémoire</h2>
<p>En mémoire, les maillons d’une liste chaînée, comme celle vue en <code>C</code>, sont sur le tas et de manière désorganisée. Cela signifie qu’il n’y a aucune raison que deux maillons proches dans une liste soient proches en mémoire.</p>
<p><center><div class="ui image center"><img src="assets/pics/memoire.png" /></div></center></p>
<p>Or, les processeurs optimisent la gestion de la mémoire à l’aide d’un cache qui, au lieu de n’accéder qu’à une seule valeur située à une adresse, va charger une zone mémoire autour de cette adresse. Ceci encourage une cohérence spatiale dans l’organisation de la mémoire afin de profiter au maximum de cette mise en cache.</p>
<p>Une stratégie pour réaliser des listes chaînées efficacement peut consiste à allouer un tableau de maillons et à gérer ensuite les allocations parmi cette réserve.</p>
<h1 data-number="4" id="sec:travaux-pratiques"><span class="header-section-number">4</span> Travaux pratiques</h1>
<p>On présente ici deux énoncés de travaux pratiques en <code>C</code> en lien avec ce chapitre.</p>
<h2 data-number="4.1" id="sec:tableaux-non-statiques-et-tableaux-dynamiques"><span class="header-section-number">4.1</span> Tableaux non statiques et tableaux dynamiques</h2>
<p>On va définir ici une structure de donnée pour gérer des tableaux dont la taille ne sera connu qu’à l’exécution. Pour simplifier, ce seront des tableaux d’entiers <code>int</code> mais la méthode s’adapte naturellement pour des tableaux de n’importe quoi.</p>
<h3 data-number="4.1.1" id="sec:type-array"><span class="header-section-number">4.1.1</span> Type <code>array</code></h3>
<p>On définit le type suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">struct</span> array <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>    <span class="dt">int</span> <span class="op">*</span>elements<span class="op">;</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> size<span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="op">};</span></span>
<span id="cb30-5"><a href="#cb30-5"></a><span class="kw">typedef</span> <span class="kw">struct</span> array array<span class="op">;</span></span></code></pre></div>
<p></div></p>
<p>Un <code>array</code> est donc une structure qui contient :</p>
<ul>
<li>un pointeur vers un tableau <code>elements</code> d’entiers</li>
<li>un entier indiquant la taille de ce tableau</li>
</ul>
<p><strong>Remarque importante</strong> quand on copie un pointeur, on copie uniquement un entier qui est l’adresse pointée. Ainsi, quand on copie un <code>array</code>, ce n’est finalement qu’un couple d’entiers qu’on copie. C’est pourquoi, dans la suite, on passe tous les <code>array</code> par valeur. C’est-à-dire que pour définir une fonction de recherche d’un élément dans un <code>array</code> on va écrire :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1"></a><span class="dt">int</span> search<span class="op">(</span>array t<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="op">{</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> t<span class="op">.</span>size<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>    <span class="op">{</span></span>
<span id="cb31-5"><a href="#cb31-5"></a>        <span class="cf">if</span><span class="op">(</span>t<span class="op">.</span>elements<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> x<span class="op">)</span></span>
<span id="cb31-6"><a href="#cb31-6"></a>        <span class="op">{</span></span>
<span id="cb31-7"><a href="#cb31-7"></a>            <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb31-8"><a href="#cb31-8"></a>        <span class="op">}</span></span>
<span id="cb31-9"><a href="#cb31-9"></a>    <span class="op">}</span></span>
<span id="cb31-10"><a href="#cb31-10"></a></span>
<span id="cb31-11"><a href="#cb31-11"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb31-12"><a href="#cb31-12"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Quand on va appeler la fonction, on va avoir une copie de l’argument, c’est-à-dire du <code>array</code>, mais le tableau <code>elements</code> lui sera toujours à la même place. L’alternative serait de passer les valeurs <code>array</code> par pointeurs comme dans la variante suivante :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1"></a><span class="dt">int</span> search<span class="op">(</span>array <span class="op">*</span>t<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> t<span class="op">-&gt;</span>size<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>    <span class="op">{</span></span>
<span id="cb32-5"><a href="#cb32-5"></a>        <span class="cf">if</span><span class="op">(</span>t<span class="op">-&gt;</span>elements<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> x<span class="op">)</span></span>
<span id="cb32-6"><a href="#cb32-6"></a>        <span class="op">{</span></span>
<span id="cb32-7"><a href="#cb32-7"></a>            <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb32-8"><a href="#cb32-8"></a>        <span class="op">}</span></span>
<span id="cb32-9"><a href="#cb32-9"></a>    <span class="op">}</span></span>
<span id="cb32-10"><a href="#cb32-10"></a></span>
<span id="cb32-11"><a href="#cb32-11"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb32-12"><a href="#cb32-12"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>On n’a rien à gagner au surplus de complexité induit par cela. L’unique avantage serait de permettre de modifier les paramètres de la structure passée en argument, mais on réservera ça aux fonctions qui le nécessitent.</p>
<h3 data-number="4.1.2" id="sec:allocation-initialisation-libération"><span class="header-section-number">4.1.2</span> Allocation, Initialisation, Libération</h3>
<p>Pour les fonctions suivantes, on fera usage de <code>malloc</code> et <code>free</code>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <code>array array_alloc(unsigned int size)</code> qui alloue un tableau de <code>size</code> entiers avec <code>malloc</code> et renvoie le <code>array</code> pointant dessus.</p>
<p>Conformément à ce qui est écrit au-dessus, on peut créer un <code>array</code> en variable locale et le renvoyer avec <code>return</code>, ce qui compte c’est la mémoire pointée.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1"></a>array array_alloc<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">int</span> size<span class="op">)</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3"></a>    array a<span class="op">;</span></span>
<span id="cb33-4"><a href="#cb33-4"></a>    a<span class="op">.</span>elements <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*)</span>malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">*</span> size<span class="op">);</span></span>
<span id="cb33-5"><a href="#cb33-5"></a>    a<span class="op">.</span>size <span class="op">=</span> size<span class="op">;</span></span>
<span id="cb33-6"><a href="#cb33-6"></a>    <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb33-7"><a href="#cb33-7"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <code>void array_free(array t)</code> qui libère le tableau pointé par <code>t</code> avec <code>free</code>. A partir de ce moment, on ne peut plus utiliser cette adresse sans faire d’erreurs.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1"></a><span class="dt">void</span> array_free<span class="op">(</span>array a<span class="op">)</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="op">{</span></span>
<span id="cb34-3"><a href="#cb34-3"></a>    free<span class="op">(</span>a<span class="op">.</span>elements<span class="op">);</span></span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Le tableau alloué n’est pas initialisé, écrire une fonction de prototype <code>array array_make(unsigned int size, int def)</code> qui alloue un tableau et initialise toutes les valeurs de celui-ci à <code>def</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1"></a>array array_make<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">int</span> size<span class="op">,</span> <span class="dt">int</span> def<span class="op">)</span></span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="op">{</span></span>
<span id="cb35-3"><a href="#cb35-3"></a>    array a <span class="op">=</span> array_alloc<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb35-4"><a href="#cb35-4"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb35-5"><a href="#cb35-5"></a>    <span class="op">{</span></span>
<span id="cb35-6"><a href="#cb35-6"></a>        a<span class="op">.</span>elements<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> def<span class="op">;</span></span>
<span id="cb35-7"><a href="#cb35-7"></a>    <span class="op">}</span></span>
<span id="cb35-8"><a href="#cb35-8"></a>    <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb35-9"><a href="#cb35-9"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Il est possible de mesurer le temps pris par un programme à l’aide de la fonction <code>time</code> :</p>
<pre><code>$&gt; time ./main 
./main  0.38s user 0.00s system 99% cpu 0.379 total</code></pre>
<p>Comparer le temps d’exécution d’un programme qui</p>
<ul>
<li>alloue puis libère 100 fois un tableau d’un million d’entiers</li>
<li>alloue <em>en initialisant à 0</em> avec <code>make</code> puis libère 100 fois un tableau d’un million d’entiers.</li>
</ul>
<p>Que peut-on en conclure ?</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> On se rend compte que l’allocation est presque instantanée alors que l’initilisation prend un temps linéaire en la taille des données. Ceci est cohérent avec le fait que la mémoire est allouée de manière paresseuse. On s’en rend d’autant plus compte en examinant l’empreinte mémoire des programmes. </div> </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Il existe d’autres fonctions que <code>malloc</code> comme</p>
<pre><code>void *calloc(size_t nmemb, size_t size);
void *realloc(void *ptr, size_t size);</code></pre>
<p>qui permettent :</p>
<ul>
<li>pour <code>calloc</code> d’allouer un tableau de <code>nmemb</code> membres qui sont chacun de taille <code>size</code> et <strong>d’initialiser les octets à 0</strong>. Cette fonction prend donc un temps linéaire en le nombre d’octets.</li>
<li>pour <code>realloc</code> de déplacer en mémoire un tableau en changeant sa taille (en plus ou en moins). Si jamais il y a de la place on ne bouge pas le tableau. C’est donc forcément plus efficace que de le faire à la main.</li>
</ul>
<p>Ces deux fonctions sont <strong>hors programme !</strong></div></p>
<h3 data-number="4.1.3" id="sec:affichage-copie"><span class="header-section-number">4.1.3</span> Affichage, copie</h3>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>void array_print(array a)</code> qui affiche <code>[a1,a2,...,an]</code> si <code>a</code> contient les éléments de <code>a1</code> à <code>an</code>.</p>
<p><em>Remarque</em> cette fonction vous sera utile pour tester ce que vous avez fait dans la suite.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1"></a><span class="dt">void</span> array_print<span class="op">(</span>array a<span class="op">)</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="op">{</span></span>
<span id="cb38-3"><a href="#cb38-3"></a>    printf<span class="op">(</span><span class="st">&quot;[&quot;</span><span class="op">);</span></span>
<span id="cb38-4"><a href="#cb38-4"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> a<span class="op">.</span>size<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb38-5"><a href="#cb38-5"></a>    <span class="op">{</span></span>
<span id="cb38-6"><a href="#cb38-6"></a>        printf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> a<span class="op">.</span>elements<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb38-7"><a href="#cb38-7"></a>        <span class="cf">if</span><span class="op">(</span>i <span class="op">&lt;</span> a<span class="op">.</span>size <span class="op">-</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb38-8"><a href="#cb38-8"></a>            printf<span class="op">(</span><span class="st">&quot;,&quot;</span><span class="op">);</span></span>
<span id="cb38-9"><a href="#cb38-9"></a>    <span class="op">}</span></span>
<span id="cb38-10"><a href="#cb38-10"></a>    printf<span class="op">(</span><span class="st">&quot;]</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb38-11"><a href="#cb38-11"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1"></a><span class="dt">void</span> array_blit<span class="op">(</span>array src<span class="op">,</span> <span class="dt">int</span> src_start<span class="op">,</span> </span>
<span id="cb39-2"><a href="#cb39-2"></a>    array dst<span class="op">,</span> <span class="dt">int</span> dst_start<span class="op">,</span> <span class="dt">int</span> len<span class="op">)</span></span></code></pre></div>
<p></div></p>
<p>qui copie <code>len</code> éléments depuis le tableau <code>src</code> à partir de l’indice <code>src_start</code> dans le tableau <code>dst</code> à partir de l’indice <code>dst_start</code>.</p>
<p><em>Remarque</em> on a déjà écrit cette fonction en <code>OCaml</code>, vous pouvez vous en inspirer.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1"></a><span class="dt">void</span> array_blit<span class="op">(</span>array src<span class="op">,</span> <span class="dt">int</span> src_start<span class="op">,</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>            array dst<span class="op">,</span> <span class="dt">int</span> dst_start<span class="op">,</span> <span class="dt">int</span> len<span class="op">)</span></span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="op">{</span></span>
<span id="cb40-4"><a href="#cb40-4"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb40-5"><a href="#cb40-5"></a>        dst<span class="op">.</span>elements<span class="op">[</span>i <span class="op">+</span> dst_start<span class="op">]</span> <span class="op">=</span> </span>
<span id="cb40-6"><a href="#cb40-6"></a>            src<span class="op">.</span>elements<span class="op">[</span>i <span class="op">+</span> src_start<span class="op">];</span></span>
<span id="cb40-7"><a href="#cb40-7"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h3 data-number="4.1.4" id="sec:implémentation-dune-pile-non-bornée"><span class="header-section-number">4.1.4</span> Implémentation d’une pile non bornée</h3>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <code>void array_push(array *a, int x)</code> qui rajoute <code>x</code> à la fin du array <code>a</code>, c’est-à-dire :</p>
<ul>
<li>on va allouer un nouveau <code>array</code> <code>b</code> dont le tableau contient <code>a-&gt;size+1</code> éléments</li>
<li>on va copier les anciennes valeurs de <code>*a</code> dans <code>b</code></li>
<li>écrire <code>x</code></li>
<li>libérer <code>*a</code></li>
<li>remplacer avec <code>*a = b</code>.</li>
</ul>
<p><em>Remarque</em> On peut tout à faire écrire <code>*a = b</code> pour que <code>a</code> ait les mêmes valeurs que <code>b</code> en dehors de la fonction;</p>
<p><em>Rappel</em> pour une <code>struct</code> par pointeurs, on utilise <code>-&gt;</code> pour accéder aux champs. Donc <code>a-&gt;elements</code> et <code>a-&gt;size</code> ici.</p>
<p><strong>Remarque</strong> Faites des tests comme en créant un tableau de taille 0 et en empilant les entiers de 1 à 10 et en affichant le résultat. Faites les tests avec <code>-fsanitize=address</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb41"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1"></a><span class="dt">void</span> array_push<span class="op">(</span>array <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="op">{</span></span>
<span id="cb41-3"><a href="#cb41-3"></a>    array b <span class="op">=</span> array_alloc<span class="op">(</span>a<span class="op">-&gt;</span>size<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb41-4"><a href="#cb41-4"></a>    array_blit<span class="op">(*</span>a<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> b<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> a<span class="op">-&gt;</span>size<span class="op">);</span></span>
<span id="cb41-5"><a href="#cb41-5"></a>    b<span class="op">.</span>elements<span class="op">[</span>a<span class="op">-&gt;</span>size<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb41-6"><a href="#cb41-6"></a>    array_free<span class="op">(*</span>a<span class="op">);</span></span>
<span id="cb41-7"><a href="#cb41-7"></a>    <span class="op">*</span>a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb41-8"><a href="#cb41-8"></a><span class="op">}</span></span>
<span id="cb41-9"><a href="#cb41-9"></a></span>
<span id="cb41-10"><a href="#cb41-10"></a><span class="co">// Note qu&#39;on aurait pu proposer une interface persistante pour push/pop ainsi</span></span>
<span id="cb41-11"><a href="#cb41-11"></a><span class="co">// pas de pointeurs mais on renvoie le nouveau array</span></span>
<span id="cb41-12"><a href="#cb41-12"></a>array array_push_2<span class="op">(</span>array a<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb41-13"><a href="#cb41-13"></a><span class="op">{</span></span>
<span id="cb41-14"><a href="#cb41-14"></a>    array b <span class="op">=</span> array_alloc<span class="op">(</span>a<span class="op">.</span>size<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb41-15"><a href="#cb41-15"></a>    array_blit<span class="op">(</span>a<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> b<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> a<span class="op">.</span>size<span class="op">);</span></span>
<span id="cb41-16"><a href="#cb41-16"></a>    b<span class="op">.</span>elements<span class="op">[</span>a<span class="op">.</span>size<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb41-17"><a href="#cb41-17"></a>    <span class="co">// pas de raison de faire de free ici de a, c&#39;est </span></span>
<span id="cb41-18"><a href="#cb41-18"></a>    <span class="co">// a l&#39;appelant de gérer.</span></span>
<span id="cb41-19"><a href="#cb41-19"></a>    <span class="cf">return</span> b<span class="op">;</span></span>
<span id="cb41-20"><a href="#cb41-20"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>int array_pop(array *a)</code> qui retire le dernier élément du tableau <code>a</code> et renvoie sa valeur. Il faudra donc :</p>
<ul>
<li>allouer un nouveau <code>array</code> <code>b</code> dont le tableau contient <code>a-&gt;size-1</code> éléments</li>
<li>copier les anciennes valeurs sauf une</li>
<li>récupèrer dans une variable <code>x</code> la valeur de la dernière case de <code>a</code> (<em>parce qu’il n’est pas possible d’y accéder après l’étape suivante</em>)</li>
<li>libérer l’ancien tableau</li>
<li>remplacer avec <code>*a = b</code>.</li>
</ul>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1"></a><span class="dt">int</span> array_pop<span class="op">(</span>array <span class="op">*</span>a<span class="op">)</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="op">{</span></span>
<span id="cb42-3"><a href="#cb42-3"></a>    array b <span class="op">=</span> array_alloc<span class="op">(</span>a<span class="op">-&gt;</span>size<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb42-4"><a href="#cb42-4"></a>    array_blit<span class="op">(*</span>a<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> b<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> a<span class="op">-&gt;</span>size<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb42-5"><a href="#cb42-5"></a>    <span class="dt">int</span> x <span class="op">=</span> a<span class="op">-&gt;</span>elements<span class="op">[</span>a<span class="op">-&gt;</span>size<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb42-6"><a href="#cb42-6"></a>    array_free<span class="op">(*</span>a<span class="op">);</span></span>
<span id="cb42-7"><a href="#cb42-7"></a>    <span class="op">*</span>a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb42-8"><a href="#cb42-8"></a>    <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb42-9"><a href="#cb42-9"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h3 data-number="4.1.5" id="sec:tableaux-dynamiques"><span class="header-section-number">4.1.5</span> Tableaux dynamiques</h3>
<p>Reprendre toutes les questions précédentes en changeant la structure de donnée pour permettre de faire des tableaux dynamiques. Il faudra ainsi avoir deux entiers : <code>int p_size</code> qui contiendra la taille <em>physique</em> en mémoire et <code>int l_size</code> qui contiendra la taille <em>logique</em> c’est-à-dire les éléments signifiants stockés.</p>
<p>Quand on a besoin de reallouer la mémoire, on choisira de doubler la taille physique. Le <code>pop</code> ne libérera jamais de taille physique.</p>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb43-3"><a href="#cb43-3"></a></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="kw">struct</span> array <span class="op">{</span></span>
<span id="cb43-5"><a href="#cb43-5"></a>    <span class="dt">int</span> <span class="op">*</span>elements<span class="op">;</span></span>
<span id="cb43-6"><a href="#cb43-6"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> p_size<span class="op">;</span></span>
<span id="cb43-7"><a href="#cb43-7"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> l_size<span class="op">;</span></span>
<span id="cb43-8"><a href="#cb43-8"></a><span class="op">};</span></span>
<span id="cb43-9"><a href="#cb43-9"></a></span>
<span id="cb43-10"><a href="#cb43-10"></a><span class="kw">typedef</span> <span class="kw">struct</span> array array<span class="op">;</span></span>
<span id="cb43-11"><a href="#cb43-11"></a></span>
<span id="cb43-12"><a href="#cb43-12"></a>array array_alloc<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">int</span> size<span class="op">)</span></span>
<span id="cb43-13"><a href="#cb43-13"></a><span class="op">{</span></span>
<span id="cb43-14"><a href="#cb43-14"></a>    array a<span class="op">;</span></span>
<span id="cb43-15"><a href="#cb43-15"></a>    a<span class="op">.</span>elements <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*)</span>malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">*</span> size<span class="op">);</span></span>
<span id="cb43-16"><a href="#cb43-16"></a>    a<span class="op">.</span>p_size <span class="op">=</span> size<span class="op">;</span></span>
<span id="cb43-17"><a href="#cb43-17"></a>    a<span class="op">.</span>l_size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb43-18"><a href="#cb43-18"></a>    <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb43-19"><a href="#cb43-19"></a><span class="op">}</span></span>
<span id="cb43-20"><a href="#cb43-20"></a></span>
<span id="cb43-21"><a href="#cb43-21"></a><span class="dt">void</span> array_free<span class="op">(</span>array a<span class="op">)</span></span>
<span id="cb43-22"><a href="#cb43-22"></a><span class="op">{</span></span>
<span id="cb43-23"><a href="#cb43-23"></a>    free<span class="op">(</span>a<span class="op">.</span>elements<span class="op">);</span></span>
<span id="cb43-24"><a href="#cb43-24"></a><span class="op">}</span></span>
<span id="cb43-25"><a href="#cb43-25"></a></span>
<span id="cb43-26"><a href="#cb43-26"></a>array array_make<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">int</span> size<span class="op">,</span> <span class="dt">int</span> def<span class="op">)</span></span>
<span id="cb43-27"><a href="#cb43-27"></a><span class="op">{</span></span>
<span id="cb43-28"><a href="#cb43-28"></a>    array a <span class="op">=</span> array_alloc<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb43-29"><a href="#cb43-29"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb43-30"><a href="#cb43-30"></a>    <span class="op">{</span></span>
<span id="cb43-31"><a href="#cb43-31"></a>        a<span class="op">.</span>elements<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> def<span class="op">;</span></span>
<span id="cb43-32"><a href="#cb43-32"></a>    <span class="op">}</span></span>
<span id="cb43-33"><a href="#cb43-33"></a>    a<span class="op">.</span>l_size <span class="op">=</span> size<span class="op">;</span></span>
<span id="cb43-34"><a href="#cb43-34"></a>    <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb43-35"><a href="#cb43-35"></a><span class="op">}</span></span>
<span id="cb43-36"><a href="#cb43-36"></a></span>
<span id="cb43-37"><a href="#cb43-37"></a><span class="dt">void</span> array_print<span class="op">(</span>array a<span class="op">)</span></span>
<span id="cb43-38"><a href="#cb43-38"></a><span class="op">{</span></span>
<span id="cb43-39"><a href="#cb43-39"></a>    printf<span class="op">(</span><span class="st">&quot;[&quot;</span><span class="op">);</span></span>
<span id="cb43-40"><a href="#cb43-40"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> a<span class="op">.</span>l_size<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb43-41"><a href="#cb43-41"></a>    <span class="op">{</span></span>
<span id="cb43-42"><a href="#cb43-42"></a>        printf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> a<span class="op">.</span>elements<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb43-43"><a href="#cb43-43"></a>        <span class="cf">if</span><span class="op">(</span>i <span class="op">&lt;</span> a<span class="op">.</span>l_size <span class="op">-</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb43-44"><a href="#cb43-44"></a>            printf<span class="op">(</span><span class="st">&quot;,&quot;</span><span class="op">);</span></span>
<span id="cb43-45"><a href="#cb43-45"></a>    <span class="op">}</span></span>
<span id="cb43-46"><a href="#cb43-46"></a>    printf<span class="op">(</span><span class="st">&quot;]</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb43-47"><a href="#cb43-47"></a><span class="op">}</span></span>
<span id="cb43-48"><a href="#cb43-48"></a></span>
<span id="cb43-49"><a href="#cb43-49"></a><span class="dt">void</span> array_blit<span class="op">(</span>array src<span class="op">,</span> <span class="dt">int</span> src_start<span class="op">,</span></span>
<span id="cb43-50"><a href="#cb43-50"></a>            array dst<span class="op">,</span> <span class="dt">int</span> dst_start<span class="op">,</span> <span class="dt">int</span> len<span class="op">)</span></span>
<span id="cb43-51"><a href="#cb43-51"></a><span class="op">{</span></span>
<span id="cb43-52"><a href="#cb43-52"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb43-53"><a href="#cb43-53"></a>        dst<span class="op">.</span>elements<span class="op">[</span>i <span class="op">+</span> dst_start<span class="op">]</span> <span class="op">=</span> </span>
<span id="cb43-54"><a href="#cb43-54"></a>            src<span class="op">.</span>elements<span class="op">[</span>i <span class="op">+</span> src_start<span class="op">];</span></span>
<span id="cb43-55"><a href="#cb43-55"></a><span class="op">}</span></span>
<span id="cb43-56"><a href="#cb43-56"></a></span>
<span id="cb43-57"><a href="#cb43-57"></a><span class="dt">void</span> array_push<span class="op">(</span>array <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb43-58"><a href="#cb43-58"></a><span class="op">{</span></span>
<span id="cb43-59"><a href="#cb43-59"></a>    <span class="cf">if</span> <span class="op">(</span>a<span class="op">-&gt;</span>l_size <span class="op">&lt;</span> a<span class="op">-&gt;</span>p_size<span class="op">)</span></span>
<span id="cb43-60"><a href="#cb43-60"></a>    <span class="op">{</span></span>
<span id="cb43-61"><a href="#cb43-61"></a>        a<span class="op">-&gt;</span>elements<span class="op">[</span>a<span class="op">-&gt;</span>l_size<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb43-62"><a href="#cb43-62"></a>        a<span class="op">-&gt;</span>l_size <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb43-63"><a href="#cb43-63"></a>    <span class="op">}</span></span>
<span id="cb43-64"><a href="#cb43-64"></a>    <span class="cf">else</span></span>
<span id="cb43-65"><a href="#cb43-65"></a>    <span class="op">{</span></span>
<span id="cb43-66"><a href="#cb43-66"></a>        array b <span class="op">=</span> array_alloc<span class="op">(</span><span class="dv">2</span><span class="op">*</span>a<span class="op">-&gt;</span>l_size<span class="op">);</span></span>
<span id="cb43-67"><a href="#cb43-67"></a>        array_blit<span class="op">(*</span>a<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> b<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> a<span class="op">-&gt;</span>l_size<span class="op">);</span></span>
<span id="cb43-68"><a href="#cb43-68"></a>        b<span class="op">.</span>elements<span class="op">[</span>a<span class="op">-&gt;</span>l_size<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb43-69"><a href="#cb43-69"></a>        b<span class="op">.</span>l_size <span class="op">=</span> a<span class="op">-&gt;</span>l_size <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb43-70"><a href="#cb43-70"></a>        array_free<span class="op">(*</span>a<span class="op">);</span></span>
<span id="cb43-71"><a href="#cb43-71"></a>        <span class="op">*</span>a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb43-72"><a href="#cb43-72"></a>    <span class="op">}</span></span>
<span id="cb43-73"><a href="#cb43-73"></a><span class="op">}</span></span>
<span id="cb43-74"><a href="#cb43-74"></a></span>
<span id="cb43-75"><a href="#cb43-75"></a><span class="dt">int</span> array_pop<span class="op">(</span>array <span class="op">*</span>a<span class="op">)</span></span>
<span id="cb43-76"><a href="#cb43-76"></a><span class="op">{</span></span>
<span id="cb43-77"><a href="#cb43-77"></a>    a<span class="op">-&gt;</span>l_size <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb43-78"><a href="#cb43-78"></a>    <span class="cf">return</span> a<span class="op">-&gt;</span>elements<span class="op">[</span>a<span class="op">-&gt;</span>l_size<span class="op">];</span></span>
<span id="cb43-79"><a href="#cb43-79"></a><span class="op">}</span></span>
<span id="cb43-80"><a href="#cb43-80"></a></span>
<span id="cb43-81"><a href="#cb43-81"></a></span>
<span id="cb43-82"><a href="#cb43-82"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb43-83"><a href="#cb43-83"></a><span class="op">{</span></span>
<span id="cb43-84"><a href="#cb43-84"></a>    array a <span class="op">=</span> array_alloc<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb43-85"><a href="#cb43-85"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb43-86"><a href="#cb43-86"></a>        array_push<span class="op">(&amp;</span>a<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb43-87"><a href="#cb43-87"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb43-88"><a href="#cb43-88"></a>        printf<span class="op">(</span><span class="st">&quot;Pop %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> array_pop<span class="op">(&amp;</span>a<span class="op">));</span></span>
<span id="cb43-89"><a href="#cb43-89"></a>    array_print<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb43-90"><a href="#cb43-90"></a>    array_free<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb43-91"><a href="#cb43-91"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<h2 data-number="4.2" id="sec:listes-chaînées"><span class="header-section-number">4.2</span> Listes chaînées</h2>
<h3 data-number="4.2.1" id="sec:listes-simplement-chaînées"><span class="header-section-number">4.2.1</span> Listes simplement chaînées</h3>
<p>On va définir des fonctions sur les listes chaînées en utilisant le type suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb44"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1"></a><span class="kw">struct</span> maillon <span class="op">{</span></span>
<span id="cb44-2"><a href="#cb44-2"></a>    <span class="dt">int</span> valeur<span class="op">;</span></span>
<span id="cb44-3"><a href="#cb44-3"></a>    <span class="kw">struct</span> maillon <span class="op">*</span>suivant<span class="op">;</span></span>
<span id="cb44-4"><a href="#cb44-4"></a><span class="op">};</span></span>
<span id="cb44-5"><a href="#cb44-5"></a><span class="kw">typedef</span> <span class="kw">struct</span> maillon maillon<span class="op">;</span></span>
<span id="cb44-6"><a href="#cb44-6"></a></span>
<span id="cb44-7"><a href="#cb44-7"></a><span class="kw">struct</span> liste <span class="op">{</span></span>
<span id="cb44-8"><a href="#cb44-8"></a>    maillon <span class="op">*</span>premier<span class="op">;</span></span>
<span id="cb44-9"><a href="#cb44-9"></a>    maillon <span class="op">*</span>dernier<span class="op">;</span></span>
<span id="cb44-10"><a href="#cb44-10"></a><span class="op">};</span></span>
<span id="cb44-11"><a href="#cb44-11"></a><span class="kw">typedef</span> <span class="kw">struct</span> liste liste<span class="op">;</span></span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div><strong>Invariants à maintenir</strong></p>
<ul>
<li>Dans un maillon, <code>suivant</code> est soit <code>NULL</code> si c’est le dernier maillon de la chaîne, soit un pointeur vers le maillon qui le suit.</li>
<li>Si la liste est vide alors <code>premier</code> et <code>dernier</code> valent <code>NULL</code>. Sinon, ils pointent respectivement sur le premier et le dernier maillon de la chaîne.</div></li>
</ul>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb45"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1"></a>liste liste_vide<span class="op">();</span></span></code></pre></div>
<p></div> qui renvoie la liste vide. Ici, on pourrait dire <strong>une</strong> liste vide mais cela correspond à une unique valeur de la structure <code>liste</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb46"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1"></a>liste liste_vide<span class="op">()</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="op">{</span></span>
<span id="cb46-3"><a href="#cb46-3"></a>    liste l<span class="op">;</span></span>
<span id="cb46-4"><a href="#cb46-4"></a>    l<span class="op">.</span>premier <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb46-5"><a href="#cb46-5"></a>    l<span class="op">.</span>dernier <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb46-6"><a href="#cb46-6"></a>    <span class="cf">return</span> l<span class="op">;</span></span>
<span id="cb46-7"><a href="#cb46-7"></a><span class="op">}</span></span></code></pre></div>
</div> </div> </div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb47"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1"></a><span class="dt">void</span> liste_affiche<span class="op">(</span>liste l<span class="op">);</span></span></code></pre></div>
<p></div> qui affiche le contenu de la liste sous la forme <code>[1,2,3]</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb48"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1"></a><span class="dt">void</span> liste_affiche<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="op">{</span></span>
<span id="cb48-3"><a href="#cb48-3"></a>    putchar<span class="op">(</span><span class="ch">&#39;[&#39;</span><span class="op">);</span></span>
<span id="cb48-4"><a href="#cb48-4"></a>    maillon <span class="op">*</span>m <span class="op">=</span> l<span class="op">.</span>premier<span class="op">;</span></span>
<span id="cb48-5"><a href="#cb48-5"></a>    <span class="cf">while</span><span class="op">(</span>m <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb48-6"><a href="#cb48-6"></a>    <span class="op">{</span></span>
<span id="cb48-7"><a href="#cb48-7"></a>        printf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> m<span class="op">-&gt;</span>valeur<span class="op">);</span></span>
<span id="cb48-8"><a href="#cb48-8"></a>        <span class="cf">if</span><span class="op">(</span>m<span class="op">-&gt;</span>suivant <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb48-9"><a href="#cb48-9"></a>            putchar<span class="op">(</span><span class="ch">&#39;,&#39;</span><span class="op">);</span></span>
<span id="cb48-10"><a href="#cb48-10"></a>        m <span class="op">=</span> m<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb48-11"><a href="#cb48-11"></a>    <span class="op">}</span></span>
<span id="cb48-12"><a href="#cb48-12"></a>    putchar<span class="op">(</span><span class="ch">&#39;]&#39;</span><span class="op">);</span></span>
<span id="cb48-13"><a href="#cb48-13"></a>    putchar<span class="op">(</span><span class="ch">&#39;\n&#39;</span><span class="op">);</span></span>
<span id="cb48-14"><a href="#cb48-14"></a><span class="op">}</span></span></code></pre></div>
</div> </div> </div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb49"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1"></a>maillon <span class="op">*</span>maillon_creer<span class="op">(</span><span class="dt">int</span> valeur<span class="op">,</span> maillon <span class="op">*</span>suivant<span class="op">);</span></span></code></pre></div>
<p></div> qui alloue et initialise un nouveau maillon.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1"></a>maillon <span class="op">*</span>maillon_creer<span class="op">(</span><span class="dt">int</span> valeur<span class="op">,</span> maillon <span class="op">*</span>suivant<span class="op">)</span></span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="op">{</span></span>
<span id="cb50-3"><a href="#cb50-3"></a>    maillon <span class="op">*</span>m <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>maillon<span class="op">));</span></span>
<span id="cb50-4"><a href="#cb50-4"></a>    m<span class="op">-&gt;</span>valeur <span class="op">=</span> valeur<span class="op">;</span></span>
<span id="cb50-5"><a href="#cb50-5"></a>    m<span class="op">-&gt;</span>suivant <span class="op">=</span> suivant<span class="op">;</span></span>
<span id="cb50-6"><a href="#cb50-6"></a>    <span class="cf">return</span> m<span class="op">;</span></span>
<span id="cb50-7"><a href="#cb50-7"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1"></a><span class="dt">void</span> maillon_detruire<span class="op">(</span>maillon <span class="op">*</span>m<span class="op">);</span></span></code></pre></div>
<p></div> qui détruit, c’est-à-dire libère, la mémoire associée à un maillon.</p>
<p>Écrire une fonction de prototype</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb52"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb52-1"><a href="#cb52-1"></a><span class="dt">void</span> chaine_detruire<span class="op">(</span>maillon <span class="op">*</span>m<span class="op">);</span></span></code></pre></div>
<p></div> qui détruit la chaîne de maillon accessible depuis le maillon <code>m</code>.</p>
<p>En déduire une fonction de prototype</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb53"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1"></a><span class="dt">void</span> liste_detruire<span class="op">(</span>liste l<span class="op">);</span></span></code></pre></div>
<p></div> qui détruit la chaîne pointée par une liste.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb54"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1"></a><span class="dt">void</span> maillon_detruire<span class="op">(</span>maillon <span class="op">*</span>m<span class="op">)</span></span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="op">{</span></span>
<span id="cb54-3"><a href="#cb54-3"></a>    free<span class="op">(</span>m<span class="op">);</span></span>
<span id="cb54-4"><a href="#cb54-4"></a><span class="op">}</span></span>
<span id="cb54-5"><a href="#cb54-5"></a></span>
<span id="cb54-6"><a href="#cb54-6"></a><span class="dt">void</span> chaine_detruire<span class="op">(</span>maillon <span class="op">*</span>m<span class="op">)</span></span>
<span id="cb54-7"><a href="#cb54-7"></a><span class="op">{</span></span>
<span id="cb54-8"><a href="#cb54-8"></a>    <span class="cf">while</span><span class="op">(</span>m <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb54-9"><a href="#cb54-9"></a>    <span class="op">{</span></span>
<span id="cb54-10"><a href="#cb54-10"></a>        maillon <span class="op">*</span>suivant <span class="op">=</span> m<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb54-11"><a href="#cb54-11"></a>        maillon_detruire<span class="op">(</span>m<span class="op">);</span></span>
<span id="cb54-12"><a href="#cb54-12"></a>        m <span class="op">=</span> suivant<span class="op">;</span></span>
<span id="cb54-13"><a href="#cb54-13"></a>    <span class="op">}</span></span>
<span id="cb54-14"><a href="#cb54-14"></a><span class="op">}</span></span>
<span id="cb54-15"><a href="#cb54-15"></a></span>
<span id="cb54-16"><a href="#cb54-16"></a><span class="dt">void</span> liste_detruire<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb54-17"><a href="#cb54-17"></a><span class="op">{</span></span>
<span id="cb54-18"><a href="#cb54-18"></a>    chaine_detruire<span class="op">(</span>l<span class="op">.</span>premier<span class="op">);</span></span>
<span id="cb54-19"><a href="#cb54-19"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1"></a><span class="dt">int</span> liste_longueur<span class="op">(</span>liste l<span class="op">);</span></span></code></pre></div>
<p></div> qui renvoie la longueur de la liste <code>l</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb56"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1"></a><span class="dt">int</span> liste_longueur<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb56-2"><a href="#cb56-2"></a><span class="op">{</span></span>
<span id="cb56-3"><a href="#cb56-3"></a>    <span class="dt">int</span> longueur <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb56-4"><a href="#cb56-4"></a>    maillon <span class="op">*</span>m <span class="op">=</span> l<span class="op">.</span>premier<span class="op">;</span></span>
<span id="cb56-5"><a href="#cb56-5"></a>    <span class="cf">while</span><span class="op">(</span>m <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb56-6"><a href="#cb56-6"></a>    <span class="op">{</span></span>
<span id="cb56-7"><a href="#cb56-7"></a>        longueur <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb56-8"><a href="#cb56-8"></a>        m <span class="op">=</span> m<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb56-9"><a href="#cb56-9"></a>    <span class="op">}</span></span>
<span id="cb56-10"><a href="#cb56-10"></a>    <span class="cf">return</span> longueur<span class="op">;</span></span>
<span id="cb56-11"><a href="#cb56-11"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb57"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb57-1"><a href="#cb57-1"></a><span class="dt">int</span> liste_tete<span class="op">(</span>liste l<span class="op">);</span></span>
<span id="cb57-2"><a href="#cb57-2"></a>liste liste_queue<span class="op">(</span>liste l<span class="op">);</span></span></code></pre></div>
<p></div></p>
<p>qui renvoient respectivement la tête et la queue d’une liste. <strong>Attention</strong>, ici, contrairement au type vu plus haut, le maillon suivant n’est pas une liste.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb58"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1"></a><span class="dt">int</span> liste_tete<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb58-2"><a href="#cb58-2"></a><span class="op">{</span></span>
<span id="cb58-3"><a href="#cb58-3"></a>    assert<span class="op">(</span>l<span class="op">.</span>premier <span class="op">!=</span> NULL<span class="op">);</span></span>
<span id="cb58-4"><a href="#cb58-4"></a>    <span class="cf">return</span> l<span class="op">.</span>premier<span class="op">-&gt;</span>valeur<span class="op">;</span></span>
<span id="cb58-5"><a href="#cb58-5"></a><span class="op">}</span></span>
<span id="cb58-6"><a href="#cb58-6"></a></span>
<span id="cb58-7"><a href="#cb58-7"></a>liste liste_queue<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb58-8"><a href="#cb58-8"></a><span class="op">{</span></span>
<span id="cb58-9"><a href="#cb58-9"></a>    assert<span class="op">(</span>l<span class="op">.</span>premier <span class="op">!=</span> NULL<span class="op">);</span></span>
<span id="cb58-10"><a href="#cb58-10"></a>    liste q<span class="op">;</span></span>
<span id="cb58-11"><a href="#cb58-11"></a>    q<span class="op">.</span>premier <span class="op">=</span> l<span class="op">.</span>premier<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb58-12"><a href="#cb58-12"></a>    q<span class="op">.</span>dernier <span class="op">=</span> l<span class="op">.</span>dernier<span class="op">;</span></span>
<span id="cb58-13"><a href="#cb58-13"></a>    <span class="cf">return</span> q<span class="op">;</span></span>
<span id="cb58-14"><a href="#cb58-14"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb59"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb59-1"><a href="#cb59-1"></a><span class="dt">void</span> liste_ajout_en_tete<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">);</span></span></code></pre></div>
<p></div> qui ajoute un maillon en tête de la liste pointée par <code>l</code> en <span class="math inline">\(O(1)\)</span>. On fera attention au cas où <code>l</code> pointe la liste vide.</p>
<p><div class="ui message blue"><div class="header">Note</div>Dans cette fonction et les suivantes, on a fait le choix de passer des pointeurs sur des listes pour permettre de modifier les valerus des pointeurs <code>premier</code> et <code>dernier</code>. Alternativement, on aurait pu faire en sorte que ces fonctions renvoient des <code>liste</code> par copie.</div></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb60"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb60-1"><a href="#cb60-1"></a><span class="dt">void</span> liste_ajout_en_tete<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">)</span></span>
<span id="cb60-2"><a href="#cb60-2"></a><span class="op">{</span></span>
<span id="cb60-3"><a href="#cb60-3"></a>    l<span class="op">-&gt;</span>premier <span class="op">=</span> maillon_creer<span class="op">(</span>valeur<span class="op">,</span> l<span class="op">-&gt;</span>premier<span class="op">);</span></span>
<span id="cb60-4"><a href="#cb60-4"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">-&gt;</span>dernier <span class="op">==</span> NULL<span class="op">)</span> <span class="co">// la liste était vide</span></span>
<span id="cb60-5"><a href="#cb60-5"></a>        l<span class="op">-&gt;</span>dernier <span class="op">=</span> l<span class="op">-&gt;</span>premier<span class="op">;</span></span>
<span id="cb60-6"><a href="#cb60-6"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb61"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1"></a><span class="dt">void</span> liste_suppr_en_tete<span class="op">(</span>liste <span class="op">*</span>l<span class="op">);</span></span></code></pre></div>
<p></div> qui supprime un maillon en tête de la liste <code>l</code> supposée non vide en <span class="math inline">\(O(1)\)</span>.</p>
<p>On fera attention au cas où on supprime l’unique maillon de la liste.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb62"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb62-1"><a href="#cb62-1"></a><span class="dt">void</span> liste_suppr_en_tete<span class="op">(</span>liste <span class="op">*</span>l<span class="op">)</span></span>
<span id="cb62-2"><a href="#cb62-2"></a><span class="op">{</span></span>
<span id="cb62-3"><a href="#cb62-3"></a>    assert<span class="op">(</span>l<span class="op">-&gt;</span>premier <span class="op">!=</span> NULL<span class="op">);</span></span>
<span id="cb62-4"><a href="#cb62-4"></a>    maillon <span class="op">*</span>m <span class="op">=</span> l<span class="op">-&gt;</span>premier<span class="op">;</span></span>
<span id="cb62-5"><a href="#cb62-5"></a>    l<span class="op">-&gt;</span>premier <span class="op">=</span> m<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb62-6"><a href="#cb62-6"></a>    maillon_detruire<span class="op">(</span>m<span class="op">);</span> <span class="co">// on libère la mémoire</span></span>
<span id="cb62-7"><a href="#cb62-7"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">-&gt;</span>premier <span class="op">==</span> NULL<span class="op">)</span> <span class="co">// on a vidé la liste</span></span>
<span id="cb62-8"><a href="#cb62-8"></a>        l<span class="op">-&gt;</span>dernier <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb62-9"><a href="#cb62-9"></a><span class="op">}</span></span></code></pre></div>
</div> </div> </div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb63"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb63-1"><a href="#cb63-1"></a><span class="dt">void</span> liste_ajout_en_fin<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">);</span></span></code></pre></div>
<p></div> qui ajoute un maillon en fin de la liste <code>l</code> en <span class="math inline">\(O(1)\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb64"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb64-1"><a href="#cb64-1"></a><span class="dt">void</span> liste_ajout_en_fin<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">)</span></span>
<span id="cb64-2"><a href="#cb64-2"></a><span class="op">{</span></span>
<span id="cb64-3"><a href="#cb64-3"></a>    maillon <span class="op">*</span>m <span class="op">=</span> l<span class="op">-&gt;</span>dernier<span class="op">;</span></span>
<span id="cb64-4"><a href="#cb64-4"></a>    l<span class="op">-&gt;</span>dernier <span class="op">=</span> maillon_creer<span class="op">(</span>valeur<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb64-5"><a href="#cb64-5"></a>    m<span class="op">-&gt;</span>suivant <span class="op">=</span> l<span class="op">-&gt;</span>dernier<span class="op">;</span></span>
<span id="cb64-6"><a href="#cb64-6"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">-&gt;</span>premier <span class="op">==</span> NULL<span class="op">)</span> <span class="co">// la liste était vide</span></span>
<span id="cb64-7"><a href="#cb64-7"></a>        l<span class="op">-&gt;</span>premier <span class="op">=</span> l<span class="op">-&gt;</span>dernier<span class="op">;</span></span>
<span id="cb64-8"><a href="#cb64-8"></a><span class="op">}</span></span></code></pre></div>
</div> </div> </div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb65"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb65-1"><a href="#cb65-1"></a>maillon <span class="op">*</span>liste_cherche_maillon<span class="op">(</span>liste l<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">);</span></span></code></pre></div>
<p></div> qui renvoie un pointeur sur le premier maillon de valeur <code>valeur</code> ou renvoie <code>NULL</code> s’il n’y en a pas.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb66"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb66-1"><a href="#cb66-1"></a>maillon <span class="op">*</span>liste_cherche_maillon<span class="op">(</span>liste l<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">)</span></span>
<span id="cb66-2"><a href="#cb66-2"></a><span class="op">{</span></span>
<span id="cb66-3"><a href="#cb66-3"></a>    maillon <span class="op">*</span>m <span class="op">=</span> l<span class="op">.</span>premier<span class="op">;</span></span>
<span id="cb66-4"><a href="#cb66-4"></a>    <span class="cf">while</span><span class="op">(</span>m <span class="op">!=</span> NULL <span class="op">&amp;&amp;</span> m<span class="op">-&gt;</span>valeur <span class="op">!=</span> valeur<span class="op">)</span></span>
<span id="cb66-5"><a href="#cb66-5"></a>    <span class="op">{</span></span>
<span id="cb66-6"><a href="#cb66-6"></a>        m <span class="op">=</span> m<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb66-7"><a href="#cb66-7"></a>    <span class="op">}</span></span>
<span id="cb66-8"><a href="#cb66-8"></a>    <span class="cf">return</span> m<span class="op">;</span></span>
<span id="cb66-9"><a href="#cb66-9"></a><span class="op">}</span></span></code></pre></div>
</div> </div> </div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb67"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb67-1"><a href="#cb67-1"></a><span class="dt">void</span> liste_ajout_maillon_apres<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> maillon <span class="op">*</span>m<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">);</span></span></code></pre></div>
<p></div> qui insère en <span class="math inline">\(O(1)\)</span> un maillon après le maillon <code>m</code>. On fera en sorte que l’insertion soit valide même si <code>m</code> est le dernier maillon de la liste.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb68"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb68-1"><a href="#cb68-1"></a><span class="dt">void</span> liste_ajout_maillon_apres<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> maillon <span class="op">*</span>m<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">)</span></span>
<span id="cb68-2"><a href="#cb68-2"></a><span class="op">{</span></span>
<span id="cb68-3"><a href="#cb68-3"></a>    m<span class="op">-&gt;</span>suivant <span class="op">=</span> maillon_creer<span class="op">(</span>valeur<span class="op">,</span> m<span class="op">-&gt;</span>suivant<span class="op">);</span></span>
<span id="cb68-4"><a href="#cb68-4"></a><span class="op">}</span></span></code></pre></div>
</div> </div> </div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb69"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"></code></pre></div>
<p></div> qui ajoute un maillon avant <code>m</code>. Dans le cas où <code>m</code> est le premier ou le dernier maillon, l’insertion sera en <span class="math inline">\(O(1)\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb70"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb70-1"><a href="#cb70-1"></a><span class="dt">void</span> liste_ajout_maillon_avant<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> maillon <span class="op">*</span>m<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">)</span></span>
<span id="cb70-2"><a href="#cb70-2"></a><span class="op">{</span></span>
<span id="cb70-3"><a href="#cb70-3"></a>    <span class="cf">if</span> <span class="op">(</span>m <span class="op">==</span> l<span class="op">-&gt;</span>premier<span class="op">)</span></span>
<span id="cb70-4"><a href="#cb70-4"></a>        liste_ajout_en_tete<span class="op">(</span>l<span class="op">,</span> valeur<span class="op">);</span></span>
<span id="cb70-5"><a href="#cb70-5"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>m <span class="op">==</span> l<span class="op">-&gt;</span>dernier<span class="op">)</span></span>
<span id="cb70-6"><a href="#cb70-6"></a>        liste_ajout_en_fin<span class="op">(</span>l<span class="op">,</span> valeur<span class="op">);</span></span>
<span id="cb70-7"><a href="#cb70-7"></a>    <span class="cf">else</span></span>
<span id="cb70-8"><a href="#cb70-8"></a>    <span class="op">{</span></span>
<span id="cb70-9"><a href="#cb70-9"></a>        maillon <span class="op">*</span>prec <span class="op">=</span> l<span class="op">-&gt;</span>premier<span class="op">;</span></span>
<span id="cb70-10"><a href="#cb70-10"></a>        <span class="cf">while</span><span class="op">(</span>prec<span class="op">-&gt;</span>suivant <span class="op">!=</span> m<span class="op">)</span></span>
<span id="cb70-11"><a href="#cb70-11"></a>        <span class="op">{</span></span>
<span id="cb70-12"><a href="#cb70-12"></a>            prec <span class="op">=</span> prec<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb70-13"><a href="#cb70-13"></a>        <span class="op">}</span></span>
<span id="cb70-14"><a href="#cb70-14"></a>        prec<span class="op">-&gt;</span>suivant <span class="op">=</span> maillon_creer<span class="op">(</span>valeur<span class="op">,</span> m<span class="op">);</span></span>
<span id="cb70-15"><a href="#cb70-15"></a>    <span class="op">}</span></span>
<span id="cb70-16"><a href="#cb70-16"></a><span class="op">}</span></span></code></pre></div>
</div> </div> </div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb71"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb71-1"><a href="#cb71-1"></a><span class="dt">void</span> liste_suppr_maillon<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> maillon <span class="op">*</span>m<span class="op">);</span></span></code></pre></div>
<p></div> qui supprime un maillon. Dans le cas où <code>m</code> est le premier maillon, la suppression sera en <span class="math inline">\(O(1)\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb72"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb72-1"><a href="#cb72-1"></a><span class="dt">void</span> liste_suppr_maillon<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> maillon <span class="op">*</span>m<span class="op">)</span></span>
<span id="cb72-2"><a href="#cb72-2"></a><span class="op">{</span></span>
<span id="cb72-3"><a href="#cb72-3"></a>    <span class="cf">if</span> <span class="op">(</span>m <span class="op">==</span> l<span class="op">-&gt;</span>premier<span class="op">)</span></span>
<span id="cb72-4"><a href="#cb72-4"></a>        liste_suppr_en_tete<span class="op">(</span>l<span class="op">);</span></span>
<span id="cb72-5"><a href="#cb72-5"></a>    <span class="cf">else</span></span>
<span id="cb72-6"><a href="#cb72-6"></a>    <span class="op">{</span></span>
<span id="cb72-7"><a href="#cb72-7"></a>        maillon <span class="op">*</span>prec <span class="op">=</span> l<span class="op">-&gt;</span>premier<span class="op">;</span></span>
<span id="cb72-8"><a href="#cb72-8"></a>        <span class="cf">while</span><span class="op">(</span>prec<span class="op">-&gt;</span>suivant <span class="op">!=</span> m<span class="op">)</span></span>
<span id="cb72-9"><a href="#cb72-9"></a>        <span class="op">{</span></span>
<span id="cb72-10"><a href="#cb72-10"></a>            prec <span class="op">=</span> prec<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb72-11"><a href="#cb72-11"></a>        <span class="op">}</span></span>
<span id="cb72-12"><a href="#cb72-12"></a>        prec<span class="op">-&gt;</span>suivant <span class="op">=</span> m<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb72-13"><a href="#cb72-13"></a>        maillon_detruire<span class="op">(</span>m<span class="op">);</span></span>
<span id="cb72-14"><a href="#cb72-14"></a>    <span class="op">}</span></span>
<span id="cb72-15"><a href="#cb72-15"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<h3 data-number="4.2.2" id="sec:listes-doublement-chaînées"><span class="header-section-number">4.2.2</span> Listes doublement chaînées</h3>
<p>Pour les listes doublement chaînées, on va adapter le type précédent en rajoutant juste un pointeur <code>precedent</code> dans les maillons :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb73"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb73-1"><a href="#cb73-1"></a><span class="kw">struct</span> maillon <span class="op">{</span></span>
<span id="cb73-2"><a href="#cb73-2"></a>    <span class="dt">int</span> valeur<span class="op">;</span></span>
<span id="cb73-3"><a href="#cb73-3"></a>    <span class="kw">struct</span> maillon <span class="op">*</span>suivant<span class="op">;</span></span>
<span id="cb73-4"><a href="#cb73-4"></a>    <span class="kw">struct</span> maillon <span class="op">*</span>precedent<span class="op">;</span></span>
<span id="cb73-5"><a href="#cb73-5"></a><span class="op">};</span></span>
<span id="cb73-6"><a href="#cb73-6"></a><span class="kw">typedef</span> <span class="kw">struct</span> maillon maillon<span class="op">;</span></span>
<span id="cb73-7"><a href="#cb73-7"></a></span>
<span id="cb73-8"><a href="#cb73-8"></a><span class="kw">struct</span> liste <span class="op">{</span></span>
<span id="cb73-9"><a href="#cb73-9"></a>    maillon <span class="op">*</span>premier<span class="op">;</span></span>
<span id="cb73-10"><a href="#cb73-10"></a>    maillon <span class="op">*</span>dernier<span class="op">;</span></span>
<span id="cb73-11"><a href="#cb73-11"></a><span class="op">};</span></span>
<span id="cb73-12"><a href="#cb73-12"></a><span class="kw">typedef</span> <span class="kw">struct</span> liste liste<span class="op">;</span></span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div><strong>Invariants à maintenir</strong></p>
<ul>
<li>Dans un maillon, <code>suivant</code> est soit <code>NULL</code> si c’est le dernier maillon de la chaîne, soit un pointeur vers le maillon qui le suit.</li>
<li>Dans un maillon, <code>precedent</code> est soit <code>NULL</code> si c’est le premier maillon de la chaîne, soit un pointeur vers le maillon qui le précède.</li>
<li>Si la liste est vide alors <code>premier</code> et <code>dernier</code> valent <code>NULL</code>. Sinon, ils pointent respectivement sur le premier et le dernier maillon de la chaîne.</div></li>
</ul>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Reprendre les questions précédentes avec ce nouveau type.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> Peu de modifications à faire.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb74"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb74-1"><a href="#cb74-1"></a>liste liste_vide<span class="op">()</span></span>
<span id="cb74-2"><a href="#cb74-2"></a><span class="op">{</span></span>
<span id="cb74-3"><a href="#cb74-3"></a>    liste l<span class="op">;</span></span>
<span id="cb74-4"><a href="#cb74-4"></a>    l<span class="op">.</span>premier <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb74-5"><a href="#cb74-5"></a>    l<span class="op">.</span>dernier <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb74-6"><a href="#cb74-6"></a>    <span class="cf">return</span> l<span class="op">;</span></span>
<span id="cb74-7"><a href="#cb74-7"></a><span class="op">}</span></span>
<span id="cb74-8"><a href="#cb74-8"></a></span>
<span id="cb74-9"><a href="#cb74-9"></a><span class="dt">void</span> liste_affiche<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb74-10"><a href="#cb74-10"></a><span class="op">{</span></span>
<span id="cb74-11"><a href="#cb74-11"></a>    putchar<span class="op">(</span><span class="ch">&#39;[&#39;</span><span class="op">);</span></span>
<span id="cb74-12"><a href="#cb74-12"></a>    maillon <span class="op">*</span>m <span class="op">=</span> l<span class="op">.</span>premier<span class="op">;</span></span>
<span id="cb74-13"><a href="#cb74-13"></a>    <span class="cf">while</span><span class="op">(</span>m <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb74-14"><a href="#cb74-14"></a>    <span class="op">{</span></span>
<span id="cb74-15"><a href="#cb74-15"></a>        printf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> m<span class="op">-&gt;</span>valeur<span class="op">);</span></span>
<span id="cb74-16"><a href="#cb74-16"></a>        <span class="cf">if</span><span class="op">(</span>m<span class="op">-&gt;</span>suivant <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb74-17"><a href="#cb74-17"></a>            putchar<span class="op">(</span><span class="ch">&#39;,&#39;</span><span class="op">);</span></span>
<span id="cb74-18"><a href="#cb74-18"></a>        m <span class="op">=</span> m<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb74-19"><a href="#cb74-19"></a>    <span class="op">}</span></span>
<span id="cb74-20"><a href="#cb74-20"></a>    putchar<span class="op">(</span><span class="ch">&#39;]&#39;</span><span class="op">);</span></span>
<span id="cb74-21"><a href="#cb74-21"></a>    putchar<span class="op">(</span><span class="ch">&#39;\n&#39;</span><span class="op">);</span></span>
<span id="cb74-22"><a href="#cb74-22"></a><span class="op">}</span></span>
<span id="cb74-23"><a href="#cb74-23"></a></span>
<span id="cb74-24"><a href="#cb74-24"></a>maillon <span class="op">*</span>maillon_creer<span class="op">(</span><span class="dt">int</span> valeur<span class="op">,</span></span>
<span id="cb74-25"><a href="#cb74-25"></a>        maillon <span class="op">*</span>precedent<span class="op">,</span> maillon <span class="op">*</span>suivant<span class="op">)</span></span>
<span id="cb74-26"><a href="#cb74-26"></a><span class="op">{</span></span>
<span id="cb74-27"><a href="#cb74-27"></a>    maillon <span class="op">*</span>m <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>maillon<span class="op">));</span></span>
<span id="cb74-28"><a href="#cb74-28"></a>    m<span class="op">-&gt;</span>valeur <span class="op">=</span> valeur<span class="op">;</span></span>
<span id="cb74-29"><a href="#cb74-29"></a>    m<span class="op">-&gt;</span>suivant <span class="op">=</span> suivant<span class="op">;</span></span>
<span id="cb74-30"><a href="#cb74-30"></a>    m<span class="op">-&gt;</span>precedent <span class="op">=</span> precedent<span class="op">;</span></span>
<span id="cb74-31"><a href="#cb74-31"></a>    <span class="cf">return</span> m<span class="op">;</span></span>
<span id="cb74-32"><a href="#cb74-32"></a><span class="op">}</span></span>
<span id="cb74-33"><a href="#cb74-33"></a></span>
<span id="cb74-34"><a href="#cb74-34"></a><span class="dt">void</span> maillon_detruire<span class="op">(</span>maillon <span class="op">*</span>m<span class="op">)</span></span>
<span id="cb74-35"><a href="#cb74-35"></a><span class="op">{</span></span>
<span id="cb74-36"><a href="#cb74-36"></a>    free<span class="op">(</span>m<span class="op">);</span></span>
<span id="cb74-37"><a href="#cb74-37"></a><span class="op">}</span></span>
<span id="cb74-38"><a href="#cb74-38"></a></span>
<span id="cb74-39"><a href="#cb74-39"></a><span class="dt">void</span> chaine_detruire<span class="op">(</span>maillon <span class="op">*</span>m<span class="op">)</span></span>
<span id="cb74-40"><a href="#cb74-40"></a><span class="op">{</span></span>
<span id="cb74-41"><a href="#cb74-41"></a>    <span class="cf">while</span><span class="op">(</span>m <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb74-42"><a href="#cb74-42"></a>    <span class="op">{</span></span>
<span id="cb74-43"><a href="#cb74-43"></a>        maillon <span class="op">*</span>suivant <span class="op">=</span> m<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb74-44"><a href="#cb74-44"></a>        maillon_detruire<span class="op">(</span>m<span class="op">);</span></span>
<span id="cb74-45"><a href="#cb74-45"></a>        m <span class="op">=</span> suivant<span class="op">;</span></span>
<span id="cb74-46"><a href="#cb74-46"></a>    <span class="op">}</span></span>
<span id="cb74-47"><a href="#cb74-47"></a><span class="op">}</span></span>
<span id="cb74-48"><a href="#cb74-48"></a></span>
<span id="cb74-49"><a href="#cb74-49"></a><span class="dt">void</span> liste_detruire<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb74-50"><a href="#cb74-50"></a><span class="op">{</span></span>
<span id="cb74-51"><a href="#cb74-51"></a>    chaine_detruire<span class="op">(</span>l<span class="op">.</span>premier<span class="op">);</span></span>
<span id="cb74-52"><a href="#cb74-52"></a><span class="op">}</span></span>
<span id="cb74-53"><a href="#cb74-53"></a></span>
<span id="cb74-54"><a href="#cb74-54"></a><span class="dt">int</span> liste_longueur<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb74-55"><a href="#cb74-55"></a><span class="op">{</span></span>
<span id="cb74-56"><a href="#cb74-56"></a>    <span class="dt">int</span> longueur <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb74-57"><a href="#cb74-57"></a>    maillon <span class="op">*</span>m <span class="op">=</span> l<span class="op">.</span>premier<span class="op">;</span></span>
<span id="cb74-58"><a href="#cb74-58"></a>    <span class="cf">while</span><span class="op">(</span>m <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb74-59"><a href="#cb74-59"></a>    <span class="op">{</span></span>
<span id="cb74-60"><a href="#cb74-60"></a>        longueur <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb74-61"><a href="#cb74-61"></a>        m <span class="op">=</span> m<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb74-62"><a href="#cb74-62"></a>    <span class="op">}</span></span>
<span id="cb74-63"><a href="#cb74-63"></a>    <span class="cf">return</span> longueur<span class="op">;</span></span>
<span id="cb74-64"><a href="#cb74-64"></a><span class="op">}</span></span>
<span id="cb74-65"><a href="#cb74-65"></a></span>
<span id="cb74-66"><a href="#cb74-66"></a><span class="dt">int</span> liste_tete<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb74-67"><a href="#cb74-67"></a><span class="op">{</span></span>
<span id="cb74-68"><a href="#cb74-68"></a>    assert<span class="op">(</span>l<span class="op">.</span>premier <span class="op">!=</span> NULL<span class="op">);</span></span>
<span id="cb74-69"><a href="#cb74-69"></a>    <span class="cf">return</span> l<span class="op">.</span>premier<span class="op">-&gt;</span>valeur<span class="op">;</span></span>
<span id="cb74-70"><a href="#cb74-70"></a><span class="op">}</span></span>
<span id="cb74-71"><a href="#cb74-71"></a></span>
<span id="cb74-72"><a href="#cb74-72"></a>liste liste_queue<span class="op">(</span>liste l<span class="op">)</span></span>
<span id="cb74-73"><a href="#cb74-73"></a><span class="op">{</span></span>
<span id="cb74-74"><a href="#cb74-74"></a>    assert<span class="op">(</span>l<span class="op">.</span>premier <span class="op">!=</span> NULL<span class="op">);</span></span>
<span id="cb74-75"><a href="#cb74-75"></a>    liste q<span class="op">;</span></span>
<span id="cb74-76"><a href="#cb74-76"></a>    q<span class="op">.</span>premier <span class="op">=</span> l<span class="op">.</span>premier<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb74-77"><a href="#cb74-77"></a>    q<span class="op">.</span>dernier <span class="op">=</span> l<span class="op">.</span>dernier<span class="op">;</span></span>
<span id="cb74-78"><a href="#cb74-78"></a>    <span class="cf">return</span> q<span class="op">;</span></span>
<span id="cb74-79"><a href="#cb74-79"></a><span class="op">}</span></span>
<span id="cb74-80"><a href="#cb74-80"></a></span>
<span id="cb74-81"><a href="#cb74-81"></a><span class="dt">void</span> liste_ajout_en_tete<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">)</span></span>
<span id="cb74-82"><a href="#cb74-82"></a><span class="op">{</span></span>
<span id="cb74-83"><a href="#cb74-83"></a>    l<span class="op">-&gt;</span>premier <span class="op">=</span> maillon_creer<span class="op">(</span>valeur<span class="op">,</span> NULL<span class="op">,</span> l<span class="op">-&gt;</span>premier<span class="op">);</span></span>
<span id="cb74-84"><a href="#cb74-84"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">-&gt;</span>dernier <span class="op">==</span> NULL<span class="op">)</span> <span class="co">// la liste était vide</span></span>
<span id="cb74-85"><a href="#cb74-85"></a>        l<span class="op">-&gt;</span>dernier <span class="op">=</span> l<span class="op">-&gt;</span>premier<span class="op">;</span></span>
<span id="cb74-86"><a href="#cb74-86"></a><span class="op">}</span></span>
<span id="cb74-87"><a href="#cb74-87"></a></span>
<span id="cb74-88"><a href="#cb74-88"></a><span class="dt">void</span> liste_suppr_en_tete<span class="op">(</span>liste <span class="op">*</span>l<span class="op">)</span></span>
<span id="cb74-89"><a href="#cb74-89"></a><span class="op">{</span></span>
<span id="cb74-90"><a href="#cb74-90"></a>    assert<span class="op">(</span>l<span class="op">-&gt;</span>premier <span class="op">!=</span> NULL<span class="op">);</span></span>
<span id="cb74-91"><a href="#cb74-91"></a>    maillon <span class="op">*</span>m <span class="op">=</span> l<span class="op">-&gt;</span>premier<span class="op">;</span></span>
<span id="cb74-92"><a href="#cb74-92"></a>    l<span class="op">-&gt;</span>premier <span class="op">=</span> m<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb74-93"><a href="#cb74-93"></a>    l<span class="op">-&gt;</span>premier<span class="op">-&gt;</span>precedent <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb74-94"><a href="#cb74-94"></a>    maillon_detruire<span class="op">(</span>m<span class="op">);</span> <span class="co">// on libère la mémoire</span></span>
<span id="cb74-95"><a href="#cb74-95"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">-&gt;</span>premier <span class="op">==</span> NULL<span class="op">)</span> <span class="co">// on a vidé la liste</span></span>
<span id="cb74-96"><a href="#cb74-96"></a>        l<span class="op">-&gt;</span>dernier <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb74-97"><a href="#cb74-97"></a><span class="op">}</span></span>
<span id="cb74-98"><a href="#cb74-98"></a></span>
<span id="cb74-99"><a href="#cb74-99"></a><span class="dt">void</span> liste_ajout_en_fin<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">)</span></span>
<span id="cb74-100"><a href="#cb74-100"></a><span class="op">{</span></span>
<span id="cb74-101"><a href="#cb74-101"></a>    maillon <span class="op">*</span>m <span class="op">=</span> l<span class="op">-&gt;</span>dernier<span class="op">;</span></span>
<span id="cb74-102"><a href="#cb74-102"></a>    l<span class="op">-&gt;</span>dernier <span class="op">=</span> maillon_creer<span class="op">(</span>valeur<span class="op">,</span> m<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb74-103"><a href="#cb74-103"></a>    m<span class="op">-&gt;</span>suivant <span class="op">=</span> l<span class="op">-&gt;</span>dernier<span class="op">;</span></span>
<span id="cb74-104"><a href="#cb74-104"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">-&gt;</span>premier <span class="op">==</span> NULL<span class="op">)</span> <span class="co">// la liste était vide</span></span>
<span id="cb74-105"><a href="#cb74-105"></a>        l<span class="op">-&gt;</span>premier <span class="op">=</span> l<span class="op">-&gt;</span>dernier<span class="op">;</span></span>
<span id="cb74-106"><a href="#cb74-106"></a><span class="op">}</span></span>
<span id="cb74-107"><a href="#cb74-107"></a></span>
<span id="cb74-108"><a href="#cb74-108"></a>maillon <span class="op">*</span>liste_cherche_maillon<span class="op">(</span>liste l<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">)</span></span>
<span id="cb74-109"><a href="#cb74-109"></a><span class="op">{</span></span>
<span id="cb74-110"><a href="#cb74-110"></a>    maillon <span class="op">*</span>m <span class="op">=</span> l<span class="op">.</span>premier<span class="op">;</span></span>
<span id="cb74-111"><a href="#cb74-111"></a>    <span class="cf">while</span><span class="op">(</span>m <span class="op">!=</span> NULL <span class="op">&amp;&amp;</span> m<span class="op">-&gt;</span>valeur <span class="op">!=</span> valeur<span class="op">)</span></span>
<span id="cb74-112"><a href="#cb74-112"></a>    <span class="op">{</span></span>
<span id="cb74-113"><a href="#cb74-113"></a>        m <span class="op">=</span> m<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb74-114"><a href="#cb74-114"></a>    <span class="op">}</span></span>
<span id="cb74-115"><a href="#cb74-115"></a>    <span class="cf">return</span> m<span class="op">;</span></span>
<span id="cb74-116"><a href="#cb74-116"></a><span class="op">}</span></span>
<span id="cb74-117"><a href="#cb74-117"></a></span>
<span id="cb74-118"><a href="#cb74-118"></a><span class="dt">void</span> liste_ajout_maillon_apres<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> maillon <span class="op">*</span>m<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">)</span></span>
<span id="cb74-119"><a href="#cb74-119"></a><span class="op">{</span></span>
<span id="cb74-120"><a href="#cb74-120"></a>    m<span class="op">-&gt;</span>suivant <span class="op">=</span> maillon_creer<span class="op">(</span>valeur<span class="op">,</span> m<span class="op">,</span> m<span class="op">-&gt;</span>suivant<span class="op">);</span></span>
<span id="cb74-121"><a href="#cb74-121"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb75"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb75-1"><a href="#cb75-1"></a><span class="dt">void</span> liste_suppr_en_fin<span class="op">(</span>liste <span class="op">*</span>l<span class="op">);</span></span></code></pre></div>
<p></div> qui supprime en <span class="math inline">\(O(1)\)</span> le dernier maillon.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb76"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb76-1"><a href="#cb76-1"></a><span class="dt">void</span> liste_suppr_en_fin<span class="op">(</span>liste <span class="op">*</span>l<span class="op">);</span></span>
<span id="cb76-2"><a href="#cb76-2"></a><span class="op">{</span></span>
<span id="cb76-3"><a href="#cb76-3"></a>    maillon <span class="op">*</span>fin <span class="op">=</span> l<span class="op">-&gt;</span>dernier<span class="op">;</span></span>
<span id="cb76-4"><a href="#cb76-4"></a>    l<span class="op">-&gt;</span>dernier <span class="op">=</span> fin<span class="op">-&gt;</span>precedent<span class="op">;</span></span>
<span id="cb76-5"><a href="#cb76-5"></a>    l<span class="op">-&gt;</span>dernier<span class="op">-&gt;</span>suivant <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb76-6"><a href="#cb76-6"></a>    <span class="cf">if</span> <span class="op">(</span>l<span class="op">-&gt;</span>dernier <span class="op">==</span> NULL<span class="op">)</span></span>
<span id="cb76-7"><a href="#cb76-7"></a>        l<span class="op">-&gt;</span>premier <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb76-8"><a href="#cb76-8"></a>    maillon_detruire<span class="op">(</span>fin<span class="op">);</span></span>
<span id="cb76-9"><a href="#cb76-9"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb77"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb77-1"><a href="#cb77-1"></a><span class="dt">void</span> liste_ajout_maillon_avant<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> maillon <span class="op">*</span>m<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">);</span></span></code></pre></div>
<p></div> qui ajoute un maillon avant <code>m</code> en <span class="math inline">\(O(1)\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb78"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb78-1"><a href="#cb78-1"></a><span class="dt">void</span> liste_ajout_maillon_avant<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> maillon <span class="op">*</span>m<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">)</span></span>
<span id="cb78-2"><a href="#cb78-2"></a><span class="op">{</span></span>
<span id="cb78-3"><a href="#cb78-3"></a>    <span class="cf">if</span> <span class="op">(</span>m <span class="op">==</span> l<span class="op">-&gt;</span>premier<span class="op">)</span></span>
<span id="cb78-4"><a href="#cb78-4"></a>        liste_ajout_en_tete<span class="op">(</span>l<span class="op">,</span> valeur<span class="op">);</span></span>
<span id="cb78-5"><a href="#cb78-5"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>m <span class="op">==</span> l<span class="op">-&gt;</span>dernier<span class="op">)</span></span>
<span id="cb78-6"><a href="#cb78-6"></a>        liste_ajout_en_fin<span class="op">(</span>l<span class="op">,</span> valeur<span class="op">);</span></span>
<span id="cb78-7"><a href="#cb78-7"></a>    <span class="cf">else</span></span>
<span id="cb78-8"><a href="#cb78-8"></a>    <span class="op">{</span></span>
<span id="cb78-9"><a href="#cb78-9"></a>        <span class="co">// En O(1)</span></span>
<span id="cb78-10"><a href="#cb78-10"></a>        m<span class="op">-&gt;</span>precedent<span class="op">-&gt;</span>suivant <span class="op">=</span> maillon_creer<span class="op">(</span>valeur<span class="op">,</span></span>
<span id="cb78-11"><a href="#cb78-11"></a>                m<span class="op">-&gt;</span>precedent<span class="op">,</span> m<span class="op">);</span></span>
<span id="cb78-12"><a href="#cb78-12"></a>        m<span class="op">-&gt;</span>precedent <span class="op">=</span> m<span class="op">-&gt;</span>precedent<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb78-13"><a href="#cb78-13"></a>    <span class="op">}</span></span>
<span id="cb78-14"><a href="#cb78-14"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction de prototype <div class="ui segment code"></p>
<div class="sourceCode" id="cb79"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb79-1"><a href="#cb79-1"></a><span class="dt">void</span> liste_suppr_maillon<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> maillon <span class="op">*</span>m<span class="op">);</span></span></code></pre></div>
<p></div> qui supprime en <span class="math inline">\(O(1)\)</span> le maillon <code>m</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb80"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb80-1"><a href="#cb80-1"></a><span class="dt">void</span> list_suppr_maillon<span class="op">(</span>liste <span class="op">*</span>l<span class="op">,</span> maillon <span class="op">*</span>m<span class="op">)</span></span>
<span id="cb80-2"><a href="#cb80-2"></a><span class="op">{</span></span>
<span id="cb80-3"><a href="#cb80-3"></a>    <span class="cf">if</span> <span class="op">(</span>m <span class="op">==</span> l<span class="op">-&gt;</span>premier<span class="op">)</span></span>
<span id="cb80-4"><a href="#cb80-4"></a>        liste_suppr_en_tete<span class="op">(</span>l<span class="op">);</span></span>
<span id="cb80-5"><a href="#cb80-5"></a>    <span class="cf">else</span></span>
<span id="cb80-6"><a href="#cb80-6"></a>    <span class="op">{</span></span>
<span id="cb80-7"><a href="#cb80-7"></a>        m<span class="op">-&gt;</span>precedent<span class="op">-&gt;</span>suivant <span class="op">=</span> m<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb80-8"><a href="#cb80-8"></a>        m<span class="op">-&gt;</span>suivant<span class="op">-&gt;</span>precedent <span class="op">=</span> m<span class="op">-&gt;</span>precedent<span class="op">;</span></span>
<span id="cb80-9"><a href="#cb80-9"></a>        maillon_detruire<span class="op">(</span>m<span class="op">);</span></span>
<span id="cb80-10"><a href="#cb80-10"></a>    <span class="op">}</span></span>
<span id="cb80-11"><a href="#cb80-11"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
