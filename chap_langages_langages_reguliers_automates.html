<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Langages réguliers et automates finis</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

<style type="text/css">
  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

.ui.styled.accordion {
    width: 100% !important;
    font-size: 1rem !important;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
</style>

</head>
<body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\gO{\mathcal{O}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>


<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Langages réguliers et automates finis
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:langages-réguliers"><span>1</span> Langages réguliers</a><div class="menu"><a class="item" href="#sec:alphabet-et-mots"><div class="ui label">1.1</div> Alphabet et mots</a><a class="item" href="#sec:suffixe-préfixe-facteurs-sous-mots"><div class="ui label">1.2</div> Suffixe, Préfixe, facteurs, sous-mots</a><a class="item" href="#sec:langage"><div class="ui label">1.3</div> Langage</a><a class="item" href="#sec:langages-réguliers-1"><div class="ui label">1.4</div> Langages réguliers</a><a class="item" href="#sec:expression-régulière"><div class="ui label">1.5</div> Expression régulière</a><a class="item" href="#sec:expressions-régulières-étendues-posix"><div class="ui label">1.6</div> Expressions régulières étendues POSIX</a></div></div><div class="item header"> <a href="#sec:automates-finis"><span>2</span> Automates finis</a><div class="menu"><a class="item" href="#sec:automates-finis-déterministes"><div class="ui label">2.1</div> Automates finis déterministes</a><a class="item" href="#sec:accessibilité-co-accessibilité"><div class="ui label">2.2</div> Accessibilité, Co-accessibilité</a><a class="item" href="#sec:langage-reconnu-par-un-automate-fini"><div class="ui label">2.3</div> Langage reconnu par un automate fini</a><a class="item" href="#sec:fonction-de-transition-étendue"><div class="ui label">2.4</div> Fonction de transition étendue</a><a class="item" href="#sec:modélisation-par-des-automates"><div class="ui label">2.5</div> Modélisation par des automates</a><a class="item" href="#sec:automates-non-déterministes"><div class="ui label">2.6</div> Automates non déterministes</a><a class="item" href="#sec:transitions-spontanées"><div class="ui label">2.7</div> Transitions spontanées</a></div></div><div class="item header"> <a href="#sec:théorème-de-kleene"><span>3</span> Théorème de Kleene</a><div class="menu"><a class="item" href="#sec:des-expressions-régulières-aux-automates-non-déterministes-avec-transitions-spontanées"><div class="ui label">3.1</div> Des expressions régulières aux automates non-déterministes avec transitions spontanées</a><a class="item" href="#sec:calcul-dune-expression-régulière-depuis-un-automate---mcnaughton-et-yamada"><div class="ui label">3.2</div> Calcul d’une expression régulière depuis un automate - <em>McNaughton et Yamada</em></a><a class="item" href="#sec:élimination-des-états---brzozowski-et-mccluskey"><div class="ui label">3.3</div> Élimination des états - <em>Brzozowski et McCluskey</em></a></div></div><div class="item header"> <a href="#sec:construction-de-lautomate-de-glushkov-algorithme-de-berry-sethi"><span>4</span> Construction de l’automate de Glushkov, algorithme de Berry-Sethi</a><div class="menu"><a class="item" href="#sec:langages-locaux"><div class="ui label">4.1</div> Langages locaux</a><a class="item" href="#sec:automates-locaux"><div class="ui label">4.2</div> Automates locaux</a><a class="item" href="#sec:expressions-régulières-linéaires"><div class="ui label">4.3</div> Expressions régulières linéaires</a><a class="item" href="#sec:application-aux-expressions-régulières"><div class="ui label">4.4</div> Application aux expressions régulières</a></div></div><div class="item header"> <a href="#sec:conséquences-du-théorème-de-kleene"><span>5</span> Conséquences du théorème de Kleene</a><div class="menu"><a class="item" href="#sec:stabilité-des-langages-réguliers"><div class="ui label">5.1</div> Stabilité des langages réguliers</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:par-union-finie"><i class="circle icon"></i> Par union finie</a><a style="font-size:0.6em" class="item" href="#sec:par-complémentaire"><i class="circle icon"></i> Par complémentaire</a><a style="font-size:0.6em" class="item" href="#sec:par-intersection-finie"><i class="circle icon"></i> Par intersection finie</a></div><a class="item" href="#sec:lemme-de-létoile"><div class="ui label">5.2</div> Lemme de l’étoile</a></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Langages réguliers et automates finis
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Langages réguliers et automates finis     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_structures_arbres.jpg"> </div></p>
<h1 data-number="1" id="sec:langages-réguliers"><span
class="header-section-number">1</span> Langages réguliers</h1>
<h2 data-number="1.1" id="sec:alphabet-et-mots"><span
class="header-section-number">1.1</span> Alphabet et mots</h2>
<p><div class="ui message"><div class="header">Définition</div> On
considère un ensemble fini appelé <em>alphabet</em> et noté
traditionnelement <span class="math inline">\(\Sigma\)</span>. Ses
éléments sont appelés des <em>lettres</em> ou des <em>symboles</em>.</p>
<p>Un mot sur <span class="math inline">\(\Sigma\)</span> est une suite
finie d’éléments de <span class="math inline">\(\Sigma\)</span>. On note
<span class="math inline">\(\epsilon\)</span> le mot vide. Un mot non
vide <span class="math inline">\((a,b,c,\dots)\)</span> sera juste noté
<span class="math inline">\(abc...\)</span>.</p>
<p>On note <span class="math inline">\(\Sigma^*\)</span> l’ensemble des
mots. </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si <span class="math inline">\(\Sigma = \{ a, b, \dots, z \}\)</span>
alors <span class="math inline">\(bonjour\)</span> est un mot.</p>
<p>On utilisera souvent l’alphabet réduit à deux lettres : <span
class="math inline">\(\{ a, b\}\)</span>. Il est particulièrement
important dans le contexte du binaire.</p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<ul>
<li>On a donc <span class="math inline">\(\Sigma^* = \bigcup_{n \in \N}
\Sigma^n\)</span> en posant <span class="math inline">\(\Sigma^0 = \{
\epsilon \}\)</span>.</li>
<li>On note <span class="math inline">\(|u|\)</span> la longueur du mot
<span class="math inline">\(u\)</span>. On a donc <span
class="math inline">\(|\epsilon| = 0\)</span>.</li>
</ul>
<p></div></p>
<p><div class="ui message"><div class="header">Définition</div> On
définit une loi de composition <span class="math inline">\(.\)</span>
interne appelée concaténation ainsi : <span class="math display">\[
\forall x_1 \dots x_n, y_1 \dots y_m \in \Sigma^*,
x_1\dots x_n . y_1 \dots y_m = x_1 \dots x_n y_1 \dots y_m
\]</span> </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<ul>
<li><span class="math inline">\(\epsilon\)</span> est le neutre de la
concaténation</li>
<li>La concaténation est associative. On dit que <span
class="math inline">\((\Sigma^*, .)\)</span> est un
<strong>monoïde</strong>.</li>
<li>On omet le plus souvent le symbole de la concaténation. Dans le
contexte où on mélange des mots et des lettres, cela revient à
identifier les lettres et les mots à une lettre qui leur sont associées.
Par exemple, si on écrit <span class="math inline">\(awb\)</span> avec
<span class="math inline">\(a,b \in \Sigma\)</span> et <span
class="math inline">\(w \in \Sigma^*\)</span>.</li>
<li><span class="math inline">\(|uv| = |u| + |v|\)</span>.</li>
<li>Si <span class="math inline">\(\Sigma = \{ \star \}\)</span>
l’alphabet à une lettre, alors <span class="math inline">\((\Sigma^*,
.)\)</span> est isomorphe à <span class="math inline">\((\N, +)\)</span>
en tant que monoïde.</li>
</ul>
<p></div></p>
<p>Conséquence directe de la définition de <span
class="math inline">\(\Sigma^*\)</span> :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soient <span class="math inline">\(w, w&#39; \in
\Sigma^*\)</span>.</p>
<p><span class="math display">\[
w = w&#39; \iff \begin{cases}
|w| = |w&#39;| = n \\
w = w_1 \dots w_n, w&#39; = w&#39;_1 \dots w&#39;_n  \text{ et } \forall
i \in \range{1}{n}, w_i = w&#39;_i
\end{cases}
\]</span></p>
</div>
<h2 data-number="1.2" id="sec:suffixe-préfixe-facteurs-sous-mots"><span
class="header-section-number">1.2</span> Suffixe, Préfixe, facteurs,
sous-mots</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(u,v \in \Sigma^*\)</span>. On dit que <span
class="math inline">\(v\)</span> est un</p>
<ul>
<li><strong>suffixe</strong> de <span class="math inline">\(u\)</span>
lorsqu’il existe <span class="math inline">\(w\in \Sigma^*\)</span> tel
que <span class="math inline">\(u = w v\)</span>. Quand <span
class="math inline">\(u, w \neq \epsilon\)</span> on dit que <span
class="math inline">\(v\)</span> est un suffixe propre de <span
class="math inline">\(u\)</span>.</li>
<li><strong>préfixe</strong> de <span class="math inline">\(u\)</span>
lorsqu’il existe <span class="math inline">\(w\in \Sigma^*\)</span> tel
que <span class="math inline">\(u = v w\)</span>. Quand <span
class="math inline">\(u, w \neq \epsilon\)</span> on dit que <span
class="math inline">\(v\)</span> est un préfixe propre de <span
class="math inline">\(u\)</span>.</li>
<li><strong>facteur</strong> de <span class="math inline">\(u\)</span>
lorsqu’il existe <span class="math inline">\(w,w&#39; \in
\Sigma^*\)</span> tels que <span class="math inline">\(u = w v
w&#39;\)</span>. Quand <span class="math inline">\(u, w, w&#39; \neq
\epsilon\)</span>, on dit que <span class="math inline">\(v\)</span> est
un facteur propre de <span class="math inline">\(u\)</span>.</li>
<li><strong>sous-mot</strong> de <span class="math inline">\(u\)</span>
lorsque <span class="math inline">\(v = u =\epsilon\)</span>, ou lorsque
<span class="math inline">\(u = x_1 \dots x_n \neq\epsilon\)</span> où
<span class="math inline">\(x_1,\dots, x_n \in \Sigma\)</span> et que
<span class="math inline">\(u = \epsilon\)</span> ou qu’il existe <span
class="math inline">\(\{i_1,\dots,i_k\} \subset \range{1}{n}\)</span>
tels que <span class="math inline">\(v = x_{i_1} \dots x_{i_k}\)</span>.
</div></li>
</ul>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on considère le mot <span
class="math inline">\(triskaidekaphobia\)</span>,</p>
<ul>
<li><span class="math inline">\(tri\)</span> est un préfixe propre</li>
<li><span class="math inline">\(phobia\)</span> est un suffixe
propre</li>
<li><span class="math inline">\(aide\)</span> est un facteur propre</li>
<li><span class="math inline">\(trap\)</span> est un sous-mot</li>
</ul>
</div>
<h2 data-number="1.3" id="sec:langage"><span
class="header-section-number">1.3</span> Langage</h2>
<p><div class="ui message"><div class="header">Définition</div> Un
<strong>langage</strong> sur l’alphabet <span
class="math inline">\(\Sigma\)</span> est une partie de <span
class="math inline">\(\Sigma^*\)</span>. </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Sur l’aphabet <span class="math inline">\(\{a,b\}\)</span>, les
ensembles suivants sont des langages :</p>
<ul>
<li>les mots ne contenant que des <span class="math inline">\(a\)</span>
: <span class="math inline">\(\enscomp{a^n}{n \in \N}\)</span></li>
<li>les mots ayant le même nombre de <span
class="math inline">\(a\)</span> que de <span
class="math inline">\(b\)</span></li>
<li>les palindromes, c’est-à-dire les mots pouvant se lire de la même
manière de gauche à droite et de droite à gauche</li>
</ul>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Les langages peuvent être facile à définir mais dur à expliciter. Il
existe ainsi un langage contenant tous les énoncés que vous aurez aux
concours, mais ce sera difficile de le déterminer avant les épreuves
!</p>
<p></div></p>
<p><div class="ui message"><div class="header">Définition</div> Soient
<span class="math inline">\(L, L&#39;\)</span> des langages sur un même
alphabet.</p>
<p>On note</p>
<ul>
<li><span class="math inline">\(L+L&#39; = L\cup L&#39;\)</span> le
<strong>langage union</strong> de ces langages.</li>
<li><span class="math inline">\(L L&#39; = \enscomp{uv}{u \in L, v\in
L&#39;}\)</span> la <strong>concaténée</strong> de ces langages.</li>
<li><span class="math inline">\(L^n = L \dots L\)</span> la concaténée
de <span class="math inline">\(n\)</span> copies de <span
class="math inline">\(L\)</span> et <span class="math inline">\(L^0 = \{
\epsilon \}\)</span>.</li>
<li><span class="math inline">\(L^* = \bigcup_{n \in \N} L^n\)</span>
appelée <strong>l’étoile de Kleene</strong> de <span
class="math inline">\(L\)</span>. </div></li>
</ul>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><span class="math inline">\(L^*\)</span> est clos par concaténation :
<span class="math inline">\(\forall w, w&#39; \in L^*, ww&#39; \in
L^*\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Soit <span class="math inline">\(w,
w&#39; \in L^*\)</span>. Il existe <span class="math inline">\(n,
m\)</span> tels que <span class="math inline">\(w = w_1 \dots w_n \in
L^n\)</span> et <span class="math inline">\(w&#39; = w&#39;_1 \dots
w&#39;_m \in L^m\)</span>, on a donc <span class="math inline">\(w
w&#39; = w_1 \dots w_n w&#39;_1 \dots w&#39;_m \in L^{n+m} \subset
L^*\)</span>. </div> </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p><span class="math inline">\(\emptyset^* = \{ \epsilon \}^* = \{
\epsilon \}\)</span></p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On peut démontrer de nombreuses relations sur les langages :</p>
<ul>
<li><span class="math inline">\(\cup\)</span> est associative,
commutative, idempotente et d’élément neutre <span
class="math inline">\(\emptyset\)</span>.</li>
<li>la concaténation est associative et d’élément neutre <span
class="math inline">\(\{ \epsilon \}\)</span> mais non commutative dès
que <span class="math inline">\(\Sigma\)</span> contient au moins deux
lettres. Elle distribue sur l’union.</li>
<li>L’étoile est déjà close, <span class="math inline">\((L^*)^* =
L^*\)</span>.</li>
</ul>
<p></div></p>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> On a naturellement <span
class="math inline">\(L^* \subset (L^*)^*\)</span>. Soit <span
class="math inline">\(w \in (L^*)^*\)</span>, il existe <span
class="math inline">\(n \in \N\)</span> et <span
class="math inline">\(w_1, \dots, w_n \in L^*\)</span> tels que <span
class="math inline">\(w = w_1 \dots w_n\)</span>. Comme <span
class="math inline">\(L^*\)</span> est clos par concaténation, on a
<span class="math inline">\(w = w_1 \dots w_n \in L^*\)</span>. Ainsi,
on a l’égalité par double inclusion. </div> </div></p>
<h2 data-number="1.4" id="sec:langages-réguliers-1"><span
class="header-section-number">1.4</span> Langages réguliers</h2>
<p><div class="ui message"><div class="header">Définition</div>
L’ensemble <span class="math inline">\(\mathop{Reg}(\Sigma)\)</span> des
langages réguliers sur <span class="math inline">\(\Sigma\)</span> est
défini inductivement ainsi :</p>
<ul>
<li><span class="math inline">\(\emptyset \in
\mathop{Reg}(\Sigma)\)</span></li>
<li><span class="math inline">\(\forall a \in \Sigma, \{a\} \in
\mathop{Reg}(\Sigma)\)</span></li>
<li><span class="math inline">\(\forall A \in \mathop{Reg}(\Sigma), A^*
\in \mathop{Reg}(\Sigma)\)</span></li>
<li><span class="math inline">\(\forall A,B \in \mathop{Reg}(\Sigma),
A+B, AB \in \mathop{Reg}(\Sigma)\)</span> </div></li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<ul>
<li>Autrement dit, <span
class="math inline">\(\mathop{Reg}(\Sigma)\)</span> est le plus petit
ensemble contenant <span class="math inline">\(\emptyset\)</span> est
les langages réduit à une lettre qui soit stable par concaténation,
union et étoile de Kleene.</li>
<li>Les langages réguliers correspondent à la classe des langages
facilement reconnaissables, comme on le verra dans la partie suivante,
tout en étant suffisament expressifs.</li>
</ul>
<p></div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Soit <span class="math inline">\(L\)</span> le langage des mots sur
<span class="math inline">\(\{ a, b \}\)</span> sans facteurs <span
class="math inline">\(aa\)</span> ou <span
class="math inline">\(bb\)</span>.</p>
<p>Il s’agit donc des mots qui alternent les lettres.</p>
<p><span class="math inline">\(L\)</span> est régulier car on peut
l’écrire :</p>
<p><span class="math display">\[
L = (\{b\} + \{\epsilon\}) \{ab\}^*
    (\{a\} + \{\epsilon\})
\]</span> En effet, un tel mot est de quatre formes selon qu’il commence
ou pas un <span class="math inline">\(b\)</span> et qu’il finisse ou pas
par un <span class="math inline">\(a\)</span>.</p>
</div>
<h2 data-number="1.5" id="sec:expression-régulière"><span
class="header-section-number">1.5</span> Expression régulière</h2>
<p>On a pu voir dans le dernier exemple que la notation d’un langage
régulier à l’aide de la définition inductive est un peu lourde. Afin
d’améliorer cela, on va introduire une dénotation particulière des
langages réguliers : les expressions régulières.</p>
<p><div class="ui message"><div class="header">Définition</div> Les
expressions régulières sur <span class="math inline">\(\Sigma\)</span>
sont des arbres d’expressions dont les feuilles sont étiquetées par
<span class="math inline">\(\{ \emptyset, \epsilon \} \cup
\Sigma\)</span> et ayant des nœuds binaires étiquettés par <span
class="math inline">\(\{|, .\}\)</span> et des nœuds unaires étiquettés
par <span class="math inline">\(\{*\}\)</span>.</p>
<p>On adopte la notation infixe usuelle pour ces expressions en plaçant
<span class="math inline">\(*\)</span> en opérateur unaire postfixe et
en omettant de noter <span class="math inline">\(.\)</span>. </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Les expressions suivantes sont des expressions régulières sur <span
class="math inline">\(\{a,b\}\)</span> :</p>
<p><span class="math display">\[
a, b, ab, a|b, (a|b)a^*, \emptyset b
\]</span></p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On suppose que les opérateurs ont des précédences dans l’ordre <span
class="math inline">\(* &gt; . &gt; |\)</span> et ainsi, on pourra
omettre certaines parenthèses : <span class="math inline">\((a(b^*))|c =
ab^*|c\)</span>.</p>
<p></div></p>
<p><div class="ui message"><div class="header">Définition</div> On
associe à toute expression régulière <span
class="math inline">\(e\)</span> sur <span
class="math inline">\(\Sigma\)</span> un langage <span
class="math inline">\(\mathop{lang}(e)\)</span> :</p>
<ul>
<li><span class="math inline">\(\mathop{lang}(\emptyset) =
\emptyset\)</span></li>
<li><span class="math inline">\(\mathop{lang}(\epsilon) = \{ \epsilon
\}\)</span></li>
<li><span class="math inline">\(\forall a \in \Sigma, \mathop{lang}(a) =
\{ a \}\)</span>.</li>
<li><span class="math inline">\(\mathop{lang}(e e&#39;) =
\mathop{lang}(e) \mathop{lang}(e&#39;)\)</span></li>
<li><span class="math inline">\(\mathop{lang}(e|e&#39;) =
\mathop{lang}(e) + \mathop{lang}(e&#39;)\)</span></li>
<li><span class="math inline">\(\mathop{lang}(e^*) =
\mathop{lang}(e)^*\)</span></li>
</ul>
<p>On dit que <span class="math inline">\(e\)</span> est une dénotation
du langage <span class="math inline">\(\mathop{lang}(e)\)</span>.
</div></p>
<p>La définition calquant celle des langages réguliers, on a directement
le théorème suivant :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Les langages admettant une dénotation par une expression rationnelle
sont exactement les langages réguliers.</p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Un langage régulier n’admet pas une unique dénotation. Par exemple,
<span class="math inline">\(\{ a \}^*\)</span> peut se noter <span
class="math inline">\(a^*\)</span> mais également <span
class="math inline">\(aa^*|\epsilon\)</span></p>
<p></div></p>
<p>Afin de simplifier les expressions régulières, on est amené à
identifier deux expressions régulières dénotant un même langage. Ainsi,
on écrira directement <span class="math inline">\((a|b)c =
ac|bc\)</span>.</p>
<h2 data-number="1.6"
id="sec:expressions-régulières-étendues-posix"><span
class="header-section-number">1.6</span> Expressions régulières étendues
POSIX</h2>
<p>On distingue trois types d’expressions régulières dans les outils
Unix :</p>
<ul>
<li>les expressions simples acceptées par un shell</li>
<li>les expresions régulières POSIX</li>
<li>les expresions régulières POSIX étendues.</li>
</ul>
<p>On présente ici les expressions étendues. Elles sont composées :</p>
<ul>
<li>de caractères, pour ceux qui sont utilisés dans les définitions
suivantes, on les <em>échappe</em> avec un <code>\</code> comme dans
<code>\.</code> ou <code>\*</code></li>
<li>de listes de caractères sous la forme <code>[abc]</code> pour
représenter <span class="math inline">\(a|b|c\)</span>. On peut aussi
utiliser <code>a-z</code> pour indiquer tous les caractères de
<code>a</code> à <code>z</code>.</li>
<li>de listes niées de la forme <code>[^...]</code> où on considère tous
les caractères sauf ceux qui sont indiqués.</li>
<li>le caractère <code>.</code> représente n’importe quel
caractère.</li>
<li>le caractère <code>^</code> est un caractère spécial représentant le
début d’une chaîne. De même, <code>$</code> représente la fin.</li>
<li>de parenthèses pour regrouper des sous-expressions</li>
<li>des opérateurs <code>*</code> et <code>|</code> comme dans la
définition des expressions régulières</li>
</ul>
<p>On a également des ajouts pratiques :</p>
<ul>
<li><code>+</code> et <code>?</code> qui sont des sucres syntaxiques
pour les définitions suivantes : <code>e+ = ee*</code> et
<code>e? = (e|)</code>. Il n’y a pas de <span
class="math inline">\(\epsilon\)</span>, on se contente d’utiliser
l’expression vide comme ici.</li>
<li>pour <span class="math inline">\(m,n \in \N\)</span> et
<code>e</code> une expression on peut écrire :
<ul>
<li><code>e{n}</code> pour exactement <span
class="math inline">\(n\)</span> copies de <code>e</code></li>
<li><code>e{m,}</code> pour au moins <span
class="math inline">\(m\)</span> copies de <code>e</code></li>
<li><code>e{,n}</code> pour au plus <span
class="math inline">\(n\)</span> copies de <code>e</code></li>
<li><code>e{m,n}</code> pour entre <span
class="math inline">\(m\)</span> et <span
class="math inline">\(n\)</span> copies de <code>e</code></li>
</ul></li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il s’agit ici aussi de sucres. En effet, on pourrait écrire :</p>
<ul>
<li><code>e{3} = eee</code></li>
<li><code>e{3,} = eeee*</code></li>
<li><code>e{,3} = (|e|ee|eee)</code></li>
<li><code>e{3,2} = (ee|eee)</code></li>
</ul>
<p></div></p>
<h1 data-number="2" id="sec:automates-finis"><span
class="header-section-number">2</span> Automates finis</h1>
<p>On va présenter ici un modèle de calcul permettant de reconnaitre des
langages réguliers.</p>
<h2 data-number="2.1" id="sec:automates-finis-déterministes"><span
class="header-section-number">2.1</span> Automates finis
déterministes</h2>
<p><div class="ui message"><div class="header">Définition</div> Un
<strong>automate fini déterministe</strong> est un quintuplet <span
class="math inline">\(A = (Q, \Sigma, \delta, q_i, F)\)</span> où</p>
<ul>
<li><span class="math inline">\(\Sigma\)</span> est un alphabet
fini</li>
<li><span class="math inline">\(Q\)</span> est un ensemble fini appelé
l’ensemble des <strong>états</strong> de l’automate</li>
<li><span class="math inline">\(q_i \in Q\)</span> est appelé
<strong>l’état initial</strong></li>
<li><span class="math inline">\(F \subset Q\)</span> est appelé
l’ensemble des <strong>états finaux</strong></li>
<li><span class="math inline">\(\delta\)</span> est une application
partielle de <span class="math inline">\(Q \times \Sigma\)</span> dans
<span class="math inline">\(Q\)</span> est appelée la <strong>fonction
de transition</strong> de l’automate. </div></li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Une application partielle de <span class="math inline">\(E\)</span>
dans <span class="math inline">\(F\)</span> est une application <span
class="math inline">\(E&#39; \rightarrow F\)</span> où <span
class="math inline">\(E&#39; \subset E\)</span> est le domaine de
l’application.</p>
<p>Quand le domaine de <span class="math inline">\(\delta\)</span> est
<span class="math inline">\(Q \times \Sigma\)</span>, on dit que
l’automate est complet.</p>
<p></div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Considérons l’automate fini <span class="math inline">\(A =
(\{q_0,q_1,q_2,q_3\}, \{a,b\}, \delta, q_0, \{ q_3 \})\)</span> où :</p>
<p><span class="math display">\[\delta(q_0,a) = q_1, \delta(q_0, b) =
q_2\]</span> <span class="math display">\[\delta(q_1,a) = q_1,
\delta(q_1, b) = q_3\]</span> <span class="math display">\[\delta(q_2,a)
= q_3, \delta(q_2, b) = q_3\]</span></p>
<p>On peut représenter <span class="math inline">\(\delta\)</span> sous
forme tabulaire, on parle alors de <strong>table de transition</strong>.
L’état initial est indiqué par une flèche et les états finaux par une
astérisque.</p>
<p><span class="math display">\[
\begin{array}{rc|cc}
&amp; &amp; a &amp; b \\
\rightarrow &amp; q_0 &amp; q_1 &amp; q_2 \\
&amp; q_1 &amp; q_1 &amp; q_3 \\
&amp; q_2 &amp; q_3 &amp; q_2 \\
* &amp; q_3
\end{array}
\]</span></p>
<p>On adopte une notation graphique pour présenter les automates. Les
états sont des nœuds et les arêtes permettent de représenter <span
class="math inline">\(\delta\)</span>. Les états finaux sont indiqués
par une flèche sortante ou un double trait comme ici :</p>
<p><center><div class="ui image center"><img
src="assets/pics/automate_ex1.png" /></div></center></p>
</div>
<h2 data-number="2.2" id="sec:accessibilité-co-accessibilité"><span
class="header-section-number">2.2</span> Accessibilité,
Co-accessibilité</h2>
<p>On peut préciser la notation précédente d’un automate sous la forme
d’un graphe. Comme on peut avoir deux transitions <span
class="math inline">\(\delta(q,a) = \delta(q,b) = q&#39;\)</span> avec
<span class="math inline">\(a \neq b\)</span> ainsi que des boucles, le
graphe n’est pas simple et parler d’ensemble de couples de sommets pour
les arêtes ne suffit plus.</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(A = (Q, \Sigma, \delta, q_i, F)\)</span> un
automate fini.</p>
<p>On pose <span class="math inline">\(E_A \subset Q \times \Sigma
\times Q\)</span> défini par <span class="math inline">\((q,a,q&#39;)
\in E_A \iff \delta(q,a) = q&#39;\)</span>.</p>
<p>Le couple <span class="math inline">\(G_A = (Q, E_A)\)</span> est le
graphe, dont les arêtes sont étiquettées, associé à l’automate <span
class="math inline">\(A\)</span>. </div></p>
<p>Grâce à ce graphe, on peut utiliser des notions de chemins entre
états :</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(A = (Q, \Sigma, \delta, q_i, F)\)</span> un
automate fini et <span class="math inline">\(q \in Q\)</span>.</p>
<p>On dit que <span class="math inline">\(q\)</span> est</p>
<ul>
<li><strong>accessible</strong> lorsque <span class="math inline">\(q_i
\leadsto q\)</span>.</li>
<li><strong>co-accessible</strong> lorsqu’il existe <span
class="math inline">\(q_f\in F\)</span> tel que <span
class="math inline">\(q \leadsto q_f\)</span>.</li>
</ul>
<p>Quand tous les états d’un automate sont accessibles et
co-accessibles, on dit que l’automate est <strong>émondé</strong>.
</div></p>
<h2 data-number="2.3"
id="sec:langage-reconnu-par-un-automate-fini"><span
class="header-section-number">2.3</span> Langage reconnu par un automate
fini</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(A = (Q, \Sigma, \delta, q_i, F)\)</span> un
automate fini.</p>
<p>On dit que <span class="math inline">\(m \in \Sigma^*\)</span> est
<strong>reconnu</strong> par <span class="math inline">\(A\)</span> si
c’est l’étiquette d’un chemin de <span
class="math inline">\(q_i\)</span> à un état final.</p>
<p>On appelle <strong>langage reconnu</strong> par l’automate l’ensemble
des mots <strong>reconnaissables</strong>, on le note <span
class="math inline">\(\mathop{lang}(A)\)</span>. </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On reprend l’exemple précédent d’automates. Pour qu’il reconnaisse un
mot, on voit que celui-ci doit être soit de la forme <span
class="math inline">\(a^nb\)</span> soit de la forme <span
class="math inline">\(b^na\)</span> avec <span class="math inline">\(n
&gt; 0\)</span>.</p>
<p>On peut décrire précisément ce langage par l’expression régulière
<span class="math inline">\(aa^*b | bb^*a\)</span>.</p>
</div>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Étant donné un automate fini, il est possible d’en déduire un
automate complet et un automate émondé ayant tous les trois le même
langage reconnu.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Seuls les états accessibles et
co-accessibles peuvent apparaitre dans un chemin de l’état initial à un
état final, ainsi, les autres états n’ont aucune influence sur le
langage reconnu.</p>
<p>Pour rendre un automate complet, il suffit de rajouter un état
supplémentaire, communément appelé <em>état puits</em>, <span
class="math inline">\(q_p\)</span> et de poser : <span
class="math inline">\(A&#39; = (Q \cup \{ q_p \}, \Sigma, \delta&#39;,
q_i, F)\)</span> avec pour <span class="math inline">\(q \in Q\cup
{q_p}\)</span> et <span class="math inline">\(a \in \Sigma\)</span>,
<span class="math inline">\(\delta&#39;(q,a) = \delta(q,a)\)</span> si
la transition était définie et <span
class="math inline">\(\delta&#39;(q,a) = q_p\)</span> sinon.</p>
<p>Pour émonder un automate, il suffit juste de supprimer tous les états
qui ne sont pas accessibles ou pas co-accessibles. </div> </div></p>
<h2 data-number="2.4" id="sec:fonction-de-transition-étendue"><span
class="header-section-number">2.4</span> Fonction de transition
étendue</h2>
<p>Il est souvent utile de raisonner directement sur des mots pour
effectuer plusieurs transitions d’affilée. On introduit alors la notion
suivante :</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(A = (Q, \Sigma, \delta, q_i, F)\)</span> un
automate fini déterministe, on définit sa <strong>fonction de transition
étendue</strong> <span class="math inline">\(\delta^* : Q \times
\Sigma^* \rightarrow Q\)</span> par récurrence sur la longueur des mots
ainsi : <span class="math display">\[
\forall q \in Q, \delta^*(q,\epsilon) = q
\]</span> <span class="math display">\[
\forall w \in \Sigma^*, \forall a \in \Sigma,
\delta^*(q,wa) = \delta(\delta^*(q,w),a)
\]</span> </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On a ainsi <span class="math display">\[
\mathop{lang}(A) = \enscomp{w \in \Sigma^*}{\delta^*(q_i,w) \in F}
\]</span></p>
<p></div></p>
<h2 data-number="2.5" id="sec:modélisation-par-des-automates"><span
class="header-section-number">2.5</span> Modélisation par des
automates</h2>
<p>On vient de voir que les automates finis permettent de caractériser
certains langages, mais ils permettent également de modéliser des
systèmes à plusieurs états.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On considère un distributeur de boissons qui permet de distribuer des
expressos ou des cafés longs. Un expresso coute 1€ et un long coute 2€.
On considère qu’on peut mettre des pièces de 50c, 1€ ou 2€. On souhaite
modéliser l’échange amenant à valider la quantité d’argent inséré. On
suppose que la boisson qui sera distribuée est stockée ailleurs que dans
un état, donc un état final signifiera uniquement que le bon montant a
été inséré.</p>
<p>On ignore également toutes les pièces dépassant le montant dû, on
pourrait ainsi rajouter des boucles sur les états avec ces valeurs. On
les omet dans le dessin suivant pour être plus lisible :</p>
<p><center><div class="ui image center"><img
src="assets/pics/automate_ex_distrib.png" /></div></center></p>
<p>Les mots reconnus sont alors :</p>
<ul>
<li>long-2€</li>
<li>long-1€-1€</li>
<li>long-1€-50c-50c</li>
<li>long-50c-1€-50c</li>
<li>long-50c-50c-1€</li>
<li>long-50c-50c-50c-50c</li>
<li>expresso-1€</li>
<li>expresso-50c-50c</li>
</ul>
<p>Ce qui correspond exactement au comportement souhaité.</p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On a parlé de mots, mais on parle en général de <strong>traces
d’exécution</strong> qui permettent de s’assurer que le comportement est
celui que l’on souhaite.</p>
<p></div></p>
<h2 data-number="2.6" id="sec:automates-non-déterministes"><span
class="header-section-number">2.6</span> Automates non
déterministes</h2>
<p>On va modifier la définition afin de donner plus de souplesse et donc
<em>a priori</em> plus de pouvoir expressif aux automates.</p>
<p><div class="ui message"><div class="header">Définition</div> Un
<strong>automate fini non déterministe</strong> est un quintuplet <span
class="math inline">\(A = (Q, \Sigma, \delta, q_i, F)\)</span> où</p>
<ul>
<li><span class="math inline">\(\Sigma\)</span> est un alphabet
fini</li>
<li><span class="math inline">\(Q\)</span> est un ensemble fini appelé
l’ensemble des <strong>états</strong> de l’automate</li>
<li><span class="math inline">\(I \subset Q\)</span> est appelé
l’ensemble des **états initiaux*</li>
<li><span class="math inline">\(F \subset Q\)</span> est appelé
l’ensemble des <strong>états finaux</strong></li>
<li><span class="math inline">\(\delta : Q \times \Sigma \rightarrow
\mathcal{P}(Q)\)</span> est appelée la <strong>fonction de
transition</strong> de l’automate. </div></li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Dans cette définition, les seuls changements par rapport aux
automates déterministes sont la présence de plusieurs états initiaux et
le fait qu’on ait des transitions vers <span
class="math inline">\(0,1\)</span> ou plus d’états.</p>
<p>Si <span class="math inline">\(\delta(q,a) = \emptyset\)</span> c’est
équivalent à ne pas avoir défini la transition dans l’application
partielle d’un automate déterministe. La nouveauté est donc dans le fait
d’avoir plusieurs états.</p>
<p>On représente naturellement ces automates de manière en rajoutant des
flèches étiquetées par <span class="math inline">\(a\)</span> depuis un
état <span class="math inline">\(q\)</span> vers chaque état de <span
class="math inline">\(\delta(q,a)\)</span>.</p>
<p></div></p>
<p>On définit de même la fonction de transition étendue d’un automate
non-déterministe.</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(A = (Q, \Sigma, \delta, I, F)\)</span> un
automate fini non déterministe, on définit sa <strong>fonction de
transition étendue</strong> <span class="math inline">\(\delta^* : Q
\times \Sigma^* \rightarrow \mathcal{P}(Q)\)</span> par récurrence sur
la longueur des mots ainsi : <span class="math display">\[
\forall q \in Q, \delta^*(q,\epsilon) = \{q\}
\]</span> <span class="math display">\[
\forall w \in \Sigma^*, \forall a \in \Sigma,
\delta^*(q,wa) = \bigcup_{q&#39; \in \delta^*(q,w)} \delta(q&#39;,a)
\]</span> </div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(A = (Q, \Sigma, \delta, q_i, F)\)</span> un
automate fini non-déterministe, on appelle <em>langage reconnu</em> par
<span class="math inline">\(A\)</span> l’ensemble <span
class="math display">\[
\mathop{lang}(A) = \bigcup_{q_i \in I}
\enscomp{w \in \Sigma^*}{\delta^*(q_i,w) \cap F \neq \emptyset}
\]</span> </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>L’automate non-déterministe suivant reconnait les mots dont
l’avant-dernière lettre est un a.</p>
<p><center><div class="ui image center"><img
src="assets/pics/automate_ex_nfa.png" /></div></center></p>
<p>On voit qu’il y a un choix non-déterministe ici qui permet de deviner
la fin d’un mot.</p>
</div>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(A\)</span> un automate fini
non-déterministe, il existe un automate fini déterministe <span
class="math inline">\(A&#39;\)</span> reconnaissant le même langage que
<span class="math inline">\(A\)</span>.</p>
<p>De plus, si <span class="math inline">\(A\)</span> contient <span
class="math inline">\(n\)</span> états, alors <span
class="math inline">\(A&#39;\)</span> contient au plus <span
class="math inline">\(2^n\)</span> états.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> On va, en fait, présenter une
méthode permettant de <strong>déterminiser</strong> un automate fini.
Cette construction est appelée <strong>l’automates des
parties</strong>.</p>
<p>Si <span class="math inline">\(A = (Q, \Sigma, \delta, I, F)\)</span>
on pose <span class="math inline">\(A&#39; = (\mathcal{P}(Q), \Sigma,
\delta&#39;, I, F&#39;)\)</span> où <span class="math display">\[
F&#39; = \enscomp{p \subset Q}{p \cap F \neq \emptyset}
\]</span> et, pour <span class="math inline">\(p \subset Q\)</span> et
<span class="math inline">\(a \in \Sigma\)</span>, <span
class="math display">\[
\delta&#39;(p,a) = \bigcup_{q \in p} \delta(q,a)
\]</span> On peut émonder l’automate pour diminuer son nombre d’état,
mais on voit tout de suite qu’il en contient au plus <span
class="math inline">\(2^{|Q|}\)</span>.</p>
<p>Pour conclure, on doit montrer que <span
class="math inline">\(\mathop{lang}(A) = \mathop{lang}(A&#39;)\)</span>.
Pour cela, on va montrer le résultat suivant par récurrence sur <span
class="math inline">\(|w|\)</span> : <span class="math display">\[
\forall w \in \Sigma^*, \bigcup_{q_i \in I} \delta^*(q_i,w) =
\delta&#39;^*(I,w)
\]</span></p>
<ul>
<li><p><em>Initialisation</em> : <span
class="math inline">\(\bigcup_{q_i \in I} \delta^*(q_i,\epsilon) =
\bigcup_{q_i \in I} \{ q_i \} = I =
\delta&#39;^*(I,\epsilon)\)</span></p></li>
<li><p><em>Hérédité</em> : si la propriété est vraie pour des mots de
longueurs <span class="math inline">\(n\)</span>, soit <span
class="math inline">\(wa \in \Sigma^*\)</span> où <span
class="math inline">\(a \in \Sigma\)</span> avec <span
class="math inline">\(|w|=n\)</span>.</p>
<p>On a <span class="math display">\[
\begin{array}{rcl}
\bigcup_{q_i \in I} \delta^*(q_i,wa) &amp; = &amp;\bigcup_{q_i \in I}
\bigcup_{q \in \delta^*(q_i,w)} \delta(q,a)
\\ &amp; = &amp;\bigcup_{q \in \bigcup_{q_i \in I} \delta^*(q_i,w)}
\delta(q,a)
\\ &amp; = &amp;\bigcup_{q \in \delta&#39;^*(I,w)} \delta(q,a)
\\ &amp; = &amp; \delta&#39;(\delta&#39;^*(I,w),a) \\ &amp; = &amp;
\delta&#39;^*(I,wa)
\end{array}
\]</span></p></li>
</ul>
<p>Ainsi, on a l’égalité voulue et donc <span class="math display">\[
\begin{array}{rcl}
\mathop{lang}(A) &amp; = &amp; \bigcup_{q_i \in I} \enscomp{w \in
\Sigma^*}{\delta^*(q_i,w) \cap F \neq
\emptyset} \\
&amp; = &amp; \enscomp{w \in \Sigma^*}{\bigcup_{q_i \in I}
\delta^*(q_i,w) \cap F \neq
\emptyset} \\
&amp; = &amp; \enscomp{w \in \Sigma^*}{\delta&#39;^*(I,w) \cap F \neq
\emptyset}  \\
&amp; = &amp; \enscomp{w \in \Sigma^*}{\delta&#39;^*(I,w) \in
F&#39;}  \\
&amp; = &amp; \mathop{lang}(A&#39;)
\end{array}
\]</span> </div> </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Pour réaliser ce procédé de détermination en pratique, on établit une
table de transition en partant de <span class="math inline">\(I\)</span>
et en rajoutant une ligne pour chaque nouvel état rencontré. Se faisant,
on obtient un automate partiellement émondé.</p>
<p>Si on reprend l’exemple précédent, on va définir la table suivante
:</p>
<p><span class="math display">\[
\begin{array}{rc|cc}
&amp; &amp; a &amp; b \\
\rightarrow &amp; \{ q_0 \} &amp; \{ q_0, q_1 \} &amp; \{q_0\} \\
&amp; \{ q_0,q_1 \} &amp; \{ q_0, q_1, q_2 \} &amp; \{q_0, q_2\} \\
*&amp; \{ q_0,q_1,q_2 \}
&amp; \{ q_0,q_1, q_2 \} &amp; \{q_0,q_2\} \\
*&amp; \{ q_0,q_2 \}
&amp; \{ q_0,q_1, q_2 \} &amp; \{q_0\}
\end{array}
\]</span></p>
<p><center><div class="ui image center"><img
src="assets/pics/automate_ex_nfa_det.png" /></div></center></p>
<p>On remarque avec cette construction qu’on a deux états acceptants qui
correspondent aux suffixes <code>ab</code> et <code>aa</code>.</p>
</div>
<p>On admet facilement qu’il est possible de déduire un automate
non-déterministe d’un automate déterministe en posant <span
class="math inline">\(\delta&#39;(q,a) = \{ \delta(q,a) \}\)</span> et
on a alors le corollaire :</p>
<div class="ui message olive">
<div class="header">
Corollaire
</div>
<p>Les langages reconnus par des automates déterministes sont exactement
les langages reconnus par des automates non-déterministes.</p>
</div>
<h2 data-number="2.7" id="sec:transitions-spontanées"><span
class="header-section-number">2.7</span> Transitions spontanées</h2>
<p>On peut également étendre les automates non-déterministes en
rajoutant des transitions spontanées, également appelées <span
class="math inline">\(\epsilon\)</span>-transition, entre les états en
considérant une fonction de transition prenant également le mot de vide
en entrée. Comme on va le voir, cela permet de n’avoir qu’un seul état
initial.</p>
<p><div class="ui message"><div class="header">Définition</div> Un
<strong>automate fini non-déterministe à transitions spontanées</strong>
est un quintuplet <span class="math inline">\(A = (Q, \Sigma, \delta,
q_i, F)\)</span> où</p>
<ul>
<li><span class="math inline">\(\Sigma\)</span> est un alphabet
fini</li>
<li><span class="math inline">\(Q\)</span> est un ensemble fini appelé
l’ensemble des <strong>états</strong> de l’automate</li>
<li><span class="math inline">\(q_i \in Q\)</span> est appelé **l’état
initial*</li>
<li><span class="math inline">\(F \subset Q\)</span> est appelé
l’ensemble des <strong>états finaux</strong></li>
<li><span class="math inline">\(\delta : Q \times (\Sigma \cup \{
\epsilon \}) \rightarrow \mathcal{P}(Q)\)</span> est appelée la
<strong>fonction de transition</strong>. </div></li>
</ul>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>L’automate suivant présente des transitions spontanées indiquées par
<span class="math inline">\(\epsilon\)</span> :
<center><div class="ui image center"><img
src="assets/pics/automate_spont.png" /></div></center></p>
</div>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(A\)</span> un automate fini non-déterministe
possédant des transitions spontanées et <span class="math inline">\(q
\in Q\)</span>. On définit l’ensemble <span
class="math inline">\(\overline{q}\)</span> définit par induction ainsi
: <span class="math inline">\(q \in \overline{q}\)</span> et <span
class="math display">\[
\forall q&#39;\in \overline{q}, \delta(q&#39;,\epsilon) \subset
\overline{q}
\]</span></p>
<p>Si <span class="math inline">\(E \subset Q\)</span>, on pose <span
class="math inline">\(\overline{E} =\enscomp{\overline{q}}{q \in
E}\)</span>. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p><span class="math inline">\(\overline{q}\)</span> est donc l’ensemble
des états accessibles dans le sous-graphe des états obtenus en ne
conservant que les transitions spontanées.</p>
<p>Cette complétion est nécessaire pour comprendre l’action de
l’automate sur les états dans la mesure où <span
class="math inline">\(q&#39; \in \delta(q,a)\)</span> signifie qu’on
peut également accéder aux états accessibles depuis <span
class="math inline">\(q&#39;\)</span> par transition spontanée.</p>
<p>On remarque qu’on a <span class="math inline">\(\overline{E \cup F} =
\overline{E} \cup \overline{F}\)</span>.</p>
<p></div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Dans <span class="math inline">\(A&#39;&#39;\)</span> on a <span
class="math inline">\(\overline{\{q_i\}} = \{q_i,q_0,q_4\}\)</span>.</p>
</div>
<p>On peut alors définir la fonction de transition étendue d’un tel
automate ainsi : <span class="math display">\[\forall q \in Q,
\delta^*(q,\epsilon) = \overline{q}\]</span> <span
class="math display">\[\forall w \in \Sigma^*, \forall a \in \Sigma,
\delta^*(q,wa) = \overline{ \bigcup_{q&#39; \in \delta^*(q,w)}
\delta(q&#39;,a)}\]</span> et on définit alors le langage reconnu par un
tel automate ainsi : <span class="math display">\[
\mathop{lang}(A) = \enscomp{w \in \Sigma^*}{\delta^*(q_i,w) \cap F \neq
\emptyset}
\]</span></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(A\)</span> un automate fini
non-déterministe possédant des transitions spontanées. Il existe un
automate non-déterministe <span class="math inline">\(A&#39;\)</span>
tel que <span class="math inline">\(\mathop{lang}(A) =
\mathop{lang}(A&#39;)\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> On pose <span
class="math inline">\(A&#39; = (Q, \Sigma, \delta&#39;, \overline{q_i},
F)\)</span> où <span class="math display">\[
\delta&#39;(q,a) = \overline{\delta(q,a)}
\]</span></p>
<p>On va montrer par récurrence sur <span
class="math inline">\(|w|\)</span> que <span class="math display">\[
\forall w \in \Sigma^*, \delta^*(q_i, w) =
\bigcup_{q \in \overline{q_i}} \delta&#39;^*(q,w)
\]</span></p>
<ul>
<li><em>Initialisation</em> <span
class="math inline">\(\delta^*(q_i,\epsilon) = \overline{q_i} =
\bigcup_{q \in \overline{q_i}} \{q \} = \bigcup_{q \in \overline{q_i}}
\delta&#39;^*(q, \epsilon)\)</span></li>
<li><em>Hérédité</em> supposons la propriété vraie pour les mots de
longueurs <span class="math inline">\(n\)</span> et soit <span
class="math inline">\(wa \in \Sigma^*\)</span> où <span
class="math inline">\(|w|=n\)</span> et <span class="math inline">\(a
\in \Sigma\)</span>. On a <span
class="math display">\[\begin{array}{rcl} \delta^*(q_i, wa) &amp; =
&amp;
\overline{\bigcup_{q&#39; \in \delta^*(q_i,w)} \delta(q&#39;,a)}  \\
&amp; = &amp; \bigcup_{q&#39; \in \delta^*(q_i,w)}
\overline{\delta(q&#39;,a)}  \\
&amp; = &amp; \bigcup_{q&#39; \in \bigcup_{q \in \overline{q_i}}
\delta&#39;^*(q,w)} \delta&#39;(q&#39;,a) \\
&amp; = &amp; \bigcup_{q \in \overline{q_i}} \bigcup_{q&#39;
\in  \delta&#39;^*(q,w)} \delta&#39;(q&#39;,a) \\
&amp; = &amp; \bigcup_{q \in \overline{q_i}} \delta&#39;^*(q, wa)
\end{array}\]</span></li>
</ul>
<p>On peut alors conclure sur les langages reconnus : <span
class="math display">\[
\begin{array}{rcl}
\mathop{lang}(A) &amp;=&amp; \enscomp{w \in \Sigma^*}{\delta^*(q_i,w)
\cap F \neq \emptyset}\\
&amp; = &amp; \enscomp{w \in \Sigma^*}{\bigcup_{q \in \overline{q_i}}
\delta^*(q,w)
\cap F \neq \emptyset}  \\
&amp; = &amp; \bigcup_{q \in \overline{q_i}} \enscomp{w \in
\Sigma^*}{\delta^*(q,w)
\cap F \neq \emptyset} \\
&amp; = &amp; \mathop{lang}(A&#39;)
\end{array}
\]</span> </div> </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On va éliminer les transitions spontanées de l’automate précédemment
donné en exemple. Pour cela, on peut commencer par établir une table
complétée :</p>
<p><span class="math display">\[
\begin{array}{cccc}
q &amp; c &amp; \delta(q,c) &amp; \overline{\delta(q,c)} \\
\hline
q_0 &amp; a &amp; \{ q_1 \} &amp; \{ q_0, q_1, q_2, q_4 \} \\
q_1 &amp; a &amp; \{ q_1 \} &amp; \{ q_0, q_1, q_2, q_3, q_4 \} \\
q_1 &amp; b &amp; \{ q_1 \} &amp; \{ q_0, q_1, q_2, q_3, q_4 \} \\
q_3 &amp; b &amp; \{ q_4 \} &amp; \{ q_4 \} \\
q_4 &amp; a &amp; \{ q_2 \} &amp; \{ q_0, q_2, q_3 \} \\
\end{array}
\]</span> Les états initiaux sont <span
class="math inline">\(\{q_0,q_3\}\)</span> et les états finaux sont
<span class="math inline">\(\{q_1, q_2\}\)</span>.</p>
<p>On a donc l’automate non-déterministe équivalent suivant :
<center><div class="ui image center"><img
src="assets/pics/automate_spont_nfa.png" /></div></center></p>
<p>On remarque donc que cette élimination des transitions spontanées ne
change pas les sommets mais uniquement les arêtes du graphe associé à
l’automate en en rajoutant par complétion.</p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Pour passer d’un automate non déterministe à un automate non
déterministe à transitions spontanées, il suffit de rajouter un nouvel
état initial et des transitions spontanées vers les anciens états
initiaux.</p>
<p></div></p>
<p>On a donc également le corollaire suivant en composant les théorèmes
précédents.</p>
<div class="ui message olive">
<div class="header">
Corollaire
</div>
<p>Les langages reconnus par un automate fini non-déterministe possédant
des transitions spontanées sont exactement les langages reconnus par un
automate fini déterministe.</p>
</div>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>En fait, il est possible de déterminiser directement un automate avec
transition spontanées.</p>
<p>On va déterminiser l’automate présenté au dessus en utilisant
là-aussi la méthode la table de transition construite à la volée. Il
faut juste bien faire attention à prendre la complétion des états
obtenus. Afin de simplifier la représentation, on a attribué une lettre
aux états.</p>
<p><span class="math display">\[
\begin{array}{rcc|cc}
&amp; &amp; &amp; a &amp; b \\
\rightarrow &amp; A &amp; \{ q_0, q_3 \} &amp; \{ q_0, q_1, q_2, q_3,
q_4 \}
&amp; \{ q_4 \} \\
* &amp; B &amp; \{ q_0, q_1, q_2, q_3, q_4 \} &amp;
\{q_0,q_1,q_2,q_3,q_4 \}
&amp; \{q_0,q_1,q_2,q_3,q_4 \} \\
&amp; C &amp; \{ q_4\} &amp; \{q_0,q_2,q_3\} &amp; \\
* &amp; D &amp; \{q_0,q_2,q_3\} &amp; \{q_0,q_1,q_2, q_3 , q_4 \} &amp;
\{ q_4 \}
\end{array}
\]</span> Cet automate peut se représenter graphiquement ainsi :
<center><div class="ui image center"><img
src="assets/pics/automate_spont_det.png" /></div></center></p>
</div>
<h1 data-number="3" id="sec:théorème-de-kleene"><span
class="header-section-number">3</span> Théorème de Kleene</h1>
<p>Dans cette partie, on va démontrer le théorème de Kleene :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><strong>(Kleene)</strong> Les langages réguliers sont exactement les
langages reconnaissables par un automate fini déterministe.</p>
</div>
<p>La preuve de ce théorème est suffisamment complexe pour qu’on la
sépare en deux résultats. On va montrer ici comment passer d’une
expression régulière à un automate, et réciproquement. Dans les deux
sens, on dispose de constructions inefficaces, faciles à comprendre, et
d’algorithmes efficaces mais plus délicats.</p>
<h2 data-number="3.1"
id="sec:des-expressions-régulières-aux-automates-non-déterministes-avec-transitions-spontanées"><span
class="header-section-number">3.1</span> Des expressions régulières aux
automates non-déterministes avec transitions spontanées</h2>
<p>On commence ici par montrer une construction très simple d’un
automate non-déterministe à transitions spontanées associé à une
expression régulière par induction sur l’expression.</p>
<p>On note <span class="math inline">\(A(e)\)</span> l’automate de
Thompson associé à l’expression <span class="math inline">\(e\)</span>,
il va s’agir dans tous les cas d’un automate à un état initial et un
état final. Un tel automate aura donc la forme suivante :
<center><div class="ui image center"><img
src="assets/pics/regexp_nfa_t.png" /></div></center></p>
<ul>
<li><p><span class="math inline">\(A(\epsilon) =\)</span>
<center><div class="ui image center"><img
src="assets/pics/regexp_nfa_0.png" /></div></center></p></li>
<li><p><span class="math inline">\(A(\emptyset) =\)</span>
<center><div class="ui image center"><img
src="assets/pics/regexp_nfa_v.png" /></div></center></p></li>
<li><p><span class="math inline">\(\forall a \in \Sigma, A(a) =\)</span>
<center><div class="ui image center"><img
src="assets/pics/regexp_nfa_1.png" /></div></center></p></li>
<li><p><span class="math inline">\(A(ee&#39;) =\)</span>
<center><div class="ui image center"><img
src="assets/pics/regexp_nfa_2.png" /></div></center></p></li>
<li><p><span class="math inline">\(A(e|e&#39;) =\)</span>
<center><div class="ui image center"><img
src="assets/pics/regexp_nfa_3.png" /></div></center></p></li>
<li><p><span class="math inline">\(A(e^*)=\)</span>
<center><div class="ui image center"><img
src="assets/pics/regexp_nfa_4.png" /></div></center></p></li>
</ul>
<p>On peut alors passer à un automate déterministe avec la méthode de
l’automate des parties.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On considère l’expression régulière <span
class="math inline">\((a|b)^*b(a|b)\)</span>.</p>
<p>L’automate de Thompson associé est donc :</p>
<p><center><div class="ui image center"><img
src="assets/pics/regexp_thompson_ex.png" /></div></center></p>
<p>Si on retire les transitions spontanées, on obtient l’automate :</p>
<p><center><div class="ui image center"><img
src="assets/pics/regexp_thompson_ex_rem.png" /></div></center></p>
<p>qui en émondant les états qui ne sont pas accessibles ou pas
co-accessibles devient :</p>
<p><center><div class="ui image center"><img
src="assets/pics/regexp_thompson_ex_rem2.png" /></div></center></p>
<p>Notons qu’il est possible d’obtenir directement un automate
comportant moins d’états : <center><div class="ui image center"><img
src="assets/pics/regexp_thompson_ex_min.png" /></div></center></p>
</div>
<p>On peut démontrer le résultat suivant :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Pour toute expression régulière <span
class="math inline">\(e\)</span>, on a <span
class="math inline">\(\mathop{lang}(e)
=\mathop{lang}(L(e))\)</span>.</p>
</div>
<h2 data-number="3.2"
id="sec:calcul-dune-expression-régulière-depuis-un-automate---mcnaughton-et-yamada"><span
class="header-section-number">3.2</span> Calcul d’une expression
régulière depuis un automate - <em>McNaughton et Yamada</em></h2>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(A\)</span> un automate fini
déterministe, il existe un expression régulière <span
class="math inline">\(e\)</span> telle que <span
class="math inline">\(\mathop{lang}(A) = \mathop{lang}(e)\)</span>.</p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On va s’inspirer de Floyd-Warshall pour définir de manière
incrémentale des expressions régulières.</p>
<p></div></p>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> On pose <span
class="math inline">\(A = (\range{1}{n}, \Sigma, \delta, 1, F)\)</span>
en numérotant les états de <span class="math inline">\(A\)</span> et en
supposant que l’état initial a le numéro 1. On va construire une suite
de matrice d’expression régulière <span
class="math inline">\((R^{(k)})_{k \in \range{0}{n}}\)</span> telle que
<span class="math inline">\(\forall i, j \in \range{1}{n},
R^{(k)}_{i,j}\)</span> soit une expression régulière reconnaissant
toutes les étiquettes de chemins de l’état <span
class="math inline">\(i\)</span> à l’état <span
class="math inline">\(j\)</span> et dont les états intermédiaires sont
<span class="math inline">\(\le k\)</span>.</p>
<p>On va construire les <span class="math inline">\(R^{(k)}\)</span> par
récurrence.</p>
<p><strong>Initialisation</strong> : pour <span class="math inline">\(k
= 0\)</span>, il s’agit des transitions de l’automates. On va noter ici
<span class="math inline">\(\alpha(i,j) = \enscomp{ a \in \Sigma }{
\delta(i,a) = j }\)</span>. On pose donc, pour <span
class="math inline">\(i \neq j\)</span>, <span class="math display">\[
R^{(0)}_{ij} = \begin{cases} \emptyset &amp; \text{si } \alpha(i,j) =
\emptyset \\
a_1 | a_2 | \dots | a_p &amp; \text{si } \alpha(i,j)= \{ a_1, \dots, a_p
\}
\end{cases}
\]</span> Quand <span class="math inline">\(i = j\)</span>, il faut
également considérer le chemin vide de <span
class="math inline">\(i\)</span> vers <span
class="math inline">\(i\)</span> qui est d’étiquette <span
class="math inline">\(\epsilon\)</span>, on a donc : <span
class="math display">\[
R^{(0)}_{ii} = \begin{cases} \epsilon &amp; \text{si } \alpha(i,i) =
\emptyset \\
\epsilon | a_1 | a_2 | \dots | a_p &amp; \text{si } \alpha(i,i)= \{ a_1,
\dots, a_p \}
\end{cases}
\]</span></p>
<p><strong>Hérédité</strong> : supposons qu’on ait construit les <span
class="math inline">\(R^{(l)}\)</span> pour <span
class="math inline">\(0 \le l &lt; k\)</span>. Un chemin de <span
class="math inline">\(i\)</span> à <span
class="math inline">\(j\)</span> dont les états intermédiaires sont
<span class="math inline">\(\le k\)</span> est de deux sortes :</p>
<ul>
<li>Soit c’est un chemin dont les états intermédiaires sont <span
class="math inline">\(&lt; k\)</span>, donc sont étiquettes est denotée
par <span class="math inline">\(R^{(k-1)}_{ij}\)</span>.</li>
<li>Soit, il passe par l’état <span class="math inline">\(k\)</span> au
moins une fois, et il a donc la forme : <span class="math display">\[
i \xrightarrow{\phi} k \xrightarrow{\psi_1} k \rightarrow \dots
\rightarrow k \xrightarrow{\psi_p} k \xrightarrow{\tau} j
\]</span> avec <span class="math inline">\(p \in \N\)</span> qui
correspond au nombre de fois où on revient sur l’état <span
class="math inline">\(k\)</span> dans le chemin. L’étiquette de <span
class="math inline">\(\phi\)</span> est dénotée par <span
class="math inline">\(R^{(k-1)}_{ik}\)</span>, les étiquettes des <span
class="math inline">\(\psi_l\)</span> sont dénotées par <span
class="math inline">\(R^{(k-1)}_{kk}\)</span> et l’étiquette de <span
class="math inline">\(\tau\)</span> par <span
class="math inline">\(R^{(k-1)}_{kj}\)</span>. Ainsi, le chemin global a
une étiquette dénotée par <span class="math display">\[
R^{(k-1)}_{ik} \left(R^{(k-1)}_{kk}\right)^* R^{(k-1)}_{kj}
\]</span></li>
</ul>
<p>Ainsi, on pose <span class="math display">\[
  R^{(k)}_{ij} = R^{(k-1)}_{ij} | R^{(k-1)}_{ik}
\left(R^{(k-1)}_{kk}\right)^* R^{(k-1)}_{kj}
\]</span></p>
<p>On déduit de cette construction la matrice <span
class="math inline">\(R^{(n)}\)</span> et on peut donc poser <span
class="math display">\[
e = R^{(n)}_{1f_1} | \dots | R^{(n)}_{1f_p}
\]</span> où <span class="math inline">\(F = \{ f_1, \dots, f_p
\}\)</span>. </div> </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On considère l’automate :</p>
<p><img src="assets/pics/automate_spont_det.png" /></p>
<p>En numérotant dans l’ordre alphabétique <span class="math inline">\(1
= A, 2 = B, 3 = C\)</span> et <span class="math inline">\(4 =
D\)</span>. On a, en ignorant les <span
class="math inline">\(\emptyset\)</span> et en simplifiant, les matrices
suivantes :</p>
<p><span class="math display">\[
R^{(0)} = R^{(1)} = \begin{pmatrix}
\epsilon &amp; a &amp; b &amp; \emptyset \\
\emptyset &amp; \epsilon|a|b &amp; \emptyset &amp; \emptyset \\
\emptyset &amp; \emptyset &amp; \epsilon &amp; a \\
\emptyset &amp; a &amp; b &amp; \epsilon
\end{pmatrix}
\]</span> <span class="math display">\[
R^{(2)} = \begin{pmatrix}
\epsilon &amp; a | a(\epsilon|a|b)^* &amp; b &amp; \emptyset \\
\emptyset &amp; \epsilon|a|b | (\epsilon|a|b)^* &amp; \emptyset &amp;
\emptyset \\
\emptyset &amp; \emptyset &amp; \epsilon &amp; a \\
\emptyset &amp; a | a(\epsilon|a|b)^* &amp; b &amp; \epsilon
\end{pmatrix}
= \begin{pmatrix}
\epsilon &amp; a(a|b)^* &amp; b &amp; \emptyset \\
\emptyset &amp; (a|b)^* &amp; \emptyset &amp; \emptyset \\
\emptyset &amp; \emptyset &amp; \epsilon &amp; a \\
\emptyset &amp; a(a|b)^* &amp; b &amp; \epsilon
\end{pmatrix}
\]</span> <span class="math display">\[
R^{(3)}= \begin{pmatrix}
\epsilon &amp; a(a|b)^* &amp; b &amp; ba \\
\emptyset &amp; (a|b)^* &amp; \emptyset &amp; \emptyset \\
\emptyset &amp; \emptyset &amp; \epsilon &amp; a \\
\emptyset &amp; a(a|b)^* &amp; b &amp; \epsilon | b \epsilon^* a
\end{pmatrix} =
\begin{pmatrix}
\epsilon &amp; a(a|b)^* &amp; b &amp; ba \\
\emptyset &amp; (a|b)^* &amp; \emptyset &amp; \emptyset \\
\emptyset &amp; \emptyset &amp; \epsilon &amp; a \\
\emptyset &amp; a(a|b)^* &amp; b &amp; \epsilon | ba
\end{pmatrix}
\]</span> <span class="math display">\[
\begin{array}{rcl}
R^{(4)} &amp;= &amp; \begin{pmatrix}
\epsilon &amp; a(a|b)^* | ba (ba)^* a (a|b)^* &amp; b &amp; ba |
ba(ba)^* \\
\emptyset &amp; (a|b)^* &amp; \emptyset &amp; \emptyset \\
\emptyset &amp; \emptyset &amp; \epsilon | a (ba)^* b &amp; a | a(ba)^*
\epsilon \\
\emptyset &amp; a(a|b)^* &amp; b | \epsilon(ba)^*b &amp; \epsilon | ba |
(\epsilon | ba)(ba)^* (\epsilon|ba)
\end{pmatrix} \\
&amp; =  &amp;
\begin{pmatrix}
\epsilon &amp; (ba)^* a (a|b)^* &amp; b &amp; ba(ba)^* \\
\emptyset &amp; (a|b)^* &amp; \emptyset &amp; \emptyset \\
\emptyset &amp; \emptyset &amp; \epsilon | a (ba)^* b &amp; a(ba)^* \\
\emptyset &amp; a(a|b)^* &amp; (ba)^*b &amp; (ba)^*
\end{pmatrix}
\end{array}
\]</span> On en déduit donc l’expression régulière associée à l’automate
de départ : <span class="math display">\[
(ba)^* a (a|b)^* | ba(ba)^*
= (ba)^* (a (a|b)^* | ba)
\]</span></p>
</div>
<p>On peut voir dans l’exemple précédent que la détermination de cette
expression régulière est laborieuse car l’algorithme sous-jacent rajoute
4 symboles dans l’expression : un <span
class="math inline">\(|\)</span>, deux concaténations et une <span
class="math inline">\(*\)</span>. On a donc des expression dans la
matrice finale qui sont de taille <span
class="math inline">\(O(4^n)\)</span> sans simplifications. On va voir
une autre méthode permettant de déterminer de manière plus efficace des
expressions régulières.</p>
<h2 data-number="3.3"
id="sec:élimination-des-états---brzozowski-et-mccluskey"><span
class="header-section-number">3.3</span> Élimination des états -
<em>Brzozowski et McCluskey</em></h2>
<p>On présente ici le principe de l’élimination des états. Il s’agit de
construire un automate dont les transitions ne sont plus étiquetées par
des lettres mais par des expressions régulières. Cette souplesse permet
de supprimer des états en gardant le même langage reconnu. On procéde
donc, étant donné un état final donné <span
class="math inline">\(q\)</span>, par élimination jusqu’à obtenir un
automate dont les états sont <span class="math inline">\(\{ q_i,
q\}\)</span> où <span class="math inline">\(q_i\)</span> est l’état
initial. On en déduit simplement une expression régulière équivalente.
On conclut alors en faisant cela pour chaque état final et en prenant
l’union des expressions régulières.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On reprend l’automate précédent :</p>
<p><img src="assets/pics/automate_spont_det.png" /></p>
<p>On commence par retirer les états qui ne sont ni initiaux ni finaux,
ce qui permet de repartir de l’automate obtenu pour tous les états
finaux. Ici, seul l’état <span class="math inline">\(C\)</span> est dans
ce cas.</p>
<p><center><div class="ui image center"><img
src="assets/pics/elim_state_ex1.png" /></div></center></p>
<p>En considérant l’état final <span class="math inline">\(D\)</span>,
comme aucun chemin de <span class="math inline">\(A\)</span> à <span
class="math inline">\(D\)</span> ne passe par l’état <span
class="math inline">\(B\)</span>, on peut l’eliminer directement pour
obtenir l’automate à deux états final :</p>
<p><center><div class="ui image center"><img
src="assets/pics/elim_state_ex2.png" /></div></center></p>
<p>On en déduit directement l’expression régulière <span
class="math inline">\(ba(ba)^*\)</span>.</p>
<p>Maintenant, on va considérer l’état final <span
class="math inline">\(B\)</span> et on souhaite éliminer <span
class="math inline">\(D\)</span>. On doit prendre en compte le chemin
qui va de <span class="math inline">\(A\)</span> à <span
class="math inline">\(B\)</span> en passant par <span
class="math inline">\(D\)</span>, sachant qu’il y a une boucle
potentielle sur <span class="math inline">\(D\)</span> qu’on peut
prendre un nombre quelconque de fois. On obtient alors l’automate :</p>
<p><center><div class="ui image center"><img
src="assets/pics/elim_state_ex3.png" /></div></center></p>
<p>Qui admet <span class="math inline">\((a |ba (ba)^* a)(a|b)^* =
(ba)^* a (a|b)^*\)</span> comme expression régulière.</p>
<p>Au final, on obtient l’expression régulière : <span
class="math display">\[
(ba)^* a (a|b)^* | ba(ba)^* = (ba)^* (a (a|b)^* | ba)
\]</span> On retrouve donc l’expression régulière obtenue avec la
méthode précédente.</p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Quitte à rajouter des transitions spontanées, on peut se ramener à
n’avoir qu’un unique état final et donc à ne faire qu’une seule suite
d’élimination.</p>
<p>L’automate précédent avec ce nouvel état devient :</p>
<p><center><div class="ui image center"><img
src="assets/pics/elim_final.png" /></div></center></p>
<p>On note que <span class="math inline">\(\epsilon\)</span> ici désigne
une expression régulière, on n’a donc pas à sortir du cadre
précédent.</p>
<p>On peut alors éliminer les sommets <span class="math inline">\(B,
C\)</span> et <span class="math inline">\(D\)</span> :</p>
<p><center><div class="ui image center"><img
src="assets/pics/elim_C.png" /></div></center></p>
<p>On élimine alors <span class="math inline">\(D\)</span> :
<center><div class="ui image center"><img
src="assets/pics/elim_D.png" /></div></center></p>
<p>Puis en éliminant <span class="math inline">\(B\)</span> :
<center><div class="ui image center"><img
src="assets/pics/elim_B.png" /></div></center></p>
<p>On retrouve ainsi l’expression régulière précédente après
simplification.</p>
<p>On remarque que cette méthode n’est pas forcément plus pratique à la
main sur des petits automates et qu’on risque de faire apparaitre de
longues expressions régulières et de faire des erreurs de calcul.</p>
<p></div></p>
<p>On va formaliser l’élimination. Si un état <span
class="math inline">\(s\)</span> a des prédecesseurs <span
class="math inline">\(p_1, \dots, p_n\)</span> et des successeurs <span
class="math inline">\(q_1, \dots, q_m\)</span>, certains peuvent être
successeurs et prédecesseurs, on a la situation locale en <span
class="math inline">\(s\)</span> suivante :</p>
<p><center><div class="ui image center"><img
src="assets/pics/elim_avant.png" /></div></center></p>
<p>Pour passer de <span class="math inline">\(p_i\)</span> à <span
class="math inline">\(q_j\)</span> on a donc soit l’expression déjà
présente <span class="math inline">\(c_{ij}\)</span>, soit on effectue
un chemin en passant par <span class="math inline">\(s\)</span> donc de
la forme <span class="math display">\[p_i \rightarrow s \rightarrow s
\rightarrow \dots \rightarrow s
\rightarrow q_j\]</span> ce qui correspond à l’expression régulière
<span class="math inline">\(e_i l^* f_j\)</span>. On peut donc en
déduire l’automate suivant avec <span class="math inline">\(s\)</span>
éliminé :</p>
<p><center><div class="ui image center"><img
src="assets/pics/elim_apres.png" /></div></center></p>
<p>Après élimination de tous les états sauf l’état initial et un état
final, on obtient un automate de la forme :</p>
<p><center><div class="ui image center"><img
src="assets/pics/brzo_forme_finale.png" /></div></center></p>
<p>On lui associe alors l’expression régulière <span
class="math display">\[
(e_i | e e_f^* e&#39;)^* e e_f^*
\]</span></p>
<h1 data-number="4"
id="sec:construction-de-lautomate-de-glushkov-algorithme-de-berry-sethi"><span
class="header-section-number">4</span> Construction de l’automate de
Glushkov, algorithme de Berry-Sethi</h1>
<p>On présente ici une construction directe d’un automate non
déterministe reconnaissant le même langage q’une expression régulière
donnée. La construction qu’on présente ici s’effectue en plusieurs temps
:</p>
<ul>
<li>définition et reconnaissance des langages locaux par les automates
déterministes locaux</li>
<li>définition d’une expression régulière linéaire et localité de son
langage dénoté</li>
<li>obtention d’un automate non déterministe par linéarisation d’une
expression régulière puis oubli du marquage de lettres</li>
</ul>
<h2 data-number="4.1" id="sec:langages-locaux"><span
class="header-section-number">4.1</span> Langages locaux</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(\Sigma\)</span> un alphabet fini et <span
class="math inline">\(L \subset \Sigma^*\)</span> un langage.</p>
<p>On dit que <span class="math inline">\(L\)</span> est
<strong>local</strong> lorsqu’il existe <span class="math inline">\(P, S
\subset \Sigma\)</span> et <span class="math inline">\(N \subset
\Sigma^2\)</span> tels que les mots non vides de <span
class="math inline">\(L\)</span> sont exactement les mots qui</p>
<ul>
<li>commencent par une lettre de <span
class="math inline">\(P\)</span></li>
<li>finissent par une lettre de <span
class="math inline">\(S\)</span></li>
<li>ne contiennent aucun facteur dans <span
class="math inline">\(N\)</span></li>
</ul>
<p>Autrement dit, <span class="math inline">\(L\)</span> vérifie
l’égalité : <span class="math display">\[
L \backslash \{ \epsilon \}
= (P \Sigma^* \cap \Sigma^* S) \backslash \Sigma^* N \Sigma^*
\]</span> </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Pour savoir si un mot est dans un langage local, il suffit donc
d’avancer avec une fenêtre de lecture de deux caractères, c’est en ce
sens qu’il est local.</p>
<p></div></p>
<p>Si on sait qu’un langage est local, il est facile déterminer les
ensembles <span class="math inline">\(P, S\)</span> et <span
class="math inline">\(N\)</span>.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(L\)</span> un langage local et avec
les notations de la définition, on a</p>
<p><span class="math display">\[
\begin{array}{rcl}
P &amp;=&amp; \enscomp{ a \in \Sigma }{ \exists, w \in \Sigma^*, a w \in
L } \\
S &amp;=&amp; \enscomp{ a \in \Sigma }{ \exists, w \in \Sigma^*, w a \in
L } \\
N &amp;=&amp; \enscomp{ ab \in \Sigma^2 }{ \forall w\in L, ab \text{
n&#39;est pas un facteur de } w }
\end{array}
\]</span></p>
</div>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li><span class="math inline">\(\Sigma^*\)</span> est local avec <span
class="math inline">\(P = S =\Sigma\)</span> et <span
class="math inline">\(N = \emptyset\)</span>.</li>
<li><span class="math inline">\(L = a(aa)*b\)</span> n’est pas local car
on aurait alors <span class="math inline">\(P = \{ a\}\)</span>, <span
class="math inline">\(S= \{b\}\)</span> et <span class="math inline">\(N
= \{b a, bb \}\)</span>. or, <span class="math inline">\((P \Sigma^*
\cap \Sigma^* S) \backslash \Sigma^* N \Sigma^*\)</span> contient les
mots de la forme <span class="math inline">\(a^n b\)</span> avec <span
class="math inline">\(n \in \N^*\)</span> et donc contient <span
class="math inline">\(aab\)</span> qui n’est pas dans <span
class="math inline">\(L\)</span>, car les mots de <span
class="math inline">\(L\)</span> contiennent un nombre impair de <span
class="math inline">\(a\)</span>.</li>
</ul>
</div>
<h2 data-number="4.2" id="sec:automates-locaux"><span
class="header-section-number">4.2</span> Automates locaux</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(A = (Q, \Sigma, \delta, q_i, F)\)</span> un
automate fini déterministe.</p>
<p>On dit que <span class="math inline">\(A\)</span> est</p>
<ul>
<li><strong>local</strong> lorsque <span class="math inline">\(\forall a
\in \Sigma, \left| \enscomp{\delta(q,a)}{q \in Q} \right| \le
1\)</span></li>
<li><strong>standard</strong> lorsque <span
class="math inline">\(\forall a \in \Sigma, \forall q \in Q,\delta(q,a)
\neq q_i\)</span>. </div></li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Ainsi, un automate est local si la lecture d’une lettre ne peut pas
amener sur deux états différents et standard quand on ne peut pas
revenir sur l’état initial.</p>
<p></div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(L\)</span> un langage les propriétés
suivantes sont équivalentes :</p>
<ol type="1">
<li><span class="math inline">\(L\)</span> est local</li>
<li><span class="math inline">\(L\)</span> est reconnaissable par un
automate déterministe local</li>
<li><span class="math inline">\(L\)</span> est reconnaissable par un
automate déterministe local et standard</li>
</ol>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> On a directement <span
class="math inline">\(3 \Rightarrow 2\)</span>. On va montrer deux
autres implications pour avoir l’équivalence.</p>
<p><span class="math inline">\(\underline{1 \Rightarrow 3}\)</span> Soit
<span class="math inline">\(L\)</span> un langage local et <span
class="math inline">\(S,P, N\)</span> tels que <span
class="math display">\[
L \backslash \{ \epsilon \}
= (P \Sigma^* \cap \Sigma^* S) \backslash \Sigma^* N \Sigma^*
\]</span> On définit <span class="math inline">\(A = (\Sigma \cup \{
\epsilon \}, \Sigma, \delta, \epsilon, S&#39;)\)</span> où <span
class="math inline">\(S&#39; =\begin{cases} S &amp; \text{si } \epsilon
\not\in L \\ S \cup \{\epsilon\}&amp; \text{sinon} \end{cases}\)</span>,
<span class="math inline">\(\forall a \in P, \delta(\epsilon, a) =
a\)</span> et <span class="math inline">\(\forall a, b \in \Sigma, ab
\not\in N \Rightarrow \delta(a,b) = b\)</span>. Cet automate est
déterministe local et standard par définition.</p>
<p>On va montrer que <span class="math inline">\(\mathop{lang}(A) =
L\)</span>.</p>
<ul>
<li><span class="math inline">\(\mathop{lang}(A) \subset L\)</span>.
Soit <span class="math inline">\(w\)</span> reconnu par <span
class="math inline">\(A\)</span>. Si <span class="math inline">\(w =
\epsilon\)</span>, c’est forcément que <span
class="math inline">\(\epsilon\)</span> est final donc que <span
class="math inline">\(\epsilon \in L\)</span>. Sinon <span
class="math inline">\(w = a_1\dots a_n\)</span>. On a donc un chemin
<span class="math inline">\(\epsilon \xrightarrow{a_1} a_1 \dots
\xrightarrow{a_n} a_n\)</span> or :
<ul>
<li>la transition depuis <span class="math inline">\(\epsilon\)</span>
implique <span class="math inline">\(a_1 \in P\)</span></li>
<li><span class="math inline">\(a_n\)</span> est final, donc
nécessairement <span class="math inline">\(a_n \in S\)</span></li>
<li>pour <span class="math inline">\(i \in \range{1}{n-1}\)</span>,
<span class="math inline">\(a_i \xrightarrow{a_{i+1}} a_{i+1}\)</span>
implique que <span class="math inline">\(a_i a_{i+1} \not\in N\)</span>
Ainsi, par définition <span class="math inline">\(w \in L\)</span>.</li>
</ul></li>
<li><span class="math inline">\(L \subset \mathop{lang}(A)\)</span>.
Réciproquement si <span class="math inline">\(w \in L\)</span>. Soit
<span class="math inline">\(w = \epsilon\)</span> et alors <span
class="math inline">\(\epsilon\)</span> est initial et final, donc <span
class="math inline">\(\epsilon \in \mathop{lang}(A)\)</span>, soit <span
class="math inline">\(w = a_1 \dots a_n\)</span>, comme <span
class="math inline">\(a_1 \in P\)</span>, on a la transition <span
class="math inline">\(\epsilon \xrightarrow{a_1} a_1\)</span>. Ensuite,
pour chaque <span class="math inline">\(i \in \range{1}{n-1}\)</span>,
comme <span class="math inline">\(a_i a_{i+1} \not\in N\)</span>, on a
<span class="math inline">\(a_i \xrightarrow{a_{i+1}} a_{i+1}\)</span>.
Ainsi, on a donc un chemin de <span
class="math inline">\(\epsilon\)</span> à <span
class="math inline">\(a_n\)</span>, or <span class="math inline">\(a_n
\in S\)</span> donc il est final et <span
class="math inline">\(w\)</span> est reconnu.</li>
</ul>
<p><span class="math inline">\(\underline{2 \Rightarrow 1}\)</span>. On
va définir des ensembles <span class="math inline">\(P, S, N\)</span>
associés à l’automate local <span class="math inline">\(A = (Q, \Sigma,
\delta, q_i, F)\)</span> :</p>
<p><span class="math display">\[
\begin{array}{rcl}
P &amp;=&amp; \enscomp{ a\in \Sigma }{ \delta(q_i,a) \text{ est défini
}} \\
S &amp;=&amp; \enscomp{ a \in \Sigma}{\exists q \in Q, \delta(q,a) \in F
} \\
N &amp;=&amp; \enscomp{ ab \in \Sigma^2 }{\text{il n&#39;existe pas }
q,q&#39;,q&#39;&#39; \in Q,
q \xrightarrow{a} q&#39; \xrightarrow{b} q&#39;&#39;}
\end{array}
\]</span> On pose alors <span class="math inline">\(L = (P\Sigma^* \cap
\Sigma^* S) \backslash \Sigma^* N \Sigma^*\)</span>, qui nécessairement
ne contient pas <span class="math inline">\(\epsilon\)</span>, et on va
montrer que <span class="math inline">\(L = \mathop{lang}(A) \backslash
\{ \epsilon \}\)</span>.</p>
<ul>
<li><p><span class="math inline">\(L \subset \mathop{lang}(A)\)</span>.
Soit <span class="math inline">\(w = a_1\dots a_n \in L\)</span>. Par
définition de <span class="math inline">\(L\)</span>, on a <span
class="math inline">\(a_1 \in P\)</span> et <span
class="math inline">\(a_n \in S\)</span>. On va montrer par récurrence
bornée que <span class="math inline">\(\delta^*(q_i,a_1 \dots
a_j)\)</span> est bien défini.</p>
<ul>
<li>Initialisation : on a <span class="math inline">\(\delta^*(q_i,a_1)
= \delta(q_i,a_1)\)</span> défini par définition de <span
class="math inline">\(P\)</span>.</li>
<li>Hérédité : Soit <span class="math inline">\(j \in
\range{1}{n-2}\)</span> tel que <span
class="math inline">\(\delta^*(q_i,a_1\dots a_j)\)</span> est bien
défini. On pose <span class="math inline">\(q = \delta^*(q_i, a_1\dots
a_{j-1})\)</span>si <span class="math inline">\(j &gt; 1\)</span> ,ou
<span class="math inline">\(q = q_i\)</span> sinon, et <span
class="math inline">\(q&#39; = \delta^*(q_i, a_1\dots a_j)\)</span>. On
a donc <span class="math inline">\(q \xrightarrow{a_j} q&#39;\)</span>.
Par hypothèse, <span class="math inline">\(a_j a_{j+1} \not\in
N\)</span> donc il existe forcément <span
class="math inline">\(q&#39;&#39;\)</span> tel que <span
class="math inline">\(q&#39; \xrightarrow{a_{j+1}} q&#39;&#39;\)</span>.
Ainsi, <span class="math inline">\(\delta^*(q_i,a_1\dots a_{j+1}) =
q&#39;&#39;\)</span> est bien défini.</li>
</ul>
<p>Pour <span class="math inline">\(j = n\)</span>, on a <span
class="math inline">\(\delta^*(q_i,a_1\dots a_n) = q\)</span> bien
défini et comme on arrive sur cet état par <span
class="math inline">\(a_n \in S\)</span>, nécessairement <span
class="math inline">\(q \in F\)</span>, donc <span
class="math inline">\(w\)</span> est reconnu.</p></li>
<li><p><span class="math inline">\(\mathop{lang}(A)\backslash \{\epsilon
\} \subset L\)</span>. Soit <span class="math inline">\(w = a_1\dots
a_n\)</span> un mot non vide reconnu par <span
class="math inline">\(A\)</span>. On a donc un chemin <span
class="math display">\[
q_i \xrightarrow{a_1} \dots \xrightarrow{a_n} q \in F
\]</span> Par définition, on a donc <span class="math inline">\(a_1 \in
P\)</span>, <span class="math inline">\(a_n \in S\)</span> et comme on a
pu faire réaliser les transitions, pour tout <span
class="math inline">\(j \in \range{1}{n-1}\)</span>, <span
class="math inline">\(a_j a_{j+1} \not\in N\)</span>. Ainsi <span
class="math inline">\(w \in L\)</span>. </div> </div></p></li>
</ul>
<p>On peut déduire de cette caractérisation des propriétés de stabilité
des langages locaux.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(L\)</span> un langage local, le
langage <span class="math inline">\(L^*\)</span> est local.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Soit <span class="math inline">\(A =
(Q, \Sigma, \delta, q_i, F)\)</span> un automate local pour <span
class="math inline">\(L\)</span>.</p>
<p>On pose <span class="math inline">\(A&#39; = (Q, \Sigma, \delta&#39;,
q_i, F \cup \{ q_i \})\)</span> avec <span
class="math inline">\(\delta&#39;(q,a) = \delta(q,a)\)</span> pour <span
class="math inline">\((q,a)\)</span> dans le domaine de <span
class="math inline">\(\delta\)</span> et pour toute transition <span
class="math inline">\(\delta(q_i,a) = q\)</span> et <span
class="math inline">\(q&#39; \in F\)</span>, on pose <span
class="math inline">\(\delta&#39;(q&#39;,a) = q\)</span> ce qui préserve
naturellement la localité de l’automate.</p>
<p><center><div class="ui image center"><img
src="assets/pics/local_kleene.png" /></div></center></p>
<p>On montre facilement que <span class="math inline">\(A&#39;\)</span>
reconnait <span class="math inline">\(L^*\)</span>. </div> </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soient <span class="math inline">\(L_1, L_2\)</span> des langages
locaux sur des alphabets disjoints <span
class="math inline">\(\Sigma_1\)</span> et <span
class="math inline">\(\Sigma_2\)</span> les langages <span
class="math inline">\(L_1 \cup L_2\)</span> et <span
class="math inline">\(L_1 L_2\)</span> sont locaux sur l’alphabet <span
class="math inline">\(\Sigma = \Sigma_1 \cup \Sigma_2\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> On va juste donner les constructions
correspondantes d’automates locaux.</p>
<p>Soient <span class="math inline">\(A_1 = (Q_1, \Sigma_1, \delta_1,
i_1, F_1)\)</span> et <span class="math inline">\(A_2 = (Q_2, \Sigma_2,
\delta_2, i_2, F_2)\)</span> des automates standards locaux
reconnaissant respectivement <span class="math inline">\(L_1\)</span> et
<span class="math inline">\(L_2\)</span>, avec <span
class="math inline">\(Q_1 \cap Q_2 = \emptyset\)</span>.</p>
<p>On pose <span class="math display">\[
A_u = ((Q_1 \cup Q_2 \cup \{ i \}) \backslash \{ i_1, i_2\},
    \Sigma, \delta_u, i, F_u)
\]</span> avec <span class="math display">\[
F_u = \begin{cases} F_1 \cup F_2 &amp; \text{si } i_1 \not\int F_1
\wedge
    i_2 \not\in F_2 \\
    (F_1 \cup F_2 \cup \{ i \}) \backslash \{ i_1, i_2\} &amp; \text{
sinon }
    \end{cases}
\]</span> <span class="math display">\[
\forall q \in Q_1 \backslash \{ i_1 \}, \forall a \in \Sigma_1,
\delta_u(q,a) = \delta_1(q,a) \text{ si défini}
\]</span> <span class="math display">\[
\forall q \in Q_2 \backslash \{ i_2 \}, \forall a \in \Sigma_2,
\delta_u(q,a) = \delta_2(q,a) \text{ si défini}
\]</span> <span class="math display">\[
\forall a \in \Sigma_1, \delta_u(i, a) = \delta_1(i_1,a) \text{ si
défini}
\]</span> <span class="math display">\[
\forall a \in \Sigma_2, \delta_u(i, a) = \delta_2(i_1,a) \text{ si
défini}
\]</span></p>
<p>Comme les automates <span class="math inline">\(A_1\)</span> et <span
class="math inline">\(A_2\)</span> sont standards, on n’a pas perdu de
transitions ici. On vérifie facilement que <span
class="math inline">\(A_u\)</span> est local et standard et qu’il
reconnait <span class="math inline">\(L_1 \cup L_2\)</span>.</p>
<p>De même, on pose <span class="math display">\[
A_p = ((Q_1 \cup Q_2) \backslash \{ i_2 \},
\Sigma, \delta_p, i_1, F_p)
\]</span> où <span class="math display">\[
F_p =\begin{cases}
F_2 &amp; \text{si } i_2 \not\in F_2 \\
F_1 \cup (F_2 \backslash \{ i_2 \}) &amp; \text{sinon}
\end{cases}
\]</span> <span class="math display">\[
\forall q \in Q_1, \forall a \in \Sigma_1,
\delta_p(q,a) = \delta_1(q,a) \text{ si défini}
\]</span> <span class="math display">\[
\forall q \in Q_2 \backslash \{ i_2 \}, \forall a \in \Sigma_2,
\delta_p(q,a) = \delta_2(q,a) \text{ si défini}
\]</span> <span class="math display">\[
\forall q \in F_1, \forall q&#39; \in Q_2, \forall a \in \Sigma_2,
\delta_2(i_2,a) = q&#39; \Rightarrow \delta_p(q,a) = q&#39;
\]</span> Par construction <span class="math inline">\(A_p\)</span> est
local et standard, on montre qu’il reconnait <span
class="math inline">\(L_1 L_2\)</span>. </div> </div></p>
<h2 data-number="4.3" id="sec:expressions-régulières-linéaires"><span
class="header-section-number">4.3</span> Expressions régulières
linéaires</h2>
<p><div class="ui message"><div class="header">Définition</div> Une
expression régulière est dite linéaire si chaque lettre de <span
class="math inline">\(\Sigma\)</span> y apparait au plus une fois.
</div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>L’expression régulière <span class="math inline">\(a(b|c)^*\)</span>
est linéaire mais <span class="math inline">\(a(a|b)^*\)</span> ne l’est
pas.</p>
</div>
<p>On déduit des deux théorèmes précédents le théorème suivant :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(e\)</span> une expression régulière
linéaire, <span class="math inline">\(\mathop{lang}(e)\)</span> est un
langage local.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Par induction sur l’expression
régulière.</p>
<ul>
<li><em>Cas de base</em> : Si <span class="math inline">\(e = \emptyset,
\epsilon\)</span> ou <span class="math inline">\(a\)</span> avec <span
class="math inline">\(a \in \Sigma\)</span>, c’est direct.</li>
<li>Pour <span class="math inline">\(e^*, e | e&#39;\)</span> ou <span
class="math inline">\(e e&#39;\)</span>, l’hypothèse d’induction et les
théorèmes précédents permettent de conclure. On remarque juste que la
disjonction des alphabets est naturellement induite par la linéarité :
une même lettre ne peut pas être présente dans <span
class="math inline">\(e\)</span> et dans <span
class="math inline">\(e&#39;\)</span>. </div> </div></li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>La réciproque est fausse, il existe des langages locaux qui ne sont
pas dénotés par des expressions linéaires. Par exemple <span
class="math inline">\((ab)^* a\)</span> est local avec <span
class="math inline">\(P = \{ a \}, S = \{ a \}\)</span> et <span
class="math inline">\(N = \{ aa, bb \}\)</span>, mais une expression
régulière le dénotant devra forcément contenir au moins deux a.</p>
<p></div></p>
<div class="ui message olive">
<div class="header">
Corollaire
</div>
<p>Pour toute expression régulière linéaire <span
class="math inline">\(e\)</span>, il existe un automate local
déterministe <span class="math inline">\(A\)</span> tel que <span
class="math inline">\(\mathop{lang}(e) = \mathop{lang}(L)\)</span>.</p>
</div>
<p>Pour déterminer cet automate, on a vu une preuve explicite en
déterminant les ensembles <span class="math inline">\(P,S\)</span> et
<span class="math inline">\(N\)</span> pour <span
class="math inline">\(\mathop{lang}(e)\)</span>. Pour calculer ces
ensembles pour une expression régulière, on peut le faire par
induction.</p>
<p>Tout d’abord, comme on a besoin de savoir si l’expression reconnait
le mot vide, on peut définir la propriété <span
class="math inline">\(accv(e)\)</span> : <span class="math display">\[
accv(\emptyset) = \perp\quad \forall a \in \Sigma, accv(a) = \perp
\quad accv(\epsilon) =\top
\quad accv(e^*) = \top
\]</span> <span class="math display">\[
accv(e_1|e_2) = accv(e_1) \vee accv(e_2)
\quad accv(e_1 e_2) = accv(e_1) \wedge accv(e_2)
\]</span></p>
<p>On définit ensuite <span class="math inline">\(P,S\)</span> et <span
class="math inline">\(N\)</span> directement :</p>
<p><span class="math display">\[
P(\emptyset) = \emptyset \quad \forall a \in \Sigma, P(a) = \{a\}
\quad P(\epsilon) =\emptyset
\quad P(e^*) = P(e)
\]</span> <span class="math display">\[
P(e_1|e_2) = P(e_1) \cup P(e_2)
\quad P(e_1 e_2) = \begin{cases} P(e_1) \cup P(e_2) &amp; \text{si }
accv(e_1) \\
P(e_1) &amp; \text{sinon} \end{cases}
\]</span></p>
<p><span class="math display">\[
S(\emptyset) = \emptyset \quad \forall a \in \Sigma, S(a) = \{a\}
\quad S(\epsilon) =\emptyset
\quad S(e^*) = S(e)
\]</span> <span class="math display">\[
S(e_1|e_2) = S(e_1) \cup S(e_2)
\quad S(e_1 e_2) = \begin{cases} S(e_1) \cup S(e_2) &amp; \text{si }
accv(e_2) \\
S(e_2) &amp; \text{sinon} \end{cases}
\]</span></p>
<p><span class="math display">\[
N(\emptyset) = N(\epsilon) = \Sigma^2 \quad
\forall a\in \Sigma, N(a) = \Sigma^2 \quad
N(e^*) = N(e) \backslash S(e)P(e)
\]</span> <span class="math display">\[
N(e_1|e_2) = N(e_1) \cap N(e_2)
\quad
N(e_1 e_2) = (N(e_1) \cap N(e_2)) \backslash S(e_1) P(e_2)
\]</span></p>
<h2 data-number="4.4"
id="sec:application-aux-expressions-régulières"><span
class="header-section-number">4.4</span> Application aux expressions
régulières</h2>
<p>Étant donné une expression régulière <span
class="math inline">\(e\)</span>, on peut en déduire une expression
régulière linéaire en indiçant les occurrences de chaque lettre. Par
exemple, <span class="math inline">\((ab)^* aba\)</span> deviendra <span
class="math inline">\((a_1 b_1)^* a_2 b_2 a_3\)</span>.</p>
<p>On peut alors en déduire un automate déterministe local par la
méthode précédente. En <em>oubliant</em> les indices sur les transitions
de cet automate, on en deduit un automate <em>non déterministe</em>
reconnaissant le même langage que l’expression régulière initiale.</p>
<p>C’est l’algorithme de <em>Berry-Sethi</em>.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On va considérer l’expression régulière <span class="math inline">\(e
= (a|b)^* b (a|b)\)</span>.</p>
<p>On commence par la linéarisation <span class="math inline">\(e&#39; =
(a_1|b_1)^* b_2 (a_2|b_3)\)</span>.</p>
<p>On calcule les ensembles <span class="math inline">\(P, S\)</span> et
<span class="math inline">\(N\)</span> :</p>
<p><span class="math display">\[
P( (a_1 | b_1)^* b_2 (a_2|b_3) ) = \{a_1, b_1, b_2 \}
\]</span> <span class="math display">\[
S( (a_1 | b_1)^* b_2 (a_2|b_3) ) = \{a_2, b_3 \}
\]</span> Pour <span class="math inline">\(N\)</span>, il est plus
rapide de donner son complémentaire : <span class="math display">\[
\Sigma^2 \backslash N((a_1 | b_1)^* b_2 (a_2|b_3) ) = \{
a_1 b_2, b_1 b_2, a_1 a_1, b_1 b_1, a_1 b_1, b_1 a_1, b_2 a_2, b_2 b_3
\}
\]</span></p>
<p>On en déduit l’automate local :</p>
<p><center><div class="ui image center"><img
src="assets/pics/berrysethi_ex1.png" /></div></center></p>
<p>En oubliant les indices, on obtient l’automate :</p>
<p><center><div class="ui image center"><img
src="assets/pics/berrysethi_ex2.png" /></div></center></p>
</div>
<h1 data-number="5" id="sec:conséquences-du-théorème-de-kleene"><span
class="header-section-number">5</span> Conséquences du théorème de
Kleene</h1>
<h2 data-number="5.1" id="sec:stabilité-des-langages-réguliers"><span
class="header-section-number">5.1</span> Stabilité des langages
réguliers</h2>
<h3 data-number="5.1.1" id="sec:par-union-finie"><span
class="header-section-number">5.1.1</span> Par union finie</h3>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soient <span class="math inline">\(L_1, \dots, L_n\)</span> des
langages réguliers sur <span class="math inline">\(\Sigma\)</span>. Le
langage <span class="math inline">\(L_1 \cup \dots \cup L_n\)</span> est
régulier.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Du théorème de Kleene on déduit des
expressions régulières <span class="math inline">\(e_1, \dots,
e_n\)</span> dénotant respectivement <span class="math inline">\(L_1,
\dots, L_n\)</span>. Le langage dénoté par <span
class="math inline">\(e_1 |\dots | e_n\)</span> est <span
class="math inline">\(L_1 \cup \dots \cup L_n\)</span> et par le
théorème de Kleene, il est régulier. </div> </div></p>
<h3 data-number="5.1.2" id="sec:par-complémentaire"><span
class="header-section-number">5.1.2</span> Par complémentaire</h3>
<div class="ui message olive">
<div class="header">
Lemme
</div>
<p>Soit <span class="math inline">\(A = (Q, \Sigma, \delta, q_i,
F)\)</span> un automate déterministe <strong>complet</strong>,
l’automate <span class="math inline">\(A&#39; = (Q, \Sigma, \delta, q_i,
Q \backslash F)\)</span> reconnait <span class="math inline">\(\Sigma^*
\backslash \mathop{lang}(A)\)</span>.</p>
</div>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Les langages réguliers sont stables par complémentaires. Si <span
class="math inline">\(L\)</span> est régulier sur <span
class="math inline">\(\Sigma^*\)</span> alors <span
class="math inline">\(\Sigma^* \backslash L\)</span> est régulier.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Comme <span
class="math inline">\(L\)</span> est régulier il est reconnaissable par
un automate déterministe qu’on rend complet en rajoutant un état puits.
En appliquant le lemme et le théorème de Kleene, on en déduit que <span
class="math inline">\(\Sigma^* \backslash L\)</span> est régulier.
</div> </div></p>
<h3 data-number="5.1.3" id="sec:par-intersection-finie"><span
class="header-section-number">5.1.3</span> Par intersection finie</h3>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soient <span class="math inline">\(L_1, \dots, L_n\)</span> des
langages réguliers sur <span class="math inline">\(\Sigma\)</span>. Le
langage <span class="math inline">\(L_1 \cap \dots \cap L_n\)</span> est
régulier.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> On passe d’une intersection à une
union par complémentaire. Il s’agit donc d’une conséquence directe des
deux théorèmes précédents. </div> </div></p>
<h2 data-number="5.2" id="sec:lemme-de-létoile"><span
class="header-section-number">5.2</span> Lemme de l’étoile</h2>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><strong>Lemme de l’étoile</strong> Soit <span
class="math inline">\(L\)</span> un langage régulier sur <span
class="math inline">\(\Sigma\)</span>. Il existe une constante <span
class="math inline">\(n \in \N^*\)</span> telle que pour tout <span
class="math inline">\(w \in L\)</span>, si <span
class="math inline">\(|w|\ge n\)</span> alors il existe <span
class="math inline">\(x,y,z \in \Sigma^*\)</span> tels que <span
class="math inline">\(w = xyz\)</span> et</p>
<ol type="1">
<li><span class="math inline">\(y \neq \epsilon\)</span></li>
<li><span class="math inline">\(|xy| \le n\)</span></li>
<li><span class="math inline">\(x y^* z \subset L\)</span></li>
</ol>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Cela signifie que pour tout mot suffisamment long, on peut identifier
un facteur non vide qui peut être répétée autant qu’on le souhaite.</p>
<p></div></p>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Soit <span class="math inline">\(A=
(Q, \Sigma, \delta, q_0, F)\)</span> un automate déterministe
reconnaissant <span class="math inline">\(L\)</span>. On pose <span
class="math inline">\(n = |Q|\)</span>.</p>
<p>Soit <span class="math inline">\(w \in L\)</span> tel que <span
class="math inline">\(|w| \ge n\)</span>. Comme <span
class="math inline">\(w\)</span> est reconnu, il existe un chemin <span
class="math inline">\(q_0 \rightarrow q_1 \rightarrow \dots \rightarrow
q_m \in F\)</span> d’étiquette <span class="math inline">\(w\)</span>.
Comme <span class="math inline">\(m \ge n \ge |Q|\)</span> il y a
nécessairement une répétition dans les <span
class="math inline">\(n\)</span> premiers états : il existe <span
class="math inline">\(0 \le i &lt; j \le n\)</span> tels que <span
class="math inline">\(q_i = q_j\)</span>. On pose alors <span
class="math inline">\(x\)</span> l’étiquette de <span
class="math inline">\(q_0 \leadsto q_i\)</span>, <span
class="math inline">\(y\)</span> l’étiquette de <span
class="math inline">\(q_i \leadsto q_j\)</span> et <span
class="math inline">\(z\)</span> celle de <span
class="math inline">\(q_j \leadsto q_m\)</span>.</p>
<p>On a <span class="math inline">\(w = xyz\)</span>, <span
class="math inline">\(|y| = j-i &gt; 0\)</span> donc <span
class="math inline">\(y \neq \epsilon\)</span> et <span
class="math inline">\(|xy| = j \le n\)</span>.</p>
<p>Comme <span class="math inline">\(q_i = q_j\)</span>, le chemin
correspondant à <span class="math inline">\(y\)</span> est une boucle,
on peut donc l’emprunter autant qu’on le souhaite et ainsi tous les mots
de la forme <span class="math inline">\(x y^k z\)</span> sont reconnus
par <span class="math inline">\(A\)</span>. </div> </div></p>
<p>Ce lemme est très utile par sa contraposée qui permet d’affirmer que
si un langage ne vérifie par cette propriété, alors il n’est pas
régulier :</p>
<div class="ui message olive">
<div class="header">
Corollaire
</div>
<p>Soit <span class="math inline">\(L\)</span> un langage sur <span
class="math inline">\(\Sigma\)</span>. <strong>Si</strong> pour tout
<span class="math inline">\(n \in \N\)</span>, il existe <span
class="math inline">\(w \in L\)</span> tel que <span
class="math inline">\(|w| \ge n\)</span> et que pour tout <span
class="math inline">\(x, y, z \in \Sigma^*\)</span> tels que <span
class="math inline">\(w = x y z\)</span>, <span class="math inline">\(y
\neq \epsilon\)</span> et <span class="math inline">\(|xy| \le
n\)</span> il existe <span class="math inline">\(k \in \N\)</span> avec
<span class="math inline">\(x y^k z \not\in L\)</span>,
<strong>alors</strong> <span class="math inline">\(L\)</span> n’est pas
régulier.</p>
</div>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Le langage <span class="math inline">\(L = \enscomp{a^n b^n}{n \in
\N}\)</span> n’est pas régulier.</p>
<p>Soit <span class="math inline">\(n \in \N\)</span>, on considère
<span class="math inline">\(w = a^n b^n \in L\)</span>. Soient <span
class="math inline">\(x,y,z\)</span> tels que <span
class="math inline">\(w = x y z\)</span> avec <span
class="math inline">\(y \neq \epsilon\)</span> et <span
class="math inline">\(|xy| \le n\)</span>, on a donc <span
class="math inline">\(xy\)</span> préfixe de <span
class="math inline">\(a^n\)</span> : <span class="math inline">\(x =
a^k\)</span> et <span class="math inline">\(y = a^l\)</span> avec <span
class="math inline">\(k+l \le n\)</span> et <span
class="math inline">\(l &gt; 0\)</span> et ainsi <span
class="math inline">\(z = a^{n-k-l} b^n\)</span>.</p>
<p>Le mot <span class="math inline">\(x z = a^k a^{n-k-l} b^n = a^{n-l}
b^n \not\in L\)</span> car <span class="math inline">\(n - l &lt;
n\)</span>.</p>
<p>Ainsi, selon le lemme de l’étoile, <span
class="math inline">\(L\)</span> n’est pas régulier.</p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Cet exemple est très important car c’est un cas particulier très
simple des expressions bien parenthésées. On sait qu’on peut les
reconnaitre avec une pile, et on vient de voir que c’est impossible de
le faire avec un automate fini.</p>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Attention, le lemme de l’étoile n’est pas une équivalence. Un langage
peut très bien le satisfaire et être non régulier comme on va le voir
dans l’exemple suivant.</p>
<p></div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On considère le langage <span class="math display">\[
L = \enscomp{a b^n c^n}{n \in \N}
\cup \enscomp{a^k w}{k \neq 1, w \in \{b,c\}^*} = L_1 \cup L_2
\]</span></p>
<p>On a <span class="math inline">\(L \cap a b \Sigma^* = \enscomp{a b^n
c^n}{n \in \N^*}\)</span> : qui n’est pas régulier, c’est à la lettre a
en préfixe près le même exemple que le précédent. Or, <span
class="math inline">\(a b \Sigma^*\)</span> est régulier donc
nécessairement <span class="math inline">\(L\)</span> n’est pas régulier
par clôture des langages réguliers par intersection.</p>
<p>On va montrer que <span class="math inline">\(L\)</span> vérifie le
lemme de l’étoile pour <span class="math inline">\(n = 2\)</span>.</p>
<p>Soit <span class="math inline">\(w \in L\)</span> tel que <span
class="math inline">\(|w| \ge 2\)</span>. On a quatre cas possibles pour
<span class="math inline">\(w\)</span> :</p>
<ul>
<li><span class="math inline">\(w = a b^n c^n\)</span> pour <span
class="math inline">\(n \in \N^*\)</span>, on peut alors poser <span
class="math inline">\(x = \epsilon\)</span>, <span
class="math inline">\(y = a\)</span> et <span class="math inline">\(z =
b^n c^n\)</span>. On a pour <span class="math inline">\(k \in
\N\)</span>, <span class="math inline">\(xy^k z= a^k b^n c^n\)</span>
qui est soit dans <span class="math inline">\(L_1\)</span> si <span
class="math inline">\(k =1\)</span> ou dans <span
class="math inline">\(L_2\)</span> sinon.</li>
<li><span class="math inline">\(w = a^k v\)</span> avec <span
class="math inline">\(k \ge 2\)</span>, <span
class="math inline">\(k\neq 3\)</span> et <span
class="math inline">\(v\in \{b,c\}^*\)</span>. On pose <span
class="math inline">\(x = \epsilon\)</span>, <span
class="math inline">\(y = aa\)</span> et <span class="math inline">\(z =
a^{k-2} v\)</span>. On a <span class="math inline">\(x y^l z = a^{2l}
a^{k-2} v\)</span>. Si <span class="math inline">\(l = 0\)</span>, alors
<span class="math inline">\(x y^0 z = a^{k-2} v \in L\)</span> car <span
class="math inline">\(k-2 \neq 1\)</span>. Si <span
class="math inline">\(l &gt; 0\)</span>, alors <span
class="math inline">\(2l +k - 2 \ge 2l \ge 2\)</span> donc <span
class="math inline">\(x y^l z \in L\)</span>.</li>
<li><span class="math inline">\(w = a^3 v\)</span> avec <span
class="math inline">\(v \in \{b,c\}^*\)</span>. On pose <span
class="math inline">\(x =\epsilon, y = a\)</span> et <span
class="math inline">\(z = a^2 v\)</span>. Ainsi <span
class="math inline">\(x y^l z = a^{l + 2} v \in L\)</span> car <span
class="math inline">\(l + 2 \ge 2\)</span>.</li>
<li><span class="math inline">\(w \in \{b,c\}^*\)</span>, si, par
exemple, <span class="math inline">\(w = b v\)</span> on peut poser
<span class="math inline">\(x = \epsilon\)</span>, <span
class="math inline">\(y = b\)</span> et <span class="math inline">\(z =
v\)</span>. On a alors <span class="math inline">\(x y^k z = b^k v \in
\{b, c\}^* \subset L\)</span>.</li>
</ul>
<p>Ainsi, on a bien prouvé que <span class="math inline">\(L\)</span>
satisfaisait le lemme de l’étoile.</p>
</div>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
