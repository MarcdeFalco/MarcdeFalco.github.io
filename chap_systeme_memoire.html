<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Gestion de la mémoire dans un programme compilé</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

.ui.styled.accordion {
    width: 100% !important;
    font-size: 1rem !important;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\gO{\mathcal{O}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Gestion de la mémoire dans un programme compilé
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:orga"><span>1</span> Organisation de la mémoire</a><div class="menu"></div></div><div class="item header"> <a href="#sec:pointeurs"><span>2</span> Pointeurs</a><div class="menu"></div></div><div class="item header"> <a href="#sec:portée-dun-identificateur"><span>3</span> Portée d’un identificateur</a><div class="menu"></div></div><div class="item header"> <a href="#sec:pileexec"><span>4</span> Piles d’exécution, variables locales et paramètres</a><div class="menu"></div></div><div class="item header"> <a href="#sec:allocation-dynamique"><span>5</span> Allocation dynamique</a><div class="menu"><a class="item" href="#sec:allocation"><div class="ui label">5.1</div> Allocation</a><a class="item" href="#sec:libération"><div class="ui label">5.2</div> Libération</a><a class="item" href="#sec:protection-mémoire"><div class="ui label">5.3</div> Protection mémoire</a><a class="item" href="#sec:custommalloc"><div class="ui label">5.4</div> Réalisation d’un système d’allocation de mémoire</a></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Gestion de la mémoire dans un programme compilé
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Gestion de la mémoire dans un programme compilé     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_memoire.jpg"> </div></p>
<p><div class="ui message blue"><div class="header">Note</div><strong>Roadmap</strong> :</p>
<ul>
<li>reprendre les exemples en <code>C</code> en utilisant des <code>int</code> suite au changement dans le programme.</li>
<li>rajouter la présentation des pointeurs ici</div></li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div>Ce chapitre se concentre sur la manière dont un programme compilé gère la mémoire. Il est question, en particulier, de la notion de variable. Le modèle dans lequel on se place est celui du langage C où une variable est un emplacement mémoire.</div></p>
<h1 data-number="1" id="sec:orga"><span class="header-section-number">1</span> Organisation de la mémoire</h1>
<p><div class="ui message blue"><div class="header">Note</div>Ici, je fais le choix d’une présentation assez informelle pour ne pas qu’elle soit trop liée à la réalité d’un compilateur en particulier.</div></p>
<p>Un programme compilé gère la mémoire d’un ordinateur de deux manières très différentes</p>
<ul>
<li>statiquement : c’est le cas des variables locales ou globales définies dans le programme. Au moment de la compilation, le compilateur dispose de l’information suffisante pour prévoir de la place en mémoire pour stocker ces données.</li>
<li>dynamiquement : c’est le cas des objets dont la taille n’est connue qu’à l’exécution et peut varier selon l’état du programme. C’est alors au moment de l’exécution que le programme va faire une demande d’allocation pour obtenir une place mémoire.</li>
</ul>
<p><div class="ui internally celled grid"><div class="row"><div class="eleven wide column"></p>
<p>En terme d’allocation statique, on peut distinguer plusieurs types de mémoire :</p>
<ul>
<li>les variables globales initialisées qui seront stockées dans le binaire et placées en mémoire dans une zone spécifique chargée avec le binaire</li>
<li>les variables globales non initialisées dont seule la déclaration sera dans le binaire et qui seront allouées, placées en mémoire et initialisées à 0 au moment du chargement du binaire</li>
<li>les variables locales et les paramètres qui sont placés dans une pile afin de les allouer uniquement au moment de l’exécution du bloc ou de la fonction</li>
</ul>
<p>L’allocation dynamique utilise une zone mémoire appelée tas dont une possible organisation est développée dans la partie sec. 5.4.</p>
<p></div><div class="four wide column"></p>
<p><center><div class="ui image center"><img src="assets/pics/memorymap.png" /></div></center></p>
<p><br/>Structure de la mémoire associée à un programme</p>
<p></div></div></div></p>
<p>Considérons le programme c suivant.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1"></a><span class="dt">const</span> <span class="dt">int</span> a  <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="dt">int</span> b<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">};</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="dt">int</span> c<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="dt">int</span> z <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    z <span class="op">=</span> z <span class="op">*</span> y<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="cf">return</span> z<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">)</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="op">{</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>    <span class="dt">const</span> <span class="dt">int</span> d <span class="op">=</span> <span class="dv">1664</span><span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15"></a></span>
<span id="cb1-16"><a href="#cb1-16"></a>    c <span class="op">=</span> f<span class="op">(</span>a<span class="op">,</span> d<span class="op">);</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    </span>
<span id="cb1-18"><a href="#cb1-18"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Il est possible d’observer la manière dont sa mémoire sera répartie en utilisant la commande <code>objdump</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource zsh numberLines"><code class="sourceCode zsh"><span id="cb2-1"><a href="#cb2-1"></a><span class="ex">$</span> gcc <span class="at">-c</span> memoire.c</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="ex">$</span> objdump <span class="at">-x</span> memoire.o</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="ex">memoire.o:</span>     file format elf64-x86-64</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="ex">memoire.o</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="ex">architecture:</span> i386:x86-64, flags 0x00000011:</span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="ex">HAS_RELOC,</span> HAS_SYMS</span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="ex">start</span> address 0x0000000000000000</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="ex">Sections:</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="ex">Idx</span> Name          Size      VMA               LMA               File off  Algn</span>
<span id="cb2-12"><a href="#cb2-12"></a>  <span class="ex">0</span> .text         00000053  0000000000000000  0000000000000000  00000040  2<span class="pp">**</span>0</span>
<span id="cb2-13"><a href="#cb2-13"></a>                  <span class="ex">CONTENTS,</span> ALLOC, LOAD, RELOC, READONLY, CODE</span>
<span id="cb2-14"><a href="#cb2-14"></a>  <span class="ex">1</span> .data         00000000  0000000000000000  0000000000000000  00000093  2<span class="pp">**</span>0</span>
<span id="cb2-15"><a href="#cb2-15"></a>                  <span class="ex">CONTENTS,</span> ALLOC, LOAD, DATA</span>
<span id="cb2-16"><a href="#cb2-16"></a>  <span class="ex">2</span> .bss          00000004  0000000000000000  0000000000000000  00000094  2<span class="pp">**</span>2</span>
<span id="cb2-17"><a href="#cb2-17"></a>                  <span class="ex">ALLOC</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>  <span class="ex">3</span> .rodata       00000014  0000000000000000  0000000000000000  00000098  2<span class="pp">**</span>3</span>
<span id="cb2-19"><a href="#cb2-19"></a>                  <span class="ex">CONTENTS,</span> ALLOC, LOAD, READONLY, DATA</span>
<span id="cb2-20"><a href="#cb2-20"></a>  <span class="ex">4</span> .comment      00000013  0000000000000000  0000000000000000  000000ac  2<span class="pp">**</span>0</span>
<span id="cb2-21"><a href="#cb2-21"></a>                  <span class="ex">CONTENTS,</span> READONLY</span>
<span id="cb2-22"><a href="#cb2-22"></a>  <span class="ex">5</span> .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000bf  2<span class="pp">**</span>0</span>
<span id="cb2-23"><a href="#cb2-23"></a>                  <span class="ex">CONTENTS,</span> READONLY</span>
<span id="cb2-24"><a href="#cb2-24"></a>  <span class="ex">6</span> .eh_frame     00000058  0000000000000000  0000000000000000  000000c0  2<span class="pp">**</span>3</span>
<span id="cb2-25"><a href="#cb2-25"></a>                  <span class="ex">CONTENTS,</span> ALLOC, LOAD, RELOC, READONLY, DATA</span>
<span id="cb2-26"><a href="#cb2-26"></a><span class="ex">SYMBOL</span> TABLE:</span>
<span id="cb2-27"><a href="#cb2-27"></a><span class="ex">0000000000000000</span> l    df <span class="pp">*</span>ABS<span class="pp">*</span>  0000000000000000 orga.c</span>
<span id="cb2-28"><a href="#cb2-28"></a><span class="ex">0000000000000000</span> l    d  .text  0000000000000000 .text</span>
<span id="cb2-29"><a href="#cb2-29"></a><span class="ex">0000000000000000</span> l    d  .data  0000000000000000 .data</span>
<span id="cb2-30"><a href="#cb2-30"></a><span class="ex">0000000000000000</span> l    d  .bss   0000000000000000 .bss</span>
<span id="cb2-31"><a href="#cb2-31"></a><span class="ex">0000000000000000</span> l    d  .rodata    0000000000000000 .rodata</span>
<span id="cb2-32"><a href="#cb2-32"></a><span class="ex">0000000000000000</span> l    d  .note.GNU-stack    0000000000000000 .note.GNU-stack</span>
<span id="cb2-33"><a href="#cb2-33"></a><span class="ex">0000000000000000</span> l    d  .eh_frame  0000000000000000 .eh_frame</span>
<span id="cb2-34"><a href="#cb2-34"></a><span class="ex">0000000000000000</span> l    d  .comment   0000000000000000 .comment</span>
<span id="cb2-35"><a href="#cb2-35"></a><span class="ex">0000000000000000</span> g     O .rodata    0000000000000004 a</span>
<span id="cb2-36"><a href="#cb2-36"></a><span class="ex">0000000000000000</span> g     O .data  000000000000000c b</span>
<span id="cb2-37"><a href="#cb2-37"></a><span class="ex">0000000000000000</span> g     O .bss   0000000000000004 c</span>
<span id="cb2-38"><a href="#cb2-38"></a><span class="ex">0000000000000000</span> g     F .text  000000000000001f f</span>
<span id="cb2-39"><a href="#cb2-39"></a><span class="ex">000000000000001f</span> g     F .text  0000000000000034 main</span>
<span id="cb2-40"><a href="#cb2-40"></a></span>
<span id="cb2-41"><a href="#cb2-41"></a></span>
<span id="cb2-42"><a href="#cb2-42"></a><span class="ex">RELOCATION</span> RECORDS FOR <span class="pp">[</span><span class="st">.text</span><span class="pp">]</span>:</span>
<span id="cb2-43"><a href="#cb2-43"></a><span class="ex">OFFSET</span>           TYPE              VALUE </span>
<span id="cb2-44"><a href="#cb2-44"></a><span class="ex">0000000000000042</span> R_X86_64_PLT32    f-0x0000000000000004</span>
<span id="cb2-45"><a href="#cb2-45"></a><span class="ex">0000000000000048</span> R_X86_64_PC32     c-0x0000000000000004</span>
<span id="cb2-46"><a href="#cb2-46"></a></span>
<span id="cb2-47"><a href="#cb2-47"></a></span>
<span id="cb2-48"><a href="#cb2-48"></a><span class="ex">RELOCATION</span> RECORDS FOR <span class="pp">[</span><span class="st">.eh_frame</span><span class="pp">]</span>:</span>
<span id="cb2-49"><a href="#cb2-49"></a><span class="ex">OFFSET</span>           TYPE              VALUE </span>
<span id="cb2-50"><a href="#cb2-50"></a><span class="ex">0000000000000020</span> R_X86_64_PC32     .text</span>
<span id="cb2-51"><a href="#cb2-51"></a><span class="ex">0000000000000040</span> R_X86_64_PC32     .text+0x000000000000001f</span></code></pre></div>
<p></div></p>
<p>On retrouve dans les sections mémoire :</p>
<p><div class="ui internally celled grid"><div class="row"><div class="eleven wide column"></p>
<ul>
<li><code>.text</code> contenant le programme binaire</li>
<li><code>.data</code> contenant les variables globales initialisées et non constantes</li>
<li><code>.bss</code> contenant les variables non initialisées</li>
<li><code>.rodata</code> contenant les variables globales initialisées mais constantes.</li>
</ul>
<p></div><div class="four wide column"></p>
<p>Ici, le schéma mémoire est un peu plus compliqué car une zone mémoire distincte est prévue pour les variables constantes initialisées pour des raisons de sécurité.</p>
<p></div></div></div></p>
<p>La pile et le tas sont automatiques et n’ont pas besoin de figurer dans le binaire, c’est pour cela qu’on ne les trouve pas dans la liste.</p>
<p>Dans cette description mémoire, on trouve la table des symboles qui décrit où vont se trouver en mémoire certaines variables.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Nom de variable</th>
<th style="text-align: center;">Sorte de déclaration</th>
<th style="text-align: center;">Section mémoire</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">a</td>
<td style="text-align: center;">constante globale initialisée</td>
<td style="text-align: center;">rodata</td>
</tr>
<tr class="even">
<td style="text-align: center;">b</td>
<td style="text-align: center;">globale initialisée</td>
<td style="text-align: center;">data</td>
</tr>
<tr class="odd">
<td style="text-align: center;">c</td>
<td style="text-align: center;">globale non init.</td>
<td style="text-align: center;">bss</td>
</tr>
</tbody>
</table>
<p>La section suivante permettra de compléter le tableau en étudiant comment les paramètres et variables locales sont gérés. On remarque cependant qu’il n y a pas de symboles pour ceux-ci. En effet, le nom des variables locales est a priori perdu après la compilation contrairement aux variables globales.</p>
<h1 data-number="2" id="sec:pointeurs"><span class="header-section-number">2</span> Pointeurs</h1>
<h1 data-number="3" id="sec:portée-dun-identificateur"><span class="header-section-number">3</span> Portée d’un identificateur</h1>
<p>En ce qui concerne une variable dans un programme, on peut définir deux notions d’apparence assez similaire.</p>
<p>D’une part la portée d’un identificateur qui correspond au texte du programme :</p>
<p><div class="ui message"><div class="header">Définition</div> La <strong>portée</strong> d’un identificateur est définie par la zone du texte d’un programme dans laquelle il est possible d’y faire référence sans erreurs. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Dans le langage C, un identificateur peut être utilisé dès sa déclaration mais tant que la variable n’est pas initialisée, le comportement n’est pas spécifié et il faut considérer cela comme une erreur. Le compilateur produit ainsi un avertissement quand on utilise le paramètre <code>-Wall</code>.</p>
<p>Dans le cas d’une définition, il est ainsi possible de faire référence à l’identificateur dans l’expression de son initialisation : <code>int x = x</code>. Ce cas est pathologique et le fait qu’on compte la ligne de déclaration dans la portée ne devrait pas inciter à écrire ce genre de code qui produira, de toutes façons, une erreur avec les options <code>-Wall -Werror</code>.</div></p>
<p>Dans le programme :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource c numberLines numberLines"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="dt">int</span> f <span class="op">(</span><span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="dt">int</span> y <span class="op">=</span> x <span class="op">+</span> a<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    <span class="cf">return</span> y<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="op">}</span></span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="dt">int</span> g<span class="op">()</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="dt">int</span> z <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="cf">return</span> z <span class="op">+</span> f<span class="op">(</span>z<span class="op">);</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>La portée des identificateurs est :</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Identificateur</th>
<th style="text-align: center;">Portée</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">a</td>
<td style="text-align: center;">1-13</td>
</tr>
<tr class="even">
<td style="text-align: center;">x</td>
<td style="text-align: center;">3-7</td>
</tr>
<tr class="odd">
<td style="text-align: center;">y</td>
<td style="text-align: center;">5-7</td>
</tr>
<tr class="even">
<td style="text-align: center;">f</td>
<td style="text-align: center;">4-13</td>
</tr>
<tr class="odd">
<td style="text-align: center;">g</td>
<td style="text-align: center;">10-13</td>
</tr>
<tr class="even">
<td style="text-align: center;">z</td>
<td style="text-align: center;">11-13</td>
</tr>
</tbody>
</table>
<p>Pour une fonction, afin de pouvoir écrire des fonctions récursives, l’identificateur est utilisable dans le corps de la fonction.</p>
<p>Comme la portée est une notion associée aux identificateurs, elle est indépendante de la notion de variables. Si on considère le programme suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource c numberLines numberLines"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1"></a><span class="dt">int</span> f<span class="op">()</span> </span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="dt">int</span> g<span class="op">()</span> </span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="cf">return</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>L’identificateur <code>i</code> a pour portée les lignes 3-6 et 10-13.</p>
<p>Un autre phénomène plus complexe peut se produire quand on redéfinit un identificateur dans sa portée.</p>
<p>Considérons le programme suivant</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource c numberLines numberLines"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1"></a><span class="dt">int</span> f<span class="op">()</span> </span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> j<span class="op">++)</span> </span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>        <span class="dt">int</span> i <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>        </span>
<span id="cb5-9"><a href="#cb5-9"></a>        i <span class="op">+=</span> j<span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>    <span class="op">}</span></span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a>    <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Ici, l’identificateur <code>i</code> a pour portée les lignes 3-13 mais dans les lignes 7-10 il y a un phénomène dit de masquage où la première définition est cachée par la seconde.</p>
<p>L’identificateur associé à une variable globale a pour portée l’ensemble des lignes suivant sa déclaration.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>En C, la portée d’un identificateur est <strong>statique</strong> : elle dépend uniquement du texte du programme au moment de la compilation.</p>
<p>En Python, la portée d’un identificateur est <strong>dynamique</strong> : elle peut dépendre de l’exécution d’un programme. Par exemple si on considère le programme Python</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource python numberLines numberLines"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="cf">if</span> condition:</span>
<span id="cb6-2"><a href="#cb6-2"></a>    x <span class="op">=</span> <span class="dv">3</span></span></code></pre></div>
<p></div></p>
<p>La portée de l’identificateur <code>x</code> dépend ici du fait que la <code>condition</code> soit réalisée ou non.</div></p>
<h1 data-number="4" id="sec:pileexec"><span class="header-section-number">4</span> Piles d’exécution, variables locales et paramètres</h1>
<p>On a vu qu’en raison de leur durée de vie, les variables globales étaient allouées dès le chargement du programme. Pour les variables locales ainsi que la mécanique des appels, on utilise une <strong>pile</strong>.</p>
<p>Cette pile d’exécution est représentée en mémoire par un tableau et un indicateur de fond de pile.</p>
<p>Le remplissage de ce tableau s’effectue souvent des adresses hautes vers les adresses faibles : on empile en faisant diminuer les adresses.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>En fait, il existe des architectures où les adresses sont croissantes. Ce qui importe est que le tas et la pile aient des comportements opposées pour qu’ils puissent grandir dans la même zone mémoire.</div></p>
<p>Un compilateur peut faire le choix d’utiliser directement des registres processeurs pour les variables locales ou pour passer des paramètres à une fonction. Ici, pour simplifier, on va supposer que ce n’est pas le cas et que tout passe par la pile d’exécution.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Afin de pouvoir appeler une fonction dans une bibliothèque potentiellement compilée avec un autre compilateur, il est nécessaire d’avoir une convention d’appels de fonctions. Une telle convention est appelée une <em>interface applicative binaire</em> (Application Binary Interface).</p>
<p>La convention <code>System V AMD64 ABI</code> qui est celle de Linux et macOS sur des architectures 64bits consiste à utiliser des registres entiers pour les six premiers arguments entiers ou pointeurs et des registres flottants pour les huit premiers arguments flottants. Les arguments suivants sont alors passés sur la pile (donc dès le septième entier/pointeur ou neuvième flottant).</p>
<p>La convention <code>cdecl</code> qui est assez répandue sur les architectures 32bits consiste à utiliser la pile. Par contre la valeur de retour est présente dans des registres comme pour la convention <code>System V AMD64 ABI</code>.</div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eleven wide column"></p>
<p>Lors d’un appel d’une fonction passant par la pile, on commence par empiler les paramètres (souvent de la droite vers la gauche) puis on empile l’adresse à laquelle doit revenir l’exécution une fois que la fonction aura terminé son exécution.</p>
<p>Au début de l’exécution de cette fonction, on place sur la pile l’adresse du fond de pile et on déplace celui-ci pour réserver de la place pour les variables locales.</p>
<p>L’empreinte sur la pile d’un appel de fonction est appelée une structure pile (<strong>stack frame</strong> en anglais). La pile est alors organisée, depuis l’appel au point d’entrée du programme, par empilement et dépilement de structures piles.</p>
<p></div><div class="four wide column"></p>
<p><center><div class="ui image center"><img src="assets/pics/stackframe.png" /></div></center></p>
<p><br/>Structure pile associée à un appel de fonction</p>
<p></div></div></div></p>
<p>Voici un exemple possible de l’état de la pile d’exécution lors de l’exécution d’un programme compilé avec la norme <code>cdecl</code> (Il suffit d’ajouter l’argument <code>-m32</code> pour compiler en 32bits).</p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource c numberLines numberLines"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1"></a></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="dt">int</span> c <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="co">/* pile ici après l&#39;appel en l13 */</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>    c <span class="op">=</span> c <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>    c <span class="op">=</span> c <span class="op">*</span> a<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>    <span class="cf">return</span> c<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>    <span class="dt">int</span> x <span class="op">=</span> f<span class="op">(</span><span class="dv">10</span><span class="op">,</span><span class="dv">12</span><span class="op">);</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div><div class="eight wide column"></p>
<p><center><div class="ui image center"><img src="assets/pics/stackframe1.png" /></div></center></p>
<p></div></div></div></p>
<p>A chaque appel de fonction, on va donc empiler une structure de pile complète, puis la dépiler à la sortie. Ce mécanisme est essentiel pour permettre la récurrence car il permet d’effectuer plusieurs appels d’une même fonction sans risquer que la mémoire utilisée lors d’un des appels interfère avec un autre. On comprend également les limites de la récursivité ici car cet empilement successif de structures de piles peut dépasser la taille maximale de la pile d’exécution : on parle alors de <em>dépassement de pile</em> ou <strong>stack overflow</strong> en anglais.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Il est possible de définir des variables locales qui soient situées au même emplacement mémoire pour tous les appels d’une fonction, c’est ce qu’on appelé des variables <em>statiques</em> dans le paragraphe précédent.</p>
<p>Ce mécanisme est essentiellement géré comme les variables globales et il ne sera pas développé dans la suite.</div></p>
<p><div class="ui message blue"><div class="header">Note</div>Je me demande s’il faudrait parler plus précisement de la manière dont la pile est gérée avec les registres ebp/esp. Mais ça ne me semble pas apporter grand chose ici.</div></p>
<h1 data-number="5" id="sec:allocation-dynamique"><span class="header-section-number">5</span> Allocation dynamique</h1>
<p>Comme cela a été vu dans la section sec. 1, il est possible d’allouer dynamiquement de la mémoire. Pour gérer cette allocation dynamique, on passe par une zone mémoire appelé le <em>tas</em> ainsi que par un mécanisme d’allocation et de libération de mémoire au niveau du système.</p>
<p>Pour l’utilisateur, cette gestion interne est transparente et on peut se contenter de considérer qu’il y a deux mécanismes :</p>
<ul>
<li>l’<strong>allocation</strong> mémoire où on demande à ce qu’une zone mémoire d’une certaine taille soit allouée</li>
<li>la <strong>libération</strong> mémoire où on signale que la zone mémoire peut être récupérée par le système.</li>
</ul>
<p>Naturellement, la mémoire d’un ordinateur étant finie, il est très important de libérer au plus tôt la mémoire non utilisée pour éviter d’épuiser la mémoire. Quand un programme ne libère pas toute la mémoire qu’il alloue, on parle de <strong>fuite mémoire</strong>. L’empreinte mémoire d’un tel programme peut alors croître jusqu’à rendre le programme ou le système inutilisable.</p>
<h2 data-number="5.1" id="sec:allocation"><span class="header-section-number">5.1</span> Allocation</h2>
<p>Pour allouer une zone mémoire, on utilise la fonction <code>malloc</code> dans <code>stdlib.h</code> de signature :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1"></a><span class="dt">void</span> <span class="op">*</span>malloc<span class="op">(</span><span class="dt">size_t</span> size<span class="op">)</span></span></code></pre></div>
<p></div></p>
<p>Ici <code>size</code> indique le nombre d’<strong>octets</strong> à allouer et la fonction renvoie un pointeur vers le premier octet alloué. Comme la fonction ne connait pas le type d’objets alloués, on utilise ainsi le type <code>void *</code>.</p>
<p>Ce type joue un rôle spécial et on peut changer directement le type de la valeur de retour sans rien avoir à écrire d’autre l’appel à malloc :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1"></a><span class="dt">char</span> <span class="op">*</span>t <span class="op">=</span> malloc<span class="op">(</span>n<span class="op">);</span></span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Dans le langage C++ qui peut être vu comme un successeur de C, il est obligatoire de préciser ici le nouveau type à l’aide d’un un <strong>transtypage</strong>. Pour convertir la valeur <code>x</code> vers le type <code>char *</code> on écrit alors <code>(char *)x</code>. Ainsi, pour allouer un tableau de <code>n</code> caractères, on utilisera :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1"></a><span class="dt">char</span> <span class="op">*</span>t <span class="op">=</span> <span class="op">(</span><span class="dt">char</span> <span class="op">*)</span> malloc<span class="op">(</span>n<span class="op">);</span></span></code></pre></div>
<p></div></p>
<p>Bien que ce ne soit pas nécessaire en C, il est fréquent de rencontrer des programmes présentant de tels transtypages qui sont superflus mais corrects syntaxiquement en C.</div></p>
<p>Pour obtenir la taille à allouer, il peut être utile d’utiliser l’opérateur <code>sizeof</code> qui prend en entrée un type ou une valeur et renvoie sa taille. Ainsi si on peut allouer un tableau de <span class="math inline">\(n\)</span> entiers non signés ainsi :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1"></a><span class="dt">unsigned</span> <span class="dt">int</span> <span class="op">*</span>t <span class="op">=</span> malloc<span class="op">(</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">unsigned</span> <span class="dt">int</span><span class="op">)</span> <span class="op">*</span> n <span class="op">);</span></span></code></pre></div>
<p></div></p>
<p>et cet appel ne dépend de la taille prise par un <code>unsigned int</code> sur l’architecture.</p>
<p>Une autre raison de l’utilisation de <code>sizeof</code> est l’extensibilité. Par exemple, si on a un <code>struct point</code> représentant des points en 2D :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">struct</span> point <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="dt">float</span> x<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="dt">float</span> y<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="op">};</span></span></code></pre></div>
<p></div></p>
<p>on peut allouer un tableau de <span class="math inline">\(n\)</span> points ainsi :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">struct</span> point <span class="op">*</span>t <span class="op">=</span> malloc<span class="op">(</span> <span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> point<span class="op">)</span> <span class="op">*</span> n <span class="op">);</span></span></code></pre></div>
<p></div></p>
<p>Si jamais on change la structure pour représenter des points en 3D ainsi :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">struct</span> point <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>    <span class="dt">float</span> x<span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span class="dt">float</span> y<span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="dt">float</span> z<span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="op">};</span></span></code></pre></div>
<p></div></p>
<p>il sera inutile de changer le code d’allocation du tableau car <code>sizeof(point)</code> tiendra compte automatiquement du changement.</p>
<p>Si jamais une erreur empêche d’allouer la mémoire - ce qui peut être le cas s’il n’y a plus de mémoire disponible - le pointeur renvoyé par <code>malloc</code> a la valeur spéciale <code>NULL</code>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>La zone mémoire renvoyée par <code>malloc</code> n’est pas initialisée. On ne peut pas supposer qu’elle soit remplie de la valeur 0. Il faut donc manuellement initialiser la mémoire après le retour de <code>malloc</code>.</div></p>
<h2 data-number="5.2" id="sec:libération"><span class="header-section-number">5.2</span> Libération</h2>
<p>Pour libérer la mémoire, on utilise la fonction <code>free</code> également présente dans <code>stdlib.h</code> et dont la signature est :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1"></a><span class="dt">void</span> free<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>ptr<span class="op">);</span></span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Il est très important d’utiliser uniquement un pointeur obtenu précédemment par un appel à <code>malloc</code> et de ne pas l’utiliser plus d’une fois.</p>
<p>Le programme suivant provoque une erreur <code>free(): invalid pointer</code> à l’exécution mais est détécté par un avertissement du compilateur : <code>warning: attempt to free a non-heap object ‘a’</code>.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="op">{</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>    free<span class="op">(&amp;</span>a<span class="op">);</span></span>
<span id="cb16-7"><a href="#cb16-7"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Le programme suivant alloue un tableau de deux <code>char</code> et appelle <code>free</code> sur l’adresse de la seconde case. En faisant cela, il n’y a pas d’avertissement car on appelle <code>free</code> sur un objet qui est effectivement sur le tas. On obtient alors à nouveau une erreur à l’exécution <code>free(): invalid pointer</code>.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="op">{</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="dt">char</span> <span class="op">*</span>a <span class="op">=</span> malloc<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>    free<span class="op">(&amp;(</span>a<span class="op">[</span><span class="dv">1</span><span class="op">]));</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Le programme suivant libère deux fois la mémoire et provoque l’erreur <code>free(): double free detected in tcache 2</code> à l’exécution.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="op">{</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="dt">char</span> <span class="op">*</span>a <span class="op">=</span> malloc<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb18-6"><a href="#cb18-6"></a>    free<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb18-7"><a href="#cb18-7"></a>    free<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb18-8"><a href="#cb18-8"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div></p>
<h2 data-number="5.3" id="sec:protection-mémoire"><span class="header-section-number">5.3</span> Protection mémoire</h2>
<p>Comme on l’a vu dans la première partie, quand un programme s’exécute il a un environnement mémoire constitué de plusieurs zones, parfois appelées <strong>segments</strong>, avec le droit d’écriture dans certaines d’entre elles.</p>
<p>Le système d’exploitation protège ainsi la mémoire et, au niveau matériel, l’unité de gestion de la mémoire connait les adresses accessibles à un programme. En cas d’accès anormal, le matériel provoque une erreur qui remonte au système d’exploitation qui termine l’exécution du programme avec une erreur souvent intitulée <code>Segmentation fault</code>.</p>
<p>Voici quelques exemples commentés produisant des erreurs de type <code>segmentation fault</code> à l’exécution.</p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>Lecture à l’adresse 0, ce qui provoque toujours une erreur.</p>
<p>Même problème avec une adresse inaccessible ou invalide.</p>
<p></div><div class="eight wide column"></p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="op">{</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="dt">int</span> <span class="op">*</span>a <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4"></a></span>
<span id="cb19-5"><a href="#cb19-5"></a>    <span class="cf">return</span> a<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div></div></div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>Écriture dans une zone en lecture seule comme le segment du code.</p>
<p></div><div class="eight wide column"></p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>    <span class="dt">int</span> <span class="op">*</span>a <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">*)</span> <span class="op">(&amp;</span>main<span class="op">);</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="co">// a pointe sur le corps de la fonction main</span></span>
<span id="cb20-5"><a href="#cb20-5"></a></span>
<span id="cb20-6"><a href="#cb20-6"></a>    <span class="op">*</span>a <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb20-7"><a href="#cb20-7"></a></span>
<span id="cb20-8"><a href="#cb20-8"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p></div></div></div></p>
<h2 data-number="5.4" id="sec:custommalloc"><span class="header-section-number">5.4</span> Réalisation d’un système d’allocation de mémoire</h2>
<p><div class="ui message blue"><div class="header">Note</div>Prérequis : listes chaînées</div></p>
<p>Afin de comprendre comment fonctionne le tas, et en particulier malloc et free, on va simuler ici ce comportement en allouant une grande plage de mémoire avec malloc et en gérant le découpage et l’allocation de celle-ci.</p>
<p>Pour gérer les blocs mémoires libres, on utilise une liste circulaire. Une liste circulaire est une liste chaînée avec un lien supplémentaire entre le premier et le dernier maillon, ce qui fait qu’on peut considérer n’importe quel maillon comme étant la <em>tête</em> de la liste.</p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>Une liste chaînée :</p>
<p><center><div class="ui image center"><img src="assets/pics/listechainee.png" /></div></center></p>
<p>Ici le dernier maillon comprend un pointeur qui ne pointe sur rien indiqué par <span class="math inline">\(\times\)</span>, en pratique il a la valeur <code>NULL</code></p>
<p></div><div class="eight wide column"></p>
<p>Une liste circulaire :</p>
<p><center><div class="ui image center"><img src="assets/pics/listecirculaire.png" /></div></center></p>
<p>Le seul changement est donc de faire pointer le dernier maillon sur le premier. Le fait d’avoir preserver les valeurs dans les maillons permet ici de voir ce qu’est devenu le premier maillon, mais on peut accéder à cette liste par n’importe lequel de ces maillons.</p>
<p></div></div></div></p>
<p>Les noeuds de la liste circulaire de blocs libres auront pour valeur un triplet <code>(adresse,taille,libre)</code> qui indique qu’à l’adresse <code>adresse</code> il y a un bloc de <code>taille</code> octets et le booléen <code>libre</code> indique si ce bloc a été alloué ou non.</p>
<p>Pour cela on commence par définir une structure <code>bloc</code> et une fonctiond de création d’un bloc :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">struct</span> bloc <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>    <span class="dt">void</span> <span class="op">*</span>adresse<span class="op">;</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>    <span class="dt">uint32_t</span> taille<span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>    <span class="dt">bool</span> libre<span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>    <span class="kw">struct</span> bloc <span class="op">*</span>suivant<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="op">};</span></span>
<span id="cb21-7"><a href="#cb21-7"></a></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="kw">struct</span> bloc <span class="op">*</span>cree_bloc<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>adresse<span class="op">,</span> <span class="dt">uint32_t</span> taille<span class="op">,</span> <span class="dt">bool</span> libre<span class="op">)</span></span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="op">{</span></span>
<span id="cb21-10"><a href="#cb21-10"></a>    <span class="kw">struct</span> bloc <span class="op">*</span>b <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> bloc<span class="op">));</span></span>
<span id="cb21-11"><a href="#cb21-11"></a>    b<span class="op">-&gt;</span>adresse <span class="op">=</span> adresse<span class="op">;</span></span>
<span id="cb21-12"><a href="#cb21-12"></a>    b<span class="op">-&gt;</span>taille <span class="op">=</span> taille<span class="op">;</span></span>
<span id="cb21-13"><a href="#cb21-13"></a>    b<span class="op">-&gt;</span>libre <span class="op">=</span> libre<span class="op">;</span></span>
<span id="cb21-14"><a href="#cb21-14"></a>    <span class="cf">return</span> b<span class="op">;</span></span>
<span id="cb21-15"><a href="#cb21-15"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>On définit ensuite deux variables globales :</p>
<ul>
<li><code>bloc_libres</code> qui va pointer sur un maillon de la liste circulaire des blocs</li>
<li><code>plage_memoire</code> qui pointe sur l’adresse de la plage mémoire que l’on va gérer et servira à la libérer en sortie de programme.</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">struct</span> bloc <span class="op">*</span>blocs_libres<span class="op">;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="dt">void</span> <span class="op">*</span>plage_memoire<span class="op">;</span></span></code></pre></div>
<p></div></p>
<p>La fonction <code>creation_blocs_libres</code> permet de créer la liste circulaire avec un premier bloc qui pointe sur lui-même et qui correspond à l’adresse que l’on va placer dans <code>plage_memoire</code>.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1"></a><span class="dt">void</span> creation_blocs_libres<span class="op">(</span><span class="dt">uint32_t</span> taille_bloc_initial<span class="op">)</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="op">{</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    plage_memoire <span class="op">=</span> malloc<span class="op">(</span>taille_bloc_initial<span class="op">);</span></span>
<span id="cb23-4"><a href="#cb23-4"></a>    blocs_libres <span class="op">=</span> cree_bloc<span class="op">(</span>plage_memoire<span class="op">,</span> taille_bloc_initial<span class="op">,</span> true<span class="op">);</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>    blocs_libres<span class="op">-&gt;</span>suivant <span class="op">=</span> blocs_libres<span class="op">;</span> <span class="co">// boucle initiale</span></span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Pour libérer la liste à la sortie du programme, on définit la fonction <code>destruction_blocs_libres</code> qui présente ainsi le parcours usuel d’une liste circulaire : on procède comme pour une liste chaînée classique mais, au lieu d’utiliser un test <code>bloc_courant-&gt;suivant == NULL</code> pour l’arrêt, il faut se souvenir du premier bloc et tester pour voir si on est revenu au point de départ. On n’oublie pas de libérer l’espace <code>plage_memoire</code> à la fin.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1"></a><span class="dt">void</span> destruction_blocs_libres<span class="op">()</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>    <span class="kw">struct</span> bloc <span class="op">*</span>premier_bloc <span class="op">=</span> blocs_libres<span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>    <span class="kw">struct</span> bloc <span class="op">*</span>bloc_courant <span class="op">=</span> premier_bloc<span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5"></a></span>
<span id="cb24-6"><a href="#cb24-6"></a>    <span class="co">// on boucle pour libérer chaque maillon</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>    <span class="cf">while</span> <span class="op">(</span>true<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>        <span class="kw">struct</span> bloc <span class="op">*</span>bloc_suivant <span class="op">=</span> bloc_courant<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>        free<span class="op">(</span>bloc_courant<span class="op">);</span></span>
<span id="cb24-10"><a href="#cb24-10"></a>        <span class="cf">if</span> <span class="op">(</span>bloc_suivant <span class="op">==</span> premier_bloc<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb24-11"><a href="#cb24-11"></a>        bloc_courant <span class="op">=</span> bloc_suivant<span class="op">;</span></span>
<span id="cb24-12"><a href="#cb24-12"></a>    <span class="op">}</span></span>
<span id="cb24-13"><a href="#cb24-13"></a></span>
<span id="cb24-14"><a href="#cb24-14"></a>    <span class="co">// on libère la plage mémoire initiale</span></span>
<span id="cb24-15"><a href="#cb24-15"></a>    free<span class="op">(</span>plage_memoire<span class="op">);</span></span>
<span id="cb24-16"><a href="#cb24-16"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Pour allouer <span class="math inline">\(t\)</span> octets, on parcourt la liste des blocs jusqu’à trouver un bloc <span class="math inline">\(b\)</span> libre de taille <span class="math inline">\(b.t\)</span> telle que <span class="math inline">\(b.t \ge t\)</span>. Si un tel bloc n’existe pas, on renvoie le pointeur <code>NULL</code> signe d’un échec d’allocation. Sinon, on indique que le bloc est occupé, on va renvoyer l’adresse du bloc obtenu mais, si <span class="math inline">\(b.t &gt; t\)</span> on insère après <span class="math inline">\(b\)</span> un nouveau bloc libre de taille <span class="math inline">\(b.t - t\)</span>. Dans tous les cas, on fait pointer la liste des blocs libres vers le bloc qui suit <span class="math inline">\(b\)</span>, qui est peut-être le bloc nouvellement créé et a de grandes chances d’être libre.</p>
<p>Ce mécanisme est implementé dans la fonction <code>allocation</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1"></a><span class="dt">void</span> <span class="op">*</span>allocation<span class="op">(</span><span class="dt">uint32_t</span> taille<span class="op">)</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>    <span class="kw">struct</span> bloc <span class="op">*</span>premier_bloc <span class="op">=</span> blocs_libres<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4"></a>    <span class="kw">struct</span> bloc <span class="op">*</span>bloc_courant <span class="op">=</span> premier_bloc<span class="op">;</span></span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a>    <span class="cf">while</span> <span class="op">(!</span>bloc_courant<span class="op">-&gt;</span>libre <span class="op">||</span> bloc_courant<span class="op">-&gt;</span>taille <span class="op">&lt;</span> taille<span class="op">)</span></span>
<span id="cb25-7"><a href="#cb25-7"></a>    <span class="op">{</span></span>
<span id="cb25-8"><a href="#cb25-8"></a>        bloc_courant <span class="op">=</span> bloc_courant<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb25-9"><a href="#cb25-9"></a>        <span class="cf">if</span> <span class="op">(</span>bloc_courant <span class="op">==</span> premier_bloc<span class="op">)</span></span>
<span id="cb25-10"><a href="#cb25-10"></a>        <span class="op">{</span></span>
<span id="cb25-11"><a href="#cb25-11"></a>            <span class="co">// Retour au point de départ : échec d&#39;allocation</span></span>
<span id="cb25-12"><a href="#cb25-12"></a>            <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb25-13"><a href="#cb25-13"></a>        <span class="op">}</span></span>
<span id="cb25-14"><a href="#cb25-14"></a>    <span class="op">}</span></span>
<span id="cb25-15"><a href="#cb25-15"></a>    </span>
<span id="cb25-16"><a href="#cb25-16"></a>    <span class="co">// bloc_courant pointe sur un bloc libre de bonne taille</span></span>
<span id="cb25-17"><a href="#cb25-17"></a></span>
<span id="cb25-18"><a href="#cb25-18"></a>    <span class="dt">void</span> <span class="op">*</span>adresse <span class="op">=</span> bloc_courant<span class="op">-&gt;</span>adresse<span class="op">;</span></span>
<span id="cb25-19"><a href="#cb25-19"></a>    bloc_courant<span class="op">-&gt;</span>libre <span class="op">=</span> false<span class="op">;</span></span>
<span id="cb25-20"><a href="#cb25-20"></a>    <span class="cf">if</span> <span class="op">(</span>bloc_courant<span class="op">-&gt;</span>taille <span class="op">&gt;</span> taille<span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-21"><a href="#cb25-21"></a>        <span class="co">// on le sépare en deux pour récupérer la place</span></span>
<span id="cb25-22"><a href="#cb25-22"></a>        <span class="kw">struct</span> bloc <span class="op">*</span>bloc_libre <span class="op">=</span> cree_bloc<span class="op">(</span>adresse<span class="op">+</span>taille<span class="op">,</span></span>
<span id="cb25-23"><a href="#cb25-23"></a>                bloc_courant<span class="op">-&gt;</span>taille<span class="op">-</span>taille<span class="op">,</span> true<span class="op">);</span></span>
<span id="cb25-24"><a href="#cb25-24"></a>        bloc_courant<span class="op">-&gt;</span>taille <span class="op">=</span> taille<span class="op">;</span></span>
<span id="cb25-25"><a href="#cb25-25"></a>        bloc_libre<span class="op">-&gt;</span>suivant <span class="op">=</span> bloc_courant<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb25-26"><a href="#cb25-26"></a>        bloc_courant<span class="op">-&gt;</span>suivant <span class="op">=</span> bloc_libre<span class="op">;</span></span>
<span id="cb25-27"><a href="#cb25-27"></a>    <span class="op">}</span></span>
<span id="cb25-28"><a href="#cb25-28"></a></span>
<span id="cb25-29"><a href="#cb25-29"></a>    <span class="co">// On pointe sur le bloc suivant qui est sûrement libre</span></span>
<span id="cb25-30"><a href="#cb25-30"></a>    blocs_libres <span class="op">=</span> bloc_courant<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb25-31"><a href="#cb25-31"></a></span>
<span id="cb25-32"><a href="#cb25-32"></a>    <span class="cf">return</span> adresse<span class="op">;</span></span>
<span id="cb25-33"><a href="#cb25-33"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Pour libérer un bloc, on parcourt la liste jusqu’à trouver le bloc correspondant à l’adresse à libérer et on indique que le bloc est libre. Ici, il y a deux <code>assert</code> permettant de s’assurer que l’adresse est bien celle d’un bloc et que le bloc n’a pas déjà été libéré.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1"></a><span class="dt">void</span> liberation<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>adresse<span class="op">)</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3"></a>    <span class="kw">struct</span> bloc <span class="op">*</span>premier_bloc <span class="op">=</span> blocs_libres<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>    <span class="kw">struct</span> bloc <span class="op">*</span>bloc_courant <span class="op">=</span> premier_bloc<span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5"></a></span>
<span id="cb26-6"><a href="#cb26-6"></a>    <span class="cf">while</span> <span class="op">(</span>bloc_courant<span class="op">-&gt;</span>adresse <span class="op">!=</span> adresse<span class="op">)</span></span>
<span id="cb26-7"><a href="#cb26-7"></a>    <span class="op">{</span></span>
<span id="cb26-8"><a href="#cb26-8"></a>        bloc_courant <span class="op">=</span> bloc_courant<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb26-9"><a href="#cb26-9"></a>        <span class="co">// adresse invalide</span></span>
<span id="cb26-10"><a href="#cb26-10"></a>        assert<span class="op">(</span>bloc_courant <span class="op">!=</span> premier_bloc<span class="op">);</span></span>
<span id="cb26-11"><a href="#cb26-11"></a>    <span class="op">}</span></span>
<span id="cb26-12"><a href="#cb26-12"></a></span>
<span id="cb26-13"><a href="#cb26-13"></a>    <span class="co">// pas de double libération</span></span>
<span id="cb26-14"><a href="#cb26-14"></a>    assert<span class="op">(!</span>bloc_courant<span class="op">-&gt;</span>libre<span class="op">);</span></span>
<span id="cb26-15"><a href="#cb26-15"></a></span>
<span id="cb26-16"><a href="#cb26-16"></a>    <span class="co">// on libère l&#39;adresse</span></span>
<span id="cb26-17"><a href="#cb26-17"></a>    bloc_courant<span class="op">-&gt;</span>libre <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb26-18"><a href="#cb26-18"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Voici un premier programme de test de ces fonctions qui alloue 10 octets puis effectue plusieurs allocations. L’allocation de <code>c</code> échoue car il n’y a plus de place libre.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource c numberLines numberLines"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3"></a>    creation_blocs_libres<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb27-4"><a href="#cb27-4"></a></span>
<span id="cb27-5"><a href="#cb27-5"></a>    <span class="dt">uint8_t</span> <span class="op">*</span>a <span class="op">=</span> allocation<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb27-6"><a href="#cb27-6"></a>    <span class="dt">uint8_t</span> <span class="op">*</span>b <span class="op">=</span> allocation<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb27-7"><a href="#cb27-7"></a>    <span class="dt">uint8_t</span> <span class="op">*</span>c <span class="op">=</span> allocation<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb27-8"><a href="#cb27-8"></a>    liberation<span class="op">(</span>b<span class="op">);</span></span>
<span id="cb27-9"><a href="#cb27-9"></a>    <span class="dt">uint8_t</span> <span class="op">*</span>d <span class="op">=</span> allocation<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb27-10"><a href="#cb27-10"></a></span>
<span id="cb27-11"><a href="#cb27-11"></a>    printf<span class="op">(</span><span class="st">&quot;Allocation a:%p b:%p c:%p d:%p</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb27-12"><a href="#cb27-12"></a>            <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span>a<span class="op">,</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span>b<span class="op">,</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span>c<span class="op">,</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span>d<span class="op">);</span></span>
<span id="cb27-13"><a href="#cb27-13"></a></span>
<span id="cb27-14"><a href="#cb27-14"></a>    destruction_blocs_libres<span class="op">();</span></span>
<span id="cb27-15"><a href="#cb27-15"></a></span>
<span id="cb27-16"><a href="#cb27-16"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-17"><a href="#cb27-17"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Ce programme affiche alors</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1"></a>Allocation a<span class="op">:</span><span class="bn">0x55c6c0c922a0</span> b<span class="op">:</span><span class="bn">0x55c6c0c922a5</span> c<span class="op">:(</span>nil<span class="op">)</span> d<span class="op">:</span><span class="bn">0x55c6c0c922a5</span></span></code></pre></div>
<p></div></p>
<p>Voici l’évolution de la liste circulaire en présentant les maillons sous la forme :</p>
<p><center><div class="ui image center"><img src="assets/pics/maillon.png" /></div></center></p>
<p>L’évolution de la liste des blocs entre les lignes 3 et 9 est alors :</p>
<ul>
<li>Ligne 3</li>
</ul>
<p><center><div class="ui image center"><img src="assets/pics/custom_malloc_evolution1.png" /></div></center></p>
<ul>
<li>Ligne 5</li>
</ul>
<p><center><div class="ui image center"><img src="assets/pics/custom_malloc_evolution2.png" /></div></center></p>
<ul>
<li>Ligne 6</li>
</ul>
<p><center><div class="ui image center"><img src="assets/pics/custom_malloc_evolution3.png" /></div></center></p>
<ul>
<li>Ligne 8</li>
</ul>
<p><center><div class="ui image center"><img src="assets/pics/custom_malloc_evolution4.png" /></div></center></p>
<ul>
<li>Ligne 9</li>
</ul>
<p><center><div class="ui image center"><img src="assets/pics/custom_malloc_evolution5.png" /></div></center></p>
<p>Cette méthode d’allocation a un défaut majeur : elle fragmente l’espace libre. Dans le programme suivant, il sera impossible d’allouer <code>b</code> car la liste circulaire contient deux blocs libres de 5 octets et non une bloc libre de 10 octets.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1"></a>creation_blocs_libres<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="dt">uint8_t</span> <span class="op">*</span>a <span class="op">=</span> allocation<span class="op">(</span><span class="dv">5</span><span class="op">)</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>liberation<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="dt">uint8_t</span> <span class="op">*</span>b <span class="op">=</span> allocation<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>On peut observer ce phénomène sur le diagramme précédent à la ligne 8 où deux blocs contigus sont libres et pourraient être fusionnés en un unique bloc de 5 octets.</div></p>
<p>On peut éviter cela en effectuant une phase de coalescence des blocs libres à la libération. En vertu de la nature de la liste circulaire, il est nécessaire de fusionner un bloc libre avec les blocs suivants. En utilisant une liste circulaire doublement chaînée, on pourrait également fusionner avec les blocs précédents.</p>
<p>Pour cela on change la fonction <code>liberation</code> ainsi :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1"></a><span class="dt">void</span> liberation<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>adresse<span class="op">)</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="op">{</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>    <span class="kw">struct</span> bloc <span class="op">*</span>premier_bloc <span class="op">=</span> blocs_libres<span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>    <span class="kw">struct</span> bloc <span class="op">*</span>bloc_courant <span class="op">=</span> premier_bloc<span class="op">;</span></span>
<span id="cb30-5"><a href="#cb30-5"></a></span>
<span id="cb30-6"><a href="#cb30-6"></a>    <span class="cf">while</span> <span class="op">(</span>bloc_courant<span class="op">-&gt;</span>adresse <span class="op">!=</span> adresse<span class="op">)</span></span>
<span id="cb30-7"><a href="#cb30-7"></a>    <span class="op">{</span></span>
<span id="cb30-8"><a href="#cb30-8"></a>        bloc_courant <span class="op">=</span> bloc_courant<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb30-9"><a href="#cb30-9"></a>        <span class="co">// adresse invalide</span></span>
<span id="cb30-10"><a href="#cb30-10"></a>        assert<span class="op">(</span>bloc_courant <span class="op">!=</span> premier_bloc<span class="op">);</span></span>
<span id="cb30-11"><a href="#cb30-11"></a>    <span class="op">}</span></span>
<span id="cb30-12"><a href="#cb30-12"></a></span>
<span id="cb30-13"><a href="#cb30-13"></a>    <span class="co">// pas de double libération</span></span>
<span id="cb30-14"><a href="#cb30-14"></a>    assert<span class="op">(!</span>bloc_courant<span class="op">-&gt;</span>libre<span class="op">);</span></span>
<span id="cb30-15"><a href="#cb30-15"></a></span>
<span id="cb30-16"><a href="#cb30-16"></a>    <span class="co">// on libère l&#39;adresse</span></span>
<span id="cb30-17"><a href="#cb30-17"></a>    bloc_courant<span class="op">-&gt;</span>libre <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb30-18"><a href="#cb30-18"></a></span>
<span id="cb30-19"><a href="#cb30-19"></a>    premier_bloc <span class="op">=</span> bloc_courant<span class="op">;</span></span>
<span id="cb30-20"><a href="#cb30-20"></a>    bloc_courant <span class="op">=</span> bloc_courant<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb30-21"><a href="#cb30-21"></a></span>
<span id="cb30-22"><a href="#cb30-22"></a>    <span class="cf">while</span> <span class="op">(</span>bloc_courant <span class="op">!=</span> premier_bloc <span class="op">&amp;&amp;</span> bloc_courant<span class="op">-&gt;</span>libre<span class="op">)</span></span>
<span id="cb30-23"><a href="#cb30-23"></a>    <span class="op">{</span></span>
<span id="cb30-24"><a href="#cb30-24"></a>        <span class="kw">struct</span> bloc<span class="op">*</span> actuel <span class="op">=</span> bloc_courant<span class="op">;</span></span>
<span id="cb30-25"><a href="#cb30-25"></a>        premier_bloc<span class="op">-&gt;</span>taille <span class="op">+=</span> bloc_courant<span class="op">-&gt;</span>taille<span class="op">;</span></span>
<span id="cb30-26"><a href="#cb30-26"></a>        bloc_courant <span class="op">=</span> bloc_courant<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb30-27"><a href="#cb30-27"></a>        free<span class="op">(</span>actuel<span class="op">);</span> <span class="co">// on libere le bloc inutile</span></span>
<span id="cb30-28"><a href="#cb30-28"></a>    <span class="op">}</span></span>
<span id="cb30-29"><a href="#cb30-29"></a></span>
<span id="cb30-30"><a href="#cb30-30"></a>    premier_bloc<span class="op">-&gt;</span>suivant <span class="op">=</span> bloc_courant<span class="op">;</span></span>
<span id="cb30-31"><a href="#cb30-31"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
