<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Algorithmique exacte</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        width: 100%;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Algorithmique exacte
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"><span>1</span> Recherche par force brute<div class="menu"><a class="item" href="#sec:principe"><div class="ui label">1.1</div> Principe</a><a class="item" href="#sec:raffinement-droite-de-balayage"><div class="ui label">1.2</div> Raffinement : droite de balayage</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:problème-test-dintersection-pour-un-ensemble-de-segments"><i class="circle icon"></i> Problème : test d’intersection pour un ensemble de segments</a></div><a class="item" href="#sec:recherche-par-retour-sur-trace-backtracking"><div class="ui label">1.3</div> Recherche par retour sur trace (<strong>backtracking</strong>)</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:problème-résolution-de-sudoku"><i class="circle icon"></i> Problème : résolution de Sudoku</a></div></div></div><div class="item header"><span>2</span> Algorithmes gloutons<div class="menu"><a class="item" href="#sec:principe-1"><div class="ui label">2.1</div> Principe</a><a class="item" href="#sec:huffman-arbre"><div class="ui label">2.2</div> Construction de l’arbre de Huffman</a><a class="item" href="#sec:preuve-doptimalité"><div class="ui label">2.3</div> Preuve d’optimalité</a><a class="item" href="#sec:sélection-dactivités"><div class="ui label">2.4</div> Sélection d’activités</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:description"><i class="circle icon"></i> Description</a><a style="font-size:0.6em" class="item" href="#sec:algorithme-glouton-et-implémentation"><i class="circle icon"></i> Algorithme glouton et implémentation</a><a style="font-size:0.6em" class="item" href="#sec:preuve-doptimalité-1"><i class="circle icon"></i> Preuve d’optimalité</a></div><a class="item" href="#sec:ordonnancement-de-tâches"><div class="ui label">2.5</div> Ordonnancement de tâches</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:description-1"><i class="circle icon"></i> Description</a><a style="font-size:0.6em" class="item" href="#sec:algorithme-glouton-et-implémentation-1"><i class="circle icon"></i> Algorithme glouton et implémentation</a><a style="font-size:0.6em" class="item" href="#sec:preuve-doptimalité-2"><i class="circle icon"></i> Preuve d’optimalité</a></div></div></div><div class="item header"><span>3</span> Diviser pour régner<div class="menu"><a class="item" href="#sec:principe-2"><div class="ui label">3.1</div> Principe</a><a class="item" href="#sec:tri-fusion"><div class="ui label">3.2</div> Tri fusion</a><a class="item" href="#sec:nombre-dinversions"><div class="ui label">3.3</div> Nombre d’inversions</a><a class="item" href="#sec:points-les-plus-proches"><div class="ui label">3.4</div> Points les plus proches</a><a class="item" href="#sec:sous-ensemble-de-somme-donnée"><div class="ui label">3.5</div> Sous-ensemble de somme donnée</a><a class="item" href="#sec:recherche-dichotomique"><div class="ui label">3.6</div> Recherche dichotomique</a><a class="item" href="#sec:couverture-par-des-segments-égaux"><div class="ui label">3.7</div> Couverture par des segments égaux</a></div></div><div class="item header"><span>4</span> Programmation dynamique<div class="menu"><a class="item" href="#sec:principe-3"><div class="ui label">4.1</div> Principe</a><a class="item" href="#sec:somme-de-sous-ensembles"><div class="ui label">4.2</div> Somme de sous-ensembles</a><a class="item" href="#sec:ordonnancement-de-tâches-1"><div class="ui label">4.3</div> Ordonnancement de tâches</a><a class="item" href="#sec:plus-longue-sous-suite-commune"><div class="ui label">4.4</div> Plus longue sous-suite commune</a><a class="item" href="#sec:distance-dédition"><div class="ui label">4.5</div> Distance d’édition</a></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Algorithmique exacte
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Algorithmique exacte     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_algo_exacte.png"> </div></p>
<p><em>Source image : https://www.flickr.com/photos/x6e38/3440634940/</em></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Dans ce chapitre, on étudie des problèmes pour lesquels on va exprimer des algorithmes permettant d’obtenir des solutions exactes. C’est à contraster avec le chapitre sur l’algorithmique approchée.</div></p>
<p>Une grande partie des stratégies de résolution est basée sur la résolution de sous-problèmes. On verra ainsi trois types de stratégies résumées dans le schéma suivant :</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/strategies_sousproblemes.png" /></div></center></p>
<p></div></center></p>
<h1 data-number="1" id="sec:recherche-par-force-brute"><span class="header-section-number">1</span> Recherche par force brute</h1>
<h2 data-number="1.1" id="sec:principe"><span class="header-section-number">1.1</span> Principe</h2>
<p>Considérons un problème du type trouver un <span class="math inline">\(x \in V\)</span> vérifiant une propriété <span class="math inline">\(P(x)\)</span>. Par exemple, <span class="math inline">\(V\)</span> est l’ensemble des chaînes de caractère et <span class="math inline">\(P\)</span> vérifie si une chaîne est un mot de passe qu’on cherche. Dans certains problèmes, un tel <span class="math inline">\(x\)</span> n’est pas unique et on cherche à tous les énumérer.</p>
<p>Une recherche par force brute, ou recherche exhaustive, consiste à parcourir l’ensemble <span class="math inline">\(V\)</span> jusqu’à obtenir une solution. Pour la recherche du mot de passe, on pourrait commencer par énumérer les chaînes de longueur 1, puis de longueur 2, et ainsi de suite.</p>
<p>Le plus souvent, l’ensemble <span class="math inline">\(V\)</span> est fini (pour les mots de passe, cela peut consister à limiter la longueur maximale du mot de passe). Ainsi, une recherche par force brute effectue <span class="math inline">\(O(|V|)\)</span> itérations.</p>
<p>Considérons le problème <em>PlusProchePaire</em> qui, étant donné un ensemble de <span class="math inline">\(n\)</span> points (<span class="math inline">\(n \ge 2\)</span>), détermine la paire constituée des deux points les plus proches.</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/plusprochepaire_a.png" /></div></center></p>
<p></div></center></p>
<p>Une implémentation naïve de la recherche par force brute consiste à énumérer les <span class="math inline">\(\frac{n(n-1)}{2}\)</span> paires et donc à effectuer <span class="math inline">\(O(n^2)\)</span> itérations.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus_proche_paire points =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length points <span class="kw">in</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> min_paire = <span class="dt">ref</span> (distance points.(<span class="dv">0</span>) points.(<span class="dv">1</span>), (<span class="dv">0</span>, <span class="dv">1</span>)) <span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> j = i+<span class="dv">1</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> d = distance points.(i) points.(j) <span class="kw">in</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> d &lt; <span class="dt">fst</span> !min_paire</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">then</span> min_paire := (d, (i, j))</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">done</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">snd</span> !min_paire</span></code></pre></div>
<p></div></p>
<h2 data-number="1.2" id="sec:raffinement-droite-de-balayage"><span class="header-section-number">1.2</span> Raffinement : droite de balayage</h2>
<p>Il est parfois possible d’accélérer la recherche par force brute en ordonnant le parcours des candidats pour pouvoir éviter de tester certains d’entres eux.</p>
<p>En géométrie algorithmique, une approche classique consiste à ordonner les objets selon leur abscisse et à parcourir les objets par abscisse croissante. On parle alors de <strong>droite de balayage</strong> (en anglais, <em>sweep line</em>) car cela revient à balayer le plan par une droite verticale en ne traitant que les objets avant cette ligne.</p>
<p>Reprenons le problème précédent, on considère que les points sont triés par abscisse croissante : <span class="math inline">\((x_0,y_0), \dots, (x_{n-1}, y_{n-1})\)</span>. On va parcourir les points dans cet ordre en maintenant un ensemble de points à gauche du point courant, appelés <em>points actifs</em>, et en ne calculant que les intersections avec les points actifs.</p>
<p>Si on a parcouru les <span class="math inline">\(N\)</span> premiers points et qu’on a obtenu que la plus petite distance était <span class="math inline">\(d\)</span>, lorsqu’on considère le point <span class="math inline">\((x_N,y_N)\)</span>, il est inutile de tester les points qui sont forcément à distance <span class="math inline">\(&gt; d\)</span> de celui-ci. C’est-à-dire qu’on peut éliminer les points qui ne sont pas dans le rectangle <span class="math inline">\([x_N-d,x_N]\times [y_N-d,y_N+d]\)</span> du test. Les points dont l’abscisse est <span class="math inline">\(&lt; x_N -d\)</span> peuvent être éliminés définitivement vu que l’on raisonne par abscisse croissante, par contre, les points d’ordonnées invalides doivent être conservés pour les points ultérieurs.</p>
<p>Ce rectangle est représenté sur le schéma suivant ainsi qu’une ligne imaginaire qui correspond à l’abscisse du point courant et qu’on peut imaginer parcourant le plan de gauche à droite pour traiter les points au fur et à mesure.</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/plusprochepaire_b.png" /></div></center></p>
<p></div></center></p>
<p>Afin de déterminer la complexité de cet algorithme, il est nécessaire de connaitre le nombre maximal de points dans le rectangle. Comme ces points ont été pris en compte précédemment, ils sont forcément à distance au moins <span class="math inline">\(d\)</span> les uns des autres. Il s’agit donc de déterminer le nombre maximum de points qu’on peut placer dans ce rectangle à distance au moins <span class="math inline">\(d\)</span>. On remarque tout d’abord qu’on peut placer six points ainsi :</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/plusprochepaire_activesize_a.png" /></div></center></p>
<p></div></center></p>
<p>Si jamais on avait au moins sept points, on peut voir qu’il y a forcément un des six sous-rectangles suivants qui contiendrait au moins deux points :</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/plusprochepaire_activesize_b.png" /></div></center></p>
<p></div></center></p>
<p>Or, ces sous-rectangles sont de longueur <span class="math inline">\(\frac{1}{2}d\)</span> et de hauteur <span class="math inline">\(\frac{2}{3}d\)</span>, donc la distance maximale entre deux de leurs points correspond à la longueur des diagonales : <span class="math inline">\(\sqrt{\frac{1}{4} + \frac{4}{9}}d = \frac{5}{6}d &lt; d\)</span>.</p>
<p>Comme un de ces six points est le point courant, il y a toujours au plus 5 points dans l’ensemble des points actifs.</p>
<p>Voici le principe de l’algorithme que l’on va implémenter :</p>
<ul>
<li><p>On trie le tableau <code>points</code> par ordre croissant. <strong>Complexité :</strong> <span class="math inline">\(O(n \log n)\)</span></p></li>
<li><p>On initialise la plus petite distance <code>d</code> courante à la distance entre les deux premiers points</p></li>
<li><p>On crée un ensemble <code>actifs</code>, ordonné par les ordonnées, de points contenant initialement les deux premiers points</p></li>
<li><p>Pour chaque point <span class="math inline">\((x,y)\)</span> en partant du deuxième :</p>
<ul>
<li>On supprime les points <span class="math inline">\((x&#39;,y&#39;)\)</span> tels que <span class="math inline">\(x&#39; &lt; x - d\)</span> de <code>actifs</code>. <strong>Complexité :</strong> sur l’ensemble des itérations on ne pourra jamais supprimer deux fois un point, donc on effectue au maximum <span class="math inline">\(n\)</span> suppressions chacune en <span class="math inline">\(O(\log n)\)</span> donc <span class="math inline">\(O(n \log n)\)</span>.</li>
<li>On parcourt les points de <code>actifs</code> dont les ordonnées sont comprises entre <span class="math inline">\(y-d\)</span> et <span class="math inline">\(y+d\)</span>. <strong>Complexité :</strong> pour récupérer le premier point de l’ensemble, il faut <span class="math inline">\(O(\log n)\)</span> en pire cas (tous les points actifs) et ensuite on effectue au plus 5 itérations comme on vient de le prouver.</li>
</ul></li>
</ul>
<p>L’animation suivante présente le déroulement de cet algorihtme. La bande active est indiquée en gris et le rectangle autour du point courant en gris foncé :</p>
<p><img class="ui image fluid" src="assets/pics/closest_pair.gif"/></p>
<p>On remarque ainsi que la complexité en temps et en pire cas de cet algorithme est de <span class="math inline">\(O(n \log n)\)</span>. Ici, le fait d’avoir la structure <code>actifs</code> ordonnée par les ordonnées est crucial pour garantir la complexité. Pour la réalisation d’une structure d’ensemble ordonnée ayant ces complexité, voir le chapitre FIXME.</p>
<p>Ici, on utilise le module <code>Set</code> d’OCaml pour réaliser la structure d’ensemble, pour cela on commence par créer le module <code>PointSet</code> pour les ensembles de points :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Point = <span class="kw">struct</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> t = <span class="dt">float</span> * <span class="dt">float</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="dt">compare</span> (x1,y1) (x2,y2) = Stdlib.<span class="dt">compare</span> y1 y2</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> PointSet = <span class="dt">Set</span>.Make(Point)</span></code></pre></div>
<p></div></p>
<p>Puis on définit une fonction permettant de parcourir les points entre deux ordonnées :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> set_iter_entre f set bas haut =</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> e = PointSet.find_first (<span class="kw">fun</span> p -&gt; <span class="dt">snd</span> p &gt;= bas) set <span class="kw">in</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> seq = PointSet.to_seq_from e set <span class="kw">in</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">rec</span> aux seq =</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">match</span> seq () <span class="kw">with</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            | Seq.Nil -&gt; ()</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            | Seq.Cons (p, seq_suite) -&gt; </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">if</span> <span class="dt">snd</span> p &lt;= haut</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                        f p;</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                        aux seq_suite</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">end</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> aux seq</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; ()</span></code></pre></div>
<p></div></p>
<p>On implémente alors assez directement l’algorithme décrit précédemment :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus_proche_paire_balayage points =</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="dt">compare</span> (x1,y1) (x2,y2) =</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> x1 = x2</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="kw">if</span> y1 &lt; y2 <span class="kw">then</span> <span class="dv">-1</span> <span class="kw">else</span> <span class="dv">1</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span> x1 &lt; x2 <span class="kw">then</span> <span class="dv">-1</span> <span class="kw">else</span> <span class="dv">1</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Array</span>.sort <span class="dt">compare</span> points;</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length points <span class="kw">in</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> d = <span class="dt">ref</span> (distance points.(<span class="dv">0</span>) points.(<span class="dv">1</span>)) <span class="kw">in</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> couple = <span class="dt">ref</span> (points.(<span class="dv">0</span>), points.(<span class="dv">1</span>)) <span class="kw">in</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> actifs = <span class="dt">ref</span> (PointSet.empty </span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            |&gt; PointSet.add points.(<span class="dv">0</span>) |&gt; PointSet.add points.(<span class="dv">1</span>)) <span class="kw">in</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> gauche = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> i = <span class="dv">2</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> xi, yi = points.(i) <span class="kw">in</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">while</span> <span class="dt">fst</span> points.(!gauche) &lt; xi -. !d <span class="kw">do</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>            actifs := PointSet.remove points.(!gauche) !actifs;</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>            <span class="dt">incr</span> gauche</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">done</span>;</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        set_iter_entre (<span class="kw">fun</span> pj -&gt; </span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> dip = distance points.(i) pj <span class="kw">in</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> dip &lt; !d</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>            <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>                couple := (points.(i), pj);</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>                d := dip</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>            <span class="kw">end</span>) !actifs (yi -. !d) (yi +. !d);</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        actifs := PointSet.add points.(i) !actifs</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    !d</span></code></pre></div>
<p></div></p>
<h3 data-number="1.2.1" id="sec:problème-test-dintersection-pour-un-ensemble-de-segments"><span class="header-section-number">1.2.1</span> Problème : test d’intersection pour un ensemble de segments</h3>
<p>Considérons le problème suivant <em>IntersectionEnsemble</em> : étant donné <span class="math inline">\(n\)</span> segments dans le plan, il s’agit de déterminer si au moins deux des segments s’intersectent.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>On peut considérer ici que l’on dispose d’une fonction</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>intersecte : (<span class="dt">float</span> * <span class="dt">float</span>) * (<span class="dt">float</span> * <span class="dt">float</span>) </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    -&gt; (<span class="dt">float</span> * <span class="dt">float</span>) * (<span class="dt">float</span> * <span class="dt">float</span>) -&gt; <span class="dt">bool</span> </span></code></pre></div>
<p></div></p>
<p>qui teste l’intersection entre deux segments.</p>
<p>Cependant, il est possible d’écrire une telle fonction avec un peu de géométrie élémentaire.</p>
<p>Si on considère que les deux segments sont <span class="math inline">\([A_1B_1]\)</span> et <span class="math inline">\([A_2B_2]\)</span>, avec <span class="math inline">\(A_1 \neq B_1\)</span> et <span class="math inline">\(A_2 \neq B_2\)</span>, alors chaque point du segment <span class="math inline">\([A_1B_1]\)</span> est de la forme <span class="math inline">\(A_1 + t \overrightarrow{A_1B_1}\)</span> où <span class="math inline">\(t \in [0,1]\)</span>. De même les points du segments <span class="math inline">\([A_2B_2]\)</span> sont de la forme <span class="math inline">\(A_2 + u \overrightarrow{A_2B_2}\)</span> où <span class="math inline">\(u \in [0,1]\)</span>.</p>
<p>S’il y a une intersection, c’est qu’il existe <span class="math inline">\((t,u) \in [0,1]^2\)</span> tel que</p>
<p><span class="math display">\[
A_1 + t \overrightarrow{A_1B_1} = A_2 + u \overrightarrow{A_2B_2}
\iff \overrightarrow{A_2 A_1} + t \overrightarrow{A_1B_1} = u
\overrightarrow{A_2 B_2}
\]</span></p>
<p>L’idée est alors d’utiliser une opération appelée <strong>produit vectoriel</strong> sur les vecteurs. Comme ici, tout est plan, le produit vectoriel est uniquement déterminé par sa troisième coordonnée, celle qui sort du plan, et on peut se contenter de calculer celle-ci. On note ainsi <span class="math inline">\((x,y) \times (x&#39;,y&#39;) = x y&#39; - y x&#39;\)</span> cette coordonnée. On a donc <span class="math inline">\(u \times u = 0\)</span>.</p>
<p>On peut alors composer l’égalité par <span class="math inline">\(\times \overrightarrow{A_2B_2}\)</span> :</p>
<p><span class="math display">\[
\overrightarrow{A_2 A_1} \times \overrightarrow{A_2 B_2} + t 
\left( \overrightarrow{A_1 B_1} \times \overrightarrow{A_2 B_2} \right) = 0
\]</span></p>
<p>Notons <span class="math inline">\(\Delta = \overrightarrow{A_1 B_1} \times \overrightarrow{A_2 B_2}\)</span>, si <span class="math inline">\(\Delta \neq 0\)</span>, alors</p>
<p><span class="math display">\[
t = - \frac{\overrightarrow{A_2 A_1} \times \overrightarrow{A_2 B_2}}{\Delta}
= \frac{\overrightarrow{A_1 A_2} \times \overrightarrow{A_2 B_2}}{\Delta}
\]</span></p>
<p>On procède de même avec <span class="math inline">\(\times \overrightarrow{A_1 B_1}\)</span> pour obtenir une expression de <span class="math inline">\(u\)</span> : <span class="math inline">\(\overrightarrow{A_2 A_1} \times \overrightarrow{A_1 B_1} = u \left ( \overrightarrow{A_2 B_2} \times \overrightarrow{A_1 B_1} \right) = - u \Delta\)</span> et donc</p>
<p><span class="math display">\[
u = - \frac{\overrightarrow{A_2 A_1} \times \overrightarrow{A_1 B_1}}{\Delta}
= \frac{\overrightarrow{A_1 A_2} \times \overrightarrow{A_1 B_1}}{\Delta}
\]</span></p>
<p>Si <span class="math inline">\(\Delta \neq 0\)</span>, on peut donc alors exprimer <span class="math inline">\(u\)</span> et <span class="math inline">\(t\)</span> et vérifier qu’ils sont dans <span class="math inline">\([0,1]\)</span>.</p>
<p>Si <span class="math inline">\(\Delta = 0\)</span> c’est que les deux segments sont de directions parallèles ou confondues.</p>
<ul>
<li>Si <span class="math inline">\(\overrightarrow{A_1 A_2} \times \overrightarrow{A_1 B_1} \neq 0\)</span> alors <span class="math inline">\(\overrightarrow{A_1 A_2}\)</span> et <span class="math inline">\(\overrightarrow{A_1 B_1}\)</span> sont non colinéaires donc les deux segments sont sur des droites parallèles distinctes et ne peuvent s’intersecter.</li>
<li>Sinon, les segments reposent sur une même droite et il s’agit de vérifier leurs positions sur la droite. Pour cela, on exprime <span class="math inline">\(A_2 = A_1 + t_A \overrightarrow{A_1B_1}\)</span> de même pour <span class="math inline">\(B_2 = A_1 + t_B \overrightarrow{A_1 B_1}\)</span>. Plus précisement, on calcule <span class="math inline">\(\overrightarrow{A_1 A_2} \cdot \overrightarrow{A_1 B_1} = t_A ||\overrightarrow{A_1 B_1}||^2\)</span> à l’aide du produit scalaire et on a <span class="math inline">\(t_A = \frac{\overrightarrow{A_1 A_2} \cdot \overrightarrow{A_1 B_1}}{||\overrightarrow{A_1 B_1}||^2}\)</span>. De même, <span class="math inline">\(t_B = \frac{\overrightarrow{A_1 B_2} \cdot \overrightarrow{A_1 B_1}}{||\overrightarrow{A_1 B_1}||^2}\)</span>. On doit alors vérifier si l’intervalle <span class="math inline">\([t_A,t_B]\)</span> (ou <span class="math inline">\([t_B,t_A]\)</span> selon leur position) intersecte <span class="math inline">\([0,1]\)</span>.</li>
</ul>
<p>Voici une fonction <em>OCaml</em> qui correspond à ce raisonnement <div class="ui segment code"></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> intersecte (a1,b1) (a2,b2) =</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> vec (x1,y1) (x2,y2) = (x2-.x1,y2-.y1) <span class="kw">in</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> cross (x1,y1) (x2,y2) = x1 *. y2 -. y1 *. x2 <span class="kw">in</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> dot (x1,y1) (x2,y2) = x1 *. x2 +. y1 *. y2 <span class="kw">in</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> proche0 x = <span class="kw">let</span> eps = <span class="fl">1e-20</span> <span class="kw">in</span> </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> x &lt; <span class="dv">0</span>. <span class="kw">then</span> -.x &lt; eps <span class="kw">else</span> x &lt; eps <span class="kw">in</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a1b1 = vec a1 b1 <span class="kw">in</span> <span class="kw">let</span> a2b2 = vec a2 b2 <span class="kw">in</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a1a2 = vec a1 a2 <span class="kw">in</span> <span class="kw">let</span> a1b2 = vec a1 b2 <span class="kw">in</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> delta = cross a1b1 a2b2 <span class="kw">in</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> proche0 delta</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>         <span class="kw">if</span> proche0 (cross a1a2 a1b1)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>         <span class="kw">then</span> <span class="kw">let</span> na1b1 = dot a1b1 a1b1 <span class="kw">in</span> <span class="co">(* colinéaires *)</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span> tA = (dot a1a2 a1b1) /. na1b1 <span class="kw">in</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span> tB = (dot a1b2 a1b1) /. na1b1 <span class="kw">in</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>              <span class="kw">if</span> tA &lt; tB</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>              <span class="kw">then</span> <span class="dt">not</span> (tB &lt; <span class="dv">0</span>. || tA &gt; <span class="dv">1</span>.)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>              <span class="kw">else</span> <span class="dt">not</span> (tA &lt; <span class="dv">0</span>. || tB &gt; <span class="dv">1</span>.)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>         <span class="kw">else</span> <span class="kw">false</span> <span class="co">(* parallèles *)</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">let</span> t = (cross a1a2 a2b2) /. delta <span class="kw">in</span> <span class="co">(* se croisent *)</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>         <span class="kw">let</span> u = (cross a1a2 a1b1) /. delta <span class="kw">in</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>         t &gt;= <span class="dv">0</span>. &amp;&amp; t &lt;= <span class="dv">1</span>. &amp;&amp; u &gt;= <span class="dv">0</span>. &amp;&amp; u &lt;= <span class="dv">1</span>.</span></code></pre></div>
<p></div></p>
<p></div></p>
<p><div class="ui message blue"><div class="header">Note</div>réécrire cela avec le déterminant de deux vecteurs du plan qui est au programme de mathématiques de seconde.</div></p>
<p>La recherche par force brute va alors énumérer l’ensemble des paires de segments distincts et tester deux à deux les intersections. On peut ainsi écrire le programme suivant qui est assez simple et effectuera effectivement <span class="math inline">\(O(|v|^2)\)</span> itérations dans le pire cas, i.e. lorsqu’il n’y a pas d’intersections.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> Trouve</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> intersection_ensemble (v: ((<span class="dt">float</span> * <span class="dt">float</span>) * (<span class="dt">float</span> * <span class="dt">float</span>)) <span class="dt">array</span>) : <span class="dt">bool</span> =</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length v <span class="kw">in</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">for</span> j = i+<span class="dv">1</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                <span class="kw">if</span> intersecte v.(i) v.(j)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> <span class="dt">raise</span> Trouve</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">done</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">done</span>;</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">false</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">with</span> Trouve -&gt; <span class="kw">true</span></span></code></pre></div>
<p></div></p>
<p>TODO approche par droite de balayage : algorithme de Shamos et Hoey (1976)</p>
<h2 data-number="1.3" id="sec:recherche-par-retour-sur-trace-backtracking"><span class="header-section-number">1.3</span> Recherche par retour sur trace (<strong>backtracking</strong>)</h2>
<p>Dans des problèmes admettant des solutions partielles, on peut construire une solution par essai de toutes les possibilités en complétant tant qu’on a bien une solution partielle. La recherche par retour sur trace repose sur ce constat pour énumérer l’ensemble des solutions en utilisant la récursivité (d’où la notion de <em>retour sur trace</em>) pour les essais.</p>
<p>L’exemble classique de ce problème est celui des huit reines : étant donné un échiquier, peut-on placer huit reines de sorte qu’aucune reine ne puisse prendre une autre reine ? Plus précisément : sur un plateau de 8x8 cases, peut-on placer huit pions tels que deux pions quelconques ne soient jamais sur la même ligne ou la même diagonale ?</p>
<p>Exemple de solution :</p>
<p><center><div class="ui image center"><img src="assets/pics/huit_reines_ex.png" /></div></center></p>
<p>Ce problème admet effectivement des solutions partielles en ne considérant que <span class="math inline">\(k\)</span> reines à placer. Pour énumérer les solutions, on peut même se contenter de solutions partielles où les <span class="math inline">\(k\)</span> reines sont placées sur les <span class="math inline">\(k\)</span> premières rangées.</p>
<p>Voici ainsi un algorithme pour énumérer les solutions :</p>
<ul>
<li><p>Supposons que <span class="math inline">\(k\)</span> reines aient été placées et qu’on dispose d’une solution partielle.</p>
<ul>
<li>Si <span class="math inline">\(k = 8\)</span> alors toutes les reines sont placées et la solution est complète, on la comptabilise</li>
<li>Sinon, on continue la recherche pour chaque position de la <span class="math inline">\(k+1\)</span> reine sur la <span class="math inline">\(k+1\)</span> rangée qui préserve le fait d’être une solution partielle.</li>
</ul></li>
</ul>
<p>Ici, quand on dit qu’on continue la recherche, ce qu’on signifie c’est qu’on effectue un appel récursif.</p>
<p>Pour programmer cette méthode, on va définir une fonction récursive de signature :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> resout_reines : (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span> -&gt; (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span> <span class="dt">list</span></span></code></pre></div>
<p></div></p>
<p>Un appel à <code>resout_reines part</code> va ainsi renvoyer la liste des solutions complètes construites à partir de la solution partielle <code>part</code>. Les solutions sont représentées par des listes de couples de coordonnées sur l’échiquier, donc dans <span class="math inline">\([|0;7|]^2\)</span></p>
<p>Voici une implémentation où on explore les solutions à l’aide d’une boucle impérative dans l’appel récursif. La fonction <code>valide</code> permet de tester si le placement d’une reine est possible avant d’effectuer un appel.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> valide (x1,y1) l =</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; <span class="kw">true</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    | (x2,y2)::q -&gt;</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        x1 &lt;&gt; x2 &amp;&amp; <span class="dt">abs</span> (x2-x1) &lt;&gt; <span class="dt">abs</span>(y2-y1) &amp;&amp; valide (x1,y1) q</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> resout_reines part =</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> k = <span class="dt">List</span>.length part <span class="kw">in</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> k = <span class="dv">8</span> </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> [ part ]</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">begin</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> resultats = <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> x = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">7</span> <span class="kw">do</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> essai = (x,k) :: part <span class="kw">in</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> valide (x,k) part</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>                resultats := (resout_reines essai) @ !resultats;</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">end</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">done</span>;</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        !resultats</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span></code></pre></div>
<p></div></p>
<p>et, ici, une autre implémentation purement récursive à l’aide d’une fonction récursive.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> resout_reines part =</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> k = <span class="dt">List</span>.length part <span class="kw">in</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> k = <span class="dv">8</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> [ part ]</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">rec</span> aux x acc =</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> x &lt; <span class="dv">0</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">then</span> acc</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">else</span> <span class="kw">let</span> essai = (x,k) :: part <span class="kw">in</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">let</span> nacc = <span class="kw">if</span> valide (x,k) part</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>                           <span class="kw">then</span> (resout_reines essai) @ acc</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>                           <span class="kw">else</span> acc <span class="kw">in</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>                    aux (x<span class="dv">-1</span>) nacc</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        aux <span class="dv">7</span> [] </span></code></pre></div>
<p></div></p>
<p>Une partie de l’arbre de recherche est présenté sur l’image suivante :</p>
<figure>
<img src="../assets/pics/reines_arbre.png" width="1000" alt="Arbre de recherche pour les huit reines" /><figcaption aria-hidden="true">Arbre de recherche pour les huit reines</figcaption>
</figure>
<p>L’arbre complet comporte 2057 noeuds dont 92 feuilles correspondant aux solutions du problème. A titre de comparaison, l’arbre exhaustif correspondant à faire tous les choix de placement à raison d’une reine par ligne compterait <span class="math inline">\(8^8 = 16777216\)</span> noeuds. On voit bien que le backtracking est plus économe en exploration.</p>
<h3 data-number="1.3.1" id="sec:problème-résolution-de-sudoku"><span class="header-section-number">1.3.1</span> Problème : résolution de Sudoku</h3>
<p>La recherche par retour sur trace se prête très bien à la résolution de problèmes comme le Sudoku. On va ici tout simplement tenter de remplir chaque case du haut vers le bas tant qu’on satisfait les contraintes du Sudoku. Le programme sera ainsi très proche de la résolution des huit reines.</p>
<p>Commençons par rappeler le principe du Sudoku :</p>
<ul>
<li><p>On part d’une grille de 81 cases réparties en une grille de 3x3 sous-grilles de 3x3 cases et comportant des chiffres de 1 à 9 dans certaines cases. <center><div class="ui image center"><img src="assets/pics/sudoku_exemple.png" /></div></center></p></li>
<li><p>L’objectif est de remplir chaque case avec un chiffre de 1 à 9 de sorte que chaque ligne, chaque colonne et chaque sous-grille 3x3 comporte une et une seule fois chaque chiffre.</p></li>
<li><p>Un sudoku admet une unique solution.</p></li>
</ul>
<p>Pour représenter une grille de Sudoku en <code>OCaml</code> on utilise un <code>(int option) array array</code>, la valeur <code>None</code> signifiant que la case est vide et la valeur <code>Some x</code> qu’elle est remplie avec la valeur <span class="math inline">\(x\)</span>.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> grille = (<span class="dt">int</span> <span class="dt">option</span>) <span class="dt">array</span> <span class="dt">array</span></span></code></pre></div>
<p></div></p>
<p>On fait le choix de représenté la grille par un tableau de lignes, ce qui signiie que pour accèder à la case de coordonnée <span class="math inline">\((x,y)\)</span> dans <code>g</code> il faut écrire <code>g.(y).(x)</code>.</p>
<p>Le problème donnée précédemment est alors représenté par la valeur suivante : <div class="ui segment code"></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> probleme = [|</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    [| <span class="dt">Some</span> <span class="dv">1</span>; <span class="dt">None</span>; <span class="dt">None</span>;    <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span>;   <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">6</span> |];</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    [| <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">6</span>;    <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">2</span>; <span class="dt">None</span>;   <span class="dt">Some</span> <span class="dv">7</span>; <span class="dt">None</span>; <span class="dt">None</span> |];</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    [| <span class="dt">Some</span> <span class="dv">7</span>; <span class="dt">Some</span> <span class="dv">8</span>; <span class="dt">Some</span> <span class="dv">9</span>;    <span class="dt">Some</span> <span class="dv">4</span>; <span class="dt">Some</span> <span class="dv">5</span>; <span class="dt">None</span>;   <span class="dt">Some</span> <span class="dv">1</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">3</span> |];</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    [| <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span>;    <span class="dt">Some</span> <span class="dv">8</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">7</span>;   <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">4</span> |];</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    [| <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span>;    <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">3</span>; <span class="dt">None</span>;   <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span> |];</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    [| <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">9</span>; <span class="dt">None</span>;    <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">4</span>;   <span class="dt">Some</span> <span class="dv">2</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">1</span> |];</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    [| <span class="dt">Some</span> <span class="dv">3</span>; <span class="dt">Some</span> <span class="dv">1</span>; <span class="dt">Some</span> <span class="dv">2</span>;    <span class="dt">Some</span> <span class="dv">9</span>; <span class="dt">Some</span> <span class="dv">7</span>; <span class="dt">None</span>;   <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">4</span>; <span class="dt">None</span> |];</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    [| <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">4</span>; <span class="dt">None</span>;    <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">1</span>; <span class="dt">Some</span> <span class="dv">2</span>;   <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">7</span>; <span class="dt">Some</span> <span class="dv">8</span> |];</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    [| <span class="dt">Some</span> <span class="dv">9</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">8</span>;    <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span>;   <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span> |];</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    |]</span></code></pre></div>
<p></div></p>
<p>Afin de définir la fonction de résolution, on définit une première fonction <code>suivant</code> de signature :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> suivant : grille -&gt; (<span class="dt">int</span> * <span class="dt">int</span>) -&gt; (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">option</span></span></code></pre></div>
<p></div></p>
<p>telle que l’appel à <code>suivant g (x,y)</code> renvoie <code>Some (xi,yi)</code> quand <span class="math inline">\((x_i,y_i)\)</span> sont les coordonnées de la prochaine case libre, dans l’ordre gauche à droite puis haut vers bas, après <span class="math inline">\((x,y)\)</span> ou <code>None</code> quand il n’existe pas de telle case libre. Cela signifie alors que la grille est entièrement remplie.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> suivant g (x,y) =</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> y &gt; <span class="dv">8</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="dt">None</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">if</span> g.(y).(x) = <span class="dt">None</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="dt">Some</span> (x,y)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">if</span> x &lt; <span class="dv">8</span> <span class="kw">then</span> suivant g (x+<span class="dv">1</span>, y)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> suivant g (<span class="dv">0</span>, y+<span class="dv">1</span>)</span></code></pre></div>
<p></div></p>
<p>On définit également une fonction <code>valide</code> de signature</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> valide : grille -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">bool</span></span></code></pre></div>
<p></div></p>
<p>telle que l’appel à <code>valide g x y</code> renvoie <code>true</code> si et seulement si la valeur placée en coordonnée <span class="math inline">\((x,y)\)</span> n’invalide pas la grille. Ne pas prendre cette valeur en paramètre permettant d’écrire un peu plus simplement cette fonction. La fonction est assez directe, étant donné <span class="math inline">\((x,y)\)</span> on va parcourir sa ligne, sa colonne et sa sous-grille pour vérifier qu’un nombre n’a pas été placé deux fois à l’aide d’un tableau de drapeaux :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> valide g x y =</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> v = <span class="dt">ref</span> <span class="kw">true</span> <span class="kw">in</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> vus_colonne = <span class="dt">Array</span>.make <span class="dv">9</span> <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> y0 = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">8</span> <span class="kw">do</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">match</span> g.(y0).(x) <span class="kw">with</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        | <span class="dt">None</span> -&gt; ()</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        | <span class="dt">Some</span> k -&gt; </span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>                <span class="kw">if</span> vus_colonne.(k<span class="dv">-1</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> v := <span class="kw">false</span>;</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>                vus_colonne.(k<span class="dv">-1</span>) &lt;- <span class="kw">true</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> vus_ligne = <span class="dt">Array</span>.make <span class="dv">9</span> <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> x0 = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">8</span> <span class="kw">do</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">match</span> g.(y).(x0) <span class="kw">with</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>        | <span class="dt">None</span> -&gt; ()</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>        | <span class="dt">Some</span> k -&gt; </span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>                <span class="kw">if</span> vus_ligne.(k<span class="dv">-1</span>)</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> v := <span class="kw">false</span>;</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>                vus_ligne.(k<span class="dv">-1</span>) &lt;- <span class="kw">true</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> vus_grille = <span class="dt">Array</span>.make <span class="dv">9</span> <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> xb = (x / <span class="dv">3</span>) * <span class="dv">3</span> <span class="kw">in</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> yb = (y / <span class="dv">3</span>) * <span class="dv">3</span> <span class="kw">in</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> xd = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">2</span> <span class="kw">do</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> yd = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">2</span> <span class="kw">do</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">match</span> g.(yb+yd).(xb+xd) <span class="kw">with</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>            | <span class="dt">None</span> -&gt; ()</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>            | <span class="dt">Some</span> k -&gt; </span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">if</span> vus_grille.(k<span class="dv">-1</span>)</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">then</span> v := <span class="kw">false</span>;</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>                    vus_grille.(k<span class="dv">-1</span>) &lt;- <span class="kw">true</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">done</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>    !v</span></code></pre></div>
<p></div></p>
<p>On peut alors définir la fonction <code>resout</code> qui va résoudre le Sudoku en effectuant tous les remplissages tant qu’on a une grille valide. Dès qu’une solution est trouvé, on s’arrête. Pour cela, on utilise le mécanisme des exceptions pour permettre une sortie prématurée. On a fait le choix de travailler en place dans la grille, ainsi à la fin de l’exécution de la fonction, la grille correspond à la solution.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> Solution</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> resout g =</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux xi yi = <span class="kw">match</span> suivant g (xi, yi) <span class="kw">with</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        | <span class="dt">None</span> -&gt; <span class="dt">raise</span> Solution</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        | <span class="dt">Some</span> (x,y) -&gt;</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">for</span> i = <span class="dv">1</span> <span class="kw">to</span> <span class="dv">9</span> <span class="kw">do</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>                g.(y).(x) &lt;- <span class="dt">Some</span> i;</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>                <span class="kw">if</span> valide g x y</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>                    aux x y</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>                <span class="kw">end</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">done</span>;</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>            g.(y).(x) &lt;- <span class="dt">None</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> </span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> </span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>        aux <span class="dv">0</span> <span class="dv">0</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">with</span> Solution -&gt; ()</span></code></pre></div>
<p></div></p>
<p>La résolution du Sudoku donnée précédemment par ce programme est présenté dans la vidéo suivante :</p>
<p><center><video width="400" height="380" controls="controls"><source src="assets/pics/sudoku.mp4" type="video/mp4" /></video></center></p>
<h1 data-number="2" id="sec:algorithmes-gloutons"><span class="header-section-number">2</span> Algorithmes gloutons</h1>
<h2 data-number="2.1" id="sec:principe-1"><span class="header-section-number">2.1</span> Principe</h2>
<p>On considère ici un problème d’énumération comme dans la section précédente muni d’une fonction d’objectifs qui attribue une valeur numérique aux solutions et aux solutions partielles.</p>
<p>Soit <span class="math inline">\(f : P \rightarrow \R\)</span> une telle fonction, où <span class="math inline">\(S \cup P\)</span> est l’ensemble des solutions du problème d’énumération et <span class="math inline">\(P\)</span> l’ensemble des solutions partielles, on se pose maintenant le problème de l’optimalité vis-à-vis de <span class="math inline">\(f\)</span> : déterminer <span class="math inline">\(x \in S\)</span> tel que <span class="math inline">\(f(x) = \max_{y \in S} f(y)\)</span> on note souvent <span class="math inline">\(x = \text{argmax}_{y\in S} f(y)\)</span>. On parle alors de problème d’optimisation combinatoire.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<ul>
<li>En considérant <span class="math inline">\(g : y \mapsto -f(y)\)</span>, on transforme un problème de maximisation en un problème de minimisation.</li>
<li>Il y a une ambiguïté sur <span class="math inline">\(\text{argmax}_{y \in S} f(y)\)</span> quand plusieurs éléments de <span class="math inline">\(S\)</span> réalisent ce maximum. Dans la plupart des algorithmes gloutons qu’on va considérer, on commence par donner un ordre sur <span class="math inline">\(S\)</span> et on considère le plus petit <span class="math inline">\(y\)</span> pour cet ordre réalisant le maximum. L’ordre choisi est alors crucial dans la preuve de correction. C’est aussi une des raisons pour lesquelles les algorithmes gloutons sont souvent de complexité temporelle <span class="math inline">\(O(n \log_2 n)\)</span>. </div></li>
</ul>
<p>Une première stratégie très élémentaire consiste alors à énumérer <span class="math inline">\(S\)</span>, de manière exhaustive ou avec une stratégie plus fine comme le retour sur trace, puis à déterminer un élément maximal de manière directe.</p>
<p>Cela revient donc à déterminer l’arbre des solutions puis à trouver une feuille maximisant l’objectif :</p>
<p><center><div class="ui image center"><img src="assets/pics/glouton_exhaustif.png" /></div></center></p>
<p>Un algorithme glouton va suivre une approche beaucoup plus efficace : à chaque étape de construction de la solution, on choisit la branche qui maximise la fonction d’objectif. C’est-à-dire que si en partant d’une solution partielle <span class="math inline">\(x \in P\)</span> il est possible de l’étendre en d’autres solutions partielles <span class="math inline">\(p_x = \{ y_1, ..., y_n \}\)</span>, on va choisir <span class="math inline">\(y = \text{argmax}_{t \in p_x} f(t)\)</span> la solution qui maximise localement <span class="math inline">\(f\)</span>.</p>
<p>Sur l’arbre précédent, cela reviendrait à n’emprunter qu’une seule branche :</p>
<p><center><div class="ui image center"><img src="assets/pics/glouton_glouton1.png" /></div></center></p>
<p>Cela a l’air très efficace mais il y a un problème majeur : il n’y a aucune garantie qu’on aboutisse ainsi à une solution, encore moins à une solution optimale. En effet, on aurait très bien pu faire les choix suivants :</p>
<p><center><div class="ui image center"><img src="assets/pics/glouton_glouton2.png" /></div></center></p>
<p>et ne pas aboutir à une solution.</p>
<p>Considérons par exemple le problème du <strong>rendu de monnaie</strong> : étant donné, une liste de valeurs faciales de pièces <span class="math inline">\(P = (v_1,\dots,v_p) \in (\N^*)^p\)</span> avec <span class="math inline">\(1 = v_1 &lt; \dots &lt; v_p\)</span> et une somme <span class="math inline">\(n \in \N^*\)</span>, on cherche la manière d’exprimer cette somme avec le plus petit nombre de pièces possible.</p>
<p>Plus précisément, l’ensemble des solutions <span class="math inline">\(S = \{ (k_1,\dots,k_p) \in N^p ~|~ k_1 v_1 + \dots + k_p v_p = n \}\)</span> et la fonction d’objectif est <span class="math inline">\(f : (k_1,\dots,k_p) \mapsto k_1 + \dots + k_p\)</span>. Les solutions partielles ici sont les réalisations de valeur <span class="math inline">\(&lt; n\)</span>. On cherche alors <span class="math inline">\(x = argmin_{y \in S} f(y)\)</span>.</p>
<p>Comme <span class="math inline">\(1 = v_1\)</span>, <span class="math inline">\(S \neq \emptyset\)</span> car <span class="math inline">\((n,0,\dots,0) \in S\)</span> et ainsi <span class="math inline">\(f(x) \le n\)</span>.</p>
<p>L’algorithme glouton va utiliser la plus grande pièce possible à chaque étape puis on applique l’algorithme glouton sur la somme restante sauf si elle est nulle, ce qui constitue la condition d’arrêt.</p>
<p><strong>Exemple 1</strong></p>
<ul>
<li><span class="math inline">\(P = (1, 2, 5, 10)\)</span></li>
<li><span class="math inline">\(n = 14\)</span></li>
<li>On utilise la plus grande pièce possible <span class="math inline">\(10 \le 14\)</span> puis on exprime <span class="math inline">\(4 = 14 - 10\)</span></li>
<li>Ici, la plus grande pièce est <span class="math inline">\(2\)</span> et on continue avec <span class="math inline">\(2 = 4 - 2\)</span></li>
<li>La plus grande pièce est encore <span class="math inline">\(2\)</span> et on s’arrête car <span class="math inline">\(0 = 2 - 2\)</span>.</li>
<li>En conclusion, on a obtenu <span class="math inline">\(x = (0,2,0,1)\)</span>.</li>
<li>Une exploration exhuastive permet de s’assurer qu’on a effectivement obtenu une décomposition minimale. En effet, ici l’ensemble des décompositions est : { (14,0,0,0), (12,1,0,0), (8,3,0,0), (6,4,0,0), (4,5,0,0), (2,6,0,0), (0,7,0,0), (9,0,1,0), (7,1,1,0), (5,2,1,0), (3,3,1,0), (1,4,1,0), (4,0,2,0), (2,1,2,0), (0,2,2,0), (4,0,0,1), (2,1,0,1), (0,2,0,1) }.</li>
</ul>
<p><strong>Exemple 2</strong></p>
<ul>
<li><span class="math inline">\(P = (1, 2, 7, 10)\)</span></li>
<li><span class="math inline">\(n = 14\)</span></li>
<li>L’algorithme glouton va ici procéder comme dans l’exemple 1 et on va obtenir <span class="math inline">\(x = (0,2,0,1)\)</span>.</li>
<li>Mais on remarque que ce n’est pas un minimum car <span class="math inline">\(x&#39; = (0,0,2,0)\)</span> convient avec <span class="math inline">\(f(x&#39;) = 2 &lt; 3 = f(x)\)</span>.</li>
</ul>
<p><em>Conclusion</em> l’algorithme glouton n’a effectivement pas de raisons d’être optimal.</p>
<p>On peut se poser la question des algorithmes pour lesquels l’algorithme glouton aboutit nécessairement à une solution optimale.</p>
<p><div class="ui message blue"><div class="header">Note</div>TODO - Ajouter un paragraphe simple sur les matroïdes qui puisse se décliner sous la forme d’un problème.</div></p>
<h2 data-number="2.2" id="sec:huffman-arbre"><span class="header-section-number">2.2</span> Construction de l’arbre de Huffman</h2>
<p><div class="ui message orange"><div class="header">Remarque</div>Ce paragraphe décrit l’étape cruciale du principe de compression de Huffman. Celui-ci sera présenté complétement dans le chapitre <a href="chap_algorithmique_du_texte.html#sec:huffman">Algorithmique des textes</a>.</div></p>
<p>On va étudier ici un principe de compression parfaite (sans perte d’information à la décompression) de données appelé l’algorithme de Huffman et qui repose sur ce principe simple : coder sur moins de bits les caractères les plus fréquents.</p>
<p>Par exemple si on considère le mot <code>abaabc</code>, en le codant avec un nombre de bits fixes, par exemple 2 avec le code <code>a=00,b=01,c=10</code>, on aurait besoin de 12 bits pour représenter le mot. Mais si on choisit le code suivant : <code>a=0,b=10,c=11</code>, il suffit de 9 bits. On a donc gagné 3 bits soit un facteur de compression de 75%.</p>
<p>On remarque que pour pouvoir décompreser, il n’aurait pas été possible de faire commencer le code de <code>b</code> ou <code>c</code> par un <code>0</code>, sinon on aurait eu une ambiguité avec la lecture d’un <code>a</code>. On parle alors de code préfixe :</p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(X \subset \{0,1\}^*\)</span>, on dit que <span class="math inline">\(X\)</span> est un code préfixe lorsque pour tous <span class="math inline">\(x, y \in X\)</span>, <span class="math inline">\(x\)</span> n’est pas un préfixe de <span class="math inline">\(y\)</span> et <span class="math inline">\(y\)</span> n’est pas un préfixe de <span class="math inline">\(x\)</span>. </div></p>
<p>On se pose alors la question du code préfixe optimal pour un texte donné.</p>
<p>Plus précisément, étant donné un alphabet fini <span class="math inline">\(\Sigma\)</span> et une application <span class="math inline">\(f : \Sigma \rightarrow [0,1]\)</span> associant à chaque lettre son nombre d’occurences dans le texte considéré. Ainsi <span class="math inline">\(\sum_{x \in \Sigma} f(x)\)</span> est la longueur du texte. On cherche un code préfixe <span class="math inline">\(X\)</span> et une application <span class="math inline">\(c : \Sigma \rightarrow X\)</span> telle que <span class="math inline">\(\sum_{x \in \Sigma} f(x) |c(x)|\)</span> soit minimale car cela correspond au nombre de bits après codage.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>On utilise aussi la notion de fréquence du lettre qui est son nombre d’occurence rapporté à la longueur du texte. Un des avantages de la notion de fréquence est qu’il est possible de considèrer une table de fréquence déjà construite comme celle de la langue française.</div></p>
<p>L’application de codage <span class="math inline">\(c\)</span> peut être représenté par un arbre binaire où les arêtes gauches correspondent à 0, les arêtes droites à 1 et les feuilles aux éléments de <span class="math inline">\(\Sigma\)</span> dont les étiquettes des chemins y menant depuis la racine de l’arbre correspondent à leur image par <span class="math inline">\(c\)</span>.</p>
<p>Par exemple, pour le code <span class="math inline">\(a=0,b=10,c=11\)</span> on aurait l’arbre :</p>
<p><center><div class="ui image center"><img src="assets/pics/arbre_huffman_ex1.png" /></div></center></p>
<p>Avec un tel arbre, il est très simple de décoder le texte codé car il suffit de suivre un chemin dans l’arbre jusqu’à tomber sur une feuille, produire la lettre correspondante, puis repartir de la racine de l’arbre. La longueur du code associé à une lettre est alors égale à la profondeur de la feuille correspondante. L’optimalité du codage préfixe est ainsi équivalente à la minimalité de l’arbre vis-à-vis de la fonction d’objectif <span class="math inline">\(\varphi(t) = \sum_{x \in \Sigma} f(x) p(t,x)\)</span> où <span class="math inline">\(p(t,x)\)</span> est la profondeur de la feuille d’étiquette <span class="math inline">\(x\)</span> dans l’arbre <span class="math inline">\(t\)</span> ou <span class="math inline">\(0\)</span> si <span class="math inline">\(x\)</span> n’est pas une des étiquettes, cet extension permettant d’étendre la fonction d’objectif aux solutions partielles.</p>
<p>L’algorithme d’Huffman va construire un arbre correspondant à un codage optimal à l’aide d’une file de priorité d’arbres. On étend pour cela l’application <span class="math inline">\(f\)</span> à de tels arbres en définissant que si <span class="math inline">\(t\)</span> est un arbre de feuilles <span class="math inline">\(x_1,\dots,x_n\)</span> alors <span class="math inline">\(f(t) = f(x_1) + \dots + f(x_n)\)</span>.</p>
<ul>
<li><p>Au départ, on place dans la file des arbres réduits à une feuille pour chaque élément <span class="math inline">\(x \in \Sigma\)</span> et dont la priorité est <span class="math inline">\(f(x)\)</span>.</p></li>
<li><p>Tant que la file contient au moins deux éléments</p>
<ul>
<li>on retire les deux plus petits éléments <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> de la file de priorité <span class="math inline">\(f(x)\)</span> et <span class="math inline">\(f(y)\)</span></li>
<li>on ajoute un arbre <span class="math inline">\(z = Noeud(x,y)\)</span> de priorité <span class="math inline">\(f(z) = f(x) + f(y)\)</span>.</li>
</ul></li>
<li><p>On renvoie l’unique élément restant dans la file.</p></li>
</ul>
<p>L’implémentation de cet algorithme est alors assez directe avec une file de priorité. On réutilise ici la structure de tas implementée en FIXME. Comme il s’agit d’un tas max, on insère avec <span class="math inline">\(-f(x)\)</span> comme valeur.</p>
<p><div>   <div class="ui top attached tabular menu code">   <a class="active item" data-tab="ocaml-107">ocaml</a>   <a class="item" data-tab="c-107">c</a>   <a class="item" data-tab="python-107">python</a> </div> <div class="ui bottom attached active tab segment code" data-tab="ocaml-107"></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> construit_arbre occ =</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> arbres = Tas.cree <span class="dv">2000</span> (<span class="dv">0</span>, Feuille <span class="dv">0</span>) <span class="kw">in</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">255</span> <span class="kw">do</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> f = occ.(i) <span class="kw">in</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> f &gt; <span class="dv">0</span> <span class="co">(* on ignore les occurrences nulles *)</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> Tas.insere (-f, Feuille i) arbres</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> Tas.taille arbres &gt; <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> fx, x = Tas.supprime_racine arbres <span class="kw">in</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> fy, y = Tas.supprime_racine arbres <span class="kw">in</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        Tas.insere (fx+fy, Noeud(x,y)) arbres</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">snd</span> (Tas.supprime_racine arbres)</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="c-107"></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>ERROR<span class="op">:</span> src<span class="op">/</span>algorithmique<span class="op">/../../</span>snippets<span class="op">/</span>algorithmique<span class="op">/</span>huffman<span class="op">.</span>c does not exist</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="python-107"></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>ERROR: src<span class="op">/</span>algorithmique<span class="op">/</span>..<span class="op">/</span>..<span class="op">/</span>snippets<span class="op">/</span>algorithmique<span class="op">/</span>huffman.py does <span class="kw">not</span> exist</span></code></pre></div>
<p></div> </div></p>
<p>L’algorithme de Huffman est un algorithme glouton car si on considère pour solution partielle la fôret présente dans la file et pour objectif la fonction <span class="math inline">\(\varphi\)</span> étendue aux fôrets en sommant la valeur de <span class="math inline">\(\varphi\)</span> sur chaque arbre, alors fusionner dans la fôret <span class="math inline">\(F\)</span> deux arbres <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> en la transformant en une fôret <span class="math inline">\(F&#39;\)</span> va avoir l’impact suivant sur la fonction d’objectif :</p>
<p><span class="math display">\[
\varphi(F&#39;) = \varphi(F) + f(x) + f(y)
\]</span></p>
<p>car, en effet, on va rajouter 1 à la profondeur de chaque feuille et donc on passe pour la contribution de <span class="math inline">\(x\)</span> de <span class="math inline">\(\varphi(x) = \sum_{c \in \Sigma} f(c) p(x,c)\)</span> à <span class="math inline">\(\sum_{c \in \Sigma} f(c) (p(x,c)+1) = \varphi(x) + \sum_{c \in \Sigma} f(c) = \varphi(x) + f(x)\)</span>.</p>
<p>On remarque ainsi que la fusion qui minimise localement <span class="math inline">\(\varphi\)</span> est celle qui fusionne les deux arbres de plus petite valeur pour <span class="math inline">\(f\)</span>.</p>
<p>Pour montrer que l’algorithme glouton produit ici un codage minimal, on va utiliser une technique classique qui consiste à montrer qu’étant donné une solution optimale, on peut toujours la transformer sans augmenter sa valeur pour obtenir, de proche en proche, la solution renvoyée par le glouton.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Supposons que les lettres les moins fréquentes soient <span class="math inline">\(a\)</span> et <span class="math inline">\(b\)</span>, il existe un arbre optimal dont les deux feuilles étiquettées par <span class="math inline">\(a\)</span> et <span class="math inline">\(b\)</span> descendent du même noeud et sont de profondeur maximale.</p>
</div>
<div class="ui message">
<div class="header">
Preuve
</div>
<p>Considérons un arbre optimal <span class="math inline">\(t\)</span> et soient <span class="math inline">\(c\)</span> l’étiquette d’une feuille de profondeur maximale. On remarque qu’elle a forcément une feuille sœur car sinon, on pourrait omettre le noeud et l’arbre obtenu serait de plus petite valeur par <span class="math inline">\(\varphi\)</span>.</p>
<p>FIXME: dessin</p>
<p>Soit <span class="math inline">\(d\)</span> l’étiquette de cette feuille sœur. Sans perte de généralités, on suppose que <span class="math inline">\(f(c) \le f(d)\)</span> et <span class="math inline">\(f(a) \le f(b)\)</span>. Comme <span class="math inline">\(a\)</span> a le plus petit nombre d’occurences, a <span class="math inline">\(f(a) \le f(c)\)</span> et comme <span class="math inline">\(b\)</span> est la deuxième, on a <span class="math inline">\(f(b) \le f(d)\)</span>. De plus, <span class="math inline">\(p(t,a) \ge p(t,c)\)</span> et <span class="math inline">\(p(t,b) \ge p(t,d)\)</span>.</p>
<p>Si on échange les étiquettes <span class="math inline">\(a\)</span> et <span class="math inline">\(c\)</span>, seule les termes associées à ces lettres changent dans l’évaluation de <span class="math inline">\(\varphi\)</span>. Si on note <span class="math inline">\(t&#39;\)</span> le nouvel arbre obtenu après cet échange, on a <span class="math display">\[
\varphi(t&#39;) = \varphi(t) - f(a) p(t,a) - f(c) p(t,c) + f(a) p(t,c) + f(c)
p(t,a)
\]</span> Or, <span class="math inline">\(f(c) \ge f(a)\)</span> et <span class="math inline">\(p(t,a) \ge p(t,c)\)</span> donc <span class="math display">\[\varphi(t&#39;) = \varphi(t) + (f(c) - f(a))(p(t,a)-p(t,c))
\le \varphi(t)\]</span> L’échange préserve le caractère optimal. En fait, ici, on a nécessairement une égalité pour ne pas aboutir à une contradiction, donc soit les feuilles étaient à même profondeur, soit les lettres avaient le même nombre d’occurrences.</p>
<p>Comme on a les mêmes relations entre <span class="math inline">\(b\)</span> et <span class="math inline">\(d\)</span>, on peut effectuer le même argument et échanger les étiquettes en préservant le caractère optimal.</p>
</div>
<p>Le théorème suivant permet de raisonner par récurrence en diminuant le nombre de lettres.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(t\)</span> un arbre ayant <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> comme feuilles soeurs et <span class="math inline">\(t&#39;\)</span> l’arbre obtenu en remplaçant le noeud liant <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> par une feuille étiquettée par <span class="math inline">\(z\)</span> où <span class="math inline">\(z\)</span> est une nouvelle lettre telle que <span class="math inline">\(f(z) = f(x) + f(y)\)</span>.</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/huffman_fusion.png" /></div></center></p>
<p></div></center></p>
<p>On a alors <span class="math inline">\(\varphi(t) = \varphi(t&#39;) + f(z)\)</span>.</p>
</div>
<div class="ui message">
<div class="header">
Preuve
</div>
<p>Seule les termes portant sur <span class="math inline">\(x, y\)</span> et <span class="math inline">\(z\)</span> sont influencés par le changement et on a : <span class="math display">\[
\begin{array}{rl}
\varphi(t) &amp; = \varphi(t&#39;) + f(x) p(t,x) + f(y) p(t,y) - f(z) p(t&#39;,z) \\
&amp; = \varphi(t&#39;) + f(z) (p(t&#39;,z) + 1) - f(z) p(t&#39;,z) \\
&amp; = \varphi(t&#39;) + f(z)
\end{array}
\]</span></p>
</div>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>L’algorithme de Huffman renvoie un arbre optimal.</p>
</div>
<div class="ui message">
<div class="header">
Preuve
</div>
<p>Par récurrence sur <span class="math inline">\(|\Sigma|\)</span>.</p>
<p><em>Initialisation</em> : si <span class="math inline">\(\Sigma\)</span> ne contient qu’une lettre, il n’y a qu’un arbre qui est nécessairement optimal.</p>
<p><em>Hérédité</em> : si la propriété est vraie pour un alphabet de <span class="math inline">\(n-1 \ge 1\)</span> lettres, alors soit <span class="math inline">\(\Sigma\)</span> contenant <span class="math inline">\(n\)</span> lettres et <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> les deux lettres les moins fréquentes.</p>
<p>On pose <span class="math inline">\(\Sigma&#39;\)</span> obtenue en remplaçant <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> par une nouvelle lettre <span class="math inline">\(z\)</span> et on suppose que <span class="math inline">\(f(z) = f(x) + f(y)\)</span>. L’hypothèse de récurrence assure qu’on obtient un arbre optimal <span class="math inline">\(t&#39;\)</span> en appliquant l’algorithme d’Huffman sur <span class="math inline">\(\Sigma&#39;\)</span>. Comme la première étape d’Huffman va fusionner les feuilles <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span>, on sait que l’arbre <span class="math inline">\(t\)</span> obtenu en partant de <span class="math inline">\(\Sigma\)</span> se déduit de <span class="math inline">\(t&#39;\)</span> en remplaçant <span class="math inline">\(z\)</span> par <span class="math inline">\(Noeud(x,y)\)</span>. Le théorème précédent assure alors que <span class="math inline">\(\varphi(t) = \varphi(t&#39;) + f(z)\)</span>.</p>
<p>Soit <span class="math inline">\(t_o\)</span> un arbre optimal pour <span class="math inline">\(\Sigma\)</span> dans lequel <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> sont soeurs, possible en vertu du premier théorème, et soit <span class="math inline">\(t_o&#39;\)</span> l’arbre obtenue en remplaçant dans <span class="math inline">\(t_o\)</span> le noeud liant <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> par une feuille étiquettée par <span class="math inline">\(z\)</span>. On a ici encore <span class="math inline">\(\varphi(t_o) = \varphi(t_o&#39;) + f(z) \ge \varphi(t&#39;) + f(z) \ge \varphi(t)\)</span> car <span class="math inline">\(t&#39;\)</span> est optimal.</p>
<p>Ainsi, on a bien l’égalité <span class="math inline">\(\varphi(t_o) = \varphi(t)\)</span> et <span class="math inline">\(t\)</span> est optimal.</p>
</div>
<h2 data-number="2.3" id="sec:preuve-doptimalité"><span class="header-section-number">2.3</span> Preuve d’optimalité</h2>
<p>Dans le paragraphe précédent, on retrouve un schéma de preuve classique pour les preuves d’optimalité des algorithmes gloutons :</p>
<ul>
<li>Montrer qu’à partir d’une solution optimale, il est possible de déterminer une solution optimale ayant fait le même choix que l’algorithme glouton. Pour Huffman c’était le fait d’avoir un arbre optimal ayant les deux lettres les moins fréquentes comme sœurs à profondeur maximale.</li>
<li>Montrer qu’une solution optimale se comportant comme le résultat de l’algorithme glouton à une étape ne peut être meilleure que le résultat de l’algorithme glouton.</li>
</ul>
<h2 data-number="2.4" id="sec:sélection-dactivités"><span class="header-section-number">2.4</span> Sélection d’activités</h2>
<h3 data-number="2.4.1" id="sec:description"><span class="header-section-number">2.4.1</span> Description</h3>
<p>Étant donné un ensemble d’activités données par leur temps de début et leur temps de fin (on considère les temps comme des entiers pour simplifier), on se pose la question du nombre maximal d’activité que l’on puisse sélectionner sans que deux activités soient en conflits. Cela correspond par exemple à l’organisation du planning d’un employé.</p>
<p>On dit que deux activités <span class="math inline">\((d_1,f_1)\)</span> et <span class="math inline">\((d_2,f_2)\)</span> sont en conflits quand <span class="math inline">\([d_1,f_1[ \cap [d_2,f_2[ \neq \emptyset\)</span>.</p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p><center><div class="ui image center"><img src="assets/pics/activites_conflits.png" /></div></center></p>
<p></div><div class="eight wide column"></p>
<p>Ici, <span class="math inline">\(t_1\)</span> et <span class="math inline">\(t_2\)</span> sont en conflits avec <span class="math inline">\(t_3\)</span>. Mais <span class="math inline">\(t_1\)</span> et <span class="math inline">\(t_2\)</span> ne sont pas en conflit. On considère que deux activités peuvent se succéder directement : <span class="math inline">\(f_1 = d_2\)</span>.</p>
<p></div></div></div></p>
<p>On considère donc en entrée de ce problème une suite finie <span class="math inline">\(( (d_1,f_1), \dots, (d_n,f_n) )\)</span> et on cherche un sous-ensemble <span class="math inline">\(I \subset \range{1}{n}\)</span> de plus grand cardinal tel que pour tous <span class="math inline">\(i, j \in I\)</span>, si <span class="math inline">\(i \neq j\)</span> alors <span class="math inline">\((d_i,f_i)\)</span> et <span class="math inline">\((d_j,f_j)\)</span> ne sont pas en conflits. On dit que <span class="math inline">\(I\)</span> est un <strong>ensemble indépendant</strong>.</p>
<h3 data-number="2.4.2" id="sec:algorithme-glouton-et-implémentation"><span class="header-section-number">2.4.2</span> Algorithme glouton et implémentation</h3>
<p>Pour résoudre ce problème, on considère l’algorithme glouton associé à la fonction d’objectif cardinal et <strong>en triant les activités</strong> ordre croissant de temps de fin.</p>
<p>Cet algorithme est implémenté dans le programme suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> id<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> debut<span class="op">;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> fin<span class="op">;</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> selectionnee<span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> activite<span class="op">;</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> compare_activites<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>t1<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>t2<span class="op">)</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">((</span>activite <span class="op">*)</span>t1<span class="op">)-&gt;</span>fin <span class="op">-</span> <span class="op">((</span>activite <span class="op">*)</span>t2<span class="op">)-&gt;</span>fin<span class="op">;</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> selectionne<span class="op">(</span>activite <span class="op">*</span>activites<span class="op">,</span> <span class="dt">size_t</span> nb_activites<span class="op">)</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> derniere_activite <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* on commmence par trier en O(n log2 n) les activites</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="co">     * selon le temps de fin */</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    qsort<span class="op">(</span>activites<span class="op">,</span> nb_activites<span class="op">,</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">sizeof</span><span class="op">(</span>activite<span class="op">),</span> compare_activites<span class="op">);</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    activites<span class="op">[</span><span class="dv">0</span><span class="op">].</span>selectionnee <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nb_activites<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>activites<span class="op">[</span>i<span class="op">].</span>debut <span class="op">&gt;=</span> activites<span class="op">[</span>derniere_activite<span class="op">].</span>fin<span class="op">)</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>            activites<span class="op">[</span>i<span class="op">].</span>selectionnee <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>            derniere_activite <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>    activite activites<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">0</span> <span class="op">},</span> <span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">0</span> <span class="op">},</span> <span class="op">{</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">0</span> <span class="op">},</span></span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">0</span> <span class="op">},</span> <span class="op">{</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">0</span> <span class="op">},</span> <span class="op">{</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">0</span> <span class="op">},</span></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">0</span> <span class="op">}</span></span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> nb_activites <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>activites<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>activite<span class="op">);</span></span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>    selectionne<span class="op">(</span>activites<span class="op">,</span> nb_activites<span class="op">);</span></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nb_activites<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Activité %d (%d,%d) : %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a>                activites<span class="op">[</span>i<span class="op">].</span>id<span class="op">,</span> activites<span class="op">[</span>i<span class="op">].</span>debut<span class="op">,</span></span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>                activites<span class="op">[</span>i<span class="op">].</span>fin<span class="op">,</span> activites<span class="op">[</span>i<span class="op">].</span>selectionnee<span class="op">);</span></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Ce programme produit alors la sortie :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>Activité <span class="dv">0</span> <span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">)</span> <span class="op">:</span> <span class="dv">1</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>Activité <span class="dv">1</span> <span class="op">(</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">)</span> <span class="op">:</span> <span class="dv">1</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>Activité <span class="dv">2</span> <span class="op">(</span><span class="dv">2</span><span class="op">,</span><span class="dv">5</span><span class="op">)</span> <span class="op">:</span> <span class="dv">0</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>Activité <span class="dv">6</span> <span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">7</span><span class="op">)</span> <span class="op">:</span> <span class="dv">0</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>Activité <span class="dv">3</span> <span class="op">(</span><span class="dv">5</span><span class="op">,</span><span class="dv">9</span><span class="op">)</span> <span class="op">:</span> <span class="dv">1</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>Activité <span class="dv">5</span> <span class="op">(</span><span class="dv">8</span><span class="op">,</span><span class="dv">10</span><span class="op">)</span> <span class="op">:</span> <span class="dv">0</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>Activité <span class="dv">4</span> <span class="op">(</span><span class="dv">11</span><span class="op">,</span><span class="dv">12</span><span class="op">)</span> <span class="op">:</span> <span class="dv">1</span></span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Comme l’algorithme commence par effectuer un tri, on a rajouté dans la structure <code>activite</code> un champ permettant d’identifier une activité autrement que par son indice.</div></p>
<h3 data-number="2.4.3" id="sec:preuve-doptimalité-1"><span class="header-section-number">2.4.3</span> Preuve d’optimalité</h3>
<p>On va prouver que l’algorithme glouton renvoie un ensemble indépendant optimal. Le fait que l’ensemble soit indépendant étant direct, on se concentre sur la preuve d’optimalité en présentant un schéma de preuve qui correspond à celui identifié dans le paragraphe précédent.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Si <span class="math inline">\(a_1,\dots,a_n\)</span> sont des activités énumérées dans l’ordre croissant de leur temps de fin, alors il existe un ensemble indépendant optimal contenant <span class="math inline">\(a_1\)</span>.</p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div>Cela signifie qu’il fait le même choix que l’algorithme glouton à la première étape.</div></p>
<div class="ui message">
<div class="header">
Preuve
</div>
<p>Soit <span class="math inline">\(I\)</span> un ensemble indépendant optimal ne contenant pas <span class="math inline">\(a_1 = (d_1,f_1)\)</span> (sinon c’est direct). Si <span class="math inline">\(a_k = (d_k,f_k)\)</span> est l’activité de plus petit indice dans <span class="math inline">\(I\)</span>, alors <span class="math inline">\(f_k \ge f_1\)</span> donc pour tout <span class="math inline">\(a_i = (d_i,f_i)\)</span> dans <span class="math inline">\(I&#39; = I \backslash \{ a_k \}\)</span> on a <span class="math inline">\(d_i \ge f_k \ge f_1\)</span> et ainsi <span class="math inline">\(a_1\)</span> et <span class="math inline">\(a_i\)</span> ne sont pas en conflit. Ainsi <span class="math inline">\(I&#39; \cup \{ a_1\}\)</span> est un ensemble indépendant contenant <span class="math inline">\(a_1\)</span> de même cardinal que <span class="math inline">\(I\)</span> donc optimal.</p>
</div>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(A = \{ a_1,\dots,a_n \}\)</span> des activités ordonnées par ordre croissant de temps de fin et <span class="math inline">\(I\)</span> un ensemble indépendant optimal contenant <span class="math inline">\(a_1 = (d_1,f_1)\)</span> (ce qui est possible selon le théorème précédent).</p>
<p><span class="math inline">\(I&#39; = I \backslash \{a_1\}\)</span> est optimal pour <span class="math inline">\(A&#39; = \enscomp{ (d,f) \in A}{d \ge f_1}\)</span>.</p>
</div>
<div class="ui message">
<div class="header">
Preuve
</div>
<p>Si, par l’absurde, <span class="math inline">\(I&#39;\)</span> est pas optimal pour <span class="math inline">\(A&#39;\)</span> alors <span class="math inline">\(J \subset A&#39;\)</span> est un ensemble indépendant de cardinal strictement plus grand que celui de <span class="math inline">\(I&#39;\)</span>. Or, <span class="math inline">\(A&#39; \cup \{ a_1 \}\)</span> est indépendant pour l’ensemble des activités et est de cardinal strictement plus grand que <span class="math inline">\(I\)</span>. Contradiction.</p>
</div>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>L’algorithme glouton renvoie un ensemble indépendant optimal.</p>
</div>
<div class="ui message">
<div class="header">
Preuve
</div>
<p>Par récurrence forte sur le nombre d’activités.</p>
<ul>
<li><p>Initialisation : Pour une activité <span class="math inline">\(a_1\)</span>, le glouton renvoie <span class="math inline">\(\{ a_1 \}\)</span> qui est directement optimal.</p></li>
<li><p>Hérédité : Si la propriété est vérifiée pour <span class="math inline">\(k \le n\)</span> activités, soit <span class="math inline">\(A = \{ a_1, \dots, a_{n}\}\)</span> des activités ordonnées par temps de fin. Soit <span class="math inline">\(I\)</span> un ensemble indépendant optimal contenant <span class="math inline">\(a_1\)</span> et <span class="math inline">\(I&#39; = I \cap \{ a_1 \}\)</span>. Le théorème précédent assure que <span class="math inline">\(I&#39;\)</span> est optimal sur <span class="math inline">\(A&#39; = \enscomp{ (d,f) \in }{d \ge f_1}\)</span>.</p>
<p>Par hypothèse de récurrence, l’algorithme glouton sur <span class="math inline">\(A&#39;\)</span> produit un ensemble indépendant optimal <span class="math inline">\(G&#39;\)</span>, donc tel que <span class="math inline">\(|G&#39;| = |I&#39;|\)</span>. Par construction l’algorithme glouton sur <span class="math inline">\(A\)</span> renvoie <span class="math inline">\(G = G&#39; \cup \{ a_1\}\)</span> de même cardinal que <span class="math inline">\(I\)</span>, donc optimal.</p></li>
</ul>
</div>
<h2 data-number="2.5" id="sec:ordonnancement-de-tâches"><span class="header-section-number">2.5</span> Ordonnancement de tâches</h2>
<h3 data-number="2.5.1" id="sec:description-1"><span class="header-section-number">2.5.1</span> Description</h3>
<p>On considère ici un problème voisin du problème précédent. On considère <span class="math inline">\(n\)</span> tâches <span class="math inline">\(T = \{ t_1, \dots, t_n \}\)</span> prenant une unité de temps pour être traitées sur une unité de calcul.</p>
<p>Chaque tâche <span class="math inline">\(t\)</span> dispose d’une date limite <span class="math inline">\(f(t) \in \range{1}{n}\)</span> (<strong>deadline</strong>) à laquelle elle doit être traitée sans quoi on écope d’une pénalité <span class="math inline">\(p(t) \in \N\)</span>.</p>
<p>On appelle stratégie d’ordonnancement une application <span class="math inline">\(d : T \rightarrow \range{0}{n-1}\)</span> qui associe à chaque tache un unique temps de début <span class="math inline">\(d(t)\)</span>. Selon cette stratégie, on déduit une séparation de <span class="math inline">\(T\)</span> en deux ensembles disjoints :</p>
<ul>
<li><span class="math inline">\(T^+(d)\)</span> l’ensemble des tâches traitées dans les délais : <span class="math inline">\(t \in T^+(d) \iff d(t) &lt; f(t)\)</span>.</li>
<li><span class="math inline">\(T^-(d)\)</span> l’ensemble des tâches traitées en retard : <span class="math inline">\(t \in T^-(d) \iff d(t) \ge f(t)\)</span>.</li>
</ul>
<p>On note alors <span class="math inline">\(P(d) = \sum_{t \in T^-(d)} p(t)\)</span> la somme des pénalités des tâches en retard.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On considère l’ensemble de tâches :</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(t_i\)</span></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(f(t_i)\)</span></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>6</td>
</tr>
<tr class="even">
<td><span class="math inline">\(p(t_i)\)</span></td>
<td>3</td>
<td>6</td>
<td>4</td>
<td>2</td>
<td>5</td>
<td>7</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Une stratégie d’ordonnancement (les tâches en retard sont en gras) est donnée dans le tableau suivant :</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(t_i\)</span></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(d(t_i)\)</span></td>
<td><strong>6</strong></td>
<td>0</td>
<td>1</td>
<td><strong>4</strong></td>
<td>3</td>
<td>2</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>On a alors <span class="math inline">\(P(d) = 5\)</span>.</p>
</div>
<p>On cherche à obtenir une stratégie d’ordonnancement de valeur <span class="math inline">\(P(d)\)</span> minimale.</p>
<p>On remarque que l’ordonnancement des tâches en retard n’a aucune importance, et on peut donc se contenter de déterminer une stratégie d’ordonnancement pour les tâches traitées dans les délais et la compléter par n’importe quel ordonnancement des autres tâches. On peut ainsi reformuler le problème : déterminer un sous-ensemble <span class="math inline">\(T^+ \subset T\)</span> de tâches <strong>pouvant</strong> être traitées dans les délais tel que <span class="math inline">\(\sum_{t \in T^+} p(t)\)</span> soit <strong>maximale</strong>.</p>
<h3 data-number="2.5.2" id="sec:algorithme-glouton-et-implémentation-1"><span class="header-section-number">2.5.2</span> Algorithme glouton et implémentation</h3>
<p>On résout maintenant ce problème de maximisation des pénalités <span class="math inline">\(T^+\)</span> par un algorithme glouton :</p>
<ul>
<li>On commence avec <span class="math inline">\(T^+ = \emptyset\)</span> et tous les temps de <span class="math inline">\(\range{0}{n-1}\)</span> sont marqués comme étant disponibles.</li>
<li>On parcourt les tâches dans l’ordre décroissant des pénalités.
<ul>
<li>Quand on considère la tâche <span class="math inline">\(t\)</span> s’il existe un temps <span class="math inline">\(i\)</span> disponible tel que <span class="math inline">\(i &lt; d(t)\)</span> alors on marque comme indisponible le temps <span class="math inline">\(i_0 = \max \enscomp{i \in \range{0}{n-1}}{i &lt; d(t) \text{ et } i \text { disponible} }\)</span> et on rajoute alors <span class="math inline">\(t\)</span> à <span class="math inline">\(T^+\)</span> en commençant <span class="math inline">\(t\)</span> au temps <span class="math inline">\(i_0\)</span>.</li>
</ul></li>
<li>On place les tâches restantes aux temps disponibles.</li>
</ul>
<p>Pour les structures de données, on utilise une représentation en tableaux de booléens (des <code>unsigned char</code> à <code>0</code> ou <code>1</code> en C) pour la disponibilités des temps. L’ensemble <span class="math inline">\(T^+\)</span> est alors implicite car il correspond aux tâches ordonnancé dans la première étape. Utiliser un tableau implique qu’une recherche linéaire soit faite pour chercher un plus grand temps disponible, et donc, la complexité temporelle globale sera en <span class="math inline">\(O(n^2)\)</span>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Il est possible d’améliorer cela pour passer en <span class="math inline">\(O(n \log_2 n)\)</span> (<em>exercice</em>).</div></p>
<p>Le programme C suivant implémente cet algorithme.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> id<span class="op">;</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> date_limite<span class="op">;</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> penalite<span class="op">;</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> debut<span class="op">;</span> <span class="co">/* -1 tant que la tâche n&#39;est pas ordonnancée */</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> tache<span class="op">;</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> compare_taches<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>t1<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>t2<span class="op">)</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">((</span>tache <span class="op">*)</span>t2<span class="op">)-&gt;</span>penalite <span class="op">-</span> <span class="op">((</span>tache <span class="op">*)</span>t1<span class="op">)-&gt;</span>penalite<span class="op">;</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>ordonnancement<span class="op">(</span>tache <span class="op">*</span>taches<span class="op">,</span> <span class="dt">size_t</span> nb_taches<span class="op">)</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>temps_occupe <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">)</span> <span class="op">*</span> nb_taches<span class="op">);</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>temps_occupe<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> nb_taches<span class="op">);</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* tri des activités par ordre décroissant des pénalités */</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    qsort<span class="op">(</span>taches<span class="op">,</span> nb_taches<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>tache<span class="op">),</span> compare_taches<span class="op">);</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* T+ par algorithme glouton */</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> nb_taches<span class="op">;</span> k<span class="op">++)</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i0 <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nb_taches<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>temps_occupe<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> i <span class="op">&lt;</span> taches<span class="op">[</span>k<span class="op">].</span>date_limite<span class="op">)</span></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>                i0 <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i0 <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>            taches<span class="op">[</span>k<span class="op">].</span>debut <span class="op">=</span> i0<span class="op">;</span></span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>            temps_occupe<span class="op">[</span>i0<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Complétion par les tâches en retard */</span></span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// indice du dernier temps disponible utilisé</span></span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> nb_taches<span class="op">;</span> k<span class="op">++)</span></span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>taches<span class="op">[</span>k<span class="op">].</span>debut <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span><span class="op">(</span>temps_occupe<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a>                i<span class="op">++;</span></span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a>            taches<span class="op">[</span>k<span class="op">].</span>debut <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a>            temps_occupe<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb23-53"><a href="#cb23-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb23-54"><a href="#cb23-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-55"><a href="#cb23-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-56"><a href="#cb23-56" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>temps_occupe<span class="op">);</span></span>
<span id="cb23-57"><a href="#cb23-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb23-58"><a href="#cb23-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-59"><a href="#cb23-59" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb23-60"><a href="#cb23-60" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb23-61"><a href="#cb23-61" aria-hidden="true" tabindex="-1"></a>    tache taches<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb23-62"><a href="#cb23-62" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span> <span class="op">},</span> <span class="op">{</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span> <span class="op">},</span> <span class="op">{</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span> <span class="op">},</span></span>
<span id="cb23-63"><a href="#cb23-63" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span> <span class="op">},</span> <span class="op">{</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span> <span class="op">},</span> <span class="op">{</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span> <span class="op">},</span></span>
<span id="cb23-64"><a href="#cb23-64" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span> <span class="op">}</span></span>
<span id="cb23-65"><a href="#cb23-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb23-66"><a href="#cb23-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-67"><a href="#cb23-67" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> nb_taches <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>taches<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>tache<span class="op">);</span></span>
<span id="cb23-68"><a href="#cb23-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-69"><a href="#cb23-69" aria-hidden="true" tabindex="-1"></a>    ordonnancement<span class="op">(</span>taches<span class="op">,</span> nb_taches<span class="op">);</span></span>
<span id="cb23-70"><a href="#cb23-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-71"><a href="#cb23-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nb_taches<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb23-72"><a href="#cb23-72" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb23-73"><a href="#cb23-73" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;T%d (f:%d,p:%d) @ %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> taches<span class="op">[</span>i<span class="op">].</span>id<span class="op">,</span> taches<span class="op">[</span>i<span class="op">].</span>date_limite<span class="op">,</span></span>
<span id="cb23-74"><a href="#cb23-74" aria-hidden="true" tabindex="-1"></a>                taches<span class="op">[</span>i<span class="op">].</span>penalite<span class="op">,</span> taches<span class="op">[</span>i<span class="op">].</span>debut<span class="op">);</span></span>
<span id="cb23-75"><a href="#cb23-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-76"><a href="#cb23-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-77"><a href="#cb23-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb23-78"><a href="#cb23-78" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Il produit la sortie : <div class="ui segment code"></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>T6 <span class="op">(</span>f<span class="op">:</span><span class="dv">4</span><span class="op">,</span>p<span class="op">:</span><span class="dv">7</span><span class="op">)</span> @ <span class="dv">3</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>T2 <span class="op">(</span>f<span class="op">:</span><span class="dv">2</span><span class="op">,</span>p<span class="op">:</span><span class="dv">6</span><span class="op">)</span> @ <span class="dv">1</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>T5 <span class="op">(</span>f<span class="op">:</span><span class="dv">4</span><span class="op">,</span>p<span class="op">:</span><span class="dv">5</span><span class="op">)</span> @ <span class="dv">2</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>T3 <span class="op">(</span>f<span class="op">:</span><span class="dv">3</span><span class="op">,</span>p<span class="op">:</span><span class="dv">4</span><span class="op">)</span> @ <span class="dv">0</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>T1 <span class="op">(</span>f<span class="op">:</span><span class="dv">1</span><span class="op">,</span>p<span class="op">:</span><span class="dv">3</span><span class="op">)</span> @ <span class="dv">4</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>T4 <span class="op">(</span>f<span class="op">:</span><span class="dv">4</span><span class="op">,</span>p<span class="op">:</span><span class="dv">2</span><span class="op">)</span> @ <span class="dv">6</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>T7 <span class="op">(</span>f<span class="op">:</span><span class="dv">6</span><span class="op">,</span>p<span class="op">:</span><span class="dv">1</span><span class="op">)</span> @ <span class="dv">5</span></span></code></pre></div>
<p></div></p>
<p>Ce qui correspond à l’ordonnancement <span class="math inline">\(t_3, t_2, t_5, t_6, t_1, t_7, t_4\)</span>. Les tâches <span class="math inline">\(t_1\)</span> et <span class="math inline">\(t_4\)</span> sont en retard, donc la pénalité totale est de 5.</p>
<h3 data-number="2.5.3" id="sec:preuve-doptimalité-2"><span class="header-section-number">2.5.3</span> Preuve d’optimalité</h3>
<p>On va montrer que cet algorithme glouton renvoie un ensemble <span class="math inline">\(T^+\)</span> optimal. Pour cela, on procède comme précédemment. Tout d’abord, on montre qu’il existe une solution optimale qui effectue le premier choix de l’algorithme glouton.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(T\)</span> un ensemble de tâches et <span class="math inline">\(t \in T\)</span> une tâche de pénalité maximale. Il existe un ensemble <span class="math inline">\(T^+\)</span> de tâches pouvant être traitées dans les délais, maximal pour les pénalités et tel que <span class="math inline">\(t \in T^+\)</span>.</p>
</div>
<div class="ui message">
<div class="header">
Preuve
</div>
<p>Soit <span class="math inline">\(T^+ \subset T\)</span> un ensemble maximal. S’il contient <span class="math inline">\(t\)</span>, il convient directement. Sinon, il existe une tâche <span class="math inline">\(t&#39;\)</span> de <span class="math inline">\(T^+\)</span> qui est traitée à un moment où on pourrait traiter <span class="math inline">\(t\)</span> à temps (sinon <span class="math inline">\(T^+ \cup \{t\}\)</span> conviendrait et <span class="math inline">\(T^+\)</span> ne pourrait être maximal). On a <span class="math inline">\(p(t&#39;) \le p(t)\)</span> par maximalité de <span class="math inline">\(t\)</span>. L’ensemble <span class="math inline">\(T&#39;\)</span> déduit de <span class="math inline">\(T^+\)</span> en remplaçant <span class="math inline">\(t&#39;\)</span> par <span class="math inline">\(t\)</span> convient car on a forcément <span class="math inline">\(P(T&#39;) = P(T^+)\)</span> (en fait <span class="math inline">\(\ge\)</span> mais <span class="math inline">\(=\)</span> par optimalité de <span class="math inline">\(T^+\)</span>) et par construction toutes ses tâches peuvent être traitées à temps.</p>
</div>
<p>On montre maintenant qu’en enlevant le choix glouton, on obtient une solution optimale du sous-problème.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(T^+ \subset T\)</span> ensemble de tâches pouvant être traitées, maximal pour les pénalités et contenant une tâche <span class="math inline">\(t\)</span> de plus grande pénalité. Soit <span class="math inline">\(i\)</span> l’instant auquel la tâche <span class="math inline">\(t\)</span> commence dans un ordonnancement de <span class="math inline">\(T^+\)</span>.</p>
<p>On pose <span class="math inline">\(T&#39; = T \backslash \{ t \}\)</span> avec des dates limites modifiées : <span class="math display">\[\forall t&#39; \in T&#39;, d_{T&#39;}(t&#39;) = 
\begin{cases}
d_T(t&#39;) &amp; \text{si } d_T(t&#39;) \le i \\
d_T(t&#39;)-1 &amp; \text{sinon} 
\end{cases}\]</span></p>
<p><span class="math inline">\(T^+ \backslash \{t\}\)</span> est alors maximal pour <span class="math inline">\(T&#39;\)</span>.</p>
</div>
<div class="ui message">
<div class="header">
Preuve
</div>
<p>Dans <span class="math inline">\(T&#39;\)</span>, on a à la fois enlevé <span class="math inline">\(t\)</span> et supprimé l’instant <span class="math inline">\(i\)</span>. Tout ordonnancement de <span class="math inline">\(T&#39;\)</span> peut alors être <em>relevé</em> en un ordonnancement de <span class="math inline">\(T\)</span> en décalant d’un instant les tâches commençant à partir de l’instant <span class="math inline">\(i\)</span> et en ordonnançant là la tâche <span class="math inline">\(t\)</span>. Réciproquement d’un ordonnancement dans <span class="math inline">\(T\)</span>, on déduit directement un ordonnancement de <span class="math inline">\(T&#39;\)</span></p>
<p>Ainsi, s’il existait <span class="math inline">\(T&#39;^+\)</span> maximal pour <span class="math inline">\(T&#39;\)</span> tel que <span class="math inline">\(P(T&#39;^+) &gt; P(T^+ \backslash \{ t\}) = P(T^+) - p(t)\)</span> alors <span class="math inline">\(T&#39;^+ \cup \{ t \}\)</span> serait de somme de pénalités strictement plus grande que celle de <span class="math inline">\(T^+\)</span> supposé maximal.</p>
<p>Donc, <span class="math inline">\(T^+ \backslash \{ t\}\)</span> est maximal.</p>
</div>
<p>On conclut alors directement par récurrence sur le nombre de tâches comme on l’a fait précédemment pour la sélection d’activités :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>L’algorithme glouton renvoie un ordonnancement optimal.</p>
</div>
<h1 data-number="3" id="sec:diviser-pour-régner"><span class="header-section-number">3</span> Diviser pour régner</h1>
<h2 data-number="3.1" id="sec:principe-2"><span class="header-section-number">3.1</span> Principe</h2>
<p>Le principe des algorithmes dits <em>Diviser pour régner</em> est de décomposer un problème en plusieurs sous-problèmes disjoints et de déduire des solutions de ces sous-problème une solution au problème de départ.</p>
<p>Le point clé pour ce principe est de pouvoir <strong>fusionner</strong> les solutions de sous-problèmes pour en faire une solution, et de pouvoir le faire dans un temps/espace raisonnable. On procède alors par récursivité en appliquant ce principe pour résoudre les sous-problèmes eux-mêmes jusqu’à tomber sur des sous-problèmes très simples.</p>
<h2 data-number="3.2" id="sec:tri-fusion"><span class="header-section-number">3.2</span> Tri fusion</h2>
<p>L’algorithme du tri fusion est un des exemples les plus important d’algorithmes <em>Diviser pour régner</em> :</p>
<ul>
<li>Étant donnée une liste <span class="math inline">\(l\)</span> de taille <span class="math inline">\(n \ge 2\)</span>, on va considérer les sous-listes <span class="math inline">\(l_p\)</span> des valeurs d’indice pair et <span class="math inline">\(l_i\)</span> des valeurs d’indice impair.</li>
<li>On trie ensuite <span class="math inline">\(l_1\)</span> et <span class="math inline">\(l_2\)</span> pour obtenir <span class="math inline">\(l&#39;_1\)</span> et <span class="math inline">\(l&#39;_2\)</span>.</li>
<li>On fusionne ces deux listes pour obtenir <span class="math inline">\(l&#39; = \text{fusion}(l&#39;_1,l&#39;_2)\)</span> liste triée déduite de <span class="math inline">\(l\)</span>.</li>
</ul>
<p>Comme expliqué dans le paragraphe précédent, les tris de <span class="math inline">\(l_1\)</span> et <span class="math inline">\(l_2\)</span> s’effectuent eux-aussi à l’aide d’un tri fusion.</p>
<p><div class="ui message blue"><div class="header">Note</div>TODO : dessin</div></p>
<p>Voici une implémentation en <code>OCaml</code> de cet algorithme :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> separe_en_deux l =</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; ([], [])</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    | [x] -&gt; ([x], [])</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    | x::y::q -&gt; <span class="kw">let</span> l1, l2 = separe_en_deux q <span class="kw">in</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        (x::l1, y::l2)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fusionne l1 l2 =</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l1, l2 <span class="kw">with</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    | [], _ -&gt; l2</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    | _, [] -&gt; l1</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    | x::q1, y::q2 -&gt;</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> x &lt; y</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> x :: (fusionne q1 l2)</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> y :: (fusionne l1 q2)</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> tri_fusion l =</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; []</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    | [x] -&gt; [x]</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; </span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> l1, l2 = separe_en_deux l <span class="kw">in</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> l1p = tri_fusion l1 <span class="kw">in</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> l2p = tri_fusion l2 <span class="kw">in</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>        fusionne l1p l2p</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p></div></p>
<p>La correction et la terminaison de cet algorithme ne posant aucune difficulté, on va se concentrer sur le calcul de la complexité temporelle :</p>
<ul>
<li><code>separe_en_deux</code> consiste en un parcours linéaire de la liste <code>l</code> donc <span class="math inline">\(O(|l|)\)</span>.</li>
<li><code>fusionne</code> supprime un élément d’une des deux listes à chaque appel récursif, donc une complexité en <span class="math inline">\(O(|l_1|+|l_2|)\)</span>.</li>
<li>Pour <code>tri_fusion</code> la situation est plus complexe en raison du double appel récursif. On va d’abord traiter le cas des listes contenant <span class="math inline">\(2^k\)</span> éléments.</li>
</ul>
<p>Notons <span class="math inline">\(t_n\)</span> la complexité temporelle pour <span class="math inline">\(|l|=n\)</span>.</p>
<div class="ui message olive">
<div class="header">
Lemme
</div>
<p><span class="math inline">\(t_{2^n} = O(2^n \log_2 2^n)\)</span></p>
</div>
<div class="ui message">
<div class="header">
Preuve
</div>
<p>Par l’analyse de complexité des deux fonctions auxiliaires, on a pour <span class="math inline">\(n \in \N\)</span> <span class="math display">\[t_{2^{n+1}} = 2 t_{2^n} + O(2^n) \le 2 t_{2^n} + M 2^n\]</span> où on peut supposer que <span class="math inline">\(M \ge 1\)</span>.</p>
<p>On va montrer par récurence sur <span class="math inline">\(n \in \N^*\)</span> que <span class="math inline">\(t_{2^n} \le 2 M n 2^n\)</span>.</p>
<ul>
<li>Initialisation : <span class="math inline">\(t_{2^1} = 2 t_1 + M 2 = 2 M + 2 \le 4 M = 2 \times 1 \times 2^1 M\)</span>.</li>
<li>Hérédité : si <span class="math inline">\(n \in \N^*\)</span> et l’hypothèse est vérifiée pour <span class="math inline">\(t_{2^n}\)</span>, alors <span class="math inline">\(t_{2^{n+1}} \le 4 n 2^n M + M 2^n = (4n +1) M 2^n \le 4 (n+1) M 2^n \le 2 M (n+1) 2^{n+1}\)</span>.</li>
</ul>
<p>Ainsi <span class="math inline">\(t_{2^n} = O(n 2^n)\)</span>.</p>
</div>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><span class="math inline">\(t_n = O(n \log_2 n)\)</span></p>
</div>
<div class="ui message">
<div class="header">
Preuve
</div>
<p>Le lemme assure qu’il existe <span class="math inline">\(M&#39;\)</span> tel que <span class="math inline">\(\forall p \in \N^*, t_{2^p} \le M&#39; p 2^p\)</span>.</p>
<p>Soit <span class="math inline">\(n\in \N^*\)</span> et <span class="math inline">\(p\)</span> minimum tel que <span class="math inline">\(n \le 2^p\)</span>. On a <span class="math inline">\(\log_2 n \le p\)</span> par croissance de <span class="math inline">\(\log_2\)</span> et ainsi <span class="math inline">\(t_n \le t_{2^p} \le M&#39; p 2^p = M&#39; n \log_2 n\)</span>.</p>
<p>Ainsi, <span class="math inline">\(t_n = O(n \log_2 n)\)</span>.</p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div>On a utilisé implicitement la croissance de <span class="math inline">\(t_n\)</span> ici : plus la liste est longue, plus on effectue d’opérations.</div></p>
<p>Le programme suivant présente une implémentation du tri fusion reposant sur des tableaux. Les sous-tableaux sont manipulés à l’aide de leurs indices de début et de fin comme pour la recherche dichotomique.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> separe_en_deux l =</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; ([], [])</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    | [x] -&gt; ([x], [])</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    | x::y::q -&gt; <span class="kw">let</span> l1, l2 = separe_en_deux q <span class="kw">in</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        (x::l1, y::l2)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fusionne l1 l2 =</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l1, l2 <span class="kw">with</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    | [], _ -&gt; l2</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    | _, [] -&gt; l1</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    | x::q1, y::q2 -&gt;</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> x &lt; y</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> x :: (fusionne q1 l2)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> y :: (fusionne l1 q2)</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> tri_fusion l =</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; []</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    | [x] -&gt; [x]</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; </span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> l1, l2 = separe_en_deux l <span class="kw">in</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> l1p = tri_fusion l1 <span class="kw">in</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> l2p = tri_fusion l2 <span class="kw">in</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>        fusionne l1p l2p</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p></div></p>
<p><div class="ui message blue"><div class="header">Note</div>TODO : exercice tri avec un tableau et tri <strong>en place</strong></div></p>
<h2 data-number="3.3" id="sec:nombre-dinversions"><span class="header-section-number">3.3</span> Nombre d’inversions</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(t\)</span> une structure séquentielle (tableau, liste, ….) contenant des valeurs comparables <span class="math inline">\(a_0, ..., a_{n-1}\)</span> et énumérées dans cet ordre au sein de <span class="math inline">\(t\)</span>.</p>
<p>Une paire <span class="math inline">\((i,j) \in \range{0}{n-1}^2\)</span> où <span class="math inline">\(i &lt; j\)</span> est appelée une <em>inversion</em> de <span class="math inline">\(t\)</span> lorsque <span class="math inline">\(a_i &gt; a_j\)</span>.</p>
<p>On note <span class="math inline">\(I(t)\)</span> le nombre d’inversion de <span class="math inline">\(t\)</span>. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>* Le nombre d’inversions permet de mesurer à quel point <span class="math inline">\(t\)</span> est non triée dans l’ordre croissante. * Ce concept d’inversion est exactement celui utilisé pour les permutations en mathématiques : si <span class="math inline">\(\sigma \in \mathfrak{S}_n\)</span>, il suffit de considérer <span class="math inline">\((\sigma(1),\dots, \sigma(n))\)</span>.</div></p>
<p>On cherche dans ce paragraphe à calculer <span class="math inline">\(I(t)\)</span> efficacement. Remarquons tout d’abord qu’un algorithme naïf est en <span class="math inline">\(O(n^2)\)</span> où <span class="math inline">\(|t|=n\)</span> en explorant toutes les paires :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> inversions<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>t<span class="op">,</span> <span class="dt">size_t</span> taille<span class="op">)</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> inv <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> taille<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> taille<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>t<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> t<span class="op">[</span>j<span class="op">])</span> inv<span class="op">++;</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> inv<span class="op">;</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>On va maintenant donner un algorithme type <em>Diviser pour régner</em> :</p>
<ul>
<li>On sépare <span class="math inline">\(t\)</span> en deux moitiés <span class="math inline">\(t_1\)</span> et <span class="math inline">\(t_2\)</span>.</li>
<li>On calcule <span class="math inline">\(I(t_1)\)</span> et <span class="math inline">\(I(t_2)\)</span> par des appels récursifs.</li>
<li>On compte les inversions entre des éléments de <span class="math inline">\(t_1\)</span> et des éléments de <span class="math inline">\(t_2\)</span>
<ul>
<li>Cela ne dépend pas de leur position dans <span class="math inline">\(t_1\)</span> ou dans <span class="math inline">\(t_2\)</span>.</li>
<li>On peut donc trier <span class="math inline">\(t_1\)</span> en <span class="math inline">\(t&#39;_1\)</span> et <span class="math inline">\(t_2\)</span> en <span class="math inline">\(t&#39;_2\)</span>.</li>
<li>On compte <span class="math inline">\(N(t_1,t_2) = N(t&#39;_1,t&#39;_2)\)</span> le nombre d’inversions entre <span class="math inline">\(t&#39;_1\)</span> et <span class="math inline">\(t&#39;_2\)</span>.</li>
</ul></li>
<li>On en déduit que <span class="math inline">\(I(t) = I(t_1) + I(t_2) + N(t_1,t_2)\)</span>.</li>
</ul>
<p>Pour calculer le nombre d’inversions entre deux tableaux triés <span class="math inline">\(t&#39;_1\)</span> et <span class="math inline">\(t&#39;_2\)</span> on peut utiliser l’algorithme en <span class="math inline">\(O(|t&#39;_1| + |t&#39;_2|)\)</span> suivant : pour <span class="math inline">\(j\)</span> parcourant les indices de <span class="math inline">\(t&#39;_2\)</span>, on cherche le plus petit <span class="math inline">\(i\)</span> tel que <span class="math inline">\(t&#39;_1[i]\)</span>.</p>
<h2 data-number="3.4" id="sec:points-les-plus-proches"><span class="header-section-number">3.4</span> Points les plus proches</h2>
<h2 data-number="3.5" id="sec:sous-ensemble-de-somme-donnée"><span class="header-section-number">3.5</span> Sous-ensemble de somme donnée</h2>
<h2 data-number="3.6" id="sec:recherche-dichotomique"><span class="header-section-number">3.6</span> Recherche dichotomique</h2>
<h2 data-number="3.7" id="sec:couverture-par-des-segments-égaux"><span class="header-section-number">3.7</span> Couverture par des segments égaux</h2>
<h1 data-number="4" id="sec:programmation-dynamique"><span class="header-section-number">4</span> Programmation dynamique</h1>
<h2 data-number="4.1" id="sec:principe-3"><span class="header-section-number">4.1</span> Principe</h2>
<h2 data-number="4.2" id="sec:somme-de-sous-ensembles"><span class="header-section-number">4.2</span> Somme de sous-ensembles</h2>
<h2 data-number="4.3" id="sec:ordonnancement-de-tâches-1"><span class="header-section-number">4.3</span> Ordonnancement de tâches</h2>
<h2 data-number="4.4" id="sec:plus-longue-sous-suite-commune"><span class="header-section-number">4.4</span> Plus longue sous-suite commune</h2>
<h2 data-number="4.5" id="sec:distance-dédition"><span class="header-section-number">4.5</span> Distance d’édition</h2>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
