<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Calcul propositionnel</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

.ui.styled.accordion {
    width: 100% !important;
    font-size: 1rem !important;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\gO{\mathcal{O}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Calcul propositionnel
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:syntaxe"><span>1</span> Syntaxe</a><div class="menu"><a class="item" href="#sec:variables-propositionnelles"><div class="ui label">1.1</div> Variables propositionnelles</a><a class="item" href="#sec:formules-en-tant-quarbre"><div class="ui label">1.2</div> Formules en tant qu’arbre</a><a class="item" href="#sec:définition-inductive-des-formules"><div class="ui label">1.3</div> Définition inductive des formules</a></div></div><div class="item header"> <a href="#sec:sémantique-du-calcul-propositionnel"><span>2</span> Sémantique du calcul propositionnel</a><div class="menu"><a class="item" href="#sec:valuation-et-valeur-de-vérité-dune-formule"><div class="ui label">2.1</div> Valuation et valeur de vérité d’une formule</a><a class="item" href="#sec:table-de-vérité"><div class="ui label">2.2</div> Table de vérité</a><a class="item" href="#sec:satisfiabilité-tautologie"><div class="ui label">2.3</div> Satisfiabilité, tautologie</a><a class="item" href="#sec:équivalence-entre-deux-formules"><div class="ui label">2.4</div> Équivalence entre deux formules</a><a class="item" href="#sec:substitution-et-congruence"><div class="ui label">2.5</div> Substitution et congruence</a><a class="item" href="#sec:conséquence-logique"><div class="ui label">2.6</div> Conséquence logique</a></div></div><div class="item header"> <a href="#sec:formes-normales"><span>3</span> Formes normales</a><div class="menu"><a class="item" href="#sec:forme-normale-conjonctive-et-disjonctive"><div class="ui label">3.1</div> Forme normale conjonctive et disjonctive</a><a class="item" href="#sec:mise-sous-forme-normale-disjonctive"><div class="ui label">3.2</div> Mise sous forme normale disjonctive</a><a class="item" href="#sec:mise-sous-forme-normale-conjonctive"><div class="ui label">3.3</div> Mise sous forme normale conjonctive</a></div></div><div class="item header"> <a href="#sec:problème-sat"><span>4</span> Problème SAT</a><div class="menu"><a class="item" href="#sec:définition"><div class="ui label">4.1</div> Définition</a><a class="item" href="#sec:k-sat"><div class="ui label">4.2</div> <span class="math inline">\(k\)</span>-SAT</a><a class="item" href="#sec:sat"><div class="ui label">4.3</div> 1-SAT</a><a class="item" href="#sec:sat-1"><div class="ui label">4.4</div> 2-SAT</a><a class="item" href="#sec:sat-2"><div class="ui label">4.5</div> 3-SAT</a><a class="item" href="#sec:algorithme-de-quine"><div class="ui label">4.6</div> Algorithme de Quine</a></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Calcul propositionnel
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Calcul propositionnel     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_programmation_imperative.jpg"> </div></p>
<h1 data-number="1" id="sec:syntaxe"><span
class="header-section-number">1</span> Syntaxe</h1>
<h2 data-number="1.1" id="sec:variables-propositionnelles"><span
class="header-section-number">1.1</span> Variables
propositionnelles</h2>
<p>On considère un ensemble infini dénombrable <span
class="math inline">\(\mathcal{V}\)</span> dont les éléments sont
appelés des <em>variables propositionnelles</em>. On note usuellement
ces éléments par des lettres majuscules <span class="math inline">\(A,
B, X, Y\dots\)</span>.</p>
<p>Par rapport à ce qui a été fait en mathématiques, ces variables
représentent une sorte d’abstraction des formules atomiques des
mathématiques. On a pu voir des formules comme « <span
class="math inline">\(x = y\)</span> » ou « <span
class="math inline">\(n\)</span> est pair », ici on les représentera par
des variables.</p>
<p>On va alors s’intéresser à la logique en elle-même indépendamment des
mathématiques.</p>
<h2 data-number="1.2" id="sec:formules-en-tant-quarbre"><span
class="header-section-number">1.2</span> Formules en tant qu’arbre</h2>
<p>Grâce aux arbres, on peut donner une définition très précise des
formules du calcul propositionnel :</p>
<p><div class="ui message"><div class="header">Définition</div> Une
formule du calcul propositionnelle est un arbre ayant des nœuds
binaires, étiquetés par <span class="math inline">\(\wedge, \vee,
\rightarrow\)</span> ou <span
class="math inline">\(\leftrightarrow\)</span>, des nœuds unaires
étiquetés par <span class="math inline">\(\neg\)</span> et dont les
feuilles sont étiquettés par <span
class="math inline">\(\mathcal{V}\)</span>. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Les symboles <span class="math inline">\(\wedge, \vee,
\rightarrow\)</span> et <span
class="math inline">\(\leftrightarrow\)</span> et <span
class="math inline">\(\neg\)</span> sont appelés des connecteurs
logiques. Les quatres premiers sont dits binaires, ou d’arité 2, le
dernier est dit unaire, ou d’arité 1.</p>
<p>Pour le moment, il ne s’agit que de symboles mais ils ne sont pas
choisi au hasard et on leur attribuera un sens dans la suite de manière
cohérente avec l’usage mathématique.</p>
<ul>
<li><span class="math inline">\(\wedge\)</span> est appelé la
conjonction et se lit <em>et</em></li>
<li><span class="math inline">\(\vee\)</span> est appelé la disjonction
et se lit <em>ou</em></li>
<li><span class="math inline">\(\rightarrow\)</span> est appelé
l’implication et se lit <em>implique</em></li>
<li><span class="math inline">\(\leftrightarrow\)</span> est appelé
l’équivalence et se lit <em>équivaut</em></li>
<li><span class="math inline">\(\neg\)</span> est appelé la négation et
se lit <em>non</em></li>
</ul>
<p></div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p><center><div class="ui image center"><img
src="assets/pics/exformarbre.png" /></div></center></p>
<p>où <span class="math inline">\(A,B,X \in \mathcal{V}\)</span>.</p>
</div>
<p>De cette définition, on déduit directement la notion de taille et de
hauteur d’une formule, il s’agit de la taille ou de la hauteur en tant
qu’arbre.</p>
<p>On note <span class="math inline">\(\mathcal{Var}(f)\)</span>
l’ensemble des variables apparaissant dans <span
class="math inline">\(f\)</span>, c’est-à-dire l’ensemble des étiquettes
des feuilles de l’arbre <span class="math inline">\(f\)</span>.</p>
<h2 data-number="1.3" id="sec:définition-inductive-des-formules"><span
class="header-section-number">1.3</span> Définition inductive des
formules</h2>
<p>Il est plus traditionnel, bine qu’équivalent, de définir les formules
sous la forme d’un ensemble inductif :</p>
<p><div class="ui message"><div class="header">Définition</div> Les
formules du calcul propositionnel sont les éléments du plus petit
ensemble <span class="math inline">\(\mathcal{F}\)</span> tel que :</p>
<ul>
<li><span class="math inline">\(\mathcal{V} \subset
\mathcal{F}\)</span></li>
<li><span class="math inline">\(\forall f, f&#39; \in \mathcal{F},
\forall op \in \{ \wedge, \vee, \rightarrow, \leftrightarrow
\}\)</span>, <span class="math inline">\((f op f&#39;) \in
\mathcal{F}\)</span>.</li>
<li><span class="math inline">\(\forall f \in \mathcal{F}\)</span>,
<span class="math inline">\(\neg f \in \mathcal{F}\)</span>.</li>
</ul>
<p>On peut résumer cela sous la forme de l’équation inductive suivante
:</p>
<p><span class="math display">\[
\mathcal{F} = \mathcal{V}
| ( \mathcal{F} \wedge \mathcal{F} )
| ( \mathcal{F} \vee \mathcal{F} )
| ( \mathcal{F} \rightarrow \mathcal{F} )
| ( \mathcal{F} \leftrightarrow \mathcal{F} )
| \neg \mathcal{F}
\]</span> </div></p>
<p>Quand on définit ainsi l’ensemble, on peut se demander la nature
réelle des objets que l’on a défini. Ici, il y a deux approches
classiques :</p>
<ul>
<li>Les formules sont des mots sur l’alphabet <span
class="math inline">\(\mathcal{V} \cup \{ (, ), \vee, \wedge,
\rightarrow, \leftrightarrow \}\)</span>. Par exemple <span
class="math inline">\((X\vee Y)\wedge \neg Z\in \mathcal{F}\)</span>
mais <span class="math inline">\((X\neg Y) \not \in
\mathcal{F}\)</span>. C’est la vision <em>historique</em> des formules
comme des chaînes de caractères.</li>
<li>Les formules sont des arbres comme on l’a vu précédemment.
L’avantage principal étant que tous ces arbres sont des formules sans
ambigüité de lecture possible.</li>
</ul>
<p>Que ce soit sous forme de chaîne ou d’arbre, on adopte une
représentation plate des formules. Comme cela peut induire beaucoup de
parenthèses, on va adopter une convention de priorité : en cas
d’ambigüité, c’est la construction la plus prioritaire qui
s’effectue.</p>
<p>On a les règles de priorité usuelles : <span
class="math inline">\(\neg &gt; \wedge, \vee &gt; \rightarrow,
\leftrightarrow\)</span>. On justifiera de plus dans la suite qu’on peut
considérer <span class="math inline">\(\wedge\)</span> et <span
class="math inline">\(\vee\)</span> comme étant associatives, et <span
class="math inline">\(\leftrightarrow\)</span> comme étant associative à
droite.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li><span class="math inline">\((A \wedge (B \vee C))\)</span> s’écrit
<span class="math inline">\(A \wedge (B \vee C)\)</span></li>
<li><span class="math inline">\((A \vee (B \vee C))\)</span> s’écrit
<span class="math inline">\(A \vee B \vee C\)</span></li>
<li><span class="math inline">\((A \rightarrow (B \rightarrow
C))\)</span> s’écrit <span class="math inline">\(A \rightarrow B
\rightarrow C\)</span></li>
<li><span class="math inline">\(((A \rightarrow B) \rightarrow
C)\)</span> s’écrit <span class="math inline">\((A \rightarrow B)
\rightarrow C\)</span></li>
</ul>
</div>
<h1 data-number="2" id="sec:sémantique-du-calcul-propositionnel"><span
class="header-section-number">2</span> Sémantique du calcul
propositionnel</h1>
<p>On considère ici un ensemble à deux éléments <span
class="math inline">\(\mathbb{B} = \{ V, F \}\)</span> dont les éléments
sont appelés des valeurs de vérité. On parle de la valeur <em>vraie</em>
pour <span class="math inline">\(V\)</span> et <em>fausse</em> pour
<span class="math inline">\(F\)</span>. C’est une pure convention, il
n’y a aucune véracité mathématique pour appuyer ces termes. Quelque
part, c’est la même situation que pour les bases directes.</p>
<h2 data-number="2.1"
id="sec:valuation-et-valeur-de-vérité-dune-formule"><span
class="header-section-number">2.1</span> Valuation et valeur de vérité
d’une formule</h2>
<p><div class="ui message"><div class="header">Définition</div> Une
valuation est une fonction <span class="math inline">\(v : \mathcal{V}
\rightarrow \mathbb{B}\)</span>. </div></p>
<p>C’est une forme d’environnement pour les formules comme pourrait
l’être une affectation de valeurs à des variables pour évaluer des
expressions arithmétiques. On va donc pouvoir s’appuyer sur une telle
valuation pour définir la valeur de vérité d’une formule comme une
évaluation :</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(v\)</span> une valuation et <span
class="math inline">\(f \in \mathcal{F}\)</span>. On appelle
<strong>valeur de vérité</strong> de <span
class="math inline">\(f\)</span> sous la valuation <span
class="math inline">\(f\)</span>, l’élément <span
class="math inline">\([f]_v \in \mathbb{B}\)</span> défini inductivement
par :</p>
<ul>
<li><span class="math inline">\(\forall X \in \mathcal{V}, [X]_v =
v(X)\)</span></li>
<li><span class="math inline">\(\forall f \in \mathcal{F}, [\neg f]_v =
\begin{cases} V &amp; \text{si } [f]_v = F \\ F &amp; \text{sinon}
\end{cases}\)</span></li>
<li><span class="math inline">\(\forall f, f&#39; \in \mathcal{F},
\forall \square \in \{\wedge, \vee, \rightarrow, \leftrightarrow
\}\)</span> on détermine <span class="math inline">\([f \square
f&#39;]_v\)</span> en fonction de <span
class="math inline">\([f]_v\)</span> et <span
class="math inline">\([f&#39;]_v\)</span> selon la table suivante :</li>
</ul>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 9%" />
<col style="width: 15%" />
<col style="width: 17%" />
<col style="width: 22%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\([f]_v\)</span></th>
<th><span class="math inline">\([f&#39;]_v\)</span></th>
<th><span class="math inline">\([f \vee f&#39;]_v\)</span></th>
<th><span class="math inline">\([f \wedge f&#39;]_v\)</span></th>
<th><span class="math inline">\([f \rightarrow f&#39;]_v\)</span></th>
<th><span class="math inline">\([f \leftrightarrow
f&#39;]_v\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>V</td>
<td><pre><code>V</code></pre></td>
<td><pre><code>   V</code></pre></td>
<td><pre><code>   V</code></pre></td>
<td><pre><code>     V</code></pre></td>
<td><pre><code>        V</code></pre></td>
</tr>
<tr class="even">
<td>V</td>
<td><pre><code>F</code></pre></td>
<td><pre><code>   V</code></pre></td>
<td><pre><code>   F</code></pre></td>
<td><pre><code>     F</code></pre></td>
<td><pre><code>        F</code></pre></td>
</tr>
<tr class="odd">
<td>F</td>
<td><pre><code>V</code></pre></td>
<td><pre><code>   V</code></pre></td>
<td><pre><code>   F</code></pre></td>
<td><pre><code>     V</code></pre></td>
<td><pre><code>        F</code></pre></td>
</tr>
<tr class="even">
<td>F</td>
<td><pre><code>F</code></pre></td>
<td><pre><code>   F</code></pre></td>
<td><pre><code>   F</code></pre></td>
<td><pre><code>     V</code></pre></td>
<td><pre><code>        V</code></pre></td>
</tr>
</tbody>
</table>
<p></div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si <span class="math inline">\(f = A \vee B \rightarrow A \wedge
C\)</span> et qu’on sait que <span class="math inline">\(v(A) = v(C) =
V\)</span> et <span class="math inline">\(v(B) = F\)</span>, alors <span
class="math inline">\([A \vee B]_v = V\)</span> et <span
class="math inline">\([A \wedge C] = V\)</span> selon la table. On a
alors <span class="math inline">\([f]_v = V\)</span>.</p>
</div>
<h2 data-number="2.2" id="sec:table-de-vérité"><span
class="header-section-number">2.2</span> Table de vérité</h2>
<p>Une formule ne pouvant faire apparaitre qu’un nombre fini de
variable, les valuations comportent beaucoup d’information n’ayant
aucune influence sur la valeur de vérité de <span
class="math inline">\(f\)</span>. Cela est précisé dans le théorème
suivant :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(f \in \mathcal{F}\)</span> et <span
class="math inline">\(v,v&#39; : \mathcal{V} \rightarrow
\mathbb{B}\)</span> deux valuations.</p>
<p>Si <span class="math inline">\(\forall X \in Var(f), v_{X} =
v&#39;_{X}\)</span> alors <span class="math inline">\([f]_v =
[f]_{v&#39;}\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Par induction structurelle sur <span
class="math inline">\(f\)</span>.</p>
<ul>
<li>Si <span class="math inline">\(X \in \mathcal{V}\)</span> et <span
class="math inline">\(f = X\)</span>, alors <span
class="math inline">\([f]_v = v(X) = v&#39;(X) =
[f]_{v&#39;}\)</span>.</li>
<li>Si la propriété est vraie pour <span class="math inline">\(f \in
\mathcal{F}\)</span> alors <span class="math inline">\([\neg f]_v = V
\iff [f]_v = F = [f]_{v&#39;} \iff [\neg f&#39;]_v = V\)</span>. Ainsi,
comme il n’y a que deux valeurs possibles, <span
class="math inline">\([\neg f]_v = [\neg f&#39;]_v\)</span>.</li>
<li>Si la propriété est vraie pour <span class="math inline">\(f, f&#39;
\in \mathcal{F}\)</span>, alors <span class="math inline">\([f]_v =
[f]_{v&#39;}\)</span> et <span class="math inline">\([f&#39;]_v=
[f&#39;]_{v&#39;}\)</span>. Or, <span class="math inline">\([f \square
f&#39;]_v\)</span> ne dépend que de <span
class="math inline">\([f]_v\)</span> et <span
class="math inline">\([f&#39;]_v\)</span> selon les tables de la
définition pour <span class="math inline">\(\square \in \{ \vee, \wedge,
\rightarrow, \leftrightarrow \}\)</span>. On en conclut directement que
<span class="math inline">\([f \square f&#39;]_v = [f \square
f&#39;]_{v&#39;}\)</span>. </div> </div></li>
</ul>
<p>Ainsi, on peut se concentrer sur les valeurs de vérité associées aux
variables présentes dans une formule. Se faisant, on introduit le
concept de tables de vérité :</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(f \in \mathcal{F}\)</span> à <span
class="math inline">\(n\)</span> variables <span
class="math inline">\(X_1, \dots, X_n\)</span>.</p>
<p>On appelle <strong>table de vérité</strong> de <span
class="math inline">\(f\)</span> une fonction <span
class="math display">\[
T_f : \mathbb{B}^n \rightarrow \mathbb{B}
\]</span> telle que pour toute valuation <span
class="math inline">\(v\)</span> on ait <span class="math display">\[
[f]_v = T_f(v(X_1), \dots, v(X_n))
\]</span> </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Toute formule a une table de vérité et elle est unique à l’ordre près
de l’enumération de ses variables.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Soit <span class="math inline">\(f
\in \mathcal{F}\)</span> et <span class="math inline">\(X_1, \dots,
X_n\)</span> ses variables.</p>
<ol type="1">
<li><p>Si <span class="math inline">\(b = (b_1, \dots, b_n)\in
\mathbb{B}^\N\)</span>, on note <span class="math display">\[
\application{v_b}{\mathcal{V}}{\mathbb{B}}
{Y}{ \begin{cases} b_i &amp; \text{ si } Y = X_i \text{ pour } i \in
\range{1}{n}
\\ F &amp; \text{ sinon } \end{cases} }
\]</span></p>
<p>On pose alors <span class="math inline">\(T_f : b \mapsto
[f]_{v_b}\)</span>.</p></li>
<li><p>Soit <span class="math inline">\(v&#39;\)</span> une valuation et
<span class="math inline">\(b = (v&#39;(X_1), \dots,
v&#39;(X_n))\)</span>. On a <span class="math inline">\(v_b\)</span> et
<span class="math inline">\(v&#39;\)</span> identiques sur les variables
de <span class="math inline">\(f\)</span>, donc <span
class="math inline">\([f]_{v&#39;} = [f]_{v_b} =
T_f(b)\)</span>.</p></li>
<li><p>Si <span class="math inline">\(T&#39;\)</span> est une autre
table de verité pour le même ordre d’énumération, on a pour <span
class="math inline">\(b \in \mathbb{B}^\N\)</span>, par définition de la
table <span class="math inline">\(T&#39;(b) = [f]_{v_b} =
T_f(b)\)</span>. Donc <span class="math inline">\(T&#39; = T_f\)</span>.
</div> </div></p></li>
</ol>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On représente usuellement une table de vérité sous la forme d’une
table avec une colonne par variable et une colonne pour la valeur de
<span class="math inline">\(f\)</span>.</p>
<p>Par exemple, pour <span class="math inline">\(f = (A \wedge B) \vee
C\)</span> :</p>
<table style="width:22%;">
<colgroup>
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
<th>C</th>
<th>f</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>V</td>
<td>V</td>
<td>V</td>
<td>V</td>
</tr>
<tr class="even">
<td>V</td>
<td>V</td>
<td>F</td>
<td>V</td>
</tr>
<tr class="odd">
<td>V</td>
<td>F</td>
<td>V</td>
<td>V</td>
</tr>
<tr class="even">
<td>V</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr class="odd">
<td>F</td>
<td>V</td>
<td>V</td>
<td>V</td>
</tr>
<tr class="even">
<td>F</td>
<td>V</td>
<td>F</td>
<td>F</td>
</tr>
<tr class="odd">
<td>F</td>
<td>F</td>
<td>V</td>
<td>V</td>
</tr>
<tr class="even">
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
</tbody>
</table>
<p></div></p>
<h2 data-number="2.3" id="sec:satisfiabilité-tautologie"><span
class="header-section-number">2.3</span> Satisfiabilité, tautologie</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(f \in \mathcal{F}\)</span> et <span
class="math inline">\(v : \mathcal{V} \rightarrow
\mathbb{B}\)</span>.</p>
<p>On note <span class="math inline">\(v \models f\)</span> quand <span
class="math inline">\([f]_v = V\)</span> et on dit que <span
class="math inline">\(v\)</span> est un modèle de <span
class="math inline">\(f\)</span>. On note ainsi <span
class="math inline">\(\mathop{Mod}(f) = \enscomp{v}{v \models
f}\)</span>.</p>
<ul>
<li>Si <span class="math inline">\(\mathop{Mod}(f) \neq
\emptyset\)</span> on dit que <span class="math inline">\(f\)</span> est
<strong>satisfiable</strong>.</li>
<li>Si <span class="math inline">\(\mathop{Mod}(f) =
\mathbb{B}^\mathcal{V}\)</span> on dit que <span
class="math inline">\(f\)</span> est <strong>une
tautologie</strong>.</li>
<li>Si <span class="math inline">\(\mathop{Mod}(f) = \emptyset\)</span>
on dit que <span class="math inline">\(f\)</span> est <strong>une
antilogie</strong>. </div></li>
</ul>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<ul>
<li><span class="math inline">\(f\)</span> est une tautologie ssi <span
class="math inline">\(T_f\)</span> est constante de valeur <span
class="math inline">\(V\)</span></li>
<li><span class="math inline">\(f\)</span> est une antilogie ssi <span
class="math inline">\(T_f\)</span> est constante de valeur <span
class="math inline">\(F\)</span></li>
<li><span class="math inline">\(f\)</span> est satisfiable ssi <span
class="math inline">\(V \in T_f(\mathbb{B}^N)\)</span>.</li>
</ul>
</div>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li><span class="math inline">\(X \vee \neg X\)</span> est une
tautologie appelée le tiers-exclu.</li>
<li><span class="math inline">\(X \wedge \neg X\)</span> est une
antilogie appelée la non-contradiction.</li>
<li><span class="math inline">\(((A \rightarrow B) \rightarrow A)
\rightarrow A\)</span> est une tautologie.</li>
</ul>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il est pratique d’introduire des formules constantes <span
class="math inline">\(\top\)</span> et <span
class="math inline">\(\perp\)</span> pour représenter une tautologie et
une antilogie quelconque.</p>
<p></div></p>
<h2 data-number="2.4" id="sec:équivalence-entre-deux-formules"><span
class="header-section-number">2.4</span> Équivalence entre deux
formules</h2>
<p><div class="ui message"><div class="header">Définition</div> Soient
<span class="math inline">\(f, f&#39;\in \mathcal{F}\)</span>. On dit
que <span class="math inline">\(f\)</span> et <span
class="math inline">\(f&#39;\)</span> sont équivalentes, et l’on note
<span class="math inline">\(f \iff f&#39;\)</span>, lorsque <span
class="math inline">\(f\)</span> et <span
class="math inline">\(f&#39;\)</span> ont mêmes modèles, c’est-à-dire
lorsque <span class="math inline">\(\mathop{Mod}(f) =
\mathop{Mod}(f&#39;)\)</span>. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>L’équivalence logique est une relation d’équivalence.</p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<ul>
<li>Cela signifie que deux formules équivalentes ne peuvent être
distingués par leur valeur de vérité sous une valuation.</li>
<li><span class="math inline">\(f\)</span> est une tautologie si et
seulement si <span class="math inline">\(f \iff \top\)</span></li>
<li><span class="math inline">\(f\)</span> est une antilogie si et
seulement si <span class="math inline">\(f \iff \perp\)</span></li>
</ul>
<p></div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soient <span class="math inline">\(f, f&#39; \in \mathcal{F}\)</span>
avec <span class="math inline">\(\mathop{Var}(f) =
\mathop{Var}(f&#39;)\)</span>.</p>
<p>On a <span class="math inline">\(f \iff f&#39;\)</span> si et
seulement si <span class="math inline">\(T_f = T_{f&#39;}\)</span>.</p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Cela permet de vérifier l’équivalence entre deux formules en
établissant les deux tables de vérité et en vérifiant quelles sont
identiques. Comme une telle table comporte <span
class="math inline">\(2^n\)</span> lignes pour <span
class="math inline">\(n\)</span> variables, c’est souvent
fastidieux.</p>
<p></div></p>
<p>Il y a de nombreuses équivalences logiques qui sont fondamentales car
elles permettent de simplifier les formules pour travailler sur des
formules plus simples. On va démontrer ici les principales :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soient <span class="math inline">\(P, Q, R \in
\mathcal{V}\)</span></p>
<ul>
<li><span class="math inline">\(\neg \neg P \iff P\)</span></li>
<li><span class="math inline">\(P \rightarrow Q \iff \neg P \vee
Q\)</span></li>
<li><span class="math inline">\(P \leftrightarrow Q \iff (P \wedge Q)
\vee (\neg P \wedge \neg Q)\)</span></li>
</ul>
<p>Lois de de Morgan :</p>
<ul>
<li><span class="math inline">\(\neg (P \vee Q) \iff \neg P \wedge \neg
Q\)</span></li>
<li><span class="math inline">\(\neg (P \wedge Q) \iff \neg P \vee \neg
Q\)</span></li>
</ul>
<p>Commutativité : * <span class="math inline">\(P \wedge Q \iff Q
\wedge P\)</span> * <span class="math inline">\(P \vee Q \iff Q \vee
P\)</span></p>
<p>Associativité :</p>
<ul>
<li><span class="math inline">\(P \wedge (Q \wedge R) \iff (P \wedge Q)
\wedge R\)</span></li>
<li><span class="math inline">\(P \vee (Q \vee R) \iff (P \vee Q) \vee
R\)</span></li>
</ul>
<p>Distributivité :</p>
<ul>
<li><span class="math inline">\(P \wedge (Q \vee R) \iff (P \vee Q)
\wedge (P \vee R)\)</span></li>
<li><span class="math inline">\(P \vee (Q \wedge R) \iff (P \wedge Q)
\vee (P \wedge R)\)</span></li>
</ul>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Il suffit de faire de fastidieuses
vérifications à l’aide de tables de vérité. On peut se contenter de ne
démontrer qu’une partie d’entre elles grâce à la double négation et aux
lois de de Morgan. </div> </div></p>
<h2 data-number="2.5" id="sec:substitution-et-congruence"><span
class="header-section-number">2.5</span> Substitution et congruence</h2>
<p>On vient de démontrer des équivalences mais le fait d’utiliser des
variables semblent en restreindre la portée. En effet, si on considère
la formule <span class="math inline">\(\neg \neg (A \rightarrow
B)\)</span> il ne semble pas possible d’en déduire directement qu’elle
est équivalente à <span class="math inline">\(A \rightarrow B\)</span>
car l’équivalence <span class="math inline">\(\neg \neg X \iff
X\)</span> ne s’applique que pour une variable.</p>
<p>Or, dès le départ, les variables propositionnelles ne se voulaient
qu’être des abstractions sur des propriétés. On va démontrer ici un
lemme de substitution qui permettra de déduire de nouvelles équivalences
en remplaçant une variable par une formule.</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(f, g \in \mathcal{F}\)</span> et <span
class="math inline">\(X \in \mathcal{V}\)</span>. On définit la
substitution de <span class="math inline">\(X\)</span> par <span
class="math inline">\(g\)</span>, notée <span
class="math inline">\(f[g/X]\)</span> par induction ainsi :</p>
<ul>
<li>Si <span class="math inline">\(Y \in \mathcal{V} \backslash \{ X
\}\)</span>, <span class="math inline">\(Y[g/X] = Y\)</span></li>
<li><span class="math inline">\(X[g/X] = g\)</span></li>
<li>Si <span class="math inline">\(f \in \mathcal{F}\)</span>, <span
class="math inline">\((\neg f)[g/X] = \neg f[g/X]\)</span></li>
<li>Si <span class="math inline">\(\square \in \{\wedge, \vee,
\rightarrow, \leftrightarrow\}\)</span> et <span
class="math inline">\(f, f&#39; \in \mathcal{F}\)</span>, <span
class="math inline">\((f \square f&#39;)[g/X] = f[g/X] \square
f&#39;[g/X]\)</span> </div></li>
</ul>
<div class="ui message olive">
<div class="header">
Lemme
</div>
<p>Soit <span class="math inline">\(f, g \in \mathcal{F}, X \in
\mathcal{V}\)</span> et <span class="math inline">\(v : \mathcal{V}
\rightarrow \mathbb{B}\)</span>.</p>
<p>On pose <span class="math inline">\(v&#39; : \mathcal{V} \rightarrow
\mathbb{B}\)</span> telle que <span class="math inline">\(v&#39;(X) =
[g]_v\)</span> et <span class="math inline">\(v&#39;(Y) = v(Y)\)</span>
pour <span class="math inline">\(Y \neq X\)</span>.</p>
<p>On a alors <span class="math inline">\(\left[ f[g/X] \right]_v =
[f]_{v&#39;}\)</span>.</p>
</div>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soient <span class="math inline">\(f,g,h \in \mathcal{F}\)</span> et
<span class="math inline">\(X \in \mathcal{V}\)</span>.</p>
<p>Si <span class="math inline">\(f \equiv g\)</span>, alors <span
class="math inline">\(f[h/ X] \equiv g[h / X]\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Soit <span
class="math inline">\(v\)</span> une valuation, on a défini <span
class="math inline">\(v&#39;\)</span> comme dans le lemme précédent avec
<span class="math inline">\(v&#39;(X) = [h]_v\)</span>. On a alors <span
class="math inline">\(\left[ f[h/X] \right]_v = [f]_{v&#39;}\)</span> et
<span class="math inline">\(\left[ g[h/X] \right]_v =
[g]_{v&#39;}\)</span>. Or, par hypothèse, <span
class="math inline">\([f]_{v&#39;} = [g]_{v&#39;}\)</span>.</p>
<p>On a ainsi l’égalité <span class="math inline">\(\left[ f[h/X]
\right]_v = \left[ g[h/X] \right]_v\)</span> et donc <span
class="math inline">\(f[h/X] \equiv g[h/X]\)</span>. </div> </div></p>
<p>Le fait de faire passer des équivalences sous des opérations, ici les
connecteurs logiques, est traditionnellement appelé une congruence. On a
ici le théorème suivant :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soient <span class="math inline">\(f, g, h \in \mathcal{F}\)</span>
où <span class="math inline">\(f \equiv g\)</span>.</p>
<p>On a * <span class="math inline">\(\neg f \equiv \neg g\)</span> *
<span class="math inline">\(\forall \square \in \{\wedge, \vee,
\rightarrow, \leftrightarrow \}\)</span>, <span class="math inline">\(f
\square h \equiv g \square h\)</span> et <span class="math inline">\(h
\square f \equiv h \square f\)</span>.</p>
</div>
<h2 data-number="2.6" id="sec:conséquence-logique"><span
class="header-section-number">2.6</span> Conséquence logique</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(f, g \in \mathcal{F}\)</span>, on dit que
<span class="math inline">\(f\)</span> est <strong>conséquence
logique</strong> de <span class="math inline">\(g\)</span> lorsque <span
class="math inline">\(\mathop{Mod}(g) \subset
\mathop{Mod}(f)\)</span>.</p>
<p>Autrement dit, lorsque pour toute valuation <span
class="math inline">\(v\)</span>, <span class="math inline">\([g]_v =
V\)</span> implique <span class="math inline">\([f]_v = V\)</span>.</p>
<p>On note alors <span class="math inline">\(g \models f\)</span>.</p>
<p>Si <span class="math inline">\(\Gamma \subset \mathcal{F}\)</span> on
note <span class="math inline">\(\Gamma \models f\)</span> s’il existe
<span class="math inline">\(g_1, \dots, g_n \in \Gamma\)</span> tels que
<span class="math inline">\(g_1 \wedge \dots \wedge g_n \models
f\)</span>. </div></p>
<div class="ui message olive">
<div class="header">
Lemme
</div>
<p>Soient <span class="math inline">\(\Gamma,\Delta \subset
\mathcal{F}\)</span> et <span class="math inline">\(f \in
\mathcal{F}\)</span>.</p>
<p>Si <span class="math inline">\(\Gamma \models f\)</span> alors <span
class="math inline">\(\Gamma \cup \Delta \models f\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Pour simplifier, on peut supposer
que <span class="math inline">\(\Gamma\)</span> et <span
class="math inline">\(\Delta\)</span> sont réduits à une formule, quitte
à considérer <span class="math inline">\(\top\)</span> s’ils sont
vides.</p>
<p>On suppose ainsi que <span class="math inline">\(g \models f\)</span>
et on cherche à montrer que <span class="math inline">\(g \wedge h
\models f\)</span>.</p>
<p>Soit <span class="math inline">\(v\)</span> une valuation telle que
<span class="math inline">\(v \in \mathop{Mod}(g \wedge h)\)</span>. On
a donc <span class="math inline">\([g \wedge h]_v = V\)</span> et par
définition de la valeur de vérité d’une conjonction, <span
class="math inline">\([g]_v = [h]_v = V\)</span>. Or, comme <span
class="math inline">\([g]_v\)</span> et que <span
class="math inline">\(g \models f\)</span> on a <span
class="math inline">\([f]_v = V\)</span>. On vient de montrer <span
class="math inline">\(g \wedge h \models f\)</span>. </div> </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Les propriétés suivants sont équivalentes :</p>
<ol type="1">
<li><span class="math inline">\(g \models f\)</span></li>
<li><span class="math inline">\(g, \neg f \models \perp\)</span></li>
<li><span class="math inline">\(g \rightarrow f\)</span> est une
tautologie</li>
</ol>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"></p>
<p><span class="math inline">\(1. \Rightarrow 2.\)</span> : Supposons
que <span class="math inline">\(g \models f\)</span> et supposons qu’il
existe une valuation <span class="math inline">\(v\)</span> telle que
<span class="math inline">\([g \wedge \neg f]_v = V\)</span>. On a donc
<span class="math inline">\([g]_v = [\neg f]_v = V\)</span> par
l’argument usuel sur la table de la conjonction. Ainsi <span
class="math inline">\([f]_v = F\)</span> mais comme <span
class="math inline">\(g \models f\)</span>, on a <span
class="math inline">\([f]_v = V\)</span>. Or, une formule a une unique
valeur de vérité, donc on aboutit à une contradiction. Ainsi <span
class="math inline">\(\mathop{Mod}(g \wedge \neg f) = \emptyset\)</span>
et <span class="math inline">\(g \wedge \neg f \models \perp\)</span> vu
que <span class="math inline">\(\mathop{Mod}(\perp) =
\emptyset\)</span>.</p>
<p><span class="math inline">\(2. \Rightarrow 3.\)</span> Suposons que
<span class="math inline">\(g, \neg f \models \perp\)</span>. On a alors
<span class="math inline">\(\mathcal{Mod}(g \wedge \neg f) =
\emptyset\)</span>. Soit <span class="math inline">\(v\)</span> une
valuation et supposons, par l’absurde, que <span
class="math inline">\([g \rightarrow f]_v = F\)</span>. Alors, de par la
table de <span class="math inline">\(\rightarrow\)</span>, cela signifie
nécessairement que <span class="math inline">\([g]_v = V\)</span> et
<span class="math inline">\([f]_v = F\)</span>. Donc <span
class="math inline">\([g \wedge \neg f]_v = V\)</span>. Contradiction
car on a trouvé un modèle de <span class="math inline">\(g \wedge \neg
f\)</span>.</p>
<p><span class="math inline">\(3. \Rightarrow 1.\)</span> Supposons que
<span class="math inline">\(g \rightarrow f\)</span> soit une tautologie
et soit <span class="math inline">\(v\)</span> une valuation telle que
<span class="math inline">\([g]_v = V\)</span>. Comme <span
class="math inline">\([g \rightarrow f]_v = V\)</span> on a
nécessairement <span class="math inline">\([f]_v = V\)</span> par étude
de la table de <span class="math inline">\(\rightarrow\)</span>. Donc,
on a bien <span class="math inline">\(g \models f\)</span>.
</div> </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Le fait de se ramener à montrer <span class="math inline">\(\Gamma,
\neg f \models \perp\)</span> pour prouver que <span
class="math inline">\(\Gamma \models f\)</span> est un principe très
important appelé la <em>résolution</em> qui a été introduit par le
logicien John Alan Robinson et sert de base au langage de programmation
logique Prolog.</p>
<p></div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Si <span class="math inline">\(f \models g\)</span> et <span
class="math inline">\(g \models h\)</span> alors <span
class="math inline">\(f \models g\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Il s’agit juste de la transitivité
de l’inclusion sur les modèles. </div> </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Cette propriété appelé le <em>Modus Ponens</em> est un principe
fondamental du raisonnement identifiée très tôt dans l’histoire des
mathématiques.</p>
<p></div></p>
<h1 data-number="3" id="sec:formes-normales"><span
class="header-section-number">3</span> Formes normales</h1>
<p>On a vu beaucoup d’équivalences logiques dans la partie précédente,
elles permettent de réécrire une formule sous une forme plus pratique
pour raisonner. On parle alors de <strong>forme normale</strong>.</p>
<p>Comme on a pu le voir, les opérateurs <span
class="math inline">\(\rightarrow\)</span> et <span
class="math inline">\(\leftrightarrow\)</span> peuvent s’exprimer avec
les trois autres. On va donc considérer ici uniquement des formules avec
les opérateurs <span class="math inline">\(\vee, \wedge,
\neg\)</span>.</p>
<h2 data-number="3.1"
id="sec:forme-normale-conjonctive-et-disjonctive"><span
class="header-section-number">3.1</span> Forme normale conjonctive et
disjonctive</h2>
<p><div class="ui message"><div class="header">Définition</div> Une
formule de la forme <span class="math inline">\(X\)</span> ou <span
class="math inline">\(\neg X\)</span> avec <span class="math inline">\(X
\in \mathcal{V}\)</span> est appelé un <strong>littéral</strong>, on
précise parfois positif ou négatif.</p>
<p>Une formule de la forme <span class="math inline">\(l_1 \vee \dots
\vee l_n\)</span> où les <span class="math inline">\(l_i\)</span> sont
des littéraux est appelée une <strong>clause</strong>. On parle de
clause vide pour <span class="math inline">\(\perp\)</span>.</p>
<p>Une formule de la forme <span class="math inline">\(C_1 \wedge \dots
\wedge C_m\)</span> où les <span class="math inline">\(C_j\)</span> sont
des clauses est appelée une <strong>forme normale conjonctive</strong>
(FNC). On parle de FNC vide pour <span
class="math inline">\(\top\)</span>. </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li><span class="math inline">\(A \wedge (\neg A \vee B) \wedge
\perp\)</span> est une FNC.</li>
</ul>
</div>
<p>En vertu de l’associativité des connecteurs, on note de manière
synthétique</p>
<p><span class="math display">\[
\bigwedge_{i=1}^n \bigvee_{j=1}^{n_i} l_{i,j}
\]</span></p>
<p>une FNC, où les <span class="math inline">\(l_{i,j}\)</span> sont des
littéraux.</p>
<p><div class="ui message"><div class="header">Définition</div> On
définit de même les formes normales disjonctives (FND) comme les
disjonctions de conjonctions de littéraux.</p>
<p>Ce sont les formules sous la forme : <span class="math display">\[
\bigvee_{i=1}^n \bigwedge_{j=1}^{n_i} l_{i,j}
\]</span> où les <span class="math inline">\(l_{i,j}\)</span> sont des
littéraux. </div></p>
<h2 data-number="3.2" id="sec:mise-sous-forme-normale-disjonctive"><span
class="header-section-number">3.2</span> Mise sous forme normale
disjonctive</h2>
<p>Soit <span class="math inline">\(f \in \mathcal{F}\)</span> dont les
variables sont <span class="math inline">\(X_1, \dots, X_n\)</span>, on
peut passer de sa table de vérité à une FND en posant :</p>
<p><span class="math display">\[
\Phi(f) = \bigvee_{(b_1, \dots, b_n) \in T_f^{-1}(\{1\}) }
\bigwedge_{i=1}^n l(X_i,b_i)
\]</span> où <span class="math inline">\(l(X_i,V) = X_i\)</span> et
<span class="math inline">\(l(X_i,F) = \neg X_i\)</span>.</p>
<p>On a directement <span class="math inline">\(\Phi(f) \equiv
f\)</span> car <span class="math inline">\(\Phi(f)\)</span> a été
construite pour avoir la même table de vérité que <span
class="math inline">\(f\)</span>.</p>
<p>On remarque tout de suite que la taille de <span
class="math inline">\(\Phi(f)\)</span> dépend du nombre de valeur à
<span class="math inline">\(V\)</span> dans sa table de vérité. Une
tautologie portant sur <span class="math inline">\(n\)</span> variables
aura donc une FND de taille <span
class="math inline">\(O(2^n)\)</span>.</p>
<h2 data-number="3.3" id="sec:mise-sous-forme-normale-conjonctive"><span
class="header-section-number">3.3</span> Mise sous forme normale
conjonctive</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(f \in \mathcal{F}\)</span>, on définit la
formule <span class="math inline">\(\varphi(f)\)</span> ainsi par
induction structurelle :</p>
<ul>
<li>Si <span class="math inline">\(X \in \mathcal{V}\)</span>, <span
class="math inline">\(\varphi(X) = X\)</span></li>
<li>Si <span class="math inline">\(f \in \mathcal{F}\)</span>,
<ul>
<li>Soit <span class="math inline">\(f = X \in \mathcal{X}\)</span> et
<span class="math inline">\(\varphi(\neg X) = \neg X\)</span></li>
<li>Soit <span class="math inline">\(f = \neg f&#39;\)</span> et <span
class="math inline">\(\varphi(\neg f) = \varphi(f&#39;)\)</span></li>
<li>Soit <span class="math inline">\(f = g \wedge h\)</span> et <span
class="math inline">\(\varphi(\neg f)  = \varphi(\neg g) \vee
\varphi(\neg h)\)</span>.</li>
<li>Soit <span class="math inline">\(f = g \vee h\)</span> et <span
class="math inline">\(\varphi(\neg f)  = \varphi(\neg g) \wedge
\varphi(\neg h)\)</span>.</li>
</ul></li>
<li>Si <span class="math inline">\(f, f&#39; \in \mathcal{F}\)</span>,
<span class="math inline">\(\varphi(f \vee f&#39;) = \varphi(f) \vee
\varphi(f&#39;)\)</span> et <span class="math inline">\(\varphi(f \wedge
f&#39;) = \varphi(f) \wedge \varphi(f&#39;)\)</span>. </div></li>
</ul>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>On a <span class="math inline">\(\varphi(f) \iff f\)</span> et dans
<span class="math inline">\(\varphi(f)\)</span> les négations
appartiennent toutes à des littéraux.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> On démontre ce théorème rapidement
par induction structurelle rapide.</p>
<p>Pour l’équivalence, il s’agit d’équivalences déjà démontré (double
négation et lois de de Morgan). </div> </div></p>
<p>Il est possible de passer de FND à FNC à l’aide d’une négation et des
lois de de Morgan. On en déduit donc une manière d’obtenir une FNC
équivalente à <span class="math inline">\(f\)</span> : on met <span
class="math inline">\(\neg \Phi(\neg f) \equiv f\)</span> sous FNC en
éliminant la négation.</p>
<p>Cependant, on peut obtenir une FNC plus directement par induction
comme on peut le voir dans la définition suivante.</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(f\)</span> une formule dont les négations
appartiennent toutes à des littéraux, on définit <span
class="math inline">\(\psi(f)\)</span> par induction structurelle :</p>
<ul>
<li><span class="math inline">\(\psi(l) = l\)</span> si <span
class="math inline">\(l\)</span> est un littéral</li>
<li><span class="math inline">\(\psi(f \wedge g) = \psi(f) \wedge
\psi(g)\)</span></li>
<li>Si <span class="math inline">\(\psi(f) = f_1 \wedge f_2\)</span>
alors <span class="math inline">\(\psi(f \vee g) = \psi(f_1 \vee g)
\wedge \psi(f_2 \vee g)\)</span>.</li>
<li>Si <span class="math inline">\(\psi(f)\)</span> n’est pas une
conjonction et <span class="math inline">\(\psi(g) = g_1 \wedge
g_2\)</span> alors <span class="math inline">\(\psi(f \vee g) = \psi(f
\vee g_1) \wedge \psi(f \vee g_2)\)</span>.</li>
<li>Si ni <span class="math inline">\(\psi(f)\)</span> ni <span
class="math inline">\(\psi(g)\)</span> ne sont des conjonctions alors
<span class="math inline">\(\psi(f \vee g) = \psi(f) \vee
\psi(g)\)</span>. </div></li>
</ul>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(f \in \mathcal{F}\)</span>, <span
class="math inline">\(\psi(\varphi(f)) \equiv f\)</span> et <span
class="math inline">\(\psi(\varphi(f))\)</span> est en forme normale
conjonctive.</p>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il est possible d’obtenir ainsi une formule de taille
exponentielle.</p>
<p>L’exemple caractéristique est <span class="math display">\[
\bigvee_{i=1}^n (X_{i,1} \wedge X_{i,2})
\equiv \bigwedge_{a_1 \in \{1,2\}, \dots, a_n \in \{1,2\}}
\left(
X_{1,a_1} \wedge \dots \wedge X_{n,a_n}
\right)
\]</span></p>
<p>On passe ainsi d’une formule de taille <span
class="math inline">\(O(n)\)</span> à une formule de taille <span
class="math inline">\(O(2^n)\)</span>.</p>
<p></div></p>
<p>Il est possible d’implémenter directement cette méthode :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">type</span> formula = Var <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>    | And <span class="kw">of</span> formula * formula</span>
<span id="cb21-3"><a href="#cb21-3"></a>    | Or <span class="kw">of</span> formula * formula</span>
<span id="cb21-4"><a href="#cb21-4"></a>    | Not <span class="kw">of</span> formula</span>
<span id="cb21-5"><a href="#cb21-5"></a></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="kw">let</span> <span class="kw">rec</span> elim_not f = <span class="kw">match</span> f <span class="kw">with</span></span>
<span id="cb21-7"><a href="#cb21-7"></a>    | Var s -&gt; Var s</span>
<span id="cb21-8"><a href="#cb21-8"></a>    | Not (Var s) -&gt; Not (Var s)</span>
<span id="cb21-9"><a href="#cb21-9"></a>    | Not (Not f) -&gt; elim_not f</span>
<span id="cb21-10"><a href="#cb21-10"></a>    | Not (Or (f1,f2)) -&gt; And( elim_not(Not f1), elim_not(Not f2) )</span>
<span id="cb21-11"><a href="#cb21-11"></a>    | Not (And (f1,f2)) -&gt; Or( elim_not(Not f1), elim_not(Not f2) )</span>
<span id="cb21-12"><a href="#cb21-12"></a>    | Or(f1, f2) -&gt; Or(elim_not f1, elim_not f2)</span>
<span id="cb21-13"><a href="#cb21-13"></a>    | And(f1, f2) -&gt; And(elim_not f1, elim_not f2)</span>
<span id="cb21-14"><a href="#cb21-14"></a></span>
<span id="cb21-15"><a href="#cb21-15"></a><span class="kw">let</span> <span class="kw">rec</span> distrib_or f = <span class="kw">match</span> f <span class="kw">with</span></span>
<span id="cb21-16"><a href="#cb21-16"></a>    | Var _ -&gt; f</span>
<span id="cb21-17"><a href="#cb21-17"></a>    | Not (Var _) -&gt; f</span>
<span id="cb21-18"><a href="#cb21-18"></a>    | And(f1,f2) -&gt; And(distrib_or f1, distrib_or f2)</span>
<span id="cb21-19"><a href="#cb21-19"></a>    | Or(f1,f2) -&gt; <span class="kw">begin</span></span>
<span id="cb21-20"><a href="#cb21-20"></a>            <span class="kw">match</span> distrib_or f1 <span class="kw">with</span></span>
<span id="cb21-21"><a href="#cb21-21"></a>            | And(f11, f12) -&gt; And(distrib_or (Or(f11,f2)), </span>
<span id="cb21-22"><a href="#cb21-22"></a>                                   distrib_or (Or(f12,f2)))</span>
<span id="cb21-23"><a href="#cb21-23"></a>            | f1&#39; -&gt; <span class="kw">match</span> distrib_or f2 <span class="kw">with</span></span>
<span id="cb21-24"><a href="#cb21-24"></a>                | And (f21, f22) -&gt; And(distrib_or(Or(f1&#39;, f21)), </span>
<span id="cb21-25"><a href="#cb21-25"></a>                                        distrib_or(Or(f1&#39;,f22)))</span>
<span id="cb21-26"><a href="#cb21-26"></a>                | f2&#39; -&gt; Or(f1&#39;, f2&#39;)</span>
<span id="cb21-27"><a href="#cb21-27"></a>            <span class="kw">end</span></span>
<span id="cb21-28"><a href="#cb21-28"></a>    | _ -&gt; <span class="dt">failwith</span> <span class="st">&quot;Formule avec négation en dehors des littéraux&quot;</span></span>
<span id="cb21-29"><a href="#cb21-29"></a></span>
<span id="cb21-30"><a href="#cb21-30"></a><span class="kw">let</span> fnc f = distrib_or (elim_not f)</span></code></pre></div>
<p></div></p>
<h1 data-number="4" id="sec:problème-sat"><span
class="header-section-number">4</span> Problème SAT</h1>
<h2 data-number="4.1" id="sec:définition"><span
class="header-section-number">4.1</span> Définition</h2>
<p>Un des problèmes les plus importants en logique et plus largement en
informatique est le problème SAT :</p>
<div class="ui message gray">
<div class="header">
Problème - SAT
</div>
<ul>
<li>
<p>Entrée(s) :</p>
<p>Une formule <span class="math inline">\(f\)</span>, le plus souvent
en FNC.</p>
</li>
<li>
<p>Sortie :</p>
<p>Un booléen indiquant si <span class="math inline">\(f\)</span> est
satisfiable.</p>
</li>
</ul>
</div>
<h2 data-number="4.2" id="sec:k-sat"><span
class="header-section-number">4.2</span> <span
class="math inline">\(k\)</span>-SAT</h2>
<p>Le problème suivant permet un plus grand contrôle sur les
formules.</p>
<div class="ui message gray">
<div class="header">
Problème - <span class="math inline">\(k\)</span>-SAT
</div>
<ul>
<li>
<p>Entrée(s) :</p>
<p>Une formule <span class="math inline">\(f\)</span> en FNC dont les
clauses comportent au plus <span class="math inline">\(k\)</span>
littéraux.</p>
</li>
<li>
<p>Sortie :</p>
<p>Un booléen indiquant si <span class="math inline">\(f\)</span> est
satisfiable.</p>
</li>
</ul>
</div>
<p>Naturellement, si on sait résoudre <span
class="math inline">\(k\)</span>-SAT pour tout <span
class="math inline">\(k\)</span>, alors on sait résoudre SAT vu que les
formules sont finies.</p>
<h2 data-number="4.3" id="sec:sat"><span
class="header-section-number">4.3</span> 1-SAT</h2>
<p>Les formules à résoudre sont des conjonctions de littéraux vu que les
clauses sont réduites à un littéral. Or, soit cette conjonction contient
deux littéraux opposés auxquel cas <span class="math inline">\(f \equiv
\perp\)</span>, ou alors elle est satisfiable en considérant <span
class="math inline">\(v(X) = V\)</span> si <span
class="math inline">\(X\)</span> apparait positivement ou <span
class="math inline">\(v(X) = F\)</span> si elle apparait
négativement.</p>
<h2 data-number="4.4" id="sec:sat-1"><span
class="header-section-number">4.4</span> 2-SAT</h2>
<p>Pour résoudre 2-SAT on va construire un graphe en transformant les
clauses en implications :</p>
<p><span class="math display">\[
X \vee Y
\iff \neg X \rightarrow Y
\iff \neg Y \rightarrow X
\]</span> <span class="math display">\[
\neg X \vee Y
\iff X \rightarrow Y
\iff \neg Y \rightarrow \neg X
\]</span> <span class="math display">\[
\neg X \vee \neg Y
\iff X \rightarrow \neg Y
\iff Y \rightarrow \neg X
\]</span></p>
<p>On peut alors construire un graphe où les sommets sont les littéraux
apparaissant dans une formule ainsi que leur négation, et où l’on relie
<span class="math inline">\(l\)</span> et <span
class="math inline">\(l&#39;\)</span> quand une clause est équivalente à
<span class="math inline">\(l \rightarrow l&#39;\)</span>.</p>
<p>Un chemin dans ce graphe est une chaine d’implication. On peut
montrer que <span class="math inline">\(f\)</span> est satisfiable si et
seulement un littéral n’est jamais relié à son opposé. Or, pour
déterminer cela, il suffit de calculer la fermeture transitive du
graphe, par exemple avec des parcours successifs, ou avec
Floyd-Warshall. Cela se fait donc en temps et en espace polynomial dans
le nombre de variables.</p>
<h2 data-number="4.5" id="sec:sat-2"><span
class="header-section-number">4.5</span> 3-SAT</h2>
<p>On peut montrer un théorème assurant que ce chapitre aura un nombre
fini de paragraphes :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Si on sait résoudre 3-SAT alors on sait résoudre <span
class="math inline">\(k\)</span>-SAT pour tout <span
class="math inline">\(k\)</span>.</p>
</div>
<p>Cependant, comme on en reparlera dans le chapitre sur la
NP-complétude, le problème 3-SAT est <em>a priori</em> très difficile et
on a peu d’espoir de pouvoir le résoudre de manière générale autrement
qu’en énumérant les <span class="math inline">\(2^n\)</span>
valuations.</p>
<h2 data-number="4.6" id="sec:algorithme-de-quine"><span
class="header-section-number">4.6</span> Algorithme de Quine</h2>
<p>L’algorithme de Quine consiste à construire un arbre de décision
associé à une formule <span class="math inline">\(f\)</span>
inductivement ainsi :</p>
<ul>
<li>si <span class="math inline">\(f\)</span> est sans variable, <span
class="math inline">\(f \equiv top\)</span> ou <span
class="math inline">\(\perp\)</span> et on renvoie une feuille avec
cette valeur.</li>
<li>sinon on considère une variable <span
class="math inline">\(X\)</span> quelconque dans <span
class="math inline">\(f\)</span> et on renvoie l’arbre dont la racine
est étiquetée par <span class="math inline">\(X\)</span>, a pour fils
gauche l’arbre associé à <span class="math inline">\(f[\perp/X]\)</span>
et pour fils droit l’arbre associé à <span
class="math inline">\(f[\top/X]\)</span>.</li>
</ul>
<p>Si <span class="math inline">\(f\)</span> est satisfiable, alors cet
arbre a une feuille de valeur de <span
class="math inline">\(\top\)</span>. Il suffit alors de lire les
embranchements pour retrouver le modèle correspondant.</p>
<p>Si <span class="math inline">\(f\)</span> est une tautologie, toutes
ses feuilles sont étiquettes par <span
class="math inline">\(\top\)</span>.</p>
<p>On donne ici une implémentation rapide de cet algorithme :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb22-1"><a href="#cb22-1"></a>../../snippets/logique/quine.ml</span></code></pre></div>
<p></div></p>
<p><center><div class="ui image center"><img
src="assets/pics/voisinages.png" /></div></center></p>
<p><center><div class="ui image center"><img
src="assets/pics/tab2hex.png" /></div></center></p>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
