<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Complexité amortie</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

.ui.styled.accordion {
    width: 100% !important;
    font-size: 1rem !important;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\gO{\mathcal{O}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Complexité amortie
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:introduction"><span>1</span> Introduction</a><div class="menu"><a class="item" href="#sec:implémentation-dune-file-avec-deux-piles"><div class="ui label">1.1</div> Implémentation d’une file avec deux piles</a><a class="item" href="#sec:comptabdyn"><div class="ui label">1.2</div> Les tableaux dynamiques</a></div></div><div class="item header"> <a href="#sec:techniques-de-calcul"><span>2</span> Techniques de calcul</a><div class="menu"><a class="item" href="#sec:cadre"><div class="ui label">2.1</div> Cadre</a><a class="item" href="#sec:calcul-naïf"><div class="ui label">2.2</div> Calcul naïf</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:exemple-de-la-file-avec-deux-piles"><i class="circle icon"></i> Exemple de la file avec deux piles</a><a style="font-size:0.6em" class="item" href="#sec:exemple-du-tableau-dynamique"><i class="circle icon"></i> Exemple du tableau dynamique</a><a style="font-size:0.6em" class="item" href="#sec:améliorer-la-méthode-naïve"><i class="circle icon"></i> Améliorer la méthode naïve</a></div><a class="item" href="#sec:méthode-du-banquier"><div class="ui label">2.3</div> Méthode du banquier</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:exemple-de-la-file-avec-deux-piles-1"><i class="circle icon"></i> Exemple de la file avec deux piles</a><a style="font-size:0.6em" class="item" href="#sec:exemple-du-tableau-dynamique-1"><i class="circle icon"></i> Exemple du tableau dynamique</a><a style="font-size:0.6em" class="item" href="#sec:présentation-de-la-méthode"><i class="circle icon"></i> Présentation de la méthode</a></div><a class="item" href="#sec:méthode-du-potentiel"><div class="ui label">2.4</div> Méthode du potentiel</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:exemple-de-la-file-avec-deux-piles-2"><i class="circle icon"></i> Exemple de la file avec deux piles</a><a style="font-size:0.6em" class="item" href="#sec:exemple-du-tableau-dynamique-2"><i class="circle icon"></i> Exemple du tableau dynamique</a><a style="font-size:0.6em" class="item" href="#sec:comparatif-des-méthodes"><i class="circle icon"></i> Comparatif des méthodes</a></div></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Complexité amortie
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Complexité amortie     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_analyse_algo.png"> </div></p>
<p><em>Source de l’image d’en-tête <a href="https://xkcd.com/1667/">XKCD #1667</a></em></p>
<h1 data-number="1" id="sec:introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>Dans le cadre de l’étude des structures de données, il est fréquent de considérer non pas la complexité dans le pire des cas d’une opération mais celle d’une succession d’opérations divisée par le nombre d’opérations effectuées. Ainsi, on peut très bien avoir une opération ponctuellement plus coûteuse que les autres, mais en procédant ainsi on lisse le surcoût sur l’ensemble des opérations. On parle alors de <strong>complexité amortie</strong>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Cette notion ne masque pas le fait qu’une opération puisse prendre ponctuellement plus de temps. Dans des contextes temps réel où il est important de maitriser pleinement les complexités, il est peu judicieux d’utiliser de telles complexités. Par exemple, dans une visualisation en 3D, pour maintenir un débit constant d’images par secondes, chaque image doit prendre un temps similaire. Se reposer sur une structure de donnée ayant une faible complexité amortie mais une complexité dans le pire des cas importante, c’est risquer d’avoir des saccades avec une image qui prendrait plus de temps pour être calculée.</div></p>
<p>On va reprendre ici deux exemples simples déjà traité par ailleurs.</p>
<h2 data-number="1.1" id="sec:implémentation-dune-file-avec-deux-piles"><span class="header-section-number">1.1</span> Implémentation d’une file avec deux piles</h2>
<p>On considère une file réalisée avec deux piles <code>in</code> et <code>out</code> (voir le chapitre <a href="chap_structuresdonnees_pilesfiles.html#sec:filedeuxpiles">Piles et files</a>).</p>
<p>Comme on l’a vu, on enfile en <span class="math inline">\(O(1)\)</span> en empilant sur la pile <code>in</code> et on défile :</p>
<ul>
<li>soit en <span class="math inline">\(O(1)\)</span> en dépilant sur <code>out</code> si elle est non vide</li>
<li>soit en <span class="math inline">\(O(n)\)</span> en déversant <code>in</code> dans <code>out</code> puis en se ramenant au cas précédent.</li>
</ul>
<p>Ainsi, en pire cas, on est en <span class="math inline">\(O(n)\)</span> pour l’opération <em>défiler</em> mais la bascule permettra de faire ensuite cette même opération en <span class="math inline">\(O(1)\)</span>.</p>
<h2 data-number="1.2" id="sec:comptabdyn"><span class="header-section-number">1.2</span> Les tableaux dynamiques</h2>
<p>Les tableaux dynamiques sont une structure de données de haut niveau pour implémenter le type abstrait des listes. La différence principale entre cette structure de données et celle des tableaux de C est qu’on peut ajouter et supprimer des éléments.</p>
<p>Un tableau dynamique d’entiers est un triplet <code>(t,c,l)</code> où <code>t</code> est un tableau de taille <code>c</code>, appelée la capacité du tableau dynamique, et <code>l</code> est un autre entier représentant la longueur logique du tableau. A tout moment <span class="math inline">\(c \ge l\)</span>. Dans <code>t</code> il y a ainsi <span class="math inline">\(c-l\)</span> cases déjà allouées qui permettent de rajouter un élément en temps constant. Quand <span class="math inline">\(c=l\)</span>, on alloue une nouvelle zone mémoire, souvent de taille <span class="math inline">\(2c\)</span>, on déplace le tableau <code>t</code> dans cette zone et on a donc pour cet ajout prévu un certain nombre de cases d’avance.</p>
<p>La figure suivante présente une succession d’ajouts :</p>
<p><center><div class="ui image center"><img src="assets/pics/tableau_dyn.png" /></div></center></p>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Complément </div> <div class="content"> Une implémentation de ces opérations est proposée dans le programme suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="dt">int</span> <span class="op">*</span>t<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="dt">size_t</span> c<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="dt">size_t</span> l<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="op">}</span> tableau_dynamique <span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a>tableau_dynamique tableau_dynamique_creer<span class="op">()</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    tableau_dynamique d<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a>    d<span class="op">.</span>t <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>    d<span class="op">.</span>c <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>    d<span class="op">.</span>l <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17"></a></span>
<span id="cb1-18"><a href="#cb1-18"></a>    <span class="cf">return</span> d<span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="op">}</span></span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="dt">void</span> tableau_dynamique_ajout<span class="op">(</span>tableau_dynamique <span class="op">*</span>d<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="cf">if</span> <span class="op">(</span>d<span class="op">-&gt;</span>c <span class="op">==</span> d<span class="op">-&gt;</span>l<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-24"><a href="#cb1-24"></a>        <span class="cf">if</span> <span class="op">(</span>d<span class="op">-&gt;</span>c <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>        <span class="op">{</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>            d<span class="op">-&gt;</span>c <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>            d<span class="op">-&gt;</span>t <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>        <span class="op">}</span></span>
<span id="cb1-29"><a href="#cb1-29"></a>        <span class="cf">else</span></span>
<span id="cb1-30"><a href="#cb1-30"></a>        <span class="op">{</span></span>
<span id="cb1-31"><a href="#cb1-31"></a>            d<span class="op">-&gt;</span>c <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> d<span class="op">-&gt;</span>c<span class="op">;</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>            d<span class="op">-&gt;</span>t <span class="op">=</span> realloc<span class="op">(</span>d<span class="op">-&gt;</span>t<span class="op">,</span> d<span class="op">-&gt;</span>c <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb1-33"><a href="#cb1-33"></a>        <span class="op">}</span></span>
<span id="cb1-34"><a href="#cb1-34"></a>    <span class="op">}</span></span>
<span id="cb1-35"><a href="#cb1-35"></a>    d<span class="op">-&gt;</span>t<span class="op">[</span>d<span class="op">-&gt;</span>l<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>    d<span class="op">-&gt;</span>l<span class="op">++;</span></span>
<span id="cb1-37"><a href="#cb1-37"></a><span class="op">}</span></span>
<span id="cb1-38"><a href="#cb1-38"></a></span>
<span id="cb1-39"><a href="#cb1-39"></a><span class="dt">void</span> tableau_dynamique_print<span class="op">(</span>tableau_dynamique d<span class="op">)</span></span>
<span id="cb1-40"><a href="#cb1-40"></a><span class="op">{</span></span>
<span id="cb1-41"><a href="#cb1-41"></a>    printf<span class="op">(</span><span class="st">&quot;c=%d</span><span class="sc">\t</span><span class="st">l=%d</span><span class="sc">\t</span><span class="st">|&quot;</span><span class="op">,</span> d<span class="op">.</span>c<span class="op">,</span> d<span class="op">.</span>l<span class="op">);</span></span>
<span id="cb1-42"><a href="#cb1-42"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> d<span class="op">.</span>l<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-43"><a href="#cb1-43"></a>        printf<span class="op">(</span><span class="st">&quot;%d|&quot;</span><span class="op">,</span> d<span class="op">.</span>t<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-44"><a href="#cb1-44"></a>    <span class="op">}</span></span>
<span id="cb1-45"><a href="#cb1-45"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> d<span class="op">.</span>l<span class="op">;</span> i <span class="op">&lt;</span> d<span class="op">.</span>c<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-46"><a href="#cb1-46"></a>        printf<span class="op">(</span><span class="st">&quot; |&quot;</span><span class="op">);</span></span>
<span id="cb1-47"><a href="#cb1-47"></a>    <span class="op">}</span></span>
<span id="cb1-48"><a href="#cb1-48"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-49"><a href="#cb1-49"></a><span class="op">}</span></span>
<span id="cb1-50"><a href="#cb1-50"></a></span>
<span id="cb1-51"><a href="#cb1-51"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-52"><a href="#cb1-52"></a>    tableau_dynamique d <span class="op">=</span> tableau_dynamique_creer<span class="op">();</span></span>
<span id="cb1-53"><a href="#cb1-53"></a>    tableau_dynamique_print<span class="op">(</span>d<span class="op">);</span> </span>
<span id="cb1-54"><a href="#cb1-54"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">6</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-55"><a href="#cb1-55"></a>        tableau_dynamique_ajout<span class="op">(&amp;</span>d<span class="op">,</span>i<span class="op">);</span></span>
<span id="cb1-56"><a href="#cb1-56"></a>        tableau_dynamique_print<span class="op">(</span>d<span class="op">);</span> </span>
<span id="cb1-57"><a href="#cb1-57"></a>    <span class="op">}</span></span>
<span id="cb1-58"><a href="#cb1-58"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>Ce programme, une fois exécuté produit la sortie suivante qui permet de retrouver exactement le comportement attendu :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a>c<span class="op">=</span><span class="dv">0</span> l<span class="op">=</span><span class="dv">0</span> <span class="op">|</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>c<span class="op">=</span><span class="dv">1</span> l<span class="op">=</span><span class="dv">1</span> <span class="op">|</span><span class="dv">1</span><span class="op">|</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>c<span class="op">=</span><span class="dv">2</span> l<span class="op">=</span><span class="dv">2</span> <span class="op">|</span><span class="dv">1</span><span class="op">|</span><span class="dv">2</span><span class="op">|</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>c<span class="op">=</span><span class="dv">4</span> l<span class="op">=</span><span class="dv">3</span> <span class="op">|</span><span class="dv">1</span><span class="op">|</span><span class="dv">2</span><span class="op">|</span><span class="dv">3</span><span class="op">|</span> <span class="op">|</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>c<span class="op">=</span><span class="dv">4</span> l<span class="op">=</span><span class="dv">4</span> <span class="op">|</span><span class="dv">1</span><span class="op">|</span><span class="dv">2</span><span class="op">|</span><span class="dv">3</span><span class="op">|</span><span class="dv">4</span><span class="op">|</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>c<span class="op">=</span><span class="dv">8</span> l<span class="op">=</span><span class="dv">5</span> <span class="op">|</span><span class="dv">1</span><span class="op">|</span><span class="dv">2</span><span class="op">|</span><span class="dv">3</span><span class="op">|</span><span class="dv">4</span><span class="op">|</span><span class="dv">5</span><span class="op">|</span> <span class="op">|</span> <span class="op">|</span> <span class="op">|</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>Avec une analyse en pire cas, l’ajout d’un élément peut entrainer un doublement de taille et une recopie, donc coûter <span class="math inline">\(O(c)\)</span> opérations où <span class="math inline">\(c\)</span> est la capacité avant doublement. Cependant, on constate que ce doublement permettra plusieurs ajouts ensuite en temps constant, ainsi, le pire cas ne semble pas le plus pertinent.</p>
<h1 data-number="2" id="sec:techniques-de-calcul"><span class="header-section-number">2</span> Techniques de calcul</h1>
<h2 data-number="2.1" id="sec:cadre"><span class="header-section-number">2.1</span> Cadre</h2>
<p>On considère une structure de données, pour simplifier initialemetn vide, et une sucessions <span class="math inline">\(o_1, ..., o_n\)</span> d’opérations <strong>valides</strong> sur cette structure de donnée. En reprenant l’exemple précédent, cela peut être une succession d’ajouts ou de suppressions dans une file mais sans jamais essayer de retirer des éléments à une file vide.</p>
<p>On considère de plus que pour chaque opération <span class="math inline">\(o_i\)</span>, on connait le coût temporel <span class="math inline">\(c_i\)</span> en terme d’opérations élémentaires. La question que l’on se pose est d’estimer <span class="math inline">\(\frac{1}{n} \sum_{i=1}^n c_i\)</span>, c’est-à-dire le coût moyen de chaque opération. L’objectif est de montrer que ce coût moyen est <span class="math inline">\(O(f(n))\)</span>, avec assez souvent <span class="math inline">\(O(1)\)</span>, c’est-à-dire que <span class="math inline">\(\sum_{i=1}^n c_i = O(n f(n))\)</span>.</p>
<h2 data-number="2.2" id="sec:calcul-naïf"><span class="header-section-number">2.2</span> Calcul naïf</h2>
<p>Une approche näive consiste à calculer directement la somme des coûts. Tout le problème ici est qu’on ne connait pas les opérations et l’ordre dans lequel elles ont été effectuées.</p>
<h3 data-number="2.2.1" id="sec:exemple-de-la-file-avec-deux-piles"><span class="header-section-number">2.2.1</span> Exemple de la file avec deux piles</h3>
<p>On va commencer par calculer <span class="math inline">\(c_i\)</span> pour les différentes opérations :</p>
<ul>
<li>S’il s’agit d’un ajout sur <code>in</code> ou d’un dépilement sur <code>out</code>, on a <span class="math inline">\(c_i = 1\)</span></li>
<li>Si l’opération est un dépilement nécessitant un renversement, on a <span class="math inline">\(c_i = 2 p + 1\)</span> où <span class="math inline">\(p\)</span> est la taille de <code>in</code>.</li>
</ul>
<p>Le problème du calcul naïf ici est de connaitre l’ordre des opérations. On peut regrouper les opérations <span class="math inline">\(o_1,\dots,o_n\)</span> par paquet : ajouts, suppression avec renversement, ajouts ou suppressions sans reversement, suppression avec renversement… On va noter <span class="math inline">\(p_i\)</span> la taille de <code>in</code> avant le ième renversement. On a donc <span class="math inline">\(p_{i+1}\)</span> ajouts entre le ième et le (i+1)ème renversement. Ainsi, on a effectué <span class="math inline">\(p_i-1\)</span> suppressions sans renversements entre les deux.</p>
<p>Comme cela correspond au pire cas, on peut supposer que <span class="math inline">\(o_n\)</span> est une suppression avec renversement.</p>
<p>On obtient alors <span class="math display">\[\begin{eqnarray*}
\sum_{i=1}^n c_i 
&amp;=&amp; p_1 + (2 p_1 + 1) + p_2 + (p_1 - 1)
+ (2 p_2 + 1) \\
&amp; &amp; + \dots + 
p_r + (p_{r-1} - 1) + (2 p_r + 1)
\\
&amp;\le &amp; 4 (p_1 + p_2 + \dots + p_r)
\end{eqnarray*}\]</span></p>
<p>Pour conclure, il est nécessaire de relier le nombre d’opérations aux <span class="math inline">\(p_i\)</span>. Or, on a <span class="math display">\[\begin{eqnarray*}
n &amp;=&amp; p_1 + 1 + p_2 + p_1 - 1 + \dots + p_r
+ p_{r-1} - 1 + 1\\
&amp;= &amp; 2 p_1 + 2 p_2 + \dots + 2 p_{r-1} + p_r
\ge p_1 + \dots + p_r
\end{eqnarray*}\]</span></p>
<p>Ainsi <span class="math inline">\(\frac{1}{n} \sum_{i=1}^n c_i \le 4\)</span>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Cette analyse est assez pénible à mettre en oeuvre car elle demande de compter avec précision ce qui se passe.</div></p>
<h3 data-number="2.2.2" id="sec:exemple-du-tableau-dynamique"><span class="header-section-number">2.2.2</span> Exemple du tableau dynamique</h3>
<p>Ici, les opérations sont toutes des ajouts d’éléments, mais certains provoquent une recopie tandis que d’autres sont en temps constant. Cependant, on a la même distribution des coûts, la suite des <span class="math inline">\(c_i\)</span> est toujours <span class="math inline">\(1, 2, 3, 1, 5, 1, 1, 1, 9, 1, 1, 1, ...\)</span>.</p>
<p>Plus précisément, <span class="math inline">\(c_i = \begin{cases} 2^p+1 &amp; \text{si } i = 2^p+1 \\ 1 &amp; \text{sinon} \end{cases}\)</span>.</p>
<p>Donc si <span class="math inline">\(2^{p-1} &lt; n \le 2^p\)</span> on a <span class="math inline">\(\sum_{i=1}^n c_i = n + \sum_{k=1}^{p-1} 2^k = n + 2^p \le 3n\)</span>.</p>
<p>On en déduit que <span class="math inline">\(\frac{1}{n} \sum_{i=1}^n c_i \le 3\)</span> c’est-à-dire que c’est un <span class="math inline">\(O(1)\)</span>.</p>
<h3 data-number="2.2.3" id="sec:améliorer-la-méthode-naïve"><span class="header-section-number">2.2.3</span> Améliorer la méthode naïve</h3>
<p>Une amélioration de la méthode naïve va consister à considérer non pas le coût réel <span class="math inline">\(c_i\)</span> de l’opération <span class="math inline">\(o_i\)</span> mais un coût amorti <span class="math inline">\(c&#39;_i\)</span> tel qu’à la fin des opérations on ait <span class="math inline">\(\sum_{i=1}^n c_i \le \sum_{i=1}^n c&#39;_i\)</span> où cette dernière somme est facile à majorer.</p>
<p>On fera souvent en sorte que la majoration soit valide tout au long des opérations, c’est-à-dire que <span class="math display">\[
\forall k \in \range{1}{n}, \sum_{i=1}^k c_i 
\le \sum_{i=1}^k c&#39;_i
\]</span></p>
<h2 data-number="2.3" id="sec:méthode-du-banquier"><span class="header-section-number">2.3</span> Méthode du banquier</h2>
<p>On va imaginer maintenant que les opérations coûtent un certain nombre de crédits, comme si l’ordinateur marchait avec des pièces de monnaie.</p>
<p>Des opérations vont alors accumuler des crédits dans une réserve et d’autres opérations vont consommer ces crédits. L’idée est de payer un peu plus pour chaque opération peu coûteues afin de couvrir les coûts des opérations coûteuses.</p>
<p>Précisément, on considère pour chaque opération <span class="math inline">\(o_i\)</span> :</p>
<ul>
<li>une quantité <span class="math inline">\(a_i\)</span> de crédits qui seront accumulés dans la réserve</li>
<li>et une quantité <span class="math inline">\(d_i\)</span> de crédits qu’il faudra dépenser.</li>
</ul>
<p>On pose alors <span class="math inline">\(c&#39;_i = c_i + a_i - d_i\)</span>. On s’arrange pour faire en sorte que <span class="math inline">\(c&#39;_i \le A f(n)\)</span> où <span class="math inline">\(A\)</span> est une constante. Dans le cas d’une complexité constante amortie, on s’assurera que <span class="math inline">\(c&#39;_i \le A\)</span>.</p>
<p>On va maintenir un invariant sur les crédits qui est que <span class="math display">\[
\forall k \in \range{1}{n},
\sum_{i=1}^k a_i \ge \sum_{i=1}^k d_i
\]</span> Cela signifie qu’à tout moment la réserve de crédit est positive ou nulle : on ne dépense pas de crédits n’ayant pas été accumulés.</p>
<p>On a alors directement la majoration voulu de <span class="math inline">\(\sum_i c_i\)</span> : soit <span class="math inline">\(k \in \range{1}{n}\)</span>, <span class="math display">\[
\sum_{i=1}^k c&#39;_i = \sum_{i=1}^k c_i + 
\left( \sum_{i=1}^k a_i - \sum_{i=1}^k d_i \right)
\ge \sum_{i=1}^k c_i
\]</span></p>
<h3 data-number="2.3.1" id="sec:exemple-de-la-file-avec-deux-piles-1"><span class="header-section-number">2.3.1</span> Exemple de la file avec deux piles</h3>
<p>Pour chaque élément enfilé on va allouer deux crédits correspondant au futur dépilement de <code>in</code> puis empilement sur <code>out</code> qui auront lieu lors du renversement.</p>
<p>On pose donc pour chaque opération <span class="math inline">\(o_i\)</span>, <span class="math inline">\(c&#39;_i = c_i + a_i - d_i\)</span> où :</p>
<ul>
<li><span class="math inline">\(a_i = 2\)</span> et <span class="math inline">\(d_i = 0\)</span> si l’opération est un ajout</li>
<li><span class="math inline">\(a_i = d_i = 0\)</span> si l’opération est un défilement ne nécessitant pas de renversement</li>
<li><span class="math inline">\(a_i = 0\)</span> et <span class="math inline">\(d_i = 2 p\)</span> où <span class="math inline">\(p\)</span> est la taille de <code>in</code> dans le cas d’un défilement provoquant un renversement.</li>
</ul>
<p>On a donc <span class="math inline">\(\sum_{i=1}^k a_i = 2 A\)</span> où <span class="math inline">\(A\)</span> est le nombre d’ajouts effectués par les <span class="math inline">\(k\)</span> premières opérations. Si on a effectué des renversements successifs de <span class="math inline">\(p_1, p_2, \dots, p_r\)</span> éléments dans <code>in</code>, on a <span class="math display">\[\begin{eqnarray*}
\sum_{i=1}^k d_i &amp; = &amp; 2 p_1 + \dots + 2 p_r \\
&amp; = &amp; 2(p_1 + \dots + p_r) \\
&amp; \le &amp; 2 A \\
&amp; \le &amp; \sum_{i=1}^k a_i
\end{eqnarray*}\]</span></p>
<p>La majoration venant du fait qu’un élément n’est ajouté qu’une seule fois dans <code>in</code> et donc que la somme <span class="math inline">\(p_1+\dots+p_r\)</span> des longueurs de <code>in</code> au cours des opérations ne peut dépasser le nombre <span class="math inline">\(A\)</span> d’éléments empilés.</p>
<p>On a ainsi vérifié l’invariant sur les crédits et on a donc la majoration <span class="math inline">\(\sum_{i=1}^k c_i \le \sum_{i=1}^k c&#39;_i\)</span>.</p>
<p>Pour conclure, il suffit de calculer <span class="math inline">\(c&#39;_i\)</span> selon les cas :</p>
<ul>
<li>Si l’opération est un ajout, on a <span class="math inline">\(c&#39;_i = 1 + 2 - 0 = 3\)</span>.</li>
<li>Si l’opération est une suppression sans renversement, on a <span class="math inline">\(c&#39;_i = 1\)</span></li>
<li>Si l’opération est une suppression avec renversement, on a <span class="math inline">\(c&#39;_i = 2 p + 1 + 0 - 2p = 1\)</span></li>
</ul>
<p>Dans tous les cas, on a donc <span class="math inline">\(c&#39;_i \le 3\)</span>.</p>
<p>On en déduit la majoration <span class="math inline">\(\sum_{i=1}^n c_i \le \sum_{i=1}^n c&#39;_i \le 3 n\)</span> qui est plus fine que la majoration obtenue précédemment.</p>
<h3 data-number="2.3.2" id="sec:exemple-du-tableau-dynamique-1"><span class="header-section-number">2.3.2</span> Exemple du tableau dynamique</h3>
<p>On va considérer qu’on alloue 2 crédits pour chaque opération d’ajout d’un élément :</p>
<ul>
<li>Un crédit pour la première recopie de cet élément</li>
<li>Un crédit pour copier l’élément qui lui est symétrique par rapport à la demi-capacité :</li>
</ul>
<p><center><div class="ui image center"><img src="assets/pics/ca_tab_dyn1.png" /></div></center></p>
<p>Ainsi, juste avant un doublement de capacité, on dispose d’un crédit pour chaque recopie :</p>
<p><center><div class="ui image center"><img src="assets/pics/ca_tab_dyn2.png" /></div></center></p>
<p>Plus précisément, on définit pour chaque opération <span class="math inline">\(o_i\)</span> : <span class="math inline">\(c&#39;_i = c_i + a_i - d_i\)</span> où <span class="math inline">\(a_i = \begin{cases} 1 &amp; \text{si } i = 1 \\ 2 &amp; \text{sinon}\end{cases}\)</span> et <span class="math inline">\(d_i = \begin{cases} 2^p &amp; \text{si } i = 2^p+1 \\ 0 &amp; \text{sinon} \end{cases}\)</span>.</p>
<p>On a donc <span class="math inline">\(c&#39;_i = 3\)</span> dans tous les cas.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><span class="math inline">\(\forall n \in \N^*, \sum_{i=1}^n a_i \ge \sum_{i=1}^n d_i\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> On a <span class="math inline">\(\sum_{i=1}^n a_i = 2n - 1\)</span> et si <span class="math inline">\(2^p &lt; n \le 2^{p+1}\)</span>,</p>
<p><span class="math display">\[\begin{eqnarray*}
\sum_{i=1}^n d_i 
&amp; = &amp; d_2 + d_3 + d_5 + \dots + d_{2^p+1} \\
&amp; = &amp; 1 + 2 + 2^2 + \dots + 2^p \\
&amp; = &amp; 2^{p+1} - 1
 \le 2 n - 1
\end{eqnarray*}\]</span></p>
<p>L’inégalité est bien vérifiée. </div> </div></p>
<p>Ainsi, <span class="math display">\[3 n = \sum_{i=1}^n c&#39;_i = \sum_{i=1}^n c_i + 
\left( \sum_{i=1}^n a_i - \sum_{i=1}^n d_i \right)
\ge \sum_{i=1}^n c_i\]</span></p>
<p>On retombe sur une complexité amortie en <span class="math inline">\(O(1)\)</span>.</p>
<h3 data-number="2.3.3" id="sec:présentation-de-la-méthode"><span class="header-section-number">2.3.3</span> Présentation de la méthode</h3>
<p>La présentation qui vient d’être faiter de cette méthode est assez lourde bien que précise. En général, on se contente de présenter informellement la distribution de crédits en s’assurant qu’on a couvert les opérations coûteuses.</p>
<p>Une manière de bien s’en assurer est de <em>décorer</em> les structures de données en rendant les crédits apparents.</p>
<p>Si on reprend les tableaux dynamiques, on va rajouter sous une case le nombre de crédits dont elle dispose. Si on reprend la séquence d’ajouts précédente on pourra la représenter ainsi :</p>
<p><center><div class="ui image center"><img src="assets/pics/tableau_dyn_credits.png" /></div></center></p>
<h2 data-number="2.4" id="sec:méthode-du-potentiel"><span class="header-section-number">2.4</span> Méthode du potentiel</h2>
<p>L’idée de la méthode du potentiel est de définir une fonction sur <span class="math inline">\(\Phi\)</span> qui associe à chaque valeur de la structure de données un nombre réel. Ce réel correspond à la notion physique de potentiel : si on considère un pendule simple dans sa trajectoire son énergie potentielle est maximale au sommet quand sa vitesse, et donc son énergie cinétique est nulle. À l’inverse son énergie potentielle est nulle au point le plus bas et sa vitesse maximale.</p>
<p><center><div class="ui image center"><img src="assets/pics/pendule.png" /></div></center></p>
<p>L’idée ici est que le potentiel va correspondre aux gains de temps obtenus par des opérations peu coûteuses. Chaque opération va ainsi faire évoluer le potentiel. On peut prendre l’image d’un empilement de tuiles de bois, comme des Kapla, chaque ajout d’une tuile de bois augmente le potentiel jusqu’à un éventuel effondrement. On retrouve ici la dualité entre les opérations rapides et les opérations coûteuses liées à un basculement.</p>
<p>Précisement, on va noter <span class="math inline">\(t_i\)</span> la structure obtenue à l’issue de l’opération <span class="math inline">\(o_i\)</span>. On considère que <span class="math inline">\(t_0\)</span> est la structure vide et <span class="math inline">\(\Phi(t_0) =0\)</span>. On pose <span class="math inline">\(c&#39;_i = c_i + \Phi(t_i) - \Phi(t_{i-1})\)</span> ce qui correspond à considérer la différence de potentiel.</p>
<p>On a donc <span class="math display">\[\sum_{i=1}^k c&#39;_i 
= \sum_{i=1}^k c_i + \sum_{i=1}^k \Phi(t_i) - \Phi(t_{i-1})
= \sum_{i=1}^k c_i + \Phi(t_k)\]</span></p>
<p>Pour conclure par une majoration de <span class="math inline">\(\sum_{i=1}^k c_i\)</span>, il suffit de s’assurer que le potentiel ne soit jamais négatif.</p>
<h3 data-number="2.4.1" id="sec:exemple-de-la-file-avec-deux-piles-2"><span class="header-section-number">2.4.1</span> Exemple de la file avec deux piles</h3>
<p>On va poser <span class="math inline">\(\Phi(t) = 2|\textsf{in}|\)</span> où <span class="math inline">\(|\textsf{in}|\)</span> est la taille de la pile d’entrée. Pour reprendre le parallèle physique, on peut s’imaginer que la pile <code>in</code> est au dessus de la pile <code>out</code> et que les éléments menacent de s’y deverser. Ce qui permet d’avoir l’image du potentiel comme pour le pendule au sommet de sa trajectoire.</p>
<p><center><div class="ui image center"><img src="assets/pics/potfile.png" /></div></center></p>
<p>On a directement la majoration car <span class="math inline">\(\Phi(t) \ge 0\)</span>.</p>
<p>Pour conclure, il faut calculer <span class="math inline">\(c&#39;_i\)</span> dans chaque cas :</p>
<ul>
<li>Si l’opération est un ajout, <code>in</code> augmente d’un élément et donc <span class="math inline">\(c&#39;_i = c_i + 2 = 3\)</span></li>
<li>Si l’opération est une suppression sans renversement, le potentiel ne change pas et <span class="math inline">\(c&#39;_i = 1\)</span></li>
<li>Si l’opération est une suppression avec renversement et que <code>in</code> contient <span class="math inline">\(p\)</span> éléments, on a <span class="math inline">\(c&#39;_i = 2 p + 1 + 0 - 2p = 1\)</span>.</li>
</ul>
<p>On retombe exactement sur le calcul précédent avec la méthodde du banquier.</p>
<h3 data-number="2.4.2" id="sec:exemple-du-tableau-dynamique-2"><span class="header-section-number">2.4.2</span> Exemple du tableau dynamique</h3>
<p>On pose ici <span class="math inline">\(\Phi(t) = 2 l(t) - c(t)\)</span> où <span class="math inline">\(l(t)\)</span> est la longueur de <span class="math inline">\(t\)</span> et <span class="math inline">\(c(t)\)</span> est sa capacité.</p>
<p>Ici, ce potentiel se comprend mieux en écrivant <span class="math inline">\(2 (l(t) - c(t)/2)\)</span> car <span class="math inline">\(l(t) - c(t)/2\)</span> correspond aux éléments ajoutés après doublement.</p>
<p>Comme <span class="math inline">\(c(t) \ge l(t) \ge \frac{c(t)}{2}\)</span> on a <span class="math inline">\(\Phi(t) \ge 0\)</span> ce qui valide la majoration.</p>
<p>On calcule <span class="math inline">\(c&#39;_i\)</span> dans les deux cas d’ajout :</p>
<ul>
<li>Si c’est un ajout sans doublement, alors <span class="math inline">\(l(t_i) = 1 + l(t_{i-1}), c(t_i) = c(t_{i-1})\)</span> et ainsi</li>
</ul>
<p><span class="math display">\[\begin{eqnarray*}
c&#39;_i &amp;=&amp; c_i + \Phi(t_i) - \Phi(t_{i-1}) \\
&amp;=&amp; 1 + 2 l(t_{i-1}) - c(t_{i-1}) 
- 2 l(t_{i-1}) + c(t_{i-1}) = 1 
\end{eqnarray*}\]</span></p>
<ul>
<li>Si c’est un ajout avec doublement de capacité, alors <span class="math inline">\(l(t_{i-1}) = c(t_{i-1}) = A\)</span>, <span class="math inline">\(l(t_i) = 1 + l(t_{i-1}) = 1 + A\)</span>, <span class="math inline">\(c(t_i) = 2 c(t_{i-1}) = 2A\)</span> et <span class="math inline">\(c_i = A+1\)</span>. On a donc :</li>
</ul>
<p><span class="math display">\[\begin{eqnarray*}
c&#39;_i &amp;=&amp; c_i + \Phi(t_i) - \Phi(t_{i-1}) \\
&amp; = &amp; A + 1 + 2(A+1) - 2A
- 2A + A  \\
&amp; = &amp; 3
\end{eqnarray*}\]</span></p>
<p>Ainsi, <span class="math inline">\(3 n \ge \sum_{i=1}^n c&#39;_i \ge \sum_{i=1}^n c_i\)</span>. On retombe sur la majoration voulue.</p>
<h3 data-number="2.4.3" id="sec:comparatif-des-méthodes"><span class="header-section-number">2.4.3</span> Comparatif des méthodes</h3>
<p>On remarque que la méthode du potentiel et la méthode du banquier sont très proches. En fait, on peut montrer qu’elles sont équivalentes. La différence entre les deux est que la méthode du banquier demande de regarder avec précision les opérations pour lesquelles il va falloir allouer des crédits alors que pour la méthode du potentiel il suffit de trouver son expression. Cependant, trouver l’expression du potentiel est parfois plus complexe que de définir les crédits.</p>
<p>On cherchera donc la méthode la mieux adaptée aux problèmes considérés. Dans l’exemple de la file, le potentiel est très facilement défini, dans le cas du tableau dynamique, la méthode du banquier peut paraitre plus naturelle.</p>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
