<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Union-Find</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

<style type="text/css">
  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

.ui.styled.accordion {
    width: 100% !important;
    font-size: 1rem !important;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
</style>

</head>
<body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\gO{\mathcal{O}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>


<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Union-Find
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:structure-de-données-abstraite-densembles-disjoints"><span>1</span> Structure de données abstraite d’ensembles disjoints</a><div class="menu"><a class="item" href="#sec:objectif-et-définition"><div class="ui label">1.1</div> Objectif et définition</a><a class="item" href="#sec:exemple-emblématique-dutilisation"><div class="ui label">1.2</div> Exemple emblématique d’utilisation</a><a class="item" href="#sec:classe-déquivalence-et-représentant"><div class="ui label">1.3</div> Classe d’équivalence et représentant</a></div></div><div class="item header"> <a href="#sec:implémentation-naïve-listes-chaînées"><span>2</span> Implémentation naïve : listes chaînées</a><div class="menu"><a class="item" href="#sec:quick-find"><div class="ui label">2.1</div> Quick-find</a><a class="item" href="#sec:quick-union"><div class="ui label">2.2</div> Quick-union</a></div></div><div class="item header"> <a href="#sec:implémentation-efficace"><span>3</span> Implémentation efficace</a><div class="menu"><a class="item" href="#sec:forêt-disjointe"><div class="ui label">3.1</div> Forêt disjointe</a><a class="item" href="#sec:union-pondérée"><div class="ui label">3.2</div> Union pondérée</a><a class="item" href="#sec:compression-de-chemins"><div class="ui label">3.3</div> Compression de chemins</a></div></div><div class="item header"> <a href="#sec:implémentation-en-c-avec-un-tableau-parent"><span>4</span> Implémentation en <code>C</code>avec un tableau <code>parent</code></a><div class="menu"></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Union-Find
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Union-Find     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_algo_exacte.png"> </div></p>
<h1 data-number="1"
id="sec:structure-de-données-abstraite-densembles-disjoints"><span
class="header-section-number">1</span> Structure de données abstraite
d’ensembles disjoints</h1>
<h2 data-number="1.1" id="sec:objectif-et-définition"><span
class="header-section-number">1.1</span> Objectif et définition</h2>
<p>On cherche à réaliser une structure permettant de manipuler des
ensembles disjoints de manière dynamique, c’est-à-dire en fusionnant des
ensembles à la volée.</p>
<p>La structure abstraite union-find est ainsi définie par :</p>
<ul>
<li>un type <code>'a uf</code> pour manipuler la collection d’ensembles
dont les élements sont de type <code>'a</code>.</li>
<li>une opération <code>makeset</code> qui étant donné un élèment <span
class="math inline">\(x\)</span> va rajouter <span
class="math inline">\(\{ x\}\)</span> à la collection.</li>
<li>une opération <code>find</code> qui associe à chaque élément <span
class="math inline">\(x\)</span>, l’ensemble qui le contient dans la
collection.</li>
<li>une opération <code>union</code> qui fusionne deux ensembles
disjoints, le plus souvent donnés par des éléments qu’ils contiennent,
donc implicitement en utilisant <code>find</code>.</li>
</ul>
<h2 data-number="1.2" id="sec:exemple-emblématique-dutilisation"><span
class="header-section-number">1.2</span> Exemple emblématique
d’utilisation</h2>
<p>On considère le problème déjà vu du calcul des composantes connexes
d’un graphe, mais avec le graphe donné à la volée, arête après arête,
par exemple lors d’un téléchargement.</p>
<p>La solution qu’on connait consiste à itérer des parcours quelconques
d’un sommet non découvert, à chaque parcours on calcule une nouvelle
composante connexe. Cet algorithme est ainsi en <span
class="math inline">\(O(|S|+|A|)\)</span>, donc linéaire, ce qui est a
priori très satisfaisant.</p>
<p>Cependant, si on rajoute une arrête, on change la nature des
composantes et il est nécessaire de refaire un parcours.</p>
<p>Avec une structure union-find, on peut procéder ainsi :</p>
<ul>
<li>on appelle <code>makeset</code> pour chaque sommet</li>
<li>pour chaque arête <span class="math inline">\((x,y)\)</span> où
<span class="math inline">\(find(x) \neq find(y)\)</span>, on appelle
<span class="math inline">\(union(x, y)\)</span>.</li>
</ul>
<p>Si jamais une nouvelle arête est à considérer, il suffit d’appeler
<code>union</code>.</p>
<p>Pour <span class="math inline">\(n\)</span> éléments dans tous les
ensembles, si on suppose que la complexité est est <span
class="math inline">\(m(n)\)</span> pour <code>makeset</code>, <span
class="math inline">\(u(n)\)</span> pour <code>union</code> et <span
class="math inline">\(f(n)\)</span> pour <code>find</code>, on a alors
une complexité du calcul en <span
class="math inline">\(O(m(|S|)|S|+(f(|S|)+u(|S|))|A|)\)</span>.</p>
<p>Pour que cet algorithme soit intéressant,il faut que cette complexité
soit proche de la précédente. Cela signifie que les trois fonctions
devraient être en <span class="math inline">\(O(1)\)</span> ou
presque.</p>
<h2 data-number="1.3" id="sec:classe-déquivalence-et-représentant"><span
class="header-section-number">1.3</span> Classe d’équivalence et
représentant</h2>
<p>On peut définir une relation d’équivalence sur les éléments en posant
:</p>
<p><span class="math display">\[x\sim y \iff find(x)
=find(y)\]</span></p>
<p>Les ensembles sont alors des classes d’équivalence dont il suffit de
donner un représentant pour les retrouver. Ainsi, <code>find</code>
pourra se contenter de renvoyer un représentant <strong>sous
réserve</strong> que <code>find(x)</code> et <code>find(y)</code>
renvoie le même quand <span class="math inline">\(x \sim y\)</span>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Comme on l’a vu en mathématiques, on peut toujours représenter une
classe de congruence modulo <span class="math inline">\(p\)</span> avec
un représentant dans <span
class="math inline">\(\range{0}{p-1}\)</span>.</p>
<p></div></p>
<h1 data-number="2" id="sec:implémentation-naïve-listes-chaînées"><span
class="header-section-number">2</span> Implémentation naïve : listes
chaînées</h1>
<p>!susbsection(Première implémentation)</p>
<p>On peut représenter chaque élément par un maillon et chaque ensemble
par une liste chaînée. Le dernier maillon de chaque liste correspondra
alors à l’élément distingué qui représente l’ensemble.</p>
<p>Plus précisément :</p>
<ul>
<li><code>makeset</code> crée un maillon <span
class="math inline">\(O(1)\)</span>
<ul>
<li>pour pouvoir manipuler directement des maillons depuis leurs
valeurs, il peut être nécessaire de maintenir un dictionnaire permettant
d’associer à une valeur son maillon, on peut le faire en <span
class="math inline">\(O(1)\)</span> avec des tables de hâchages.</li>
</ul></li>
<li><code>find</code> va descendre le long de la liste correspondant à
l’ensemble pour déterminer le maillon final. En pire cas, il faut
parcourir toute la liste, c’est donc en <span
class="math inline">\(O(n)\)</span> où <span
class="math inline">\(n\)</span> est le nombre total d’éléments.</li>
<li><code>union</code> doit réaliser une concaténation de listes, ce qui
est en <span class="math inline">\(O(n)\)</span> en pire cas.</li>
</ul>
<h2 data-number="2.1" id="sec:quick-find"><span
class="header-section-number">2.1</span> Quick-find</h2>
<p>On peut améliorer les performances de <code>find</code> en rajoutant
un pointeur direct depuis chaque maillon vers le maillon final de la
liste qui les contient. L’opération <code>find</code> est alors en <span
class="math inline">\(O(1)\)</span>. Cependant <code>union</code> sera
en <span class="math inline">\(O(n)\)</span>, même en faisant en sorte
d’avoir une concaténation rapide comme expliqué dans le paragraphe
suivant, car il faut maintenir les pointeurs vers le maillon final.</p>
<p>Cette implémentation est en général dénommée <code>Quick-find</code>
car <code>find</code> est rapide.</p>
<h2 data-number="2.2" id="sec:quick-union"><span
class="header-section-number">2.2</span> Quick-union</h2>
<p>On peut faire en sorte que l’union soit rapide en faisant en sorte
que le maillon distingué pointe sur le premier et dernier maillon de
chaque liste. Ainsi, pour l’union, il suffit de faire un nombre constant
d’opérations.</p>
<p><strong>Attention</strong>, cela suppose ici que <code>union</code>
ne va pas réaliser des <code>find</code>, qui eux, resteront
coûteux.</p>
<h1 data-number="3" id="sec:implémentation-efficace"><span
class="header-section-number">3</span> Implémentation efficace</h1>
<h2 data-number="3.1" id="sec:forêt-disjointe"><span
class="header-section-number">3.1</span> Forêt disjointe</h2>
<p>On va représenter une structure union-find par une forêt d’arbres
dont les étiquettes sont toutes distinctes. Chaque arbre représentera
alors l’ensemble des valeurs de ses étiquettes et la forêt sera
naturellement une représentation d’une collection d’ensembles
disjoints.</p>
<p>On peut alors identifier une valeur au nœud de l’arbre dont c’est
l’étiquette et naïvement effectuer les opérations :</p>
<ul>
<li><code>makeset</code> crée un arbre avec une feuille et le rajoute à
la forêt, ce qui fait en temps constant en supposant que la forêt est
une liste d’arbres</li>
<li><code>find</code> va remonter du nœud vers sa racine et renvoyer sa
racine, ce qui est en <span class="math inline">\(O(h)\)</span> où <span
class="math inline">\(h\)</span> est la hauteur de la forêt,
c’est-à-dire la plus grande hauteur des arbres qu’elle contient.</li>
<li><code>union</code> va supprimer deux arbres et les remplacer par un
unique arbre :</li>
</ul>
<p><center><div class="ui image center"><img
src="assets/pics/uf_arbre_fus.png" /></div></center></p>
<p>Ainsi, <code>union</code> est naturellement en <span
class="math inline">\(O(1)\)</span> sous réserve de partir des racines.
On retrouve donc une complexité meilleure que Quick-union avec les
listes chaînées.</p>
<p>Cependant, il est possible d’avoir des arbres très profonds et en
pire cas, <code>find</code> est en <span
class="math inline">\(O(n)\)</span> où <span
class="math inline">\(n\)</span> est le nombre d’éléments.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Si on considère les entiers de <span class="math inline">\(0\)</span>
à <span class="math inline">\(n\)</span>, la suite d’union <span
class="math inline">\((1,0), (2,0), \dots, (n, 0)\)</span> va créer un
peigne avec <span class="math inline">\(n\)</span> à la racine et une
unique branche <span class="math inline">\(n -- (n-1) -- \dots -- 2 -- 1
-- 0\)</span> donc <span class="math inline">\(0\)</span> est à
profondeur <span class="math inline">\(n\)</span> et ainsi <span
class="math inline">\(find(0)\)</span> devra remonter les n arêtes.</p>
<p></div></p>
<h2 data-number="3.2" id="sec:union-pondérée"><span
class="header-section-number">3.2</span> Union pondérée</h2>
<p>Quand on réalise une union, on a deux choix sur qui sera la racine de
l’arbre fusionné. Si on s’assure de toujours faire le choix qui minimise
la hauteur, on doit permettre à la forêt d’être de hauteur en <span
class="math inline">\(O(log(n))\)</span>.</p>
<p>Calculer les tailles ou les hauteurs de chaque arbre n’est pas utile,
on peut se contenter de définir le rang d’un arbre noté <span
class="math inline">\(rg(a)\)</span> :</p>
<ul>
<li>au départ, chaque feuille est de rang 0</li>
<li>quand on réalise une union entre deux arbres <span
class="math inline">\(a\)</span> et <span
class="math inline">\(a&#39;\)</span>
<ul>
<li>si <span class="math inline">\(rg(a) &gt; rg(a&#39;)\)</span> on n’a
pas intérêt à placer <span class="math inline">\(a\)</span> plus
profondément donc on rajoute <span class="math inline">\(a&#39;\)</span>
comme enfant de <span class="math inline">\(a\)</span> et on préserve
les rangs</li>
<li>sinon, on fait la fusion dans l’autre sens et dans le cas où les
deux rangs étaient égaux, on augmente le rang de <span
class="math inline">\(a&#39;\)</span> de 1.</li>
</ul></li>
</ul>
<p>Ainsi, les rangs indiquent le nombre de fusions successifs qui ont
augmenté la profondeur et permettent ainsi de calculer sans peine la
hauteur de l’arbre.</p>
<p>En procédant ainsi, on s’assure effectivement que la fusion soit en
<span class="math inline">\(O(\log n)\)</span> en moyenne.</p>
<h2 data-number="3.3" id="sec:compression-de-chemins"><span
class="header-section-number">3.3</span> Compression de chemins</h2>
<p>La structure de l’arbre est souvent inintéressante, on peut donc se
permettre de la supprimer et d’aplatir les arbres. Pour cela, si la
parenté est déterminé par un tableau <code>parent</code> avec
<code>parent[x] = x</code> à la racine, on peut procéder récursivement
pour <code>find</code> :</p>
<p><strong>Calcul de <code>find(x)</code></strong></p>
<ul>
<li>Si <code>x</code> <span class="math inline">\(\neq\)</span>
<code>parent[x]</code>
<ul>
<li><code>parent[x] = find(parent[x])</code></li>
</ul></li>
<li>Renvoyer <code>parent[x]</code></li>
</ul>
<p>Ainsi, la valeur de <code>parent[x]</code> est toujours mise à jour
vers la racine directement. Cela à revient à aplatir l’arbre pour que
chaque nœud soit enfant de la racine. On parle de <em>compression de
chemins</em> puisque les chemins sont tous triviaux.</p>
<p>On peut prouver ainsi que <code>find</code> est en <span
class="math inline">\(O(\alpha(n))\)</span> en moyenne où <span
class="math inline">\(\alpha(n)\)</span> est une fonction qui croit
tellement lentement que <span class="math inline">\(\alpha(n) \le
4\)</span> pour <span class="math inline">\(n \le 10^{80}\)</span>.</p>
<h1 data-number="4"
id="sec:implémentation-en-c-avec-un-tableau-parent"><span
class="header-section-number">4</span> Implémentation en <code>C</code>
avec un tableau <code>parent</code></h1>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Cette implémentation peut également se faire facilement avec
<code>OCaml</code>.</p>
<p></div></p>
<p>On va considérer que les élèments sont les entiers de <span
class="math inline">\(0\)</span> à <span
class="math inline">\(n-1\)</span> et on va représenter la forêt par un
tableau <code>parent</code> où <code>parent[x]</code>indique le père de
<span class="math inline">\(x\)</span> si <span
class="math inline">\(x\)</span> n’est pas une racine, et
<code>parent[x] = x</code> pour les racines.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On peut donc tester si un élèment est la racine d’un arbre en <span
class="math inline">\(O(1)\)</span>.</p>
<p></div></p>
<p>On va représenter la forêt par le type suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">struct</span> union_find <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="dt">int</span> <span class="op">*</span>parent<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="dt">int</span> <span class="op">*</span>rang<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="dt">int</span> nelements<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="op">};</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">typedef</span> <span class="kw">struct</span> union_find union_find<span class="op">;</span></span></code></pre></div>
<p></div></p>
<p>Pour commencer, on crée une forêt de feuilles qui sont toutes de rang
0.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a>union_find uf_makesets<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    union_find uf<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    uf<span class="op">.</span>parent <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">*</span> n<span class="op">);</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>        uf<span class="op">.</span>parent<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>        uf<span class="op">.</span>rang<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="op">}</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>    uf<span class="op">.</span>nelements <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="cf">return</span> uf<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>On implémente alors directement <code>find</code> et
<code>union</code>, en prenant garde au fait que <code>union</code> est
un mot-clé en <code>C</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1"></a><span class="dt">int</span> uf_find<span class="op">(</span>union_find uf<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="cf">if</span> <span class="op">(</span>uf<span class="op">.</span>parent<span class="op">[</span>x<span class="op">]</span> <span class="op">!=</span> x<span class="op">)</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>        uf<span class="op">.</span>parent<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> uf_find<span class="op">(</span>uf<span class="op">,</span> uf<span class="op">.</span>parent<span class="op">[</span>x<span class="op">]);</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="cf">return</span> uf<span class="op">.</span>parent<span class="op">[</span>x<span class="op">];</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="op">}</span></span></code></pre></div>
<p></div> <div class="ui segment code"></p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1"></a><span class="dt">void</span> uf_union<span class="op">(</span>union_find uf<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="dt">int</span> rx <span class="op">=</span> uf_find<span class="op">(</span>uf<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="dt">int</span> ry <span class="op">=</span> uf_find<span class="op">(</span>uf<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>    assert<span class="op">(</span>rx <span class="op">!=</span> ry<span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="cf">if</span> <span class="op">(</span>uf<span class="op">.</span>rang<span class="op">[</span>rx<span class="op">]</span> <span class="op">&gt;</span> uf<span class="op">.</span>rang<span class="op">[</span>ry<span class="op">])</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>        uf<span class="op">.</span>parent<span class="op">[</span>ry<span class="op">]</span> <span class="op">=</span> rx<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>        uf<span class="op">.</span>parent<span class="op">[</span>rx<span class="op">]</span> <span class="op">=</span> ry<span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>        <span class="cf">if</span> <span class="op">(</span>uf<span class="op">.</span>rang<span class="op">[</span>rx<span class="op">]</span> <span class="op">==</span> uf<span class="op">.</span>rang<span class="op">[</span>ry<span class="op">])</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>            uf<span class="op">.</span>rang<span class="op">[</span>ry<span class="op">]</span> <span class="op">=</span> uf<span class="op">.</span>rang<span class="op">[</span>ry<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="op">}</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
