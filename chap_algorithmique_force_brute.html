<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Recherche par Force brute</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

.ui.styled.accordion {
    width: 100% !important;
    font-size: 1rem !important;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Recherche par Force brute
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:principe"><span>1</span> Principe</a><div class="menu"><a class="item" href="#sec:problème-de-décision-et-exploration-exhaustive"><div class="ui label">1.1</div> Problème de décision et exploration exhaustive</a><a class="item" href="#sec:problème-doptimisation-et-exploration-exhaustive"><div class="ui label">1.2</div> Problème d’optimisation et exploration exhaustive</a></div></div><div class="item header"> <a href="#sec:recherche-par-retour-sur-trace-backtracking"><span>2</span> Recherche par retour sur trace (<strong>backtracking</strong>)</a><div class="menu"><a class="item" href="#sec:construction-itérative-de-candidats"><div class="ui label">2.1</div> Construction itérative de candidats</a><a class="item" href="#sec:évaluation-partielle-et-raccourcis"><div class="ui label">2.2</div> Évaluation partielle et raccourcis</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:problème-résolution-de-sudoku"><i class="circle icon"></i> Problème : résolution de Sudoku</a></div><a class="item" href="#sec:énumération-de-toutes-les-solutions"><div class="ui label">2.3</div> Énumération de toutes les solutions</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:problèmes-des-huit-reines"><i class="circle icon"></i> Problèmes des huit reines</a></div><a class="item" href="#sec:tp-tours-du-cavalier"><div class="ui label">2.4</div> TP : tours du cavalier</a><a class="item" href="#sec:tp-jeu-du-solitaire"><div class="ui label">2.5</div> TP : jeu du solitaire</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:première-implémentation-naïve"><i class="circle icon"></i> Première implémentation naïve</a><a style="font-size:0.6em" class="item" href="#sec:cache-des-mauvaises-positions"><i class="circle icon"></i> Cache des mauvaises positions</a></div></div></div><div class="item header"> <a href="#sec:stratégies-dénumération"><span>3</span> Stratégies d’énumération</a><div class="menu"><a class="item" href="#sec:combinatoire-élémentaire"><div class="ui label">3.1</div> Combinatoire élémentaire</a><a class="item" href="#sec:enumération-darbres"><div class="ui label">3.2</div> Enumération d’arbres</a></div></div><div class="item header"> <a href="#sec:droite-de-balayage"><span>4</span> Droite de balayage</a><div class="menu"><a class="item" href="#sec:principe-1"><div class="ui label">4.1</div> Principe</a><a class="item" href="#sec:plusprochepaire"><div class="ui label">4.2</div> Plus proche paire</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:recherche-exhaustive"><i class="circle icon"></i> Recherche exhaustive</a><a style="font-size:0.6em" class="item" href="#sec:raffinement-droite-de-balayage"><i class="circle icon"></i> Raffinement : droite de balayage</a><a style="font-size:0.6em" class="item" href="#sec:problème-test-dintersection-pour-un-ensemble-de-segments"><i class="circle icon"></i> Problème : test d’intersection pour un ensemble de segments</a></div></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Recherche par Force brute
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Recherche par Force brute     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_algo_exacte.png"> </div></p>
<p><em>Source image : https://www.flickr.com/photos/x6e38/3440634940/</em></p>
<h1 data-number="1" id="sec:principe"><span class="header-section-number">1</span> Principe</h1>
<h2 data-number="1.1" id="sec:problème-de-décision-et-exploration-exhaustive"><span class="header-section-number">1.1</span> Problème de décision et exploration exhaustive</h2>
<p>Considérons un problème du type trouver un <span class="math inline">\(x \in V\)</span> vérifiant une propriété <span class="math inline">\(P(x)\)</span>.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li><span class="math inline">\(V\)</span> est l’ensemble des chaînes de caractères et <span class="math inline">\(P\)</span> vérifié si<br />
si une chaîne est un mot de passe qu’on cherche.</li>
<li><span class="math inline">\(V\)</span> est l’ensemble des indices possibles dans un tableau <code>t</code> et <span class="math inline">\(P\)</span> vérifie si la valeur à l’indice <span class="math inline">\(i\)</span> est une valeur <span class="math inline">\(x\)</span> que l’on cherche.</li>
<li><span class="math inline">\(V\)</span> est l’ensemble des grilles complétées d’un problème de Sudoku et <span class="math inline">\(P\)</span> vérifie si la grille est valide.</li>
<li><span class="math inline">\(V\)</span> est l’ensemble d’assemblages de pièces d’un puzzle et <span class="math inline">\(P\)</span> vérifie si le puzzle est correcte, c’est-à-dire si deux pièces côtes à côtés ont des côtés compatibles.</li>
</ul>
</div>
<p>Dans certains problèmes, un tel <span class="math inline">\(x\)</span> n’est pas unique et on cherche à tous les énumérer.</p>
<p>Une recherche par force brute ou recherche exhaustive, consiste à énumérer l’ensemble <span class="math inline">\(V\)</span> jusqu’à obtenir une solution en testant <span class="math inline">\(P\)</span> pour chaque valeur rencontrée.</p>
<p>Des problèmes précédents, la recherche linéaire est le plus simple et le programme suivant est caractéristique d’une recherche exhaustive :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">exception</span> Trouve <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">let</span> recherche t x =</span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="kw">try</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>        <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> <span class="dt">Array</span>.length t - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>            <span class="kw">if</span> t.(i) = x</span>
<span id="cb1-7"><a href="#cb1-7"></a>            <span class="kw">then</span> <span class="dt">raise</span> (Trouve i)</span>
<span id="cb1-8"><a href="#cb1-8"></a>        <span class="kw">done</span>;</span>
<span id="cb1-9"><a href="#cb1-9"></a>        <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="kw">with</span> Trouve i -&gt; i</span></code></pre></div>
<p></div></p>
<p>La forme usuelle sera alors</p>
<pre><code>pour chaque v dans V
    si P(v) est vérifié
       s&#39;arrêter avec la solution v</code></pre>
<p>On rappelle que pour pouvoir s’arrêter au cours de l’énumération en <code>OCaml</code>, si on programme en impératif, on utilise en général des exceptions comme dans le chapitre <a href="chap_programmation_exceptions_ocaml.html#sec:exceptions">Exceptions en OCaml</a>.</p>
<p>Cela pose naturellement la question de l’énumération des éléments de <span class="math inline">\(V\)</span>. Si c’est immédiat dans l’exemple peu pertinent de la recherche dans un tableau, c’est beaucoup plus complexe pour l’énumération des assemblages de pièces d’un puzzle, par exemple.</p>
<p>Pour la recherche du mot de passe, on pourrait commencer par énumérer les chaînes de longueur 1, puis de longueur 2, et ainsi de suite.</p>
<p>Le plus souvent, l’ensemble <span class="math inline">\(V\)</span> est fini (pour les mots de passe, cela peut consister à limiter la longueur maximale du mot de passe). Ainsi, une recherche par force brute effectue <span class="math inline">\(O(|V|)\)</span> itérations.</p>
<h2 data-number="1.2" id="sec:problème-doptimisation-et-exploration-exhaustive"><span class="header-section-number">1.2</span> Problème d’optimisation et exploration exhaustive</h2>
<p>On retrouve la notion d’exploration exhaustive ou force brute pour des problèmes d’optimisation. Il s’agit de problèmes de la forme : déterminer <span class="math inline">\(x \in V\)</span> tel que <span class="math inline">\(f(x)\)</span> soit minimale ou maximale.</p>
<p>L’exploration exhaustive consiste alors à calculer toutes les images par <span class="math inline">\(f\)</span> des éléments de <span class="math inline">\(V\)</span> afin de déterminer un extremum.</p>
<h1 data-number="2" id="sec:recherche-par-retour-sur-trace-backtracking"><span class="header-section-number">2</span> Recherche par retour sur trace (<strong>backtracking</strong>)</h1>
<h2 data-number="2.1" id="sec:construction-itérative-de-candidats"><span class="header-section-number">2.1</span> Construction itérative de candidats</h2>
<p>Dans de nombreux cas, l’ensemble <span class="math inline">\(V\)</span> peut se décrire une processus itératifs de construction de ses éléments. Une manière de voir cela est de parler de positions et de mouvements, ou coups.</p>
<p>Par exemple, considérons un puzzle comme le puzzle <a href="https://en.wikipedia.org/wiki/Eternity_II_puzzle">Eternity II</a> constitué de 256 pièces carrées. Une configuration finale du puzzle consiste à avoir placé les 256 pièces. Parmi celles-ci, les configurations valides sont celles satisfaisant les contraintes de chaque côté.</p>
<p>Comme pour tous les puzzles, la position initiale est un plateau vide et chaque mouvement consiste à placer une pièce disponible dans un emplacement disponible. Cela correspond à la manière dont on procéderait à la main : <img src="assets/pics/Eternity_II.jpg" /></p>
<p>Ainsi, on peut représenter la construction de <span class="math inline">\(V\)</span> sous la forme d’un arbre dont les nœuds sont les positions et les arêtes les mouvements. Les positions complètes sont les feuilles de l’arbre, elles correspondent aux éléments de <span class="math inline">\(V\)</span> et ce sont donc celles-ci qu’on va explorer pour y trouver une solution.</p>
<p><center><div class="ui image center"><img src="assets/pics/constV.png" /></div></center></p>
<p>L’avantage de cette représentation arborescente est qu’elle découle naturellement d’un parcours récursif des positions.</p>
<p>Tout d’abord, il va falloir définir un type de positions partielles comme on a pu le voir dans le chapitre <a href="chap_programmation_options_ocaml.html#sec:valeurspartielles">Options en OCaml</a>.</p>
<p>Comme indiqué dans ce chapitre, si le type d’une grille de Sudoku remplie est <code>int array array</code>, pour pouvoir représenter des grilles en cours de remplissage, on va utiliser le type <code>int option array array</code>. On rappelle que l’utilisation de la valeur <code>None</code> permettra de représenter une partie non construite comme une case vide.</p>
<p>On considère ainsi un type <code>position</code> des positions partielles, un type <code>mouvement</code> et des fonctions <div class="ui segment code"></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">(* les mouvements accessibles depuis une position.</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co">  [] si la position est complète *)</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">val</span> mouvements : position -&gt; mouvement <span class="dt">list</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co">(* applique un mouvement *)</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">val</span> applique : position -&gt; mouvement -&gt; position</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co">(* vérifie si une position est complete *)</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">val</span> complete : position -&gt; <span class="dt">bool</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="co">(* vérifie si une position complete est valide *)</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="kw">val</span> valide : position -&gt; <span class="dt">bool</span></span></code></pre></div>
<p></div></p>
<p>Schématiquement, un algorithme d’énumération aura la structure suivante en <code>OCaml</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">exception</span> Solution <span class="kw">of</span> position</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">let</span> <span class="kw">rec</span> enumere pos =</span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="kw">if</span> complete pos</span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>        <span class="kw">if</span> valide pos</span>
<span id="cb4-7"><a href="#cb4-7"></a>        <span class="kw">then</span> <span class="dt">raise</span> (Solution pos)</span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="kw">end</span> <span class="kw">else</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>        <span class="dt">List</span>.iter (<span class="kw">fun</span> mouv -&gt; enumere (applique pos mouv))</span>
<span id="cb4-10"><a href="#cb4-10"></a>            (mouvements pos)</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Ici, l’usage de <code>List.iter</code> permet de faire l’équivalent d’une boucle for mais sur une liste. Pour s’en passer, on peut écrire une fonction auxiliaire récursive ou, quand les mouvements sont en petit nombre, une conversion en <code>array</code> suivie d’une boucle <code>for</code>.</div></p>
<p>Si la position initiale est <code>pos0</code>, on pourra résoudre le problème ainsi :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">let</span> resout () =</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="kw">try</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>        enumere pos0;</span>
<span id="cb5-4"><a href="#cb5-4"></a>        <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="kw">with</span> Solution pos -&gt; pos</span></code></pre></div>
<p></div></p>
<p>Cet algorithme de parcours des solutions est appelé le <em>retour sur trace</em>, ou <em>backtracking</em> en anglais. Il tire partie de la récursivité pour remonter les positions après avoir essayé en vain une construction.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Il est possible de reprendre la construction précédente avec des données mutables et une manière de <em>défaire</em> les mouvements :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">val</span> applique : position -&gt; mouvement -&gt; <span class="dt">unit</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">val</span> defaire : position -&gt; mouvement -&gt; <span class="dt">unit</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="kw">let</span> <span class="kw">rec</span> enumere pos =</span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="kw">if</span> complete pos</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>        <span class="kw">if</span> valide pos</span>
<span id="cb6-8"><a href="#cb6-8"></a>        <span class="kw">then</span> <span class="dt">raise</span> (Solution pos)</span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="kw">end</span> <span class="kw">else</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>        <span class="dt">List</span>.iter (<span class="kw">fun</span> mouv -&gt; </span>
<span id="cb6-11"><a href="#cb6-11"></a>                    applique pos mouv;</span>
<span id="cb6-12"><a href="#cb6-12"></a>                    enumere pos;</span>
<span id="cb6-13"><a href="#cb6-13"></a>                    defaire pos mouv)</span>
<span id="cb6-14"><a href="#cb6-14"></a>            (mouvements pos)</span></code></pre></div>
<p></div></p>
<p></div></p>
<h2 data-number="2.2" id="sec:évaluation-partielle-et-raccourcis"><span class="header-section-number">2.2</span> Évaluation partielle et raccourcis</h2>
<p>Si on reprend la construction itérative précédente, on se rend compte qu’elle n’est pas très intelligente : faut-il remplir l’intégralité d’un puzzle avant de se rendre compte qu’il est invalide en raison des deux premières pièces ?</p>
<p>On peut donc raffiner l’approche précédente en introduisant une notion de mouvements valides qui sont les mouvements qui préservent la correction partielle.</p>
<p>En pratique, il suffit de remplacer la fonction <code>mouvements</code> par une fonction <code>mouvements_valides</code>.</p>
<p>C’est un changement réduit qui peut avoir un grand impact sur l’arbre des positions. En reprenant l’illustration précédente, on peut imaginer que cela reviendrait à ne pas parcourir les mouvements rouges et les sous-arbres associés :</p>
<p><center><div class="ui image center"><img src="assets/pics/constB.png" /></div></center></p>
<h3 data-number="2.2.1" id="sec:problème-résolution-de-sudoku"><span class="header-section-number">2.2.1</span> Problème : résolution de Sudoku</h3>
<p>La recherche par retour sur trace se prête très bien à la résolution de problèmes comme le Sudoku. On va ici tout simplement tenter de remplir chaque case du haut vers le bas tant qu’on satisfait les contraintes du Sudoku. Le programme sera ainsi très proche de la résolution des huit reines.</p>
<p>Commençons par rappeler le principe du Sudoku :</p>
<ul>
<li><p>On part d’une grille de 81 cases réparties en une grille de 3x3 sous-grilles de 3x3 cases et comportant des chiffres de 1 à 9 dans certaines cases. <center><div class="ui image center"><img src="assets/pics/sudoku_exemple.png" /></div></center></p></li>
<li><p>L’objectif est de remplir chaque case avec un chiffre de 1 à 9 de sorte que chaque ligne, chaque colonne et chaque sous-grille 3x3 comporte une et une seule fois chaque chiffre.</p></li>
<li><p>Un sudoku admet une unique solution.</p></li>
</ul>
<p>Pour représenter une grille de Sudoku en <code>OCaml</code> on utilise un <code>(int option) array array</code>, la valeur <code>None</code> signifiant que la case est vide et la valeur <code>Some x</code> qu’elle est remplie avec la valeur <span class="math inline">\(x\)</span>.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">type</span> grille = (<span class="dt">int</span> <span class="dt">option</span>) <span class="dt">array</span> <span class="dt">array</span></span></code></pre></div>
<p></div></p>
<p>On fait le choix de représenté la grille par un tableau de lignes, ce qui signiie que pour accèder à la case de coordonnée <span class="math inline">\((x,y)\)</span> dans <code>g</code> il faut écrire <code>g.(y).(x)</code>.</p>
<p>Le problème donné précédemment est alors représenté par la valeur suivante : <div class="ui segment code"></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">let</span> probleme = [|</span>
<span id="cb8-2"><a href="#cb8-2"></a>    [| <span class="dt">Some</span> <span class="dv">1</span>; <span class="dt">None</span>; <span class="dt">None</span>;    <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span>;   <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">6</span> |];</span>
<span id="cb8-3"><a href="#cb8-3"></a>    [| <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">6</span>;    <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">2</span>; <span class="dt">None</span>;   <span class="dt">Some</span> <span class="dv">7</span>; <span class="dt">None</span>; <span class="dt">None</span> |];</span>
<span id="cb8-4"><a href="#cb8-4"></a>    [| <span class="dt">Some</span> <span class="dv">7</span>; <span class="dt">Some</span> <span class="dv">8</span>; <span class="dt">Some</span> <span class="dv">9</span>;    <span class="dt">Some</span> <span class="dv">4</span>; <span class="dt">Some</span> <span class="dv">5</span>; <span class="dt">None</span>;   <span class="dt">Some</span> <span class="dv">1</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">3</span> |];</span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a>    [| <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span>;    <span class="dt">Some</span> <span class="dv">8</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">7</span>;   <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">4</span> |];</span>
<span id="cb8-7"><a href="#cb8-7"></a>    [| <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span>;    <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">3</span>; <span class="dt">None</span>;   <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span> |];</span>
<span id="cb8-8"><a href="#cb8-8"></a>    [| <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">9</span>; <span class="dt">None</span>;    <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">4</span>;   <span class="dt">Some</span> <span class="dv">2</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">1</span> |];</span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a>    [| <span class="dt">Some</span> <span class="dv">3</span>; <span class="dt">Some</span> <span class="dv">1</span>; <span class="dt">Some</span> <span class="dv">2</span>;    <span class="dt">Some</span> <span class="dv">9</span>; <span class="dt">Some</span> <span class="dv">7</span>; <span class="dt">None</span>;   <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">4</span>; <span class="dt">None</span> |];</span>
<span id="cb8-11"><a href="#cb8-11"></a>    [| <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">4</span>; <span class="dt">None</span>;    <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">1</span>; <span class="dt">Some</span> <span class="dv">2</span>;   <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">7</span>; <span class="dt">Some</span> <span class="dv">8</span> |];</span>
<span id="cb8-12"><a href="#cb8-12"></a>    [| <span class="dt">Some</span> <span class="dv">9</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">8</span>;    <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span>;   <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span> |];</span>
<span id="cb8-13"><a href="#cb8-13"></a>    |]</span></code></pre></div>
<p></div></p>
<p>Afin de définir la fonction de résolution, on définit une première fonction <code>suivant</code> de signature :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">val</span> suivant : grille -&gt; (<span class="dt">int</span> * <span class="dt">int</span>) -&gt; (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">option</span></span></code></pre></div>
<p></div></p>
<p>telle que l’appel à <code>suivant g (x,y)</code> renvoie <code>Some (xi,yi)</code> quand <span class="math inline">\((x_i,y_i)\)</span> sont les coordonnées de la prochaine case libre, dans l’ordre gauche à droite puis haut vers bas, après <span class="math inline">\((x,y)\)</span> ou <code>None</code> quand il n’existe pas de telle case libre. Cela signifie alors que la grille est entièrement remplie.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">let</span> <span class="kw">rec</span> suivant g (x,y) =</span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="kw">if</span> y &gt; <span class="dv">8</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="kw">then</span> <span class="dt">None</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>    <span class="kw">else</span> <span class="kw">if</span> g.(y).(x) = <span class="dt">None</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="kw">then</span> <span class="dt">Some</span> (x,y)</span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="kw">else</span> <span class="kw">if</span> x &lt; <span class="dv">8</span> <span class="kw">then</span> suivant g (x+<span class="dv">1</span>, y)</span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="kw">else</span> suivant g (<span class="dv">0</span>, y+<span class="dv">1</span>)</span></code></pre></div>
<p></div></p>
<p>On définit également une fonction <code>valide</code> de signature</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">val</span> valide : grille -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">bool</span></span></code></pre></div>
<p></div></p>
<p>telle que l’appel à <code>valide g x y</code> renvoie <code>true</code> si et seulement si la valeur placée en coordonnée <span class="math inline">\((x,y)\)</span> n’invalide pas la grille. Ne pas prendre cette valeur en paramètre permettant d’écrire un peu plus simplement cette fonction. La fonction est assez directe, étant donné <span class="math inline">\((x,y)\)</span> on va parcourir sa ligne, sa colonne et sa sous-grille pour vérifier qu’un nombre n’a pas été placé deux fois à l’aide d’un tableau de drapeaux :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">let</span> valide g x y =</span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="kw">let</span> v = <span class="dt">ref</span> <span class="kw">true</span> <span class="kw">in</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="kw">let</span> vus_colonne = <span class="dt">Array</span>.make <span class="dv">9</span> <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    <span class="kw">for</span> y0 = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">8</span> <span class="kw">do</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>        <span class="kw">match</span> g.(y0).(x) <span class="kw">with</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>        | <span class="dt">None</span> -&gt; ()</span>
<span id="cb12-7"><a href="#cb12-7"></a>        | <span class="dt">Some</span> k -&gt; </span>
<span id="cb12-8"><a href="#cb12-8"></a>                <span class="kw">if</span> vus_colonne.(k<span class="dv">-1</span>)</span>
<span id="cb12-9"><a href="#cb12-9"></a>                <span class="kw">then</span> v := <span class="kw">false</span>;</span>
<span id="cb12-10"><a href="#cb12-10"></a>                vus_colonne.(k<span class="dv">-1</span>) &lt;- <span class="kw">true</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>    <span class="kw">done</span>;</span>
<span id="cb12-12"><a href="#cb12-12"></a>    <span class="kw">let</span> vus_ligne = <span class="dt">Array</span>.make <span class="dv">9</span> <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb12-13"><a href="#cb12-13"></a>    <span class="kw">for</span> x0 = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">8</span> <span class="kw">do</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>        <span class="kw">match</span> g.(y).(x0) <span class="kw">with</span></span>
<span id="cb12-15"><a href="#cb12-15"></a>        | <span class="dt">None</span> -&gt; ()</span>
<span id="cb12-16"><a href="#cb12-16"></a>        | <span class="dt">Some</span> k -&gt; </span>
<span id="cb12-17"><a href="#cb12-17"></a>                <span class="kw">if</span> vus_ligne.(k<span class="dv">-1</span>)</span>
<span id="cb12-18"><a href="#cb12-18"></a>                <span class="kw">then</span> v := <span class="kw">false</span>;</span>
<span id="cb12-19"><a href="#cb12-19"></a>                vus_ligne.(k<span class="dv">-1</span>) &lt;- <span class="kw">true</span></span>
<span id="cb12-20"><a href="#cb12-20"></a>    <span class="kw">done</span>;</span>
<span id="cb12-21"><a href="#cb12-21"></a>    <span class="kw">let</span> vus_grille = <span class="dt">Array</span>.make <span class="dv">9</span> <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb12-22"><a href="#cb12-22"></a>    <span class="kw">let</span> xb = (x / <span class="dv">3</span>) * <span class="dv">3</span> <span class="kw">in</span></span>
<span id="cb12-23"><a href="#cb12-23"></a>    <span class="kw">let</span> yb = (y / <span class="dv">3</span>) * <span class="dv">3</span> <span class="kw">in</span></span>
<span id="cb12-24"><a href="#cb12-24"></a>    <span class="kw">for</span> xd = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">2</span> <span class="kw">do</span></span>
<span id="cb12-25"><a href="#cb12-25"></a>        <span class="kw">for</span> yd = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">2</span> <span class="kw">do</span></span>
<span id="cb12-26"><a href="#cb12-26"></a>            <span class="kw">match</span> g.(yb+yd).(xb+xd) <span class="kw">with</span></span>
<span id="cb12-27"><a href="#cb12-27"></a>            | <span class="dt">None</span> -&gt; ()</span>
<span id="cb12-28"><a href="#cb12-28"></a>            | <span class="dt">Some</span> k -&gt; </span>
<span id="cb12-29"><a href="#cb12-29"></a>                    <span class="kw">if</span> vus_grille.(k<span class="dv">-1</span>)</span>
<span id="cb12-30"><a href="#cb12-30"></a>                    <span class="kw">then</span> v := <span class="kw">false</span>;</span>
<span id="cb12-31"><a href="#cb12-31"></a>                    vus_grille.(k<span class="dv">-1</span>) &lt;- <span class="kw">true</span></span>
<span id="cb12-32"><a href="#cb12-32"></a>        <span class="kw">done</span></span>
<span id="cb12-33"><a href="#cb12-33"></a>    <span class="kw">done</span>;</span>
<span id="cb12-34"><a href="#cb12-34"></a>    !v</span></code></pre></div>
<p></div></p>
<p>On peut alors définir la fonction <code>resout</code> qui va résoudre le Sudoku en effectuant tous les remplissages tant qu’on a une grille valide. Dès qu’une solution est trouvée, on s’arrête. Pour cela, on utilise le mécanisme des exceptions pour permettre une sortie prématurée. On a fait le choix de travailler en place dans la grille, ainsi à la fin de l’exécution de la fonction, la grille correspond à la solution.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">exception</span> Solution</span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">let</span> resout g =</span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux xi yi = <span class="kw">match</span> suivant g (xi, yi) <span class="kw">with</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>        | <span class="dt">None</span> -&gt; <span class="dt">raise</span> Solution</span>
<span id="cb13-6"><a href="#cb13-6"></a>        | <span class="dt">Some</span> (x,y) -&gt;</span>
<span id="cb13-7"><a href="#cb13-7"></a>            <span class="kw">for</span> i = <span class="dv">1</span> <span class="kw">to</span> <span class="dv">9</span> <span class="kw">do</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>                g.(y).(x) &lt;- <span class="dt">Some</span> i;</span>
<span id="cb13-9"><a href="#cb13-9"></a>                <span class="kw">if</span> valide g x y</span>
<span id="cb13-10"><a href="#cb13-10"></a>                <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>                    aux x y</span>
<span id="cb13-12"><a href="#cb13-12"></a>                <span class="kw">end</span></span>
<span id="cb13-13"><a href="#cb13-13"></a>            <span class="kw">done</span>;</span>
<span id="cb13-14"><a href="#cb13-14"></a>            g.(y).(x) &lt;- <span class="dt">None</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>    <span class="kw">in</span> </span>
<span id="cb13-16"><a href="#cb13-16"></a>    <span class="kw">try</span> </span>
<span id="cb13-17"><a href="#cb13-17"></a>        aux <span class="dv">0</span> <span class="dv">0</span></span>
<span id="cb13-18"><a href="#cb13-18"></a>    <span class="kw">with</span> Solution -&gt; ()</span></code></pre></div>
<p></div></p>
<p>La résolution du Sudoku donnée précédemment par ce programme est présenté dans la vidéo suivante :</p>
<p><center><video width="400" height="380" controls="controls"><source src="assets/pics/sudoku.mp4" type="video/mp4" /></video></center></p>
<h2 data-number="2.3" id="sec:énumération-de-toutes-les-solutions"><span class="header-section-number">2.3</span> Énumération de toutes les solutions</h2>
<p>Le problème précédent du Sudoku n’avait par définition qu’une unique solution. Cependant, il existe des problèmes pour lesquels plusieurs solutions existent et pour lesquels on souhaite les énumérer.</p>
<p>La fonction précédente pourra alors devenir :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">let</span> <span class="kw">rec</span> enumere pos =</span>
<span id="cb14-2"><a href="#cb14-2"></a>    <span class="kw">if</span> complete pos</span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>        <span class="kw">if</span> valide pos</span>
<span id="cb14-5"><a href="#cb14-5"></a>        <span class="kw">then</span> [ pos ]</span>
<span id="cb14-6"><a href="#cb14-6"></a>        <span class="kw">else</span> []</span>
<span id="cb14-7"><a href="#cb14-7"></a>    <span class="kw">end</span> <span class="kw">else</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>        <span class="dt">List</span>.concat </span>
<span id="cb14-9"><a href="#cb14-9"></a>            (<span class="dt">List</span>.map (<span class="kw">fun</span> mouv -&gt; enumere (applique pos mouv))</span>
<span id="cb14-10"><a href="#cb14-10"></a>                (mouvements_valides pos))</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>La fonction <code>List.concat</code> permet de concaténer une <code>'a list list</code> d’un coup comme dans :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1"></a># <span class="dt">List</span>.concat [ [<span class="dv">1</span>;<span class="dv">2</span>]; [<span class="dv">3</span>]; []; [<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">6</span>] ];;</span>
<span id="cb15-2"><a href="#cb15-2"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>]</span></code></pre></div>
<p></div> </div></p>
<h3 data-number="2.3.1" id="sec:problèmes-des-huit-reines"><span class="header-section-number">2.3.1</span> Problèmes des huit reines</h3>
<p>L’exemple classique de ce problème est celui des huit reines : étant donné un échiquier, peut-on placer huit reines de sorte qu’aucune reine ne puisse prendre une autre reine ? Plus précisément : sur un plateau de 8x8 cases, peut-on placer huit pions tels que deux pions quelconques ne soient jamais sur la même ligne ou la même diagonale ?</p>
<p>Exemple de solution :</p>
<p><center><div class="ui image center"><img src="assets/pics/huit_reines_ex.png" /></div></center></p>
<p>Ce problème admet effectivement des solutions partielles en ne considérant que <span class="math inline">\(k\)</span> reines à placer. Pour énumérer les solutions, on peut même se contenter de solutions partielles où les <span class="math inline">\(k\)</span> reines sont placées sur les <span class="math inline">\(k\)</span> premières rangées.</p>
<p>Voici ainsi un algorithme pour énumérer les solutions :</p>
<ul>
<li><p>Supposons que <span class="math inline">\(k\)</span> reines aient été placées et qu’on dispose d’une solution partielle.</p>
<ul>
<li>Si <span class="math inline">\(k = 8\)</span> alors toutes les reines sont placées et la solution est complète, on la comptabilise</li>
<li>Sinon, on continue la recherche pour chaque position de la <span class="math inline">\(k+1\)</span> reine sur la <span class="math inline">\(k+1\)</span> rangée qui préserve le fait d’être une solution partielle.</li>
</ul></li>
</ul>
<p>Ici, quand on dit qu’on continue la recherche, ce qu’on signifie, c’est qu’on effectue un appel récursif.</p>
<p>Pour programmer cette méthode, on va définir une fonction récursive de signature :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">val</span> resout_reines : (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span> -&gt; (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span> <span class="dt">list</span></span></code></pre></div>
<p></div></p>
<p>Un appel à <code>resout_reines part</code> va ainsi renvoyer la liste des solutions complètes construites à partir de la solution partielle <code>part</code>. Les solutions sont représentées par des listes de couples de coordonnées sur l’échiquier, donc dans <span class="math inline">\([|0;7|]^2\)</span></p>
<p>Voici une implémentation où on explore les solutions à l’aide d’une boucle impérative dans l’appel récursif. La fonction <code>valide</code> permet de tester si le placement d’une reine est possible avant d’effectuer un appel.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">let</span> <span class="kw">rec</span> valide (x1,y1) l =</span>
<span id="cb17-2"><a href="#cb17-2"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    | [] -&gt; <span class="kw">true</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>    | (x2,y2)::q -&gt;</span>
<span id="cb17-5"><a href="#cb17-5"></a>        x1 &lt;&gt; x2 &amp;&amp; <span class="dt">abs</span> (x2-x1) &lt;&gt; <span class="dt">abs</span>(y2-y1) &amp;&amp; valide (x1,y1) q</span>
<span id="cb17-6"><a href="#cb17-6"></a></span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="kw">let</span> <span class="kw">rec</span> resout_reines part =</span>
<span id="cb17-8"><a href="#cb17-8"></a>    <span class="kw">let</span> k = <span class="dt">List</span>.length part <span class="kw">in</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>    <span class="kw">if</span> k = <span class="dv">8</span> </span>
<span id="cb17-10"><a href="#cb17-10"></a>    <span class="kw">then</span> [ part ]</span>
<span id="cb17-11"><a href="#cb17-11"></a>    <span class="kw">else</span> <span class="kw">begin</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>        <span class="kw">let</span> resultats = <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb17-13"><a href="#cb17-13"></a>        <span class="kw">for</span> x = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">7</span> <span class="kw">do</span></span>
<span id="cb17-14"><a href="#cb17-14"></a>            <span class="kw">let</span> essai = (x,k) :: part <span class="kw">in</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>            <span class="kw">if</span> valide (x,k) part</span>
<span id="cb17-16"><a href="#cb17-16"></a>            <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb17-17"><a href="#cb17-17"></a>                resultats := (resout_reines essai) @ !resultats;</span>
<span id="cb17-18"><a href="#cb17-18"></a>            <span class="kw">end</span></span>
<span id="cb17-19"><a href="#cb17-19"></a>        <span class="kw">done</span>;</span>
<span id="cb17-20"><a href="#cb17-20"></a>        !resultats</span>
<span id="cb17-21"><a href="#cb17-21"></a>    <span class="kw">end</span></span></code></pre></div>
<p></div></p>
<p>et, ici, une autre implémentation purement récursive à l’aide d’une fonction récursive.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">let</span> <span class="kw">rec</span> resout_reines part =</span>
<span id="cb18-2"><a href="#cb18-2"></a>    <span class="kw">let</span> k = <span class="dt">List</span>.length part <span class="kw">in</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>    <span class="kw">if</span> k = <span class="dv">8</span> </span>
<span id="cb18-4"><a href="#cb18-4"></a>    <span class="kw">then</span> [ part ]</span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="kw">else</span> </span>
<span id="cb18-6"><a href="#cb18-6"></a>        <span class="kw">let</span> <span class="kw">rec</span> aux x acc =</span>
<span id="cb18-7"><a href="#cb18-7"></a>            <span class="kw">if</span> x &lt; <span class="dv">0</span></span>
<span id="cb18-8"><a href="#cb18-8"></a>            <span class="kw">then</span> acc</span>
<span id="cb18-9"><a href="#cb18-9"></a>            <span class="kw">else</span> <span class="kw">let</span> essai = (x,k) :: part <span class="kw">in</span></span>
<span id="cb18-10"><a href="#cb18-10"></a>                 <span class="kw">let</span> nacc = <span class="kw">if</span> valide (x,k) part</span>
<span id="cb18-11"><a href="#cb18-11"></a>                           <span class="kw">then</span> (resout_reines essai) @ acc</span>
<span id="cb18-12"><a href="#cb18-12"></a>                           <span class="kw">else</span> acc <span class="kw">in</span></span>
<span id="cb18-13"><a href="#cb18-13"></a>                    aux (x<span class="dv">-1</span>) nacc</span>
<span id="cb18-14"><a href="#cb18-14"></a>        <span class="kw">in</span></span>
<span id="cb18-15"><a href="#cb18-15"></a>        aux <span class="dv">7</span> [] </span></code></pre></div>
<p></div></p>
<p>Une partie de l’arbre de recherche est présenté sur l’image suivante :</p>
<figure>
<img src="../assets/pics/reines_arbre.png" width="1000" alt="Arbre de recherche pour les huit reines" /><figcaption aria-hidden="true">Arbre de recherche pour les huit reines</figcaption>
</figure>
<p>L’arbre complet comporte 2057 nœuds dont 92 feuilles correspondant aux solutions du problème. À titre de comparaison, l’arbre exhaustif correspondant à faire tous les choix de placement à raison d’une reine par ligne compterait <span class="math inline">\(8^8 = 16777216\)</span> nœuds. On voit bien que le backtracking est plus économe en exploration.</p>
<h2 data-number="2.4" id="sec:tp-tours-du-cavalier"><span class="header-section-number">2.4</span> TP : tours du cavalier</h2>
<h2 data-number="2.5" id="sec:tp-jeu-du-solitaire"><span class="header-section-number">2.5</span> TP : jeu du solitaire</h2>
<p>On considère ici le jeu du solitaire. On a un plateau comportant 33 emplacements et initialement 32 pions, représenté par des ronds blancs, et un emplacement vide au centre :</p>
<p><center><div class="ui image center"><img src="assets/pics/solitaire.png" /></div></center></p>
<p>Les différents mouvements possibles consiste à passer d’une configuration <span class="math inline">\(\bullet \bullet \circ\)</span> à <span class="math inline">\(\circ \circ \bullet\)</span> et ainsi à diminuer d’un pion le nombre total de pions. Ces configurations peuvent être rencontrées dans les directions horizontales ou verticales.</p>
<p>On considère que la partie est gagnée quand il n’y a plus qu’un pion sur le plateau.</p>
<h3 data-number="2.5.1" id="sec:première-implémentation-naïve"><span class="header-section-number">2.5.1</span> Première implémentation naïve</h3>
<p>On va représenter un plateau par le type <code>OCaml</code> :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">type</span> case = Vide | Pion | Invalide</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="kw">type</span> plateau = case <span class="dt">array</span> <span class="dt">array</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="kw">let</span> n = <span class="dv">7</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="co">(* Un plateau est une matrice 7x7 avec des cases invalides aux coins *)</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Définir une fonction <code>print_plateau</code> qui affiche un plateau sous un format textuel lisible.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">let</span> print_plateau p =</span>
<span id="cb20-2"><a href="#cb20-2"></a>    <span class="kw">for</span> j = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>        <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>            <span class="kw">let</span> c = <span class="kw">match</span> p.(i).(j) <span class="kw">with</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>            | Invalide -&gt; <span class="ch">&#39; &#39;</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>            | Vide -&gt; <span class="ch">&#39;.&#39;</span></span>
<span id="cb20-7"><a href="#cb20-7"></a>            | Pion -&gt; <span class="ch">&#39;#&#39;</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>            <span class="kw">in</span> <span class="dt">Printf</span>.printf <span class="st">&quot;%c&quot;</span> c</span>
<span id="cb20-9"><a href="#cb20-9"></a>        <span class="kw">done</span>;</span>
<span id="cb20-10"><a href="#cb20-10"></a>        <span class="dt">print_newline</span> ()</span>
<span id="cb20-11"><a href="#cb20-11"></a>    <span class="kw">done</span>;</span>
<span id="cb20-12"><a href="#cb20-12"></a>    <span class="dt">print_newline</span> ()</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>plateau_initial : unit -&gt; plateau</code> qui renvoie un plateau correspondant à la configuration de départ.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">let</span> plateau_initial () =</span>
<span id="cb21-2"><a href="#cb21-2"></a>    [|</span>
<span id="cb21-3"><a href="#cb21-3"></a>        [| Invalide; Invalide; Pion; Pion; Pion; Invalide; Invalide |];</span>
<span id="cb21-4"><a href="#cb21-4"></a>        [| Invalide; Invalide; Pion; Pion; Pion; Invalide; Invalide |];</span>
<span id="cb21-5"><a href="#cb21-5"></a>        [| Pion; Pion; Pion; Pion; Pion; Pion; Pion |];</span>
<span id="cb21-6"><a href="#cb21-6"></a>        [| Pion; Pion; Pion; Vide; Pion; Pion; Pion |];</span>
<span id="cb21-7"><a href="#cb21-7"></a>        [| Pion; Pion; Pion; Pion; Pion; Pion; Pion |];</span>
<span id="cb21-8"><a href="#cb21-8"></a>        [| Invalide; Invalide; Pion; Pion; Pion; Invalide; Invalide |];</span>
<span id="cb21-9"><a href="#cb21-9"></a>        [| Invalide; Invalide; Pion; Pion; Pion; Invalide; Invalide |]</span>
<span id="cb21-10"><a href="#cb21-10"></a>    |]</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>Un mouvement peut être assimilé à un triplet de coordonnées décrivant, dans l’ordre <span class="math inline">\(\bullet \bullet \circ\)</span> les trois cases concernées. Il se trouve que la case centrale est toujours le milieu des deux autres, on peut donc se contenter de donner un couple de coordonnées pour décrire un mouvement.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">type</span> mouvement = (<span class="dt">int</span> * <span class="dt">int</span>) * (<span class="dt">int</span> * <span class="dt">int</span>)</span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>mouvements : plateau -&gt; mouvement list</code> qui renvoie la liste des mouvements possibles sur le plateau passé en paramètre.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">let</span> possible p (i1,j1) (i3,j3) =</span>
<span id="cb23-2"><a href="#cb23-2"></a>    <span class="kw">let</span> i2, j2 = (i1+i3)/<span class="dv">2</span>, (j1+j3)/<span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    p.(i1).(j1) = Pion &amp;&amp; p.(i2).(j2) = Pion &amp;&amp; p.(i3).(j3) = Vide</span>
<span id="cb23-4"><a href="#cb23-4"></a></span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="kw">let</span> mouvements p =</span>
<span id="cb23-6"><a href="#cb23-6"></a>    <span class="co">(* on utilise une pile *)</span></span>
<span id="cb23-7"><a href="#cb23-7"></a>    <span class="kw">let</span> l = <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb23-8"><a href="#cb23-8"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb23-9"><a href="#cb23-9"></a>        <span class="kw">for</span> j = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-3</span> <span class="kw">do</span></span>
<span id="cb23-10"><a href="#cb23-10"></a>            <span class="kw">if</span> possible p (i,j) (i,j+<span class="dv">2</span>)</span>
<span id="cb23-11"><a href="#cb23-11"></a>            <span class="kw">then</span> l := ( (i,j), (i,j+<span class="dv">2</span>) ) :: !l;</span>
<span id="cb23-12"><a href="#cb23-12"></a>            <span class="kw">if</span> possible p (i,j+<span class="dv">2</span>) (i,j)</span>
<span id="cb23-13"><a href="#cb23-13"></a>            <span class="kw">then</span> l := ( (i,j+<span class="dv">2</span>), (i,j) ) :: !l;</span>
<span id="cb23-14"><a href="#cb23-14"></a>            <span class="kw">if</span> possible p (j+<span class="dv">2</span>,i) (j,i)</span>
<span id="cb23-15"><a href="#cb23-15"></a>            <span class="kw">then</span> l := ( (j+<span class="dv">2</span>,i), (j,i) ) :: !l;</span>
<span id="cb23-16"><a href="#cb23-16"></a>            <span class="kw">if</span> possible p (j,i) (j+<span class="dv">2</span>,i)</span>
<span id="cb23-17"><a href="#cb23-17"></a>            <span class="kw">then</span> l := ( (j,i), (j+<span class="dv">2</span>,i) ) :: !l</span>
<span id="cb23-18"><a href="#cb23-18"></a>        <span class="kw">done</span></span>
<span id="cb23-19"><a href="#cb23-19"></a>    <span class="kw">done</span>;</span>
<span id="cb23-20"><a href="#cb23-20"></a>    !l</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>compte_pions : plateau -&gt; int</code> qui renvoie le nombre de pions sur un plateau.</p>
<p>En déduire une fonction <code>valide : plateau -&gt; bool</code> qui indique si un plateau correspond à une partie gagnante.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">let</span> compte_pions p =</span>
<span id="cb24-2"><a href="#cb24-2"></a>    <span class="kw">let</span> c = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>        <span class="kw">for</span> j = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>            <span class="kw">if</span> p.(i).(j) = Pion</span>
<span id="cb24-6"><a href="#cb24-6"></a>            <span class="kw">then</span> <span class="dt">incr</span> c</span>
<span id="cb24-7"><a href="#cb24-7"></a>        <span class="kw">done</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>    <span class="kw">done</span>;</span>
<span id="cb24-9"><a href="#cb24-9"></a>    !c</span>
<span id="cb24-10"><a href="#cb24-10"></a></span>
<span id="cb24-11"><a href="#cb24-11"></a><span class="kw">let</span> valide p = compte_pions p = <span class="dv">1</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire deux fonctions <code>faire</code> et <code>defaire</code> de type <code>plateau -&gt; mouvement -&gt; unit</code> permettant de faire et défaire un mouvement.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">let</span> applique p mouv =</span>
<span id="cb25-2"><a href="#cb25-2"></a>    <span class="kw">let</span> (i1,j1), (i3,j3) = mouv <span class="kw">in</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>    <span class="kw">let</span> i2, j2 = (i1+i3)/<span class="dv">2</span>, (j1+j3)/<span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb25-4"><a href="#cb25-4"></a>    p.(i1).(j1) &lt;- Vide;</span>
<span id="cb25-5"><a href="#cb25-5"></a>    p.(i2).(j2) &lt;- Vide;</span>
<span id="cb25-6"><a href="#cb25-6"></a>    p.(i3).(j3) &lt;- Pion</span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="kw">let</span> defaire p mouv =</span>
<span id="cb25-9"><a href="#cb25-9"></a>    <span class="kw">let</span> (i1,j1), (i3,j3) = mouv <span class="kw">in</span></span>
<span id="cb25-10"><a href="#cb25-10"></a>    <span class="kw">let</span> i2, j2 = (i1+i3)/<span class="dv">2</span>, (j1+j3)/<span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb25-11"><a href="#cb25-11"></a>    p.(i1).(j1) &lt;- Pion;</span>
<span id="cb25-12"><a href="#cb25-12"></a>    p.(i2).(j2) &lt;- Pion;</span>
<span id="cb25-13"><a href="#cb25-13"></a>    p.(i3).(j3) &lt;- Vide</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>enumere : plateau -&gt; mouvement list -&gt; unit</code> telle que <code>enumere pos chemin</code> énumère les plateaux accessibles depuis <code>pos</code> jusqu’à obtenir une solution et sachant que <code>chemin</code> est la liste de mouvements, du plus récent au plus ancien, qui ont conduit jusqu’à <code>pos</code>.</p>
<p>En cas de succès, on produira une exception <code>Solution of mouvement list</code> renvoyant la liste des mouvements ayant conduits à une solution.</p>
<p>En déduire une fonction <code>resout : unit -&gt; mouvement list</code> qui renvoie une liste de mouvement permettant de résoudre le solitaire. On prendra garde à renverser le chemin obtenu pour que le premier mouvement de la liste soit le premier mouvement effectué.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">exception</span> Solution <span class="kw">of</span> mouvement <span class="dt">list</span></span>
<span id="cb26-2"><a href="#cb26-2"></a></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="kw">let</span> <span class="kw">rec</span> enumere pos chemin =</span>
<span id="cb26-4"><a href="#cb26-4"></a>    <span class="kw">if</span> valide pos</span>
<span id="cb26-5"><a href="#cb26-5"></a>    <span class="kw">then</span> <span class="dt">raise</span> (Solution chemin)</span>
<span id="cb26-6"><a href="#cb26-6"></a>    <span class="kw">else</span> <span class="kw">let</span> l = mouvements pos <span class="kw">in</span></span>
<span id="cb26-7"><a href="#cb26-7"></a>        <span class="dt">List</span>.iter (<span class="kw">fun</span> mouv -&gt; </span>
<span id="cb26-8"><a href="#cb26-8"></a>                    applique pos mouv;</span>
<span id="cb26-9"><a href="#cb26-9"></a>                    enumere pos (mouv :: chemin);</span>
<span id="cb26-10"><a href="#cb26-10"></a>                    defaire pos mouv) l</span>
<span id="cb26-11"><a href="#cb26-11"></a></span>
<span id="cb26-12"><a href="#cb26-12"></a><span class="kw">let</span> resout () =</span>
<span id="cb26-13"><a href="#cb26-13"></a>    <span class="kw">let</span> pos = plateau_initial () <span class="kw">in</span></span>
<span id="cb26-14"><a href="#cb26-14"></a>    <span class="kw">try</span></span>
<span id="cb26-15"><a href="#cb26-15"></a>        enumere pos [];</span>
<span id="cb26-16"><a href="#cb26-16"></a>        <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb26-17"><a href="#cb26-17"></a>    <span class="kw">with</span> Solution l -&gt; <span class="dt">List</span>.rev l</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>Ce code ne permet pas de calculer la solution car il prend beaucoup trop de temps en raison du nombre de positions étudiées.</p>
<h3 data-number="2.5.2" id="sec:cache-des-mauvaises-positions"><span class="header-section-number">2.5.2</span> Cache des mauvaises positions</h3>
<p>On se rend compte que de nombreuses positions sont réetudiées alors qu’on sait déjà qu’elles ne peuvent permettre d’aboutir à une solution. En effet, il y a souvent des coups indépendants pouvant être joués au même moment, ce qui fait qu’on peut aboutir à une même position de beaucoup de manière différente, ce qui augmente exceptionnellement le nombre d’appels récursifs.</p>
<p>Une stratégie consiste a maintenir un ensemble de configurations mauvaises. Pour réaliser un tel ensemble, on va utiliser une table de hâchage dont les clés sont les positions et les valeurs <code>unit</code>. Si une position a une valeur associée dans la table, c’est qu’elle sera mauvaise.</p>
<p>Cela pose la question de la représentation persistante et immuable des positions. Une première stratégie peut consister à transformer le plateau en <code>case list list</code>. Cette stratégie est beaucoup trop coûteuse et elle ne permet pas de répondre instantanément. On va profiter du fait qu’il n’y est que 49 cases dans le plateau pour le représenter par un entiers sur 49 bits : <span class="math inline">\(a_{00} + a_{10} 2 + a_{20} 2^2 + ... + a_{60} 2^6 + a_{01} 2^7 + ... + a_{66} 2^{48}\)</span> où <span class="math inline">\(a_{ij}\)</span> vaut 1 lorsqu’il y a un pion sur la jième ligne et la ième colonne, c’est-à-dire quand <code>p.(i).(j) = Pion</code>.</p>
<p><em>Indication</em> l’entier <code>1 lsl n</code> est <span class="math inline">\(2^n\)</span>. <code>lsl</code> signifie qu’on décale le chiffre <code>1</code> de <code>n</code> bits vers la droite dans son écriture binaire.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>code : plateau -&gt; int</code> qui renvoie le numéro associé à un plateau.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">let</span> code p =</span>
<span id="cb27-2"><a href="#cb27-2"></a>    <span class="kw">let</span> c = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb27-3"><a href="#cb27-3"></a>    <span class="kw">for</span> j = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">6</span> <span class="kw">do</span></span>
<span id="cb27-4"><a href="#cb27-4"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">6</span> <span class="kw">do</span></span>
<span id="cb27-5"><a href="#cb27-5"></a>        <span class="kw">if</span> p.(i).(j) = Pion</span>
<span id="cb27-6"><a href="#cb27-6"></a>        <span class="kw">then</span> c := !c + <span class="dv">1</span> <span class="kw">lsl</span> (<span class="dv">7</span>*j+i)</span>
<span id="cb27-7"><a href="#cb27-7"></a>    <span class="kw">done</span></span>
<span id="cb27-8"><a href="#cb27-8"></a>    <span class="kw">done</span>;</span>
<span id="cb27-9"><a href="#cb27-9"></a>    !c</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>Pour manipuler un ensemble, on va définir</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">let</span> mauvaises = <span class="dt">Hashtbl</span>.create <span class="dv">42</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="kw">let</span> ajoute x = <span class="dt">Hashtbl</span>.add mauvaises x ()</span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="kw">let</span> contient x = <span class="dt">Hashtbl</span>.mem mauvaises x</span></code></pre></div>
<p></div></p>
<p>L’appel à <code>ajoute x</code> rajoute <code>x</code> dans l’ensemble des mauvaises positions et <code>contient x</code> vérifie si <code>x</code> est dans cet ensemble.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Reprendre la fonction <code>enumere</code> avec un ensemble de mauvais codes.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Réponse </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">let</span> <span class="kw">rec</span> enumere pos chemin =</span>
<span id="cb29-2"><a href="#cb29-2"></a>    <span class="kw">if</span> valide pos</span>
<span id="cb29-3"><a href="#cb29-3"></a>    <span class="kw">then</span> <span class="dt">raise</span> (Solution chemin)</span>
<span id="cb29-4"><a href="#cb29-4"></a>    <span class="kw">else</span></span>
<span id="cb29-5"><a href="#cb29-5"></a>        <span class="kw">let</span> c = code pos <span class="kw">in</span></span>
<span id="cb29-6"><a href="#cb29-6"></a>        <span class="kw">if</span> <span class="dt">not</span> (contient c)</span>
<span id="cb29-7"><a href="#cb29-7"></a>        <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb29-8"><a href="#cb29-8"></a>            <span class="kw">let</span> l = mouvements pos <span class="kw">in</span></span>
<span id="cb29-9"><a href="#cb29-9"></a>            <span class="dt">List</span>.iter (<span class="kw">fun</span> mouv -&gt; </span>
<span id="cb29-10"><a href="#cb29-10"></a>                        applique pos mouv;</span>
<span id="cb29-11"><a href="#cb29-11"></a>                        enumere pos (mouv :: chemin);</span>
<span id="cb29-12"><a href="#cb29-12"></a>                        defaire pos mouv) l;</span>
<span id="cb29-13"><a href="#cb29-13"></a>            <span class="co">(* Si on est ici c&#39;est que le noeud ne permet pas de trouver </span></span>
<span id="cb29-14"><a href="#cb29-14"></a><span class="co">               une solution *)</span></span>
<span id="cb29-15"><a href="#cb29-15"></a>            ajoute c</span>
<span id="cb29-16"><a href="#cb29-16"></a>        <span class="kw">end</span></span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>Normalement, le code doit pouvoir permettre de réaliser la résolution instantanément.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Possibles extensions :</p>
<ul>
<li>rajouter un affichage de la résolution</li>
<li>déterminer la proportion de recalculs évités</li>
<li>gérer les symétries des plateaux</div></li>
</ul>
<h1 data-number="3" id="sec:stratégies-dénumération"><span class="header-section-number">3</span> Stratégies d’énumération</h1>
<h2 data-number="3.1" id="sec:combinatoire-élémentaire"><span class="header-section-number">3.1</span> Combinatoire élémentaire</h2>
<p>produits, combinaisons, permutations</p>
<h2 data-number="3.2" id="sec:enumération-darbres"><span class="header-section-number">3.2</span> Enumération d’arbres</h2>
<p>Imaginons que l’on souhaite énumérer des arbres binaires non étiquettés pour trouver le premier arbre binaire à <span class="math inline">\(n\)</span> nœuds vérifiant une certaine propriété. On suppose ainsi défini un type</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">type</span> arbre = Nil | Noeud <span class="kw">of</span> arbre * arbre</span></code></pre></div>
<p></div></p>
<p>et une fonction pour tester le prédicat :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">val</span> : valide : arbre -&gt; <span class="dt">bool</span></span></code></pre></div>
<p></div></p>
<p>Une première possibilité est d’effectuer un simple parcours récursif :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">let</span> <span class="kw">rec</span> recherche n =</span>
<span id="cb32-2"><a href="#cb32-2"></a>    <span class="kw">if</span> n = <span class="dv">0</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>    <span class="kw">then</span> </span></code></pre></div>
<p></div></p>
<p>normale, par passage de continuation</p>
<h1 data-number="4" id="sec:droite-de-balayage"><span class="header-section-number">4</span> Droite de balayage</h1>
<h2 data-number="4.1" id="sec:principe-1"><span class="header-section-number">4.1</span> Principe</h2>
<p>Il est parfois possible d’ordonner <span class="math inline">\(V\)</span> pour tirer pour permettre de trouver une solution plus vite, voir d’ordonner des données basique pour ne pas énumérer <span class="math inline">\(V\)</span> mais énumérer un <span class="math inline">\(V&#39; \subset V\)</span> plus petit.</p>
<p>C’est un procédé classique dans le contexte de la géométrie algorithmique dans le plan : étant donné un ensemble <span class="math inline">\(V\)</span> de candidats qu’on déduit d’un ensemble de points du plan, par exemple l’ensemble des paires de points, on va énumérer <span class="math inline">\(V\)</span> à l’aide d’un parcours des points de gauche à droite (ou tout autre direction géométrique) pour ne pas énumérer tout <span class="math inline">\(V\)</span> mais seulement une partie plus petite. Tout se passe comme si on balayait avec un droite l’ensemble des points, d’où le nom de droite de balayage.</p>
<p>Du point de vue de la complexité temporelle, on obtient le plus souvent un algorithme en <span class="math inline">\(O(n \log n)\)</span> où <span class="math inline">\(n\)</span> est le nombre de points. Cela signifie que l’étape la plus coûteuse en temps est le tri initial.</p>
<p>On va présenter ici deux exemples d’utilisation d’une droite de balayage. Il est assez clair qu’il sera nécessaire dans ces cas de réfléchir géométriquement. Les exemples présentés sont donc assez simples d’un point de vue informatique, mais plutôt complexes d’un point de vue mathématiques.</p>
<h2 data-number="4.2" id="sec:plusprochepaire"><span class="header-section-number">4.2</span> Plus proche paire</h2>
<p>On considère le problème</p>
<div class="ui message gray">
<div class="header">
Problème - PlusProchePaire
</div>
<ul>
<li>
<p>Entrée(s) :</p>
<p>Un ensemble <span class="math inline">\(P\)</span> de <span class="math inline">\(n\)</span> points dans le plan.</p>
</li>
<li>
Sortie : Une paire <span class="math inline">\(\{p,p&#39;\}\)</span> de points telle que <span class="math inline">\(dist(p,p&#39;) = ||\vec{pp&#39;}||\)</span> soit minimale.
</li>
</ul>
</div>
<h3 data-number="4.2.1" id="sec:recherche-exhaustive"><span class="header-section-number">4.2.1</span> Recherche exhaustive</h3>
<p>Considérons le problème <em>PlusProchePaire</em> qui, étant donné un ensemble de <span class="math inline">\(n\)</span> points (<span class="math inline">\(n \ge 2\)</span>), détermine la paire constituée des deux points les plus proches.</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/plusprochepaire_a.png" /></div></center></p>
<p></div></center></p>
<p>Une implémentation naïve de la recherche par force brute consiste à énumérer les <span class="math inline">\(\frac{n(n-1)}{2}\)</span> paires et donc à effectuer <span class="math inline">\(O(n^2)\)</span> itérations.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">let</span> plus_proche_paire points =</span>
<span id="cb33-2"><a href="#cb33-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length points <span class="kw">in</span></span>
<span id="cb33-3"><a href="#cb33-3"></a>    <span class="kw">let</span> min_paire = <span class="dt">ref</span> (distance points.(<span class="dv">0</span>) points.(<span class="dv">1</span>), (<span class="dv">0</span>, <span class="dv">1</span>)) <span class="kw">in</span></span>
<span id="cb33-4"><a href="#cb33-4"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb33-5"><a href="#cb33-5"></a>        <span class="kw">for</span> j = i+<span class="dv">1</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb33-6"><a href="#cb33-6"></a>            <span class="kw">let</span> d = distance points.(i) points.(j) <span class="kw">in</span></span>
<span id="cb33-7"><a href="#cb33-7"></a>            <span class="kw">if</span> d &lt; <span class="dt">fst</span> !min_paire</span>
<span id="cb33-8"><a href="#cb33-8"></a>            <span class="kw">then</span> min_paire := (d, (i, j))</span>
<span id="cb33-9"><a href="#cb33-9"></a>        <span class="kw">done</span></span>
<span id="cb33-10"><a href="#cb33-10"></a>    <span class="kw">done</span>;</span>
<span id="cb33-11"><a href="#cb33-11"></a>    <span class="dt">snd</span> !min_paire</span></code></pre></div>
<p></div></p>
<h3 data-number="4.2.2" id="sec:raffinement-droite-de-balayage"><span class="header-section-number">4.2.2</span> Raffinement : droite de balayage</h3>
<p>Il est parfois possible d’accélérer la recherche par force brute en ordonnant le parcours des candidats pour pouvoir éviter de tester certains d’entre eux.</p>
<p>En géométrie algorithmique, une approche classique consiste à ordonner les objets selon leur abscisse et à parcourir les objets par abscisse croissante. On parle alors de <strong>droite de balayage</strong> (en anglais, <em>sweep line</em>) car cela revient à balayer le plan par une droite verticale en ne traitant que les objets avant cette ligne.</p>
<p>Reprenons le problème précédent, on considère que les points sont triés par abscisse croissante : <span class="math inline">\((x_0,y_0), \dots, (x_{n-1}, y_{n-1})\)</span>. On va parcourir les points dans cet ordre en maintenant un ensemble de points à gauche du point courant, appelés <em>points actifs</em>, et en ne calculant que les intersections avec les points actifs.</p>
<p>Si on a parcouru les <span class="math inline">\(N\)</span> premiers points et qu’on a obtenu que la plus petite distance était <span class="math inline">\(d\)</span>, lorsqu’on considère le point <span class="math inline">\((x_N,y_N)\)</span>, il est inutile de tester les points qui sont forcément à distance <span class="math inline">\(&gt; d\)</span> de celui-ci. C’est-à-dire qu’on peut éliminer les points qui ne sont pas dans le rectangle <span class="math inline">\([x_N-d,x_N]\times [y_N-d,y_N+d]\)</span> du test. Les points dont l’abscisse est <span class="math inline">\(&lt; x_N -d\)</span> peuvent être éliminés définitivement vu que l’on raisonne par abscisse croissante, par contre, les points d’ordonnées invalides doivent être conservés pour les points ultérieurs.</p>
<p>Ce rectangle est représenté sur le schéma suivant ainsi qu’une ligne imaginaire qui correspond à l’abscisse du point courant et qu’on peut imaginer parcourant le plan de gauche à droite pour traiter les points au fur et à mesure.</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/plusprochepaire_b.png" /></div></center></p>
<p></div></center></p>
<p>Afin de déterminer la complexité de cet algorithme, il est nécessaire de connaitre le nombre maximal de points dans le rectangle. Comme ces points ont été pris en compte précédemment, ils sont forcément à distance au moins <span class="math inline">\(d\)</span> les uns des autres. Il s’agit donc de déterminer le nombre maximum de points qu’on peut placer dans ce rectangle à distance au moins <span class="math inline">\(d\)</span>. On remarque tout d’abord qu’on peut placer six points ainsi :</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/plusprochepaire_activesize_a.png" /></div></center></p>
<p></div></center></p>
<p>Si jamais on avait au moins sept points, on peut voir qu’il y a forcément un des six sous-rectangles suivants qui contiendrait au moins deux points :</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/plusprochepaire_activesize_b.png" /></div></center></p>
<p></div></center></p>
<p>Or, ces sous-rectangles sont de longueur <span class="math inline">\(\frac{1}{2}d\)</span> et de hauteur <span class="math inline">\(\frac{2}{3}d\)</span>, donc la distance maximale entre deux de leurs points correspond à la longueur des diagonales : <span class="math inline">\(\sqrt{\frac{1}{4} + \frac{4}{9}}d = \frac{5}{6}d &lt; d\)</span>.</p>
<p>Comme un de ces six points est le point courant, il y a toujours au plus 5 points dans l’ensemble des points actifs.</p>
<p>Voici le principe de l’algorithme que l’on va implémenter :</p>
<ul>
<li><p>On trie le tableau <code>points</code> par ordre croissant. <strong>Complexité :</strong> <span class="math inline">\(O(n \log n)\)</span></p></li>
<li><p>On initialise la plus petite distance <code>d</code> courante à la distance entre les deux premiers points</p></li>
<li><p>On crée un ensemble <code>actifs</code>, ordonné par les ordonnées, de points contenant initialement les deux premiers points</p></li>
<li><p>Pour chaque point <span class="math inline">\((x,y)\)</span> en partant du deuxième :</p>
<ul>
<li>On supprime les points <span class="math inline">\((x&#39;,y&#39;)\)</span> tels que <span class="math inline">\(x&#39; &lt; x - d\)</span> de <code>actifs</code>. <strong>Complexité :</strong> sur l’ensemble des itérations on ne pourra jamais supprimer deux fois un point, donc on effectue au maximum <span class="math inline">\(n\)</span> suppressions chacune en <span class="math inline">\(O(\log n)\)</span> donc <span class="math inline">\(O(n \log n)\)</span>.</li>
<li>On parcourt les points de <code>actifs</code> dont les ordonnées sont comprises entre <span class="math inline">\(y-d\)</span> et <span class="math inline">\(y+d\)</span>. <strong>Complexité :</strong> pour récupérer le premier point de l’ensemble, il faut <span class="math inline">\(O(\log n)\)</span> en pire cas (tous les points actifs) et ensuite on effectue au plus 5 itérations comme on vient de le prouver.</li>
</ul></li>
</ul>
<p>L’animation suivante présente le déroulement de cet algorihtme. La bande active est indiquée en gris et le rectangle autour du point courant en gris foncé :</p>
<p><img class="ui image fluid" src="assets/pics/closest_pair.gif"/></p>
<p>On remarque ainsi que la complexité en temps et en pire cas de cet algorithme est de <span class="math inline">\(O(n \log n)\)</span>. Ici, le fait d’avoir la structure <code>actifs</code> ordonnée par les ordonnées est crucial pour garantir la complexité. Pour la réalisation d’une structure d’ensemble ordonnée ayant ces complexités, voir le chapitre FIXME.</p>
<p>Ici, on utilise le module <code>Set</code> d’OCaml pour réaliser la structure d’ensemble, pour cela on commence par créer le module <code>PointSet</code> pour les ensembles de points :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">module</span> Point = <span class="kw">struct</span></span>
<span id="cb34-2"><a href="#cb34-2"></a>    <span class="kw">type</span> t = <span class="dt">float</span> * <span class="dt">float</span></span>
<span id="cb34-3"><a href="#cb34-3"></a>    <span class="kw">let</span> <span class="dt">compare</span> (x1,y1) (x2,y2) = Stdlib.<span class="dt">compare</span> y1 y2</span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="kw">end</span></span>
<span id="cb34-5"><a href="#cb34-5"></a></span>
<span id="cb34-6"><a href="#cb34-6"></a><span class="kw">module</span> PointSet = <span class="dt">Set</span>.Make(Point)</span></code></pre></div>
<p></div></p>
<p>Puis on définit une fonction permettant de parcourir les points entre deux ordonnées :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">let</span> set_iter_entre f set bas haut =</span>
<span id="cb35-2"><a href="#cb35-2"></a>    <span class="kw">try</span></span>
<span id="cb35-3"><a href="#cb35-3"></a>        <span class="kw">let</span> e = PointSet.find_first (<span class="kw">fun</span> p -&gt; <span class="dt">snd</span> p &gt;= bas) set <span class="kw">in</span></span>
<span id="cb35-4"><a href="#cb35-4"></a>        <span class="kw">let</span> seq = PointSet.to_seq_from e set <span class="kw">in</span></span>
<span id="cb35-5"><a href="#cb35-5"></a>        <span class="kw">let</span> <span class="kw">rec</span> aux seq =</span>
<span id="cb35-6"><a href="#cb35-6"></a>            <span class="kw">match</span> seq () <span class="kw">with</span></span>
<span id="cb35-7"><a href="#cb35-7"></a>            | Seq.Nil -&gt; ()</span>
<span id="cb35-8"><a href="#cb35-8"></a>            | Seq.Cons (p, seq_suite) -&gt; </span>
<span id="cb35-9"><a href="#cb35-9"></a>                    <span class="kw">if</span> <span class="dt">snd</span> p &lt;= haut</span>
<span id="cb35-10"><a href="#cb35-10"></a>                    <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb35-11"><a href="#cb35-11"></a>                        f p;</span>
<span id="cb35-12"><a href="#cb35-12"></a>                        aux seq_suite</span>
<span id="cb35-13"><a href="#cb35-13"></a>                    <span class="kw">end</span></span>
<span id="cb35-14"><a href="#cb35-14"></a>        <span class="kw">in</span> aux seq</span>
<span id="cb35-15"><a href="#cb35-15"></a>    <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; ()</span></code></pre></div>
<p></div></p>
<p>On implémente alors assez directement l’algorithme décrit précédemment :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">let</span> plus_proche_paire_balayage points =</span>
<span id="cb36-2"><a href="#cb36-2"></a>    <span class="kw">let</span> <span class="dt">compare</span> (x1,y1) (x2,y2) =</span>
<span id="cb36-3"><a href="#cb36-3"></a>        <span class="kw">if</span> x1 = x2</span>
<span id="cb36-4"><a href="#cb36-4"></a>        <span class="kw">then</span> <span class="kw">if</span> y1 &lt; y2 <span class="kw">then</span> <span class="dv">-1</span> <span class="kw">else</span> <span class="dv">1</span></span>
<span id="cb36-5"><a href="#cb36-5"></a>        <span class="kw">else</span> <span class="kw">if</span> x1 &lt; x2 <span class="kw">then</span> <span class="dv">-1</span> <span class="kw">else</span> <span class="dv">1</span></span>
<span id="cb36-6"><a href="#cb36-6"></a>    <span class="kw">in</span></span>
<span id="cb36-7"><a href="#cb36-7"></a>    <span class="dt">Array</span>.sort <span class="dt">compare</span> points;</span>
<span id="cb36-8"><a href="#cb36-8"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length points <span class="kw">in</span></span>
<span id="cb36-9"><a href="#cb36-9"></a>    <span class="kw">let</span> d = <span class="dt">ref</span> (distance points.(<span class="dv">0</span>) points.(<span class="dv">1</span>)) <span class="kw">in</span></span>
<span id="cb36-10"><a href="#cb36-10"></a>    <span class="kw">let</span> couple = <span class="dt">ref</span> (points.(<span class="dv">0</span>), points.(<span class="dv">1</span>)) <span class="kw">in</span></span>
<span id="cb36-11"><a href="#cb36-11"></a>    <span class="kw">let</span> actifs = <span class="dt">ref</span> (PointSet.empty </span>
<span id="cb36-12"><a href="#cb36-12"></a>            |&gt; PointSet.add points.(<span class="dv">0</span>) |&gt; PointSet.add points.(<span class="dv">1</span>)) <span class="kw">in</span></span>
<span id="cb36-13"><a href="#cb36-13"></a></span>
<span id="cb36-14"><a href="#cb36-14"></a>    <span class="kw">let</span> gauche = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb36-15"><a href="#cb36-15"></a></span>
<span id="cb36-16"><a href="#cb36-16"></a>    <span class="kw">for</span> i = <span class="dv">2</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb36-17"><a href="#cb36-17"></a>        <span class="kw">let</span> xi, yi = points.(i) <span class="kw">in</span></span>
<span id="cb36-18"><a href="#cb36-18"></a>        </span>
<span id="cb36-19"><a href="#cb36-19"></a>        <span class="kw">while</span> <span class="dt">fst</span> points.(!gauche) &lt; xi -. !d <span class="kw">do</span></span>
<span id="cb36-20"><a href="#cb36-20"></a>            actifs := PointSet.remove points.(!gauche) !actifs;</span>
<span id="cb36-21"><a href="#cb36-21"></a>            <span class="dt">incr</span> gauche</span>
<span id="cb36-22"><a href="#cb36-22"></a>        <span class="kw">done</span>;</span>
<span id="cb36-23"><a href="#cb36-23"></a></span>
<span id="cb36-24"><a href="#cb36-24"></a>        set_iter_entre (<span class="kw">fun</span> pj -&gt; </span>
<span id="cb36-25"><a href="#cb36-25"></a>            <span class="kw">let</span> dip = distance points.(i) pj <span class="kw">in</span></span>
<span id="cb36-26"><a href="#cb36-26"></a>            <span class="kw">if</span> dip &lt; !d</span>
<span id="cb36-27"><a href="#cb36-27"></a>            <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb36-28"><a href="#cb36-28"></a>                couple := (points.(i), pj);</span>
<span id="cb36-29"><a href="#cb36-29"></a>                d := dip</span>
<span id="cb36-30"><a href="#cb36-30"></a>            <span class="kw">end</span>) !actifs (yi -. !d) (yi +. !d);</span>
<span id="cb36-31"><a href="#cb36-31"></a></span>
<span id="cb36-32"><a href="#cb36-32"></a>        actifs := PointSet.add points.(i) !actifs</span>
<span id="cb36-33"><a href="#cb36-33"></a>    <span class="kw">done</span>;</span>
<span id="cb36-34"><a href="#cb36-34"></a>    !d</span></code></pre></div>
<p></div></p>
<h3 data-number="4.2.3" id="sec:problème-test-dintersection-pour-un-ensemble-de-segments"><span class="header-section-number">4.2.3</span> Problème : test d’intersection pour un ensemble de segments</h3>
<p>Considérons le problème suivant <em>IntersectionEnsemble</em> : étant donné <span class="math inline">\(n\)</span> segments dans le plan, il s’agit de déterminer si au moins deux des segments s’intersectent.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>On peut considérer ici que l’on dispose d’une fonction</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb37-1"><a href="#cb37-1"></a>intersecte : (<span class="dt">float</span> * <span class="dt">float</span>) * (<span class="dt">float</span> * <span class="dt">float</span>) </span>
<span id="cb37-2"><a href="#cb37-2"></a>    -&gt; (<span class="dt">float</span> * <span class="dt">float</span>) * (<span class="dt">float</span> * <span class="dt">float</span>) -&gt; <span class="dt">bool</span> </span></code></pre></div>
<p></div></p>
<p>qui teste l’intersection entre deux segments.</p>
<p>Cependant, il est possible d’écrire une telle fonction avec un peu de géométrie élémentaire.</p>
<p>Si on considère que les deux segments sont <span class="math inline">\([A_1B_1]\)</span> et <span class="math inline">\([A_2B_2]\)</span>, avec <span class="math inline">\(A_1 \neq B_1\)</span> et <span class="math inline">\(A_2 \neq B_2\)</span>, alors chaque point du segment <span class="math inline">\([A_1B_1]\)</span> est de la forme <span class="math inline">\(A_1 + t \overrightarrow{A_1B_1}\)</span> où <span class="math inline">\(t \in [0,1]\)</span>. De même les points du segment <span class="math inline">\([A_2B_2]\)</span> sont de la forme <span class="math inline">\(A_2 + u \overrightarrow{A_2B_2}\)</span> où <span class="math inline">\(u \in [0,1]\)</span>.</p>
<p>S’il y a une intersection, c’est qu’il existe <span class="math inline">\((t,u) \in [0,1]^2\)</span> tel que</p>
<p><span class="math display">\[
A_1 + t \overrightarrow{A_1B_1} = A_2 + u \overrightarrow{A_2B_2}
\iff \overrightarrow{A_2 A_1} + t \overrightarrow{A_1B_1} = u
\overrightarrow{A_2 B_2}
\]</span></p>
<p>L’idée est alors d’utiliser une opération appelée <strong>produit vectoriel</strong> sur les vecteurs. Comme ici, tout est plan, le produit vectoriel est uniquement déterminé par sa troisième coordonnée, celle qui sort du plan, et on peut se contenter de calculer celle-ci. On note ainsi <span class="math inline">\((x,y) \times (x&#39;,y&#39;) = x y&#39; - y x&#39;\)</span> cette coordonnée. On a donc <span class="math inline">\(u \times u = 0\)</span>.</p>
<p>On peut alors composer l’égalité par <span class="math inline">\(\times \overrightarrow{A_2B_2}\)</span> :</p>
<p><span class="math display">\[
\overrightarrow{A_2 A_1} \times \overrightarrow{A_2 B_2} + t 
\left( \overrightarrow{A_1 B_1} \times \overrightarrow{A_2 B_2} \right) = 0
\]</span></p>
<p>Notons <span class="math inline">\(\Delta = \overrightarrow{A_1 B_1} \times \overrightarrow{A_2 B_2}\)</span>, si <span class="math inline">\(\Delta \neq 0\)</span>, alors</p>
<p><span class="math display">\[
t = - \frac{\overrightarrow{A_2 A_1} \times \overrightarrow{A_2 B_2}}{\Delta}
= \frac{\overrightarrow{A_1 A_2} \times \overrightarrow{A_2 B_2}}{\Delta}
\]</span></p>
<p>On procède de même avec <span class="math inline">\(\times \overrightarrow{A_1 B_1}\)</span> pour obtenir une expression de <span class="math inline">\(u\)</span> : <span class="math inline">\(\overrightarrow{A_2 A_1} \times \overrightarrow{A_1 B_1} = u \left ( \overrightarrow{A_2 B_2} \times \overrightarrow{A_1 B_1} \right) = - u \Delta\)</span> et donc</p>
<p><span class="math display">\[
u = - \frac{\overrightarrow{A_2 A_1} \times \overrightarrow{A_1 B_1}}{\Delta}
= \frac{\overrightarrow{A_1 A_2} \times \overrightarrow{A_1 B_1}}{\Delta}
\]</span></p>
<p>Si <span class="math inline">\(\Delta \neq 0\)</span>, on peut donc alors exprimer <span class="math inline">\(u\)</span> et <span class="math inline">\(t\)</span> et vérifier qu’ils sont dans <span class="math inline">\([0,1]\)</span>.</p>
<p>Si <span class="math inline">\(\Delta = 0\)</span> c’est que les deux segments sont de directions parallèles ou confondues.</p>
<ul>
<li>Si <span class="math inline">\(\overrightarrow{A_1 A_2} \times \overrightarrow{A_1 B_1} \neq 0\)</span> alors <span class="math inline">\(\overrightarrow{A_1 A_2}\)</span> et <span class="math inline">\(\overrightarrow{A_1 B_1}\)</span> sont non colinéaires donc les deux segments sont sur des droites parallèles distinctes et ne peuvent s’intersecter.</li>
<li>Sinon, les segments reposent sur une même droite et il s’agit de vérifier leurs positions sur la droite. Pour cela, on exprime <span class="math inline">\(A_2 = A_1 + t_A \overrightarrow{A_1B_1}\)</span> de même pour <span class="math inline">\(B_2 = A_1 + t_B \overrightarrow{A_1 B_1}\)</span>. Plus précisement, on calcule <span class="math inline">\(\overrightarrow{A_1 A_2} \cdot \overrightarrow{A_1 B_1} = t_A ||\overrightarrow{A_1 B_1}||^2\)</span> à l’aide du produit scalaire et on a <span class="math inline">\(t_A = \frac{\overrightarrow{A_1 A_2} \cdot \overrightarrow{A_1 B_1}}{||\overrightarrow{A_1 B_1}||^2}\)</span>. De même, <span class="math inline">\(t_B = \frac{\overrightarrow{A_1 B_2} \cdot \overrightarrow{A_1 B_1}}{||\overrightarrow{A_1 B_1}||^2}\)</span>. On doit alors vérifier si l’intervalle <span class="math inline">\([t_A,t_B]\)</span> (ou <span class="math inline">\([t_B,t_A]\)</span> selon leur position) intersecte <span class="math inline">\([0,1]\)</span>.</li>
</ul>
<p>Voici une fonction <em>OCaml</em> qui correspond à ce raisonnement <div class="ui segment code"></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">let</span> intersecte (a1,b1) (a2,b2) =</span>
<span id="cb38-2"><a href="#cb38-2"></a>    <span class="kw">let</span> vec (x1,y1) (x2,y2) = (x2-.x1,y2-.y1) <span class="kw">in</span></span>
<span id="cb38-3"><a href="#cb38-3"></a>    <span class="kw">let</span> cross (x1,y1) (x2,y2) = x1 *. y2 -. y1 *. x2 <span class="kw">in</span></span>
<span id="cb38-4"><a href="#cb38-4"></a>    <span class="kw">let</span> dot (x1,y1) (x2,y2) = x1 *. x2 +. y1 *. y2 <span class="kw">in</span></span>
<span id="cb38-5"><a href="#cb38-5"></a>    <span class="kw">let</span> proche0 x = <span class="kw">let</span> eps = <span class="fl">1e-20</span> <span class="kw">in</span> </span>
<span id="cb38-6"><a href="#cb38-6"></a>        <span class="kw">if</span> x &lt; <span class="dv">0</span>. <span class="kw">then</span> -.x &lt; eps <span class="kw">else</span> x &lt; eps <span class="kw">in</span></span>
<span id="cb38-7"><a href="#cb38-7"></a>    <span class="kw">let</span> a1b1 = vec a1 b1 <span class="kw">in</span> <span class="kw">let</span> a2b2 = vec a2 b2 <span class="kw">in</span></span>
<span id="cb38-8"><a href="#cb38-8"></a>    <span class="kw">let</span> a1a2 = vec a1 a2 <span class="kw">in</span> <span class="kw">let</span> a1b2 = vec a1 b2 <span class="kw">in</span></span>
<span id="cb38-9"><a href="#cb38-9"></a></span>
<span id="cb38-10"><a href="#cb38-10"></a>    <span class="kw">let</span> delta = cross a1b1 a2b2 <span class="kw">in</span></span>
<span id="cb38-11"><a href="#cb38-11"></a></span>
<span id="cb38-12"><a href="#cb38-12"></a>    <span class="kw">if</span> proche0 delta</span>
<span id="cb38-13"><a href="#cb38-13"></a>    <span class="kw">then</span></span>
<span id="cb38-14"><a href="#cb38-14"></a>         <span class="kw">if</span> proche0 (cross a1a2 a1b1)</span>
<span id="cb38-15"><a href="#cb38-15"></a>         <span class="kw">then</span> <span class="kw">let</span> na1b1 = dot a1b1 a1b1 <span class="kw">in</span> <span class="co">(* colinéaires *)</span></span>
<span id="cb38-16"><a href="#cb38-16"></a>              <span class="kw">let</span> tA = (dot a1a2 a1b1) /. na1b1 <span class="kw">in</span></span>
<span id="cb38-17"><a href="#cb38-17"></a>              <span class="kw">let</span> tB = (dot a1b2 a1b1) /. na1b1 <span class="kw">in</span></span>
<span id="cb38-18"><a href="#cb38-18"></a>              <span class="kw">if</span> tA &lt; tB</span>
<span id="cb38-19"><a href="#cb38-19"></a>              <span class="kw">then</span> <span class="dt">not</span> (tB &lt; <span class="dv">0</span>. || tA &gt; <span class="dv">1</span>.)</span>
<span id="cb38-20"><a href="#cb38-20"></a>              <span class="kw">else</span> <span class="dt">not</span> (tA &lt; <span class="dv">0</span>. || tB &gt; <span class="dv">1</span>.)</span>
<span id="cb38-21"><a href="#cb38-21"></a>         <span class="kw">else</span> <span class="kw">false</span> <span class="co">(* parallèles *)</span></span>
<span id="cb38-22"><a href="#cb38-22"></a>    <span class="kw">else</span> <span class="kw">let</span> t = (cross a1a2 a2b2) /. delta <span class="kw">in</span> <span class="co">(* se croisent *)</span></span>
<span id="cb38-23"><a href="#cb38-23"></a>         <span class="kw">let</span> u = (cross a1a2 a1b1) /. delta <span class="kw">in</span></span>
<span id="cb38-24"><a href="#cb38-24"></a>         t &gt;= <span class="dv">0</span>. &amp;&amp; t &lt;= <span class="dv">1</span>. &amp;&amp; u &gt;= <span class="dv">0</span>. &amp;&amp; u &lt;= <span class="dv">1</span>.</span></code></pre></div>
<p></div></p>
<p></div></p>
<p><div class="ui message blue"><div class="header">Note</div>réécrire cela avec le déterminant de deux vecteurs du plan qui est au programme de mathématiques de seconde.</div></p>
<p>La recherche par force brute va alors énumérer l’ensemble des paires de segments distincts et tester deux à deux les intersections. On peut ainsi écrire le programme suivant qui est assez simple et effectuera effectivement <span class="math inline">\(O(|v|^2)\)</span> itérations dans le pire cas, i.e. lorsqu’il n’y a pas d’intersections.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">exception</span> Trouve</span>
<span id="cb39-2"><a href="#cb39-2"></a></span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="kw">let</span> intersection_ensemble (v: ((<span class="dt">float</span> * <span class="dt">float</span>) * (<span class="dt">float</span> * <span class="dt">float</span>)) <span class="dt">array</span>) : <span class="dt">bool</span> =</span>
<span id="cb39-4"><a href="#cb39-4"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length v <span class="kw">in</span></span>
<span id="cb39-5"><a href="#cb39-5"></a>    <span class="kw">try</span></span>
<span id="cb39-6"><a href="#cb39-6"></a>        <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb39-7"><a href="#cb39-7"></a>            <span class="kw">for</span> j = i+<span class="dv">1</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb39-8"><a href="#cb39-8"></a>                <span class="kw">if</span> intersecte v.(i) v.(j)</span>
<span id="cb39-9"><a href="#cb39-9"></a>                <span class="kw">then</span> <span class="dt">raise</span> Trouve</span>
<span id="cb39-10"><a href="#cb39-10"></a>            <span class="kw">done</span></span>
<span id="cb39-11"><a href="#cb39-11"></a>        <span class="kw">done</span>;</span>
<span id="cb39-12"><a href="#cb39-12"></a>        <span class="kw">false</span></span>
<span id="cb39-13"><a href="#cb39-13"></a>    <span class="kw">with</span> Trouve -&gt; <span class="kw">true</span></span></code></pre></div>
<p></div></p>
<p>TODO approche par droite de balayage : algorithme de Shamos et Hoey (1976)</p>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
