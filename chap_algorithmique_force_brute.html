<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Recherche par Force brute</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Recherche par Force brute
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:principe"><span>1</span> Principe</a><div class="menu"></div></div><div class="item header"> <a href="#sec:recherche-par-retour-sur-trace-backtracking"><span>2</span> Recherche par retour sur trace (<strong>backtracking</strong>)</a><div class="menu"><a class="item" href="#sec:problème-résolution-de-sudoku"><div class="ui label">2.0.1</div> Problème : résolution de Sudoku</a></div></div><div class="item header"> <a href="#sec:droite-de-balayage"><span>3</span> Droite de balayage</a><div class="menu"><a class="item" href="#sec:plus-proche-paire"><div class="ui label">3.1</div> Plus proche paire</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:résolution-exhaustive"><i class="circle icon"></i> Résolution exhaustive</a><a style="font-size:0.6em" class="item" href="#sec:raffinement-droite-de-balayage"><i class="circle icon"></i> Raffinement : droite de balayage</a><a style="font-size:0.6em" class="item" href="#sec:problème-test-dintersection-pour-un-ensemble-de-segments"><i class="circle icon"></i> Problème : test d’intersection pour un ensemble de segments</a></div></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Recherche par Force brute
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Recherche par Force brute     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_algo_exacte.png"> </div></p>
<p><em>Source image : https://www.flickr.com/photos/x6e38/3440634940/</em></p>
<h1 data-number="1" id="sec:principe"><span class="header-section-number">1</span> Principe</h1>
<p>Considérons un problème du type trouver un <span class="math inline">\(x \in V\)</span> vérifiant une propriété <span class="math inline">\(P(x)\)</span>. Par exemple, <span class="math inline">\(V\)</span> est l’ensemble des chaînes de caractère et <span class="math inline">\(P\)</span> vérifie si une chaîne est un mot de passe qu’on cherche. Dans certains problèmes, un tel <span class="math inline">\(x\)</span> n’est pas unique et on cherche à tous les énumérer.</p>
<p>Une recherche par force brute ou recherche exhaustive, consiste à parcourir l’ensemble <span class="math inline">\(V\)</span> jusqu’à obtenir une solution. Pour la recherche du mot de passe, on pourrait commencer par énumérer les chaînes de longueur 1, puis de longueur 2, et ainsi de suite.</p>
<p>Le plus souvent, l’ensemble <span class="math inline">\(V\)</span> est fini (pour les mots de passe, cela peut consister à limiter la longueur maximale du mot de passe). Ainsi, une recherche par force brute effectue <span class="math inline">\(O(|V|)\)</span> itérations.</p>
<h1 data-number="2" id="sec:recherche-par-retour-sur-trace-backtracking"><span class="header-section-number">2</span> Recherche par retour sur trace (<strong>backtracking</strong>)</h1>
<p>Dans des problèmes admettant des solutions partielles, on peut construire une solution par essai de toutes les possibilités en complétant tant qu’on a bien une solution partielle. La recherche par retour sur trace repose sur ce constat pour énumérer l’ensemble des solutions en utilisant la récursivité (d’où la notion de <em>retour sur trace</em>) pour les essais.</p>
<p>L’exemple classiqu\e de ce problème est celui des huit reines : étant donné un échiquier, peut-on placer huit reines de sorte qu’aucune reine ne puisse prendre une autre reine ? Plus précisément : sur un plateau de 8x8 cases, peut-on placer huit pions tels que deux pions quelconques ne soient jamais sur la même ligne ou la même diagonale ?</p>
<p>Exemple de solution :</p>
<p><center><div class="ui image center"><img src="assets/pics/huit_reines_ex.png" /></div></center></p>
<p>Ce problème admet effectivement des solutions partielles en ne considérant que <span class="math inline">\(k\)</span> reines à placer. Pour énumérer les solutions, on peut même se contenter de solutions partielles où les <span class="math inline">\(k\)</span> reines sont placées sur les <span class="math inline">\(k\)</span> premières rangées.</p>
<p>Voici ainsi un algorithme pour énumérer les solutions :</p>
<ul>
<li><p>Supposons que <span class="math inline">\(k\)</span> reines aient été placées et qu’on dispose d’une solution partielle.</p>
<ul>
<li>Si <span class="math inline">\(k = 8\)</span> alors toutes les reines sont placées et la solution est complète, on la comptabilise</li>
<li>Sinon, on continue la recherche pour chaque position de la <span class="math inline">\(k+1\)</span> reine sur la <span class="math inline">\(k+1\)</span> rangée qui préserve le fait d’être une solution partielle.</li>
</ul></li>
</ul>
<p>Ici, quand on dit qu’on continue la recherche, ce qu’on signifie, c’est qu’on effectue un appel récursif.</p>
<p>Pour programmer cette méthode, on va définir une fonction récursive de signature :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">val</span> resout_reines : (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span> -&gt; (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span> <span class="dt">list</span></span></code></pre></div>
<p></div></p>
<p>Un appel à <code>resout_reines part</code> va ainsi renvoyer la liste des solutions complètes construites à partir de la solution partielle <code>part</code>. Les solutions sont représentées par des listes de couples de coordonnées sur l’échiquier, donc dans <span class="math inline">\([|0;7|]^2\)</span></p>
<p>Voici une implémentation où on explore les solutions à l’aide d’une boucle impérative dans l’appel récursif. La fonction <code>valide</code> permet de tester si le placement d’une reine est possible avant d’effectuer un appel.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">let</span> <span class="kw">rec</span> valide (x1,y1) l =</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    | [] -&gt; <span class="kw">true</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    | (x2,y2)::q -&gt;</span>
<span id="cb2-5"><a href="#cb2-5"></a>        x1 &lt;&gt; x2 &amp;&amp; <span class="dt">abs</span> (x2-x1) &lt;&gt; <span class="dt">abs</span>(y2-y1) &amp;&amp; valide (x1,y1) q</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">let</span> <span class="kw">rec</span> resout_reines part =</span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="kw">let</span> k = <span class="dt">List</span>.length part <span class="kw">in</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="kw">if</span> k = <span class="dv">8</span> </span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="kw">then</span> [ part ]</span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="kw">else</span> <span class="kw">begin</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>        <span class="kw">let</span> resultats = <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>        <span class="kw">for</span> x = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">7</span> <span class="kw">do</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>            <span class="kw">let</span> essai = (x,k) :: part <span class="kw">in</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>            <span class="kw">if</span> valide (x,k) part</span>
<span id="cb2-16"><a href="#cb2-16"></a>            <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>                resultats := (resout_reines essai) @ !resultats;</span>
<span id="cb2-18"><a href="#cb2-18"></a>            <span class="kw">end</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>        <span class="kw">done</span>;</span>
<span id="cb2-20"><a href="#cb2-20"></a>        !resultats</span>
<span id="cb2-21"><a href="#cb2-21"></a>    <span class="kw">end</span></span></code></pre></div>
<p></div></p>
<p>et, ici, une autre implémentation purement récursive à l’aide d’une fonction récursive.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">let</span> <span class="kw">rec</span> resout_reines part =</span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="kw">let</span> k = <span class="dt">List</span>.length part <span class="kw">in</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="kw">if</span> k = <span class="dv">8</span> </span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="kw">then</span> [ part ]</span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="kw">else</span> </span>
<span id="cb3-6"><a href="#cb3-6"></a>        <span class="kw">let</span> <span class="kw">rec</span> aux x acc =</span>
<span id="cb3-7"><a href="#cb3-7"></a>            <span class="kw">if</span> x &lt; <span class="dv">0</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>            <span class="kw">then</span> acc</span>
<span id="cb3-9"><a href="#cb3-9"></a>            <span class="kw">else</span> <span class="kw">let</span> essai = (x,k) :: part <span class="kw">in</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>                 <span class="kw">let</span> nacc = <span class="kw">if</span> valide (x,k) part</span>
<span id="cb3-11"><a href="#cb3-11"></a>                           <span class="kw">then</span> (resout_reines essai) @ acc</span>
<span id="cb3-12"><a href="#cb3-12"></a>                           <span class="kw">else</span> acc <span class="kw">in</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>                    aux (x<span class="dv">-1</span>) nacc</span>
<span id="cb3-14"><a href="#cb3-14"></a>        <span class="kw">in</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>        aux <span class="dv">7</span> [] </span></code></pre></div>
<p></div></p>
<p>Une partie de l’arbre de recherche est présenté sur l’image suivante :</p>
<figure>
<img src="../assets/pics/reines_arbre.png" width="1000" alt="Arbre de recherche pour les huit reines" /><figcaption aria-hidden="true">Arbre de recherche pour les huit reines</figcaption>
</figure>
<p>L’arbre complet comporte 2057 nœuds dont 92 feuilles correspondant aux solutions du problème. À titre de comparaison, l’arbre exhaustif correspondant à faire tous les choix de placement à raison d’une reine par ligne compterait <span class="math inline">\(8^8 = 16777216\)</span> nœuds. On voit bien que le backtracking est plus économe en exploration.</p>
<h3 data-number="2.0.1" id="sec:problème-résolution-de-sudoku"><span class="header-section-number">2.0.1</span> Problème : résolution de Sudoku</h3>
<p>La recherche par retour sur trace se prête très bien à la résolution de problèmes comme le Sudoku. On va ici tout simplement tenter de remplir chaque case du haut vers le bas tant qu’on satisfait les contraintes du Sudoku. Le programme sera ainsi très proche de la résolution des huit reines.</p>
<p>Commençons par rappeler le principe du Sudoku :</p>
<ul>
<li><p>On part d’une grille de 81 cases réparties en une grille de 3x3 sous-grilles de 3x3 cases et comportant des chiffres de 1 à 9 dans certaines cases. <center><div class="ui image center"><img src="assets/pics/sudoku_exemple.png" /></div></center></p></li>
<li><p>L’objectif est de remplir chaque case avec un chiffre de 1 à 9 de sorte que chaque ligne, chaque colonne et chaque sous-grille 3x3 comporte une et une seule fois chaque chiffre.</p></li>
<li><p>Un sudoku admet une unique solution.</p></li>
</ul>
<p>Pour représenter une grille de Sudoku en <code>OCaml</code> on utilise un <code>(int option) array array</code>, la valeur <code>None</code> signifiant que la case est vide et la valeur <code>Some x</code> qu’elle est remplie avec la valeur <span class="math inline">\(x\)</span>.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">type</span> grille = (<span class="dt">int</span> <span class="dt">option</span>) <span class="dt">array</span> <span class="dt">array</span></span></code></pre></div>
<p></div></p>
<p>On fait le choix de représenté la grille par un tableau de lignes, ce qui signiie que pour accèder à la case de coordonnée <span class="math inline">\((x,y)\)</span> dans <code>g</code> il faut écrire <code>g.(y).(x)</code>.</p>
<p>Le problème donné précédemment est alors représenté par la valeur suivante : <div class="ui segment code"></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">let</span> probleme = [|</span>
<span id="cb5-2"><a href="#cb5-2"></a>    [| <span class="dt">Some</span> <span class="dv">1</span>; <span class="dt">None</span>; <span class="dt">None</span>;    <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span>;   <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">6</span> |];</span>
<span id="cb5-3"><a href="#cb5-3"></a>    [| <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">6</span>;    <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">2</span>; <span class="dt">None</span>;   <span class="dt">Some</span> <span class="dv">7</span>; <span class="dt">None</span>; <span class="dt">None</span> |];</span>
<span id="cb5-4"><a href="#cb5-4"></a>    [| <span class="dt">Some</span> <span class="dv">7</span>; <span class="dt">Some</span> <span class="dv">8</span>; <span class="dt">Some</span> <span class="dv">9</span>;    <span class="dt">Some</span> <span class="dv">4</span>; <span class="dt">Some</span> <span class="dv">5</span>; <span class="dt">None</span>;   <span class="dt">Some</span> <span class="dv">1</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">3</span> |];</span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a>    [| <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span>;    <span class="dt">Some</span> <span class="dv">8</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">7</span>;   <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">4</span> |];</span>
<span id="cb5-7"><a href="#cb5-7"></a>    [| <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span>;    <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">3</span>; <span class="dt">None</span>;   <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span> |];</span>
<span id="cb5-8"><a href="#cb5-8"></a>    [| <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">9</span>; <span class="dt">None</span>;    <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">4</span>;   <span class="dt">Some</span> <span class="dv">2</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">1</span> |];</span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a>    [| <span class="dt">Some</span> <span class="dv">3</span>; <span class="dt">Some</span> <span class="dv">1</span>; <span class="dt">Some</span> <span class="dv">2</span>;    <span class="dt">Some</span> <span class="dv">9</span>; <span class="dt">Some</span> <span class="dv">7</span>; <span class="dt">None</span>;   <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">4</span>; <span class="dt">None</span> |];</span>
<span id="cb5-11"><a href="#cb5-11"></a>    [| <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">4</span>; <span class="dt">None</span>;    <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">1</span>; <span class="dt">Some</span> <span class="dv">2</span>;   <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">7</span>; <span class="dt">Some</span> <span class="dv">8</span> |];</span>
<span id="cb5-12"><a href="#cb5-12"></a>    [| <span class="dt">Some</span> <span class="dv">9</span>; <span class="dt">None</span>; <span class="dt">Some</span> <span class="dv">8</span>;    <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span>;   <span class="dt">None</span>; <span class="dt">None</span>; <span class="dt">None</span> |];</span>
<span id="cb5-13"><a href="#cb5-13"></a>    |]</span></code></pre></div>
<p></div></p>
<p>Afin de définir la fonction de résolution, on définit une première fonction <code>suivant</code> de signature :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">val</span> suivant : grille -&gt; (<span class="dt">int</span> * <span class="dt">int</span>) -&gt; (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">option</span></span></code></pre></div>
<p></div></p>
<p>telle que l’appel à <code>suivant g (x,y)</code> renvoie <code>Some (xi,yi)</code> quand <span class="math inline">\((x_i,y_i)\)</span> sont les coordonnées de la prochaine case libre, dans l’ordre gauche à droite puis haut vers bas, après <span class="math inline">\((x,y)\)</span> ou <code>None</code> quand il n’existe pas de telle case libre. Cela signifie alors que la grille est entièrement remplie.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">let</span> <span class="kw">rec</span> suivant g (x,y) =</span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="kw">if</span> y &gt; <span class="dv">8</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="kw">then</span> <span class="dt">None</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="kw">else</span> <span class="kw">if</span> g.(y).(x) = <span class="dt">None</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="kw">then</span> <span class="dt">Some</span> (x,y)</span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span class="kw">else</span> <span class="kw">if</span> x &lt; <span class="dv">8</span> <span class="kw">then</span> suivant g (x+<span class="dv">1</span>, y)</span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="kw">else</span> suivant g (<span class="dv">0</span>, y+<span class="dv">1</span>)</span></code></pre></div>
<p></div></p>
<p>On définit également une fonction <code>valide</code> de signature</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">val</span> valide : grille -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">bool</span></span></code></pre></div>
<p></div></p>
<p>telle que l’appel à <code>valide g x y</code> renvoie <code>true</code> si et seulement si la valeur placée en coordonnée <span class="math inline">\((x,y)\)</span> n’invalide pas la grille. Ne pas prendre cette valeur en paramètre permettant d’écrire un peu plus simplement cette fonction. La fonction est assez directe, étant donné <span class="math inline">\((x,y)\)</span> on va parcourir sa ligne, sa colonne et sa sous-grille pour vérifier qu’un nombre n’a pas été placé deux fois à l’aide d’un tableau de drapeaux :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">let</span> valide g x y =</span>
<span id="cb9-2"><a href="#cb9-2"></a>    <span class="kw">let</span> v = <span class="dt">ref</span> <span class="kw">true</span> <span class="kw">in</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="kw">let</span> vus_colonne = <span class="dt">Array</span>.make <span class="dv">9</span> <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="kw">for</span> y0 = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">8</span> <span class="kw">do</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>        <span class="kw">match</span> g.(y0).(x) <span class="kw">with</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>        | <span class="dt">None</span> -&gt; ()</span>
<span id="cb9-7"><a href="#cb9-7"></a>        | <span class="dt">Some</span> k -&gt; </span>
<span id="cb9-8"><a href="#cb9-8"></a>                <span class="kw">if</span> vus_colonne.(k<span class="dv">-1</span>)</span>
<span id="cb9-9"><a href="#cb9-9"></a>                <span class="kw">then</span> v := <span class="kw">false</span>;</span>
<span id="cb9-10"><a href="#cb9-10"></a>                vus_colonne.(k<span class="dv">-1</span>) &lt;- <span class="kw">true</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>    <span class="kw">done</span>;</span>
<span id="cb9-12"><a href="#cb9-12"></a>    <span class="kw">let</span> vus_ligne = <span class="dt">Array</span>.make <span class="dv">9</span> <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb9-13"><a href="#cb9-13"></a>    <span class="kw">for</span> x0 = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">8</span> <span class="kw">do</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>        <span class="kw">match</span> g.(y).(x0) <span class="kw">with</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>        | <span class="dt">None</span> -&gt; ()</span>
<span id="cb9-16"><a href="#cb9-16"></a>        | <span class="dt">Some</span> k -&gt; </span>
<span id="cb9-17"><a href="#cb9-17"></a>                <span class="kw">if</span> vus_ligne.(k<span class="dv">-1</span>)</span>
<span id="cb9-18"><a href="#cb9-18"></a>                <span class="kw">then</span> v := <span class="kw">false</span>;</span>
<span id="cb9-19"><a href="#cb9-19"></a>                vus_ligne.(k<span class="dv">-1</span>) &lt;- <span class="kw">true</span></span>
<span id="cb9-20"><a href="#cb9-20"></a>    <span class="kw">done</span>;</span>
<span id="cb9-21"><a href="#cb9-21"></a>    <span class="kw">let</span> vus_grille = <span class="dt">Array</span>.make <span class="dv">9</span> <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb9-22"><a href="#cb9-22"></a>    <span class="kw">let</span> xb = (x / <span class="dv">3</span>) * <span class="dv">3</span> <span class="kw">in</span></span>
<span id="cb9-23"><a href="#cb9-23"></a>    <span class="kw">let</span> yb = (y / <span class="dv">3</span>) * <span class="dv">3</span> <span class="kw">in</span></span>
<span id="cb9-24"><a href="#cb9-24"></a>    <span class="kw">for</span> xd = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">2</span> <span class="kw">do</span></span>
<span id="cb9-25"><a href="#cb9-25"></a>        <span class="kw">for</span> yd = <span class="dv">0</span> <span class="kw">to</span> <span class="dv">2</span> <span class="kw">do</span></span>
<span id="cb9-26"><a href="#cb9-26"></a>            <span class="kw">match</span> g.(yb+yd).(xb+xd) <span class="kw">with</span></span>
<span id="cb9-27"><a href="#cb9-27"></a>            | <span class="dt">None</span> -&gt; ()</span>
<span id="cb9-28"><a href="#cb9-28"></a>            | <span class="dt">Some</span> k -&gt; </span>
<span id="cb9-29"><a href="#cb9-29"></a>                    <span class="kw">if</span> vus_grille.(k<span class="dv">-1</span>)</span>
<span id="cb9-30"><a href="#cb9-30"></a>                    <span class="kw">then</span> v := <span class="kw">false</span>;</span>
<span id="cb9-31"><a href="#cb9-31"></a>                    vus_grille.(k<span class="dv">-1</span>) &lt;- <span class="kw">true</span></span>
<span id="cb9-32"><a href="#cb9-32"></a>        <span class="kw">done</span></span>
<span id="cb9-33"><a href="#cb9-33"></a>    <span class="kw">done</span>;</span>
<span id="cb9-34"><a href="#cb9-34"></a>    !v</span></code></pre></div>
<p></div></p>
<p>On peut alors définir la fonction <code>resout</code> qui va résoudre le Sudoku en effectuant tous les remplissages tant qu’on a une grille valide. Dès qu’une solution est trouvée, on s’arrête. Pour cela, on utilise le mécanisme des exceptions pour permettre une sortie prématurée. On a fait le choix de travailler en place dans la grille, ainsi à la fin de l’exécution de la fonction, la grille correspond à la solution.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">exception</span> Solution</span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">let</span> resout g =</span>
<span id="cb10-4"><a href="#cb10-4"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux xi yi = <span class="kw">match</span> suivant g (xi, yi) <span class="kw">with</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>        | <span class="dt">None</span> -&gt; <span class="dt">raise</span> Solution</span>
<span id="cb10-6"><a href="#cb10-6"></a>        | <span class="dt">Some</span> (x,y) -&gt;</span>
<span id="cb10-7"><a href="#cb10-7"></a>            <span class="kw">for</span> i = <span class="dv">1</span> <span class="kw">to</span> <span class="dv">9</span> <span class="kw">do</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>                g.(y).(x) &lt;- <span class="dt">Some</span> i;</span>
<span id="cb10-9"><a href="#cb10-9"></a>                <span class="kw">if</span> valide g x y</span>
<span id="cb10-10"><a href="#cb10-10"></a>                <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>                    aux x y</span>
<span id="cb10-12"><a href="#cb10-12"></a>                <span class="kw">end</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>            <span class="kw">done</span>;</span>
<span id="cb10-14"><a href="#cb10-14"></a>            g.(y).(x) &lt;- <span class="dt">None</span></span>
<span id="cb10-15"><a href="#cb10-15"></a>    <span class="kw">in</span> </span>
<span id="cb10-16"><a href="#cb10-16"></a>    <span class="kw">try</span> </span>
<span id="cb10-17"><a href="#cb10-17"></a>        aux <span class="dv">0</span> <span class="dv">0</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>    <span class="kw">with</span> Solution -&gt; ()</span></code></pre></div>
<p></div></p>
<p>La résolution du Sudoku donnée précédemment par ce programme est présenté dans la vidéo suivante :</p>
<p><center><video width="400" height="380" controls="controls"><source src="assets/pics/sudoku.mp4" type="video/mp4" /></video></center></p>
<h1 data-number="3" id="sec:droite-de-balayage"><span class="header-section-number">3</span> Droite de balayage</h1>
<h2 data-number="3.1" id="sec:plus-proche-paire"><span class="header-section-number">3.1</span> Plus proche paire</h2>
<h3 data-number="3.1.1" id="sec:résolution-exhaustive"><span class="header-section-number">3.1.1</span> Résolution exhaustive</h3>
<p>Considérons le problème <em>PlusProchePaire</em> qui, étant donné un ensemble de <span class="math inline">\(n\)</span> points (<span class="math inline">\(n \ge 2\)</span>), détermine la paire constituée des deux points les plus proches.</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/plusprochepaire_a.png" /></div></center></p>
<p></div></center></p>
<p>Une implémentation naïve de la recherche par force brute consiste à énumérer les <span class="math inline">\(\frac{n(n-1)}{2}\)</span> paires et donc à effectuer <span class="math inline">\(O(n^2)\)</span> itérations.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">let</span> plus_proche_paire points =</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length points <span class="kw">in</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="kw">let</span> min_paire = <span class="dt">ref</span> (distance points.(<span class="dv">0</span>) points.(<span class="dv">1</span>), (<span class="dv">0</span>, <span class="dv">1</span>)) <span class="kw">in</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>        <span class="kw">for</span> j = i+<span class="dv">1</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>            <span class="kw">let</span> d = distance points.(i) points.(j) <span class="kw">in</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>            <span class="kw">if</span> d &lt; <span class="dt">fst</span> !min_paire</span>
<span id="cb11-8"><a href="#cb11-8"></a>            <span class="kw">then</span> min_paire := (d, (i, j))</span>
<span id="cb11-9"><a href="#cb11-9"></a>        <span class="kw">done</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>    <span class="kw">done</span>;</span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="dt">snd</span> !min_paire</span></code></pre></div>
<p></div></p>
<h3 data-number="3.1.2" id="sec:raffinement-droite-de-balayage"><span class="header-section-number">3.1.2</span> Raffinement : droite de balayage</h3>
<p>Il est parfois possible d’accélérer la recherche par force brute en ordonnant le parcours des candidats pour pouvoir éviter de tester certains d’entre eux.</p>
<p>En géométrie algorithmique, une approche classique consiste à ordonner les objets selon leur abscisse et à parcourir les objets par abscisse croissante. On parle alors de <strong>droite de balayage</strong> (en anglais, <em>sweep line</em>) car cela revient à balayer le plan par une droite verticale en ne traitant que les objets avant cette ligne.</p>
<p>Reprenons le problème précédent, on considère que les points sont triés par abscisse croissante : <span class="math inline">\((x_0,y_0), \dots, (x_{n-1}, y_{n-1})\)</span>. On va parcourir les points dans cet ordre en maintenant un ensemble de points à gauche du point courant, appelés <em>points actifs</em>, et en ne calculant que les intersections avec les points actifs.</p>
<p>Si on a parcouru les <span class="math inline">\(N\)</span> premiers points et qu’on a obtenu que la plus petite distance était <span class="math inline">\(d\)</span>, lorsqu’on considère le point <span class="math inline">\((x_N,y_N)\)</span>, il est inutile de tester les points qui sont forcément à distance <span class="math inline">\(&gt; d\)</span> de celui-ci. C’est-à-dire qu’on peut éliminer les points qui ne sont pas dans le rectangle <span class="math inline">\([x_N-d,x_N]\times [y_N-d,y_N+d]\)</span> du test. Les points dont l’abscisse est <span class="math inline">\(&lt; x_N -d\)</span> peuvent être éliminés définitivement vu que l’on raisonne par abscisse croissante, par contre, les points d’ordonnées invalides doivent être conservés pour les points ultérieurs.</p>
<p>Ce rectangle est représenté sur le schéma suivant ainsi qu’une ligne imaginaire qui correspond à l’abscisse du point courant et qu’on peut imaginer parcourant le plan de gauche à droite pour traiter les points au fur et à mesure.</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/plusprochepaire_b.png" /></div></center></p>
<p></div></center></p>
<p>Afin de déterminer la complexité de cet algorithme, il est nécessaire de connaitre le nombre maximal de points dans le rectangle. Comme ces points ont été pris en compte précédemment, ils sont forcément à distance au moins <span class="math inline">\(d\)</span> les uns des autres. Il s’agit donc de déterminer le nombre maximum de points qu’on peut placer dans ce rectangle à distance au moins <span class="math inline">\(d\)</span>. On remarque tout d’abord qu’on peut placer six points ainsi :</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/plusprochepaire_activesize_a.png" /></div></center></p>
<p></div></center></p>
<p>Si jamais on avait au moins sept points, on peut voir qu’il y a forcément un des six sous-rectangles suivants qui contiendrait au moins deux points :</p>
<p><center><div class="ui image center"><center><div class="ui image center"><img src="assets/pics/plusprochepaire_activesize_b.png" /></div></center></p>
<p></div></center></p>
<p>Or, ces sous-rectangles sont de longueur <span class="math inline">\(\frac{1}{2}d\)</span> et de hauteur <span class="math inline">\(\frac{2}{3}d\)</span>, donc la distance maximale entre deux de leurs points correspond à la longueur des diagonales : <span class="math inline">\(\sqrt{\frac{1}{4} + \frac{4}{9}}d = \frac{5}{6}d &lt; d\)</span>.</p>
<p>Comme un de ces six points est le point courant, il y a toujours au plus 5 points dans l’ensemble des points actifs.</p>
<p>Voici le principe de l’algorithme que l’on va implémenter :</p>
<ul>
<li><p>On trie le tableau <code>points</code> par ordre croissant. <strong>Complexité :</strong> <span class="math inline">\(O(n \log n)\)</span></p></li>
<li><p>On initialise la plus petite distance <code>d</code> courante à la distance entre les deux premiers points</p></li>
<li><p>On crée un ensemble <code>actifs</code>, ordonné par les ordonnées, de points contenant initialement les deux premiers points</p></li>
<li><p>Pour chaque point <span class="math inline">\((x,y)\)</span> en partant du deuxième :</p>
<ul>
<li>On supprime les points <span class="math inline">\((x&#39;,y&#39;)\)</span> tels que <span class="math inline">\(x&#39; &lt; x - d\)</span> de <code>actifs</code>. <strong>Complexité :</strong> sur l’ensemble des itérations on ne pourra jamais supprimer deux fois un point, donc on effectue au maximum <span class="math inline">\(n\)</span> suppressions chacune en <span class="math inline">\(O(\log n)\)</span> donc <span class="math inline">\(O(n \log n)\)</span>.</li>
<li>On parcourt les points de <code>actifs</code> dont les ordonnées sont comprises entre <span class="math inline">\(y-d\)</span> et <span class="math inline">\(y+d\)</span>. <strong>Complexité :</strong> pour récupérer le premier point de l’ensemble, il faut <span class="math inline">\(O(\log n)\)</span> en pire cas (tous les points actifs) et ensuite on effectue au plus 5 itérations comme on vient de le prouver.</li>
</ul></li>
</ul>
<p>L’animation suivante présente le déroulement de cet algorihtme. La bande active est indiquée en gris et le rectangle autour du point courant en gris foncé :</p>
<p><img class="ui image fluid" src="assets/pics/closest_pair.gif"/></p>
<p>On remarque ainsi que la complexité en temps et en pire cas de cet algorithme est de <span class="math inline">\(O(n \log n)\)</span>. Ici, le fait d’avoir la structure <code>actifs</code> ordonnée par les ordonnées est crucial pour garantir la complexité. Pour la réalisation d’une structure d’ensemble ordonnée ayant ces complexités, voir le chapitre FIXME.</p>
<p>Ici, on utilise le module <code>Set</code> d’OCaml pour réaliser la structure d’ensemble, pour cela on commence par créer le module <code>PointSet</code> pour les ensembles de points :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">module</span> Point = <span class="kw">struct</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="kw">type</span> t = <span class="dt">float</span> * <span class="dt">float</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="kw">let</span> <span class="dt">compare</span> (x1,y1) (x2,y2) = Stdlib.<span class="dt">compare</span> y1 y2</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="kw">end</span></span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="kw">module</span> PointSet = <span class="dt">Set</span>.Make(Point)</span></code></pre></div>
<p></div></p>
<p>Puis on définit une fonction permettant de parcourir les points entre deux ordonnées :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">let</span> set_iter_entre f set bas haut =</span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="kw">try</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>        <span class="kw">let</span> e = PointSet.find_first (<span class="kw">fun</span> p -&gt; <span class="dt">snd</span> p &gt;= bas) set <span class="kw">in</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>        <span class="kw">let</span> seq = PointSet.to_seq_from e set <span class="kw">in</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>        <span class="kw">let</span> <span class="kw">rec</span> aux seq =</span>
<span id="cb13-6"><a href="#cb13-6"></a>            <span class="kw">match</span> seq () <span class="kw">with</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>            | Seq.Nil -&gt; ()</span>
<span id="cb13-8"><a href="#cb13-8"></a>            | Seq.Cons (p, seq_suite) -&gt; </span>
<span id="cb13-9"><a href="#cb13-9"></a>                    <span class="kw">if</span> <span class="dt">snd</span> p &lt;= haut</span>
<span id="cb13-10"><a href="#cb13-10"></a>                    <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>                        f p;</span>
<span id="cb13-12"><a href="#cb13-12"></a>                        aux seq_suite</span>
<span id="cb13-13"><a href="#cb13-13"></a>                    <span class="kw">end</span></span>
<span id="cb13-14"><a href="#cb13-14"></a>        <span class="kw">in</span> aux seq</span>
<span id="cb13-15"><a href="#cb13-15"></a>    <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; ()</span></code></pre></div>
<p></div></p>
<p>On implémente alors assez directement l’algorithme décrit précédemment :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">let</span> plus_proche_paire_balayage points =</span>
<span id="cb14-2"><a href="#cb14-2"></a>    <span class="kw">let</span> <span class="dt">compare</span> (x1,y1) (x2,y2) =</span>
<span id="cb14-3"><a href="#cb14-3"></a>        <span class="kw">if</span> x1 = x2</span>
<span id="cb14-4"><a href="#cb14-4"></a>        <span class="kw">then</span> <span class="kw">if</span> y1 &lt; y2 <span class="kw">then</span> <span class="dv">-1</span> <span class="kw">else</span> <span class="dv">1</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>        <span class="kw">else</span> <span class="kw">if</span> x1 &lt; x2 <span class="kw">then</span> <span class="dv">-1</span> <span class="kw">else</span> <span class="dv">1</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="kw">in</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>    <span class="dt">Array</span>.sort <span class="dt">compare</span> points;</span>
<span id="cb14-8"><a href="#cb14-8"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length points <span class="kw">in</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>    <span class="kw">let</span> d = <span class="dt">ref</span> (distance points.(<span class="dv">0</span>) points.(<span class="dv">1</span>)) <span class="kw">in</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>    <span class="kw">let</span> couple = <span class="dt">ref</span> (points.(<span class="dv">0</span>), points.(<span class="dv">1</span>)) <span class="kw">in</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>    <span class="kw">let</span> actifs = <span class="dt">ref</span> (PointSet.empty </span>
<span id="cb14-12"><a href="#cb14-12"></a>            |&gt; PointSet.add points.(<span class="dv">0</span>) |&gt; PointSet.add points.(<span class="dv">1</span>)) <span class="kw">in</span></span>
<span id="cb14-13"><a href="#cb14-13"></a></span>
<span id="cb14-14"><a href="#cb14-14"></a>    <span class="kw">let</span> gauche = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb14-15"><a href="#cb14-15"></a></span>
<span id="cb14-16"><a href="#cb14-16"></a>    <span class="kw">for</span> i = <span class="dv">2</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb14-17"><a href="#cb14-17"></a>        <span class="kw">let</span> xi, yi = points.(i) <span class="kw">in</span></span>
<span id="cb14-18"><a href="#cb14-18"></a>        </span>
<span id="cb14-19"><a href="#cb14-19"></a>        <span class="kw">while</span> <span class="dt">fst</span> points.(!gauche) &lt; xi -. !d <span class="kw">do</span></span>
<span id="cb14-20"><a href="#cb14-20"></a>            actifs := PointSet.remove points.(!gauche) !actifs;</span>
<span id="cb14-21"><a href="#cb14-21"></a>            <span class="dt">incr</span> gauche</span>
<span id="cb14-22"><a href="#cb14-22"></a>        <span class="kw">done</span>;</span>
<span id="cb14-23"><a href="#cb14-23"></a></span>
<span id="cb14-24"><a href="#cb14-24"></a>        set_iter_entre (<span class="kw">fun</span> pj -&gt; </span>
<span id="cb14-25"><a href="#cb14-25"></a>            <span class="kw">let</span> dip = distance points.(i) pj <span class="kw">in</span></span>
<span id="cb14-26"><a href="#cb14-26"></a>            <span class="kw">if</span> dip &lt; !d</span>
<span id="cb14-27"><a href="#cb14-27"></a>            <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb14-28"><a href="#cb14-28"></a>                couple := (points.(i), pj);</span>
<span id="cb14-29"><a href="#cb14-29"></a>                d := dip</span>
<span id="cb14-30"><a href="#cb14-30"></a>            <span class="kw">end</span>) !actifs (yi -. !d) (yi +. !d);</span>
<span id="cb14-31"><a href="#cb14-31"></a></span>
<span id="cb14-32"><a href="#cb14-32"></a>        actifs := PointSet.add points.(i) !actifs</span>
<span id="cb14-33"><a href="#cb14-33"></a>    <span class="kw">done</span>;</span>
<span id="cb14-34"><a href="#cb14-34"></a>    !d</span></code></pre></div>
<p></div></p>
<h3 data-number="3.1.3" id="sec:problème-test-dintersection-pour-un-ensemble-de-segments"><span class="header-section-number">3.1.3</span> Problème : test d’intersection pour un ensemble de segments</h3>
<p>Considérons le problème suivant <em>IntersectionEnsemble</em> : étant donné <span class="math inline">\(n\)</span> segments dans le plan, il s’agit de déterminer si au moins deux des segments s’intersectent.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>On peut considérer ici que l’on dispose d’une fonction</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1"></a>intersecte : (<span class="dt">float</span> * <span class="dt">float</span>) * (<span class="dt">float</span> * <span class="dt">float</span>) </span>
<span id="cb15-2"><a href="#cb15-2"></a>    -&gt; (<span class="dt">float</span> * <span class="dt">float</span>) * (<span class="dt">float</span> * <span class="dt">float</span>) -&gt; <span class="dt">bool</span> </span></code></pre></div>
<p></div></p>
<p>qui teste l’intersection entre deux segments.</p>
<p>Cependant, il est possible d’écrire une telle fonction avec un peu de géométrie élémentaire.</p>
<p>Si on considère que les deux segments sont <span class="math inline">\([A_1B_1]\)</span> et <span class="math inline">\([A_2B_2]\)</span>, avec <span class="math inline">\(A_1 \neq B_1\)</span> et <span class="math inline">\(A_2 \neq B_2\)</span>, alors chaque point du segment <span class="math inline">\([A_1B_1]\)</span> est de la forme <span class="math inline">\(A_1 + t \overrightarrow{A_1B_1}\)</span> où <span class="math inline">\(t \in [0,1]\)</span>. De même les points du segment <span class="math inline">\([A_2B_2]\)</span> sont de la forme <span class="math inline">\(A_2 + u \overrightarrow{A_2B_2}\)</span> où <span class="math inline">\(u \in [0,1]\)</span>.</p>
<p>S’il y a une intersection, c’est qu’il existe <span class="math inline">\((t,u) \in [0,1]^2\)</span> tel que</p>
<p><span class="math display">\[
A_1 + t \overrightarrow{A_1B_1} = A_2 + u \overrightarrow{A_2B_2}
\iff \overrightarrow{A_2 A_1} + t \overrightarrow{A_1B_1} = u
\overrightarrow{A_2 B_2}
\]</span></p>
<p>L’idée est alors d’utiliser une opération appelée <strong>produit vectoriel</strong> sur les vecteurs. Comme ici, tout est plan, le produit vectoriel est uniquement déterminé par sa troisième coordonnée, celle qui sort du plan, et on peut se contenter de calculer celle-ci. On note ainsi <span class="math inline">\((x,y) \times (x&#39;,y&#39;) = x y&#39; - y x&#39;\)</span> cette coordonnée. On a donc <span class="math inline">\(u \times u = 0\)</span>.</p>
<p>On peut alors composer l’égalité par <span class="math inline">\(\times \overrightarrow{A_2B_2}\)</span> :</p>
<p><span class="math display">\[
\overrightarrow{A_2 A_1} \times \overrightarrow{A_2 B_2} + t 
\left( \overrightarrow{A_1 B_1} \times \overrightarrow{A_2 B_2} \right) = 0
\]</span></p>
<p>Notons <span class="math inline">\(\Delta = \overrightarrow{A_1 B_1} \times \overrightarrow{A_2 B_2}\)</span>, si <span class="math inline">\(\Delta \neq 0\)</span>, alors</p>
<p><span class="math display">\[
t = - \frac{\overrightarrow{A_2 A_1} \times \overrightarrow{A_2 B_2}}{\Delta}
= \frac{\overrightarrow{A_1 A_2} \times \overrightarrow{A_2 B_2}}{\Delta}
\]</span></p>
<p>On procède de même avec <span class="math inline">\(\times \overrightarrow{A_1 B_1}\)</span> pour obtenir une expression de <span class="math inline">\(u\)</span> : <span class="math inline">\(\overrightarrow{A_2 A_1} \times \overrightarrow{A_1 B_1} = u \left ( \overrightarrow{A_2 B_2} \times \overrightarrow{A_1 B_1} \right) = - u \Delta\)</span> et donc</p>
<p><span class="math display">\[
u = - \frac{\overrightarrow{A_2 A_1} \times \overrightarrow{A_1 B_1}}{\Delta}
= \frac{\overrightarrow{A_1 A_2} \times \overrightarrow{A_1 B_1}}{\Delta}
\]</span></p>
<p>Si <span class="math inline">\(\Delta \neq 0\)</span>, on peut donc alors exprimer <span class="math inline">\(u\)</span> et <span class="math inline">\(t\)</span> et vérifier qu’ils sont dans <span class="math inline">\([0,1]\)</span>.</p>
<p>Si <span class="math inline">\(\Delta = 0\)</span> c’est que les deux segments sont de directions parallèles ou confondues.</p>
<ul>
<li>Si <span class="math inline">\(\overrightarrow{A_1 A_2} \times \overrightarrow{A_1 B_1} \neq 0\)</span> alors <span class="math inline">\(\overrightarrow{A_1 A_2}\)</span> et <span class="math inline">\(\overrightarrow{A_1 B_1}\)</span> sont non colinéaires donc les deux segments sont sur des droites parallèles distinctes et ne peuvent s’intersecter.</li>
<li>Sinon, les segments reposent sur une même droite et il s’agit de vérifier leurs positions sur la droite. Pour cela, on exprime <span class="math inline">\(A_2 = A_1 + t_A \overrightarrow{A_1B_1}\)</span> de même pour <span class="math inline">\(B_2 = A_1 + t_B \overrightarrow{A_1 B_1}\)</span>. Plus précisement, on calcule <span class="math inline">\(\overrightarrow{A_1 A_2} \cdot \overrightarrow{A_1 B_1} = t_A ||\overrightarrow{A_1 B_1}||^2\)</span> à l’aide du produit scalaire et on a <span class="math inline">\(t_A = \frac{\overrightarrow{A_1 A_2} \cdot \overrightarrow{A_1 B_1}}{||\overrightarrow{A_1 B_1}||^2}\)</span>. De même, <span class="math inline">\(t_B = \frac{\overrightarrow{A_1 B_2} \cdot \overrightarrow{A_1 B_1}}{||\overrightarrow{A_1 B_1}||^2}\)</span>. On doit alors vérifier si l’intervalle <span class="math inline">\([t_A,t_B]\)</span> (ou <span class="math inline">\([t_B,t_A]\)</span> selon leur position) intersecte <span class="math inline">\([0,1]\)</span>.</li>
</ul>
<p>Voici une fonction <em>OCaml</em> qui correspond à ce raisonnement <div class="ui segment code"></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">let</span> intersecte (a1,b1) (a2,b2) =</span>
<span id="cb16-2"><a href="#cb16-2"></a>    <span class="kw">let</span> vec (x1,y1) (x2,y2) = (x2-.x1,y2-.y1) <span class="kw">in</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>    <span class="kw">let</span> cross (x1,y1) (x2,y2) = x1 *. y2 -. y1 *. x2 <span class="kw">in</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>    <span class="kw">let</span> dot (x1,y1) (x2,y2) = x1 *. x2 +. y1 *. y2 <span class="kw">in</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="kw">let</span> proche0 x = <span class="kw">let</span> eps = <span class="fl">1e-20</span> <span class="kw">in</span> </span>
<span id="cb16-6"><a href="#cb16-6"></a>        <span class="kw">if</span> x &lt; <span class="dv">0</span>. <span class="kw">then</span> -.x &lt; eps <span class="kw">else</span> x &lt; eps <span class="kw">in</span></span>
<span id="cb16-7"><a href="#cb16-7"></a>    <span class="kw">let</span> a1b1 = vec a1 b1 <span class="kw">in</span> <span class="kw">let</span> a2b2 = vec a2 b2 <span class="kw">in</span></span>
<span id="cb16-8"><a href="#cb16-8"></a>    <span class="kw">let</span> a1a2 = vec a1 a2 <span class="kw">in</span> <span class="kw">let</span> a1b2 = vec a1 b2 <span class="kw">in</span></span>
<span id="cb16-9"><a href="#cb16-9"></a></span>
<span id="cb16-10"><a href="#cb16-10"></a>    <span class="kw">let</span> delta = cross a1b1 a2b2 <span class="kw">in</span></span>
<span id="cb16-11"><a href="#cb16-11"></a></span>
<span id="cb16-12"><a href="#cb16-12"></a>    <span class="kw">if</span> proche0 delta</span>
<span id="cb16-13"><a href="#cb16-13"></a>    <span class="kw">then</span></span>
<span id="cb16-14"><a href="#cb16-14"></a>         <span class="kw">if</span> proche0 (cross a1a2 a1b1)</span>
<span id="cb16-15"><a href="#cb16-15"></a>         <span class="kw">then</span> <span class="kw">let</span> na1b1 = dot a1b1 a1b1 <span class="kw">in</span> <span class="co">(* colinéaires *)</span></span>
<span id="cb16-16"><a href="#cb16-16"></a>              <span class="kw">let</span> tA = (dot a1a2 a1b1) /. na1b1 <span class="kw">in</span></span>
<span id="cb16-17"><a href="#cb16-17"></a>              <span class="kw">let</span> tB = (dot a1b2 a1b1) /. na1b1 <span class="kw">in</span></span>
<span id="cb16-18"><a href="#cb16-18"></a>              <span class="kw">if</span> tA &lt; tB</span>
<span id="cb16-19"><a href="#cb16-19"></a>              <span class="kw">then</span> <span class="dt">not</span> (tB &lt; <span class="dv">0</span>. || tA &gt; <span class="dv">1</span>.)</span>
<span id="cb16-20"><a href="#cb16-20"></a>              <span class="kw">else</span> <span class="dt">not</span> (tA &lt; <span class="dv">0</span>. || tB &gt; <span class="dv">1</span>.)</span>
<span id="cb16-21"><a href="#cb16-21"></a>         <span class="kw">else</span> <span class="kw">false</span> <span class="co">(* parallèles *)</span></span>
<span id="cb16-22"><a href="#cb16-22"></a>    <span class="kw">else</span> <span class="kw">let</span> t = (cross a1a2 a2b2) /. delta <span class="kw">in</span> <span class="co">(* se croisent *)</span></span>
<span id="cb16-23"><a href="#cb16-23"></a>         <span class="kw">let</span> u = (cross a1a2 a1b1) /. delta <span class="kw">in</span></span>
<span id="cb16-24"><a href="#cb16-24"></a>         t &gt;= <span class="dv">0</span>. &amp;&amp; t &lt;= <span class="dv">1</span>. &amp;&amp; u &gt;= <span class="dv">0</span>. &amp;&amp; u &lt;= <span class="dv">1</span>.</span></code></pre></div>
<p></div></p>
<p></div></p>
<p><div class="ui message blue"><div class="header">Note</div>réécrire cela avec le déterminant de deux vecteurs du plan qui est au programme de mathématiques de seconde.</div></p>
<p>La recherche par force brute va alors énumérer l’ensemble des paires de segments distincts et tester deux à deux les intersections. On peut ainsi écrire le programme suivant qui est assez simple et effectuera effectivement <span class="math inline">\(O(|v|^2)\)</span> itérations dans le pire cas, i.e. lorsqu’il n’y a pas d’intersections.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">exception</span> Trouve</span>
<span id="cb17-2"><a href="#cb17-2"></a></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="kw">let</span> intersection_ensemble (v: ((<span class="dt">float</span> * <span class="dt">float</span>) * (<span class="dt">float</span> * <span class="dt">float</span>)) <span class="dt">array</span>) : <span class="dt">bool</span> =</span>
<span id="cb17-4"><a href="#cb17-4"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length v <span class="kw">in</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="kw">try</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>        <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>            <span class="kw">for</span> j = i+<span class="dv">1</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>                <span class="kw">if</span> intersecte v.(i) v.(j)</span>
<span id="cb17-9"><a href="#cb17-9"></a>                <span class="kw">then</span> <span class="dt">raise</span> Trouve</span>
<span id="cb17-10"><a href="#cb17-10"></a>            <span class="kw">done</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>        <span class="kw">done</span>;</span>
<span id="cb17-12"><a href="#cb17-12"></a>        <span class="kw">false</span></span>
<span id="cb17-13"><a href="#cb17-13"></a>    <span class="kw">with</span> Trouve -&gt; <span class="kw">true</span></span></code></pre></div>
<p></div></p>
<p>TODO approche par droite de balayage : algorithme de Shamos et Hoey (1976)</p>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
