<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Graphes</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

.ui.styled.accordion {
    width: 100% !important;
    font-size: 1rem !important;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\gO{\mathcal{O}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Graphes
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:graphes-orientés"><span>1</span> Graphes orientés</a><div class="menu"><a class="item" href="#sec:définition"><div class="ui label">1.1</div> Définition</a><a class="item" href="#sec:voisins-et-degrés"><div class="ui label">1.2</div> Voisins et degrés</a><a class="item" href="#sec:chemin"><div class="ui label">1.3</div> Chemin</a><a class="item" href="#sec:sous-graphe"><div class="ui label">1.4</div> Sous-graphe</a><a class="item" href="#sec:implémentation"><div class="ui label">1.5</div> Implémentation</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:énumération-de-sommets"><i class="circle icon"></i> Énumération de sommets</a><a style="font-size:0.6em" class="item" href="#sec:matrice-dadjacence"><i class="circle icon"></i> Matrice d’adjacence</a><a style="font-size:0.6em" class="item" href="#sec:listes-dadjacences"><i class="circle icon"></i> Listes d’adjacences</a><a style="font-size:0.6em" class="item" href="#sec:comparaison"><i class="circle icon"></i> Comparaison</a></div></div></div><div class="item header"> <a href="#sec:graphes-non-orientés"><span>2</span> Graphes non orientés</a><div class="menu"><a class="item" href="#sec:graphes_symetrises"><div class="ui label">2.1</div> Définition et adaptation du vocabulaire</a><a class="item" href="#sec:connexité"><div class="ui label">2.2</div> Connexité</a><a class="item" href="#sec:graphe-acyclique-connexe"><div class="ui label">2.3</div> Graphe acyclique connexe</a><a class="item" href="#sec:graphe-biparti"><div class="ui label">2.4</div> Graphe biparti</a></div></div><div class="item header"> <a href="#sec:graphes-classiques"><span>3</span> Graphes classiques</a><div class="menu"><a class="item" href="#sec:graphes-complets"><div class="ui label">3.1</div> Graphes complets</a><a class="item" href="#sec:cycles"><div class="ui label">3.2</div> Cycles</a><a class="item" href="#sec:grilles-et-hypercubes"><div class="ui label">3.3</div> Grilles et hypercubes</a></div></div><div class="item header"> <a href="#sec:parcours"><span>4</span> Parcours</a><div class="menu"><a class="item" href="#sec:principe"><div class="ui label">4.1</div> Principe</a><a class="item" href="#sec:parcours-en-profondeur-récursif"><div class="ui label">4.2</div> Parcours en profondeur récursif</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:première-version"><i class="circle icon"></i> Première version</a><a style="font-size:0.6em" class="item" href="#sec:arbre-de-parcours"><i class="circle icon"></i> Arbre de parcours</a><a style="font-size:0.6em" class="item" href="#sec:composantes-connexes"><i class="circle icon"></i> Composantes connexes</a><a style="font-size:0.6em" class="item" href="#sec:détection-de-cycles"><i class="circle icon"></i> Détection de cycles</a><a style="font-size:0.6em" class="item" href="#sec:classification-des-arêtes"><i class="circle icon"></i> Classification des arêtes</a><a style="font-size:0.6em" class="item" href="#sec:temps-dentrée-et-de-sortie"><i class="circle icon"></i> Temps d’entrée et de sortie</a></div><a class="item" href="#sec:parcours-quelconque"><div class="ui label">4.3</div> Parcours <strong>quelconque</strong></a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:implémentation-en-python"><i class="circle icon"></i> Implémentation en <code>Python</code></a></div><a class="item" href="#sec:parcours-en-largeur"><div class="ui label">4.4</div> Parcours en largeur</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:preuve"><i class="circle icon"></i> Preuve</a></div><a class="item" href="#sec:pseudo-parcours-en-profondeur"><div class="ui label">4.5</div> Pseudo-parcours en profondeur</a></div></div><div class="item header"> <a href="#sec:tri-topologique"><span>5</span> Tri topologique</a><div class="menu"></div></div><div class="item header"> <a href="#sec:plus-courts-chemins"><span>6</span> Plus courts chemins</a><div class="menu"><a class="item" href="#sec:graphes-pondérés-et-définition-du-problème"><div class="ui label">6.1</div> Graphes pondérés et définition du problème</a><a class="item" href="#sec:cas-des-poids-rationnels"><div class="ui label">6.2</div> Cas des poids rationnels</a><a class="item" href="#sec:algorithme-de-dijkstra"><div class="ui label">6.3</div> Algorithme de Dijkstra</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:utilisation-dune-file-de-priorité"><i class="circle icon"></i> Utilisation d’une file de priorité</a></div><a class="item" href="#sec:relaxation"><div class="ui label">6.4</div> Relaxation</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:arêtes-tendues"><i class="circle icon"></i> Arêtes tendues</a><a style="font-size:0.6em" class="item" href="#sec:algorithme-de-dijkstra-comme-relaxation"><i class="circle icon"></i> Algorithme de Dijkstra comme relaxation</a></div><a class="item" href="#sec:floyd-warshall"><div class="ui label">6.5</div> Floyd-Warshall</a></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Graphes
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Graphes     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_graphe.jpg"> </div></p>
<p><div class="ui message blue"><div class="header">Note</div></p>
<p>Une grande partie est issue verbatim de mon ancien poly. À
affiner.</p>
<p></div></p>
<h1 data-number="1" id="sec:graphes-orientés"><span
class="header-section-number">1</span> Graphes orientés</h1>
<h2 data-number="1.1" id="sec:définition"><span
class="header-section-number">1.1</span> Définition</h2>
<p><div class="ui message"><div class="header">Définition</div> Un
graphe orienté est un couple <span class="math inline">\(G = (S,
A)\)</span> où <span class="math inline">\(S\)</span> est un ensemble
fini et <span class="math inline">\(A\)</span> est une relation
<strong>irréflexive</strong> sur <span class="math inline">\(S\)</span>,
c’est-à-dire <span class="math inline">\(A \subset \{ (x,y) ~|~ x,y \in
S, x \neq y\}\)</span>.</p>
<p>Les éléments de <span class="math inline">\(S\)</span> sont appelés
les <strong>sommets</strong> du graphe <span
class="math inline">\(G\)</span> et les éléments de <span
class="math inline">\(A\)</span> les <strong>arêtes</strong>. Si <span
class="math inline">\((x,y) \in A\)</span>, on dit que <span
class="math inline">\(x\)</span> est la source de l’arête et <span
class="math inline">\(y\)</span> est son but. Quand le contexte n’est
pas ambigu, on notera <span class="math inline">\(x \rightarrow
y\)</span>. </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li><span class="math inline">\(G = ( \{ a, b, c \}, \{ (a, b), (b, c),
(c, b) \} )\)</span></li>
<li><span class="math inline">\(D_n = ( \range{1}{n}, \{ (a,b) ~|~ a
\text{ divise } b, a \neq b \} )\)</span></li>
</ul>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Ici, on a exclu les graphes infinis ainsi que les graphes avec des
boucles ou des arêtes parallèles. On est dans le contexte des
<strong>graphes finis simples</strong>.</p>
<p></div></p>
<p>On représente graphiquement un graphe sous la forme d’un diagramme
sagittaire où les sommets sont des points et où une arêtes <span
class="math inline">\((a,b)\)</span> est une flèche allant du point
<span class="math inline">\(a\)</span> au point <span
class="math inline">\(b\)</span>.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li><p><span class="math inline">\(G\)</span> est représenté par
<center><div class="ui image center"><img
src="assets/pics/graphe_g_rep.png" /></div></center></p></li>
<li><p><span class="math inline">\(D_{10}\)</span> est représenté par
<center><div class="ui image center"><img
src="assets/pics/graphe_d10_rep.png" /></div></center></p></li>
</ul>
</div>
<h2 data-number="1.2" id="sec:voisins-et-degrés"><span
class="header-section-number">1.2</span> Voisins et degrés</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(G = (S, A)\)</span> un graphe orienté et
<span class="math inline">\(x \in S\)</span>.</p>
<p>On appelle <strong>voisins sortants</strong>, ou
<strong>successeurs</strong>, de <span class="math inline">\(x\)</span>
les éléments de <span class="math display">\[
v_+(x) = \enscomp{y \in S}{(x,y) \in A}
\]</span> et on appelle <strong>degré sortant</strong> de <span
class="math inline">\(x\)</span> le cardinal de cet ensemble <span
class="math inline">\(d_+(x) = |v_+(x)|\)</span>.</p>
<p>De même, on parle de <strong>voisins entrants</strong>, ou
<strong>prédéceseurs</strong> pour les éléments de <span
class="math display">\[
v_-(x) = \enscomp{z \in S}{(z,x) \in A}
\]</span> et on parle de <strong>degré entrant</strong> pour <span
class="math inline">\(d_-(x) = |v_-(x)|\)</span>. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(G = (S, A)\)</span> un graphe, on a
<span class="math inline">\(\sum_{x \in S} d_+(x) = \sum_{x \in S}
d_-(x) = |A|\)</span></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> On peut partitionner <span
class="math inline">\(A\)</span> en regroupant les arêtes de même
source, on a ainsi :</p>
<p><span class="math display">\[
A = \bigcup_{x \in S} \enscomp{(x,y)}{y \in S, (x,y) \in A}
= \bigcup_{x \in S} \enscomp{(x,y)}{y \in v_+(x)}
\]</span></p>
<p>Et en prenant la cardinal de cette égalité, on obtient directement
<span class="math inline">\(|A| = \sum_{x \in S} d_+(x)\)</span>.
L’autre égalité est symétrique en considérant les arêtes de même but.
</div> </div></p>
<h2 data-number="1.3" id="sec:chemin"><span
class="header-section-number">1.3</span> Chemin</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(G = (S,A)\)</span> un graphe orienté et
<span class="math inline">\(x, y \in S\)</span>.</p>
<p>Une suite finie <span class="math inline">\(\varphi = (s_0, s_1,
\dots, s_p)\)</span> où <span class="math inline">\(p \in \N, s_0 = x,
s_p = y\)</span> et <span class="math display">\[
\forall i \in \range{1}{p}, (s_{i-1},s_i) \in A
\]</span> est appelée un <strong>chemin</strong>, de longueur <span
class="math inline">\(p\)</span>, de <span
class="math inline">\(x\)</span> vers <span
class="math inline">\(y\)</span>. On a donc <span
class="math display">\[
s_0 \rightarrow s_1 \rightarrow \dots \rightarrow s_p
\]</span></p>
<p>On notera <span class="math inline">\(\varphi : x \leadsto y\)</span>
pour signifier que <span class="math inline">\(\varphi\)</span> est un
tel chemin et <span class="math inline">\(x \leadsto y\)</span> pour
signifier qu’il existe un chemin de <span
class="math inline">\(x\)</span> vers <span
class="math inline">\(y\)</span>. On dit alors que <span
class="math inline">\(y\)</span> est accessible depuis <span
class="math inline">\(x\)</span>. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><span class="math inline">\(\leadsto\)</span> est la plus petite
relation sur <span class="math inline">\(S\)</span> contenant <span
class="math inline">\(\rightarrow\)</span> et qui soit réflexive et
transitive.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> On considère <span
class="math inline">\(\rightarrow \subset R \subset S^2\)</span> telle
que <span class="math inline">\(R\)</span> soit réflexive et
transitive.</p>
<p>Soient <span class="math inline">\(x, y \in S\)</span> et <span
class="math inline">\(\varphi = (s_0, \dots, s_p) : x \leadsto
y\)</span>.</p>
<p>Comme <span class="math inline">\(s_{i-1} \rightarrow s_i\)</span> on
a <span class="math inline">\(s_{i-1} R s_i\)</span> et, par
transitivité, <span class="math inline">\(x = s_0 R s_p = y\)</span>.
Donc <span class="math inline">\(x \leadsto y \Rightarrow x R
y\)</span>.</p>
<p>Ainsi <span class="math inline">\(\leadsto \subset R\)</span>.
</div> </div></p>
<p>On dit que <span class="math inline">\(\leadsto\)</span> est la
fermeture réflexive et transitive de <span
class="math inline">\(\rightarrow\)</span>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Vocabulaire additionnel :</p>
<ul>
<li>Si tous les sommets sont distincts, sauf éventuellement le premier
et le dernier, on dit que le chemin est
<strong>élémentaire</strong>.</li>
<li>Si toutes les arêtes sont distinctes, on dit que le chemin est
<strong>simple</strong>.</li>
<li>Si <span class="math inline">\(x = y\)</span>, on dit que le chemin
est <strong>fermé</strong>.</li>
<li>Un chemin simple dont tous les sommets sont distincts est appelé une
<strong>chaîne</strong>.</li>
<li>Un chemin élémentaire fermé simple de longueur au moins 1 est appelé
un <strong>cycle</strong>. <em>Comme le chemin vide issu de <span
class="math inline">\(x\)</span> est fermé, il est nécessaire de
considérer des chemins non vides.</em></li>
<li>Un graphe contenant au moins un cycle est dit
<strong>cyclique</strong>. Dans le cas contraire, on dit qu’il est
<strong>acyclique</strong>.</li>
</ul>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Si <span class="math inline">\(\varphi : x \leadsto y\)</span> et
<span class="math inline">\(\psi : y \leadsto z\)</span> on note <span
class="math inline">\(\varphi \psi :x \leadsto z\)</span> la concaténée
des deux chemins.</p>
<p></div></p>
<p><div class="ui message"><div class="header">Définition</div> On note
<span class="math inline">\(\leftrightarrow y\)</span> la plus grande
relation d’équivalence incluse dans <span
class="math inline">\(\leadsto\)</span>.</p>
<p>Plus précisément, on a <span class="math display">\[
x \leftrightarrow y \iff (x \leadsto y \wedge y \leadsto x)
\]</span></p>
<p>Les classes d’équivalences pour <span
class="math inline">\(\leftrightarrow\)</span> sont appelées les
composantes <strong>fortement connexes</strong> du graphe. S’il n’y a
qu’une classe, on dit que le graphe est <strong>fortement
connexe</strong>. </div></p>
<h2 data-number="1.4" id="sec:sous-graphe"><span
class="header-section-number">1.4</span> Sous-graphe</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(G = (S,A)\)</span> et <span
class="math inline">\(X \subset S\)</span>. On appelle
<strong>sous-graphe</strong> induit par <span
class="math inline">\(X\)</span> le graphe <span
class="math inline">\((X, A_X)\)</span> où <span class="math display">\[
A_X = \enscomp{ (a,b) \in A}{a \in X\wedge b \in X}
\]</span></p>
<p>Un graphe <span class="math inline">\(G&#39;\)</span> est un
<strong>sous-graphe</strong> de <span class="math inline">\(G\)</span>
quand c’est le sous-graphe de <span class="math inline">\(G\)</span>
induit par les sommets de <span class="math inline">\(G&#39;\)</span>
(ils sont alors nécessairement des sommets de <span
class="math inline">\(G\)</span>). </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Les composantes fortement connexes sont les sous-graphes fortement
connexes maximaux pour l’inclusion.</p>
<p></div></p>
<h2 data-number="1.5" id="sec:implémentation"><span
class="header-section-number">1.5</span> Implémentation</h2>
<h3 data-number="1.5.1" id="sec:énumération-de-sommets"><span
class="header-section-number">1.5.1</span> Énumération de sommets</h3>
<p>Si on considère un graphe <span class="math inline">\(G =
(S,A)\)</span>, il est assez naturel de représenter ses sommets dans un
tableau. Pour cela, on fixe naturellement un ordre sur ces sommets et on
va associer à chaque sommet son indice dans le tableau.</p>
<p>Par exemple, si <span class="math inline">\(S = \{ a, b, c,
d\}\)</span> on va pouvoir considérer <code>[ a, b, c, d ]</code> et
ainsi associer à <code>a</code> son indice 0 dans le tableau. L’ordre
est arbitraire, on aurait pu considérer <code>[ b, c, a, d ]</code> et
l’indice de <code>a</code> aurait alors été 2.</p>
<p>Ce qui compte, c’est de pouvoir travailler directement sur les
indices et pas sur les éléments. Une manière de s’en convaincre est
d’imaginer le graphe d’un réseau social où un sommet correspond au
profil d’une personne, et contient donc beaucoup (<em>trop</em>)
d’informations. Il est bien plus raisonnable de lui associer un
identifiant unique et d’utiliser cet identifiant ensuite.</p>
<p>Quand on va implémenter des graphes, on peut donc supposer que les
sommets sont les entiers de <code>0</code> à <code>n-1</code> où <span
class="math inline">\(|S| = n\)</span>. Il sera toujours possible de
retrouver la correspondance avec les sommets eux-mêmes.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Si on est bloqué par le coût de l’opération permettant d’obtenir
l’indice d’un sommet, qui est en <span
class="math inline">\(O(|S|)\)</span> par une recherche linéaire, on
peut très bien définir un dictionnaire associant à chaque sommet son
indice en <span class="math inline">\(O(1)\)</span>.</p>
<p>Il se trouve qu’on ne va pas forcément s’intéresser à ces questions
mais plus aux raisonnements sur la structure du graphe.</p>
<p></div></p>
<h3 data-number="1.5.2" id="sec:matrice-dadjacence"><span
class="header-section-number">1.5.2</span> Matrice d’adjacence</h3>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(G = (S,A)\)</span> un graphe et <span
class="math inline">\(S = \{ s_1, \dots, s_n \}\)</span> une énumération
sans répétition des sommets de <span class="math inline">\(G\)</span>.
La matrice <span class="math inline">\(M_G = \left( m_{ij} \right)_{1
\le i, j \le n} \in \mathcal{M}_n(\R)\)</span> définie par <span
class="math display">\[
\forall i, j \in \range{1}{n}, m_{ij} = \begin{cases}
1 &amp;\text{ si } s_i \rightarrow s_j \\ 0 &amp; \text{ sinon }
\end{cases}
\]</span> est appelée une <strong>matrice d’adjacence</strong> de <span
class="math inline">\(G\)</span>. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il s’agit bien d’<strong>une</strong> matrice d’adjacence et pas de
<strong>la</strong> matrice car elle dépend de l’énumération des
sommets.</p>
<p></div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on considère le graphe</p>
<p><img src="assets/pics/matex1.png" /></p>
<p>On aura pour l’énumération <span
class="math inline">\(a,b,c,d\)</span> la matrice : <span
class="math display">\[
\begin{pmatrix}
0 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 &amp; 0
\end{pmatrix}
\]</span> En fait, la ième ligne correspond au ième sommet de
l’énumération. Ici, la dernière ligne <span class="math inline">\(1 1 0
0\)</span> correspond au sommet d et donne dans l’ordre <span
class="math inline">\(a,b,c,d\)</span> la présence ou non d’une arête
<span class="math inline">\(d \rightarrow *\)</span>.</p>
<p>Si on considère l’énumération <span
class="math inline">\(b,a,d,c\)</span> on aura la matrice :</p>
<p><span class="math display">\[
\begin{pmatrix}
0 &amp; 1 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1 &amp; 1 \\
1 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}
\]</span></p>
</div>
<p>On en déduit ainsi une implémentation directe d’un graphe en
représentant la matrice d’adjacence comme l’a fait pour des images.</p>
<p><div>   <div class="ui top attached tabular menu code">   <a class="active item" data-tab="python-91">python</a>   <a class="item" data-tab="c-91">c</a>   <a class="item" data-tab="ocaml-91">ocaml</a> </div> <div class="ui bottom attached active tab segment code" data-tab="python-91"></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> [ [ <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span> ],</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      [ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span> ],</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span> ],</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      [ <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span> ] ]</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="c-91"></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="ocaml-91"></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> m = [| [| <span class="dv">0</span>; <span class="dv">1</span>; <span class="dv">1</span>; <span class="dv">1</span> |];</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>           [| <span class="dv">1</span>; <span class="dv">0</span>; <span class="dv">0</span>; <span class="dv">1</span> |];</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>           [| <span class="dv">0</span>; <span class="dv">0</span>; <span class="dv">0</span>; <span class="dv">1</span> |];</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>           [| <span class="dv">1</span>; <span class="dv">1</span>; <span class="dv">0</span>; <span class="dv">0</span> |] |]</span></code></pre></div>
<p></div> </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il y a le même lien entre les différentes matrices d’adjacence d’un
graphe donnée et la matrice d’un endomorphisme dans les différentes
permutations d’une même base, à chaque fois on obtient la nouvelle
matrice en permutant de même ses lignes et ses colonnes.</p>
<p></div></p>
<p>Cette représentation permet d’accéder, en lecture comme en écriture,
à une arête en temps constant. Cependant, pour récupérer les voisins
d’un sommet, il est nécessaire de parcourir toute la ligne
correspondante, donc en <span class="math inline">\(O(|S|)\)</span>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Dans la majorité des cas, <span class="math inline">\(A\)</span> est
petit par rapport à <span class="math inline">\(|S|^2\)</span>. Ainsi,
la matrice contient très peu de 1 et beaucoup de 0, on dit qu’elle est
<em>creuse</em>. Une telle matrice <em>creuse</em> peut-être
efficacement représenté par l’ensemble fini des arêtes <span
class="math inline">\((i,j)\)</span>. Par exemple, avec une table de
hachage. Cependant, dans le cas des graphes, il est possible d’avoir une
structure creuse plus efficace.</p>
<p>A titre d’exemple, un graphe issu d’un réseau social est présenté
plus bas, il contient <span class="math inline">\(300 000\)</span>
arêtes pour <span class="math inline">\(8 000\)</span> sommets. Donc le
rapport <span class="math inline">\(|A|/|S|^2\)</span> est de 4 pour
1000 !</p>
<p></div></p>
<h3 data-number="1.5.3" id="sec:listes-dadjacences"><span
class="header-section-number">1.5.3</span> Listes d’adjacences</h3>
<p>La donnée de <span class="math inline">\(v_+(x)\)</span> pour chaque
sommet <span class="math inline">\(x \in S\)</span> suffit à
reconstruire <span class="math inline">\(A\)</span>.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on reprend le graphe précédent, <img
src="assets/pics/matex1_bis.png" /> on a <span class="math inline">\(S =
\{ a,b,c,d\}\)</span> et <span class="math inline">\(A = \{ (a, b), (a,
c), (a,d), (b,a), (b, d) , (c,d), (d, a), (d, b) \}\)</span>.</p>
<p>Or <span class="math inline">\(v_+(a) = \{ b, c, d \}, v_+(b) = \{ a,
d \}, v_+(c) = \{ d \}\)</span> et <span class="math inline">\(v_+(d) =
\{ a, b \}\)</span>.</p>
<p>Si on pose <span class="math inline">\(V_+(x) = \enscomp{ (x,y) }{ y
\in v_+(x) }\)</span> on a directement <span class="math inline">\(A =
\bigcup_{x \in S} V_+(x)\)</span>.</p>
</div>
<p>On en déduit ainsi une représentation d’un graphe où on place dans un
tableau chaque <span class="math inline">\(v_+(x)\)</span> représenté
par une liste chaînée ou un tableau dynamique.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Pour représenter <span class="math inline">\(v_+(x)\)</span> on a
plusieurs choix : on peut utiliser directement les valeurs des sommets
ou utiliser des indices dans une énumération. C’est le second choix
qu’on fera en général car il est plus simple. Cependant, en cas de
suppression d’un sommet, les indices changent, et il faut renuméroter
dans les listes.</p>
<p>Pour le graphe précédent, on pourra donc considérer une énumeration
<code>[ a, b, c, d ]</code> et la représentation sous forme de liste
d’adjacence pourra être :</p>
<p><div class="ui top attached tabular menu code">   <a class="active item" data-tab="python">python</a>   <a class="item" data-tab="ocaml">ocaml</a> </div> <div class="ui bottom attached active tab segment code" data-tab="python"></p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> [ [ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ], [ <span class="dv">0</span>, <span class="dv">3</span> ], [ <span class="dv">3</span> ], [ <span class="dv">0</span>, <span class="dv">1</span> ] ]</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="ocaml"></p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> l = [| </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    [ <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span> ]; [ <span class="dv">0</span>; <span class="dv">3</span> ]; [ <span class="dv">3</span> ]; [ <span class="dv">0</span>; <span class="dv">1</span> ]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    |]</span></code></pre></div>
<p></div></p>
<p></div></p>
<p>L’accès en lecture ou en écriture à une arête est alors en <span
class="math inline">\(O(|A|)\)</span> mais on peut parcourir les voisins
sortant en <span class="math inline">\(O(|A|)\)</span> également. Pour
un sommet donné, on peut même préciser <span
class="math inline">\(O(d_+(x))\)</span>. Accéder à la liste peut même
se faire en <span class="math inline">\(O(1)\)</span>.</p>
<p>Pour obtenir les voisins entrants, il est par contre nécessaire de
tester la présence de <span class="math inline">\(x\)</span> dans
chacune des autres listes, on obtient donc un algorithme en <span
class="math inline">\(O(|S| + |A|)\)</span> : on parcourt chaque case du
tableau des listes puis chaque maillon de listes d’adjacence.</p>
<p>Il est possible d’améliorer cela en utilisant un structure plus
efficace pour stocker les ensembles. Cela peut-être un dictionnaire
reposant sur une table de hachage. L’avantage de cela est que pour
tester l’appartenance <span class="math inline">\(y \in v_+(x)\)</span>
on sera en <span class="math inline">\(O(1)\)</span> avec un
dictionnaire alors qu’on sera en <span
class="math inline">\(O(d_+(x))\)</span> avec une liste.</p>
<h3 data-number="1.5.4" id="sec:comparaison"><span
class="header-section-number">1.5.4</span> Comparaison</h3>
<table style="width:86%;">
<colgroup>
<col style="width: 29%" />
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th>opération</th>
<th>Matrice</th>
<th>Listes</th>
<th>Dictionnaire</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>complexité spatiale</td>
<td><span class="math inline">\(O(|S|^2)\)</span></td>
<td><span class="math inline">\(O(|S|+|A|)\)</span></td>
<td><span class="math inline">\(O(|S|+|A|)\)</span></td>
</tr>
<tr class="even">
<td>arête test</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(|A|)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>arête ajout</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>arête suppression</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(|A|)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>sommet ajout</td>
<td><span class="math inline">\(O(|S|^2)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
</tr>
<tr class="even">
<td>sommet suppression</td>
<td><span class="math inline">\(O(|S|^2)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
</tr>
<tr class="odd">
<td>voisins/degré +</td>
<td><span class="math inline">\(O(|S|)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>voisins/degré -</td>
<td><span class="math inline">\(O(|S|)\)</span></td>
<td><span class="math inline">\(O(|S|+|A|)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
</tr>
</tbody>
</table>
<p>Notons qu’il est possible d’améliorer certaines complexités en
utilisant des tableaux dynamiques, notamment les ajouts et suppressions
de sommets.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il semble a priori clair qu’on devrait utiliser des dictionnaires
pour manipuler des graphes en voyant ce tableau. Pourtant, on utilisera
presque exclusivement des listes d’adjacence. Pourquoi ? En grande
partie parce que les opérations rendues efficaces sont rares et ne
justifient pas la difficulté accrue de manipulation. En effet,
l’opération la plus importante est de pouvoir énumérer les voisins, et
une liste chaînée le permet facilement et efficacement.</p>
<p></div></p>
<h1 data-number="2" id="sec:graphes-non-orientés"><span
class="header-section-number">2</span> Graphes non orientés</h1>
<h2 data-number="2.1" id="sec:graphes_symetrises"><span
class="header-section-number">2.1</span> Définition et adaptation du
vocabulaire</h2>
<p><div class="ui message"><div class="header">Définition</div> Un
graphe non orienté est un couple <span class="math inline">\(G = (S,
A)\)</span> où <span class="math inline">\(S\)</span> est un ensemble
fini et <span class="math inline">\(A\)</span> est un ensemble de paires
d’éléments de <span class="math inline">\(S\)</span>, c’est-à-dire
d’ensembles à deux éléments <span class="math inline">\(\{x,y\}\)</span>
où <span class="math inline">\(x, y \in S\)</span>.</p>
<p>Les éléments de <span class="math inline">\(S\)</span> sont appelés
les <strong>sommets</strong> du graphe <span
class="math inline">\(G\)</span> et les éléments de <span
class="math inline">\(A\)</span> les <strong>arêtes</strong>. Si <span
class="math inline">\(\{ x,y \} \in A\)</span>, on note <span
class="math inline">\(x \smile y\)</span>. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Si <span class="math inline">\(G = (S,A)\)</span> est un graphe
orienté, on peut en déduire deux graphes non orientés :</p>
<ul>
<li>un graphe par défaut <span class="math inline">\(G^- = (S,
A^-)\)</span> où <span class="math display">\[\forall x, y \in S, x
\smile y
\iff (x \rightarrow y \wedge y \rightarrow x)\]</span></li>
<li>un graphe par excès <span class="math inline">\(G^+ = (S,
A^+)\)</span> où <span class="math display">\[\forall x, y \in S, x
\smile y
\iff (x \rightarrow y \vee y \rightarrow x)\]</span></li>
</ul>
<p>On a également <span class="math inline">\(A\)</span> symétrique
<span class="math inline">\(\iff G^+ = G^-\)</span>. Cela correspond à
un graphe où chaque arête est dans les deux sens <span
class="math inline">\(x \leftrightarrow y\)</span> et, donc, on peut
oublier l’orientation.</p>
<p>De la même manière, on peut associer à un graphe non orienté <span
class="math inline">\(G\)</span> son graphe orienté symétrique obtenu en
doublant chaque arête. C’est à dire en posant si <span
class="math inline">\(x \rightarrow y\)</span> si <span
class="math inline">\(x \smile y\)</span>. On a donc <span
class="math inline">\(\forall x, y \in S, x \rightarrow y \iff y
\rightarrow x\)</span> et le graphe est bien symétrique.</p>
<p></div></p>
<p>On reprend directement l’essentiel du vocabulaire des graphes
orientés symétriques avec des simplifications :</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(G= (S,A)\)</span> un graphe et <span
class="math inline">\(x \in S\)</span>.</p>
<ul>
<li>On appelle <em>voisins</em> de <span
class="math inline">\(x\)</span> les éléments de <span
class="math display">\[
v(x) = \enscomp{y \in S}{x \smile y}
\]</span></li>
<li>On appelle <em>degré</em> de <span class="math inline">\(x\)</span>
l’entier <span class="math inline">\(d(x) = | v(x)|\)</span>.
</div></li>
</ul>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><span class="math inline">\(\sum_{x \in S} d(x) = 2 |A|\)</span></p>
</div>
<p>On étend directement la notion de <strong>chemin</strong> mais il
faut faire attention au fait que <strong>simple</strong> n’a pas le même
sens entre un graphe non orienté symétrique et un graphe non orienté. En
effet, on <span class="math inline">\(x \rightarrow y \rightarrow
x\)</span> est simple pour un graphe orienté alors que <span
class="math inline">\(x \smile y \smile x\)</span> ne l’est pas vu qu’il
s’agit de la même arête.</p>
<h2 data-number="2.2" id="sec:connexité"><span
class="header-section-number">2.2</span> Connexité</h2>
<p><div class="ui message"><div class="header">Définition</div> On
définit <span class="math inline">\(\smile^*\)</span> comme étant la
fermeture réflexive et transitive de <span
class="math inline">\(\smile\)</span>. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<ul>
<li><span class="math inline">\(\smile^*\)</span> est une relation
d’équivalence dont les classes sont appelées les <strong>composantes
connexes</strong> du graphe.</li>
<li><span class="math inline">\(x \smile^* y \iff\)</span> il existe un
chemin de <span class="math inline">\(x\)</span> à <span
class="math inline">\(y\)</span>.</li>
</ul>
</div>
<p><div class="ui message"><div class="header">Définition</div> Un
graphe n’ayant qu’une classe d’équivalence pour <span
class="math inline">\(\smile^*\)</span> est dit
<strong>connexe</strong>. Cela signifie qu’il existe un chemin entre
toute paire de sommets. </div></p>
<h2 data-number="2.3" id="sec:graphe-acyclique-connexe"><span
class="header-section-number">2.3</span> Graphe acyclique connexe</h2>
<p><div class="ui message"><div class="header">Définition</div> On
appelle <strong>arbre</strong> un graphe acyclique connexe. Quand on a
distingué un sommet, on parle d’<strong>arbre enraciné</strong>.
</div></p>
<h2 data-number="2.4" id="sec:graphe-biparti"><span
class="header-section-number">2.4</span> Graphe biparti</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(G = (S,A)\)</span> un graphe, on dit que le
graphe est <strong>biparti</strong> lorsqu’il existe une partition <span
class="math inline">\(S = S_1 \cup S_2\)</span> et que <span
class="math display">\[
\forall \{ x, y \} \in A, x \in S_1 \iff y \in S_2
\]</span> </div></p>
<p>Ici, le graphe est biparti avec <span class="math inline">\(S_1 =
\{a,e,f,g\}\)</span> et <span class="math inline">\(S_2 =
\{b,c,d\}\)</span>.</p>
<p><center><div class="ui image center"><img
src="assets/pics/graph_biparti.png" /></div></center></p>
<p>On peut s’en rendre compte en colorant les sommets.</p>
<p><center><div class="ui image center"><img
src="assets/pics/graph_biparti2.png" /></div></center></p>
<p>En fait, être biparti est équivalent à pouvoir être coloré en deux
couleurs en sorte que deux sommets reliés soient de couleur
différente.</p>
<h1 data-number="3" id="sec:graphes-classiques"><span
class="header-section-number">3</span> Graphes classiques</h1>
<p>On présente ici brièvement des graphes ou des familles de graphes
classiques qui serviront, notamment pour les exemples.</p>
<h2 data-number="3.1" id="sec:graphes-complets"><span
class="header-section-number">3.1</span> Graphes complets</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(n \in \N^*\)</span>, on appelle
<strong>graphe complet</strong> à <span class="math inline">\(n\)</span>
sommets le graphe non orienté <span class="math inline">\(K_n\)</span>
de sommets <span class="math inline">\(\range{0}{n-1}\)</span> et tel
que <span class="math display">\[
\forall x, y \in \range{0}{n-1}, x \neq y \iff x \smile y
\]</span> </div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p><span class="math inline">\(K_5\)</span> : <img
src="assets/pics/complet5.png" /></p>
<p></div><div class="eight wide column"></p>
<p><span class="math inline">\(K_8\)</span> : <img
src="assets/pics/complet8.png" /></p>
<p></div></div></div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(n, p \in \N^*\)</span>, on appelle
<strong>graphe bipartite complet</strong> à <span
class="math inline">\((n,p)\)</span> sommets le graphe non orienté <span
class="math inline">\(K_{n,p}\)</span> de sommets <span
class="math inline">\(\range{0}{n+p-1}\)</span> et tel que <span
class="math display">\[
\forall x \in \range{0}{n-1}, \forall y \in \range{n}{n+p-1}, x \smile y
\]</span> </div></p>
<p><span class="math inline">\(K_{3,4}\)</span> : <img
src="assets/pics/complet34.png" /></p>
<h2 data-number="3.2" id="sec:cycles"><span
class="header-section-number">3.2</span> Cycles</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(n \in \N^*\)</span>, on appelle
<strong>cycle</strong> de longueur <span
class="math inline">\(n\)</span> le graphe non orienté <span
class="math inline">\(C_n\)</span> de sommets <span
class="math inline">\(\range{0}{n-1}\)</span> et tel que <span
class="math display">\[
\forall x, y \in \range{0}{n-1}, |x - y| = 1  \iff x \smile y
\]</span> </div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p><span class="math inline">\(C_5\)</span> : <img
src="assets/pics/cycle5.png" /></p>
<p></div><div class="eight wide column"></p>
<p><span class="math inline">\(C_8\)</span> : <img
src="assets/pics/cycle8.png" /></p>
<p></div></div></div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(n \in \N^*\)</span>, on appelle
<strong>cycle orienté</strong> de longueur <span
class="math inline">\(n\)</span> le graphe orienté <span
class="math inline">\(C^o_n\)</span> de sommets <span
class="math inline">\(\range{0}{n-1}\)</span> et tel que <span
class="math display">\[
\forall x, y \in \range{0}{n-1}, y \equiv  x + 1 ~ [n]  \iff x
\rightarrow y
\]</span> </div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p><span class="math inline">\(C^o_5\)</span> : <img
src="assets/pics/cycleo5.png" /></p>
<p></div><div class="eight wide column"></p>
<p><span class="math inline">\(C^o_8\)</span> : <img
src="assets/pics/cycleo8.png" /></p>
<p></div></div></div></p>
<h2 data-number="3.3" id="sec:grilles-et-hypercubes"><span
class="header-section-number">3.3</span> Grilles et hypercubes</h2>
<p>On va manipuler ici des vecteurs de dimension <span
class="math inline">\(d\)</span> à coordonnées entières dans <span
class="math inline">\(\range{0}{n-1}\)</span>.</p>
<p>On sait que <span class="math inline">\(\range{0}{n-1}^d\)</span> est
en bijection avec <span class="math inline">\(\range{0}{n^d-1}\)</span>
et on considère la bijection explicite suivante : <span
class="math display">\[
\varphi(x) = \sum_{i=0}^{d-1} x_i \text{ où } x = (x_0, \dots, x_{d-1})
\]</span></p>
<p>Soit <span class="math inline">\(x = (x_0, \dots, x_{d-1})\)</span>
et <span class="math inline">\(y = (y_0, \dots, y_{d-1}) \in
\range{0}{n-1}^d\)</span>, on note <span class="math inline">\(d_1(x,y)
= \sum_{i=0}^{d-1} |x_i-y_i|\)</span> qui compte la somme des
différences de coordonnées. Ainsi <span class="math inline">\(d_1(
(1,2,3), (3,2,2) ) = |1-3| + |2-2| + |3-2| = 3\)</span>. Comme les
coordonnées sont entières, on a le théorème suivant qui indique que les
vecteurs à distance 1 sont ceux qui différent exactement de 1 dans une
unique coordonnée :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soient <span class="math inline">\(x, y \in
\range{0}{n-1}^d\)</span>, on a <span class="math display">\[
d_1(x,y) = 1 \iff \exists i \in \range{0}{d-1},
\begin{cases}
\forall j \in \range{0}{d-1}, j \neq i \Rightarrow x_j = y_j \\
|x_j-y_j| = 1
\end{cases}
\]</span></p>
</div>
<p>On en déduit un graphe de grille des vecteurs à distance 1 :</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(n, d \in \N^*\)</span>, on appelle
<strong>grille de dimension <span class="math inline">\(d\)</span> et de
taille <span class="math inline">\(n\)</span></strong> le graphe <span
class="math inline">\(G_n^d\)</span> dont les sommets sont dans <span
class="math inline">\(\range{0}{n-1}^d\)</span> et où <span
class="math display">\[
\forall x, y \in \range{0}{n-1}^d, x \smile y \iff d_1(x,y) = 1
\]</span> </div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p><span class="math inline">\(G_3^2\)</span> : <img
src="assets/pics/grille32.png" /></p>
<p></div><div class="eight wide column"></p>
<p><span class="math inline">\(G_2^3\)</span> : <img
src="assets/pics/grille23.png" /></p>
<p></div></div></div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(n \in \N^*\)</span>, on appelle
<strong>hypercube de dimension <span
class="math inline">\(n\)</span></strong> le graphe <span
class="math inline">\(H_n = G_2^n\)</span>. </div></p>
<p>On vient de voir l’hypercube de dimension 3 dans l’exemple
précédent.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>L’hypercube de dimension <span class="math inline">\(n\)</span> est
intéressant car il permet de représenter chaque nombre de <span
class="math inline">\(\range{0}{2^n-1}\)</span> comme un sommet du
graphe. Par exemple, toute chaîne hamiltonienne, c’est-à-dire qui
contient chaque sommet du graphe, correspond à un ordre d’énumération
des nombres qui vérifie qu’un nombre et son successeur ne diffèrent que
sur un bit.</p>
<p></div></p>
<h1 data-number="4" id="sec:parcours"><span
class="header-section-number">4</span> Parcours</h1>
<p><div class="ui label">     ITC<div class="detail">Sup</div> </div>
<div class="ui label">     MP2I<div class="detail">S2</div> </div></p>
<h2 data-number="4.1" id="sec:principe"><span
class="header-section-number">4.1</span> Principe</h2>
<p>La grande majorité des algorithmes sur les graphes consistent à
parcourir les sommets de voisins en voisins pour effectuer des
traitements. La manière dont on les parcourt pouvant changer selon les
différentes applications.</p>
<p>Citons, par exemple, le fait de déterminer les composantes connexes
d’un graphe ou de trouver le plus court chemin entre deux sommets.</p>
<p>On va se placer dans le cadre d’un graphe orienté représenté par
listes d’adjacence et en supposant que les sommets sont identifiés par
leur indice. Dans ce cadre, si on a, en fait, un graphe non orienté, il
sera représenté par son graphe orienté symétrique comme on l’a vu plus
haut.</p>
<p>On va également considérer qu’on veut effectuer un traitement, ou une
visite, pour ces sommets ou les arêtes empruntées.</p>
<h2 data-number="4.2" id="sec:parcours-en-profondeur-récursif"><span
class="header-section-number">4.2</span> Parcours en profondeur
récursif</h2>
<p>On présente ici une première manière élémentaire de les parcourir en
tirant partie de la récursivité :</p>
<ul>
<li>on considère une fonction <code>parcours</code> et l’appel à
<code>parcours</code> pour le sommet <code>x</code> va effectuer des
appels récursifs à <code>parcours</code> pour chaque sommet <span
class="math inline">\(y\)</span> de <span
class="math inline">\(v_+(x)\)</span>.</li>
</ul>
<p>Le problème est qu’on ne veut pas traiter deux fois un sommet et on
veut que les appels terminent. Pour cela, on introduit une notion d’état
associé à chaque sommet. Un sommet peut-être</p>
<ul>
<li><strong>Inconnu</strong>, cela correspond au fait qu’il n’est pas
encore apparu en tant que voisin.</li>
<li><strong>Découvert</strong>, il est apparu mais n’a pas encore été
traité complètement.</li>
<li><strong>Traité</strong> (ou <strong>Visité</strong>), il a non
seulement été traité, mais également tous les sommets parcouru grâce à
lui.</li>
</ul>
<p>Pour maintenir cet état dans le code, le plus simple est de
considérer un tableau d’entiers <code>etat</code> où
<code>etat[i]</code> donne l’état du sommet <code>i</code>.</p>
<p><div class="ui message"><div class="header">Définition</div> Ce
parcours est appelé un <strong>parcours en profondeur</strong> récursif.
En anglais, on parle de <strong>depth-first search</strong> et on
utilise couramment l’acronyme <strong>DFS</strong>. </div></p>
<h3 data-number="4.2.1" id="sec:première-version"><span
class="header-section-number">4.2.1</span> Première version</h3>
<p>On adapte directement le principe précédent en un programme.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>INCONNU <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>DECOUVERT <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>TRAITE <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">def</span> parcours(ladj, x, etat):</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="cf">if</span> etat[x] <span class="op">!=</span> TRAITE:</span>
<span id="cb6-7"><a href="#cb6-7"></a>        <span class="bu">print</span>(x)</span>
<span id="cb6-8"><a href="#cb6-8"></a>        <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb6-9"><a href="#cb6-9"></a>            <span class="cf">if</span> etat[y] <span class="op">==</span> INCONNU:</span>
<span id="cb6-10"><a href="#cb6-10"></a>                etat[y] <span class="op">=</span> DECOUVERT</span>
<span id="cb6-11"><a href="#cb6-11"></a>                parcours(ladj, y, etat)</span>
<span id="cb6-12"><a href="#cb6-12"></a>        etat[x] <span class="op">=</span> TRAITE</span>
<span id="cb6-13"><a href="#cb6-13"></a></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="kw">def</span> lance_parcours(ladj, x):</span>
<span id="cb6-15"><a href="#cb6-15"></a>    <span class="co"># État initial inconnu pour tous</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>    etat <span class="op">=</span> [ INCONNU ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb6-17"><a href="#cb6-17"></a>    etat[x] <span class="op">=</span> DECOUVERT</span>
<span id="cb6-18"><a href="#cb6-18"></a>    parcours(ladj, x, etat)</span></code></pre></div>
<p></div></p>
<p>Ici, on se contente d’afficher les sommets rencontrés.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On va réaliser un parcours en profondeur du graphe suivant en partant
du sommet 0 :</p>
<p><img src="assets/pics/graphe_dfsrec_ex.png" /></p>
<p>On indique les sommets inconnus en blanc, les sommets découvert en
rouge et les sommets traités en vert.</p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>On affiche 0 et on appelle relance le parcours du voisin 1.</p>
<p><img src="assets/pics/graphe_dfsrec_ex1.png" /></p>
<p></div><div class="eight wide column"></p>
<p>On affiche 1 et on relance le parcours du voisin 2.</p>
<p><img src="assets/pics/graphe_dfsrec_ex2.png" /></p>
<p></div></div></div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>On affiche 3 et on appelle relance le parcours du voisin 4.</p>
<p><img src="assets/pics/graphe_dfsrec_ex3.png" /></p>
<p></div><div class="eight wide column"></p>
<p>On affiche 4 et comme il n’a pas de voisins non traités, on traite 4
et on sort de l’appel.</p>
<p><img src="assets/pics/graphe_dfsrec_ex4.png" /></p>
<p></div></div></div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>On revient à 2 et on relance le parcours du voisin 3. On affiche 3,
et on le traite car tous ses voisins sont connus.</p>
<p><img src="assets/pics/graphe_dfsrec_ex5.png" /></p>
<p></div><div class="eight wide column"></p>
<p>On revient à 2 et cette fois-ci il n’y a plus de voisins, on peut
marquer 2 comme étant traité.</p>
<p><img src="assets/pics/graphe_dfsrec_ex6.png" /></p>
<p></div></div></div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>On revient à 1 et on peut marquer 1 comme étant traité.</p>
<p><img src="assets/pics/graphe_dfsrec_ex7.png" /></p>
<p></div><div class="eight wide column"></p>
<p>On revient à 0 et on peut marquer 0 comme étant traité.</p>
<p><img src="assets/pics/graphe_dfsrec_ex8.png" /></p>
<p></div></div></div></p>
<p>On a donc une vague de descente dans le graphe qui marque les sommets
comme découverts et ensuite on remonte la pile d’appels récursifs en
marquant les sommets comme étant traités.</p>
<p>Les sommets sont ici affichés dans l’ordre 0 1 2 4 3. On remarque que
les sommets 5 et 6 sont inaccessibles, ils restent ainsi inconnus tout
le long du parcours.</p>
</div>
<h3 data-number="4.2.2" id="sec:arbre-de-parcours"><span
class="header-section-number">4.2.2</span> Arbre de parcours</h3>
<p>On peut noter les arêtes empruntées lors du parcours précédents pour
découvrir un nouveau sommet, et donc relancer un appel récursif. On
obtient alors une structure arborescente qui est appelé l’arbre du
parcours en profondeur.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Dans le parcours précédent, on obtient l’arbre suivant :
<div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p><img src="assets/pics/graphe_dfsrec_arbre.png" /></p>
<p></div><div class="eight wide column"></p>
<p><center><div class="ui image center"><img
src="assets/pics/graphe_dfsrec_arbre2.png" /></div></center></p>
<p></div></div></div></p>
</div>
<p>Pour obtenir cet arbre, on va construire un tableau
<code>parent</code> pendant le parcours. Lorsqu’on emprunte une arête
<span class="math inline">\(x \rightarrow y\)</span> pour découvrir
<span class="math inline">\(y\)</span>, on note <span
class="math inline">\(parent[y] = x\)</span>. Par défaut, <span
class="math inline">\(parent[y]\)</span> est indéfini (<code>None</code>
ou une valeur d’indice invalide comme <span
class="math inline">\(-1\)</span>).</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Si <span class="math inline">\(parent[y]\)</span> est défini à
l’issue du parcours depuis <span class="math inline">\(x\)</span>, alors
il existe un chemin <span class="math inline">\(\varphi : x \leadsto
y\)</span> où les arêtes <span class="math inline">\(s \rightarrow
s&#39;\)</span> empruntées lors du chemin vérifient toutes <span
class="math inline">\(parent[s&#39;] = s\)</span>.</p>
</div>
<p>Comme <span class="math inline">\(parent[y]\)</span> est défini pour
tous les sommets découverts et que les sommets découverts finissent tous
par être traités, on peut en déduire directement le théorème suivant
:</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>A l’issue du parcours depuis <span class="math inline">\(x\)</span>,
les sommets traités sont les sommets accessibles depuis <span
class="math inline">\(x\)</span>, c’est-à-dire les éléments de <span
class="math display">\[
\enscomp{y \in S}{x \leadsto y}
\]</span></p>
</div>
<p>On présente le calcul de ces chemins dans le programme suivant :
<div class="ui segment code"></p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>INCONNU <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>DECOUVERT <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>TRAITE <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="kw">def</span> parcours(ladj, x, etat, parent):</span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span class="cf">if</span> etat[x] <span class="op">!=</span> TRAITE:</span>
<span id="cb7-7"><a href="#cb7-7"></a>        <span class="bu">print</span>(x)</span>
<span id="cb7-8"><a href="#cb7-8"></a>        <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb7-9"><a href="#cb7-9"></a>            <span class="cf">if</span> etat[y] <span class="op">==</span> INCONNU:</span>
<span id="cb7-10"><a href="#cb7-10"></a>                parent[y] <span class="op">=</span> x</span>
<span id="cb7-11"><a href="#cb7-11"></a>                etat[y] <span class="op">=</span> DECOUVERT</span>
<span id="cb7-12"><a href="#cb7-12"></a>                parcours(ladj, y, etat, parent)</span>
<span id="cb7-13"><a href="#cb7-13"></a>        etat[x] <span class="op">=</span> TRAITE</span>
<span id="cb7-14"><a href="#cb7-14"></a></span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="kw">def</span> arbre_parcours(ladj, x):</span>
<span id="cb7-16"><a href="#cb7-16"></a>    etat <span class="op">=</span> [ INCONNU ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb7-17"><a href="#cb7-17"></a>    parent <span class="op">=</span> [ <span class="va">None</span> ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb7-18"><a href="#cb7-18"></a>    etat[x] <span class="op">=</span> DECOUVERT</span>
<span id="cb7-19"><a href="#cb7-19"></a>    parcours(ladj, x, etat, parent)</span>
<span id="cb7-20"><a href="#cb7-20"></a>    <span class="cf">return</span> parent</span>
<span id="cb7-21"><a href="#cb7-21"></a></span>
<span id="cb7-22"><a href="#cb7-22"></a><span class="kw">def</span> chemin(parent, y):</span>
<span id="cb7-23"><a href="#cb7-23"></a>    <span class="co"># Renvoie le chemin x -&gt; ... -&gt; y</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>    <span class="co"># en sens inverse</span></span>
<span id="cb7-25"><a href="#cb7-25"></a>    p <span class="op">=</span> [ y ]</span>
<span id="cb7-26"><a href="#cb7-26"></a>    <span class="cf">while</span> parent[y] <span class="op">!=</span> <span class="va">None</span>:</span>
<span id="cb7-27"><a href="#cb7-27"></a>        y <span class="op">=</span> parent[y]</span>
<span id="cb7-28"><a href="#cb7-28"></a>        p.append(y)</span>
<span id="cb7-29"><a href="#cb7-29"></a>    <span class="cf">return</span> p</span></code></pre></div>
<p></div></p>
<h3 data-number="4.2.3" id="sec:composantes-connexes"><span
class="header-section-number">4.2.3</span> Composantes connexes</h3>
<p>On peut déduire directement du théorème précédent, le corollaire
suivant dans le cas non orienté :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Dans un graphe non orienté, les sommets traités depuis un parcours en
profondeur issu d’un sommet sont exactement les sommets de sa composante
connexe.</p>
</div>
<p>On en déduit alors un algorithme pour obtenir les composantes
connexes d’un graphe non orienté :</p>
<div class="ui message gray">
<div class="header">
Algorithme - Composantes connexes
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<p>Un graphe non orienté <span class="math inline">\(G =
(S,A)\)</span></p>
</div>
<ul>
<li>Tant qu’il y a des sommets non traités
<ul>
<li>On choisit un sommet non traité <span
class="math inline">\(x\)</span></li>
<li>On effectue un parcours récursif depuis <span
class="math inline">\(x\)</span></li>
<li>Tous les sommets traités par ce parcours forment une composante
connexe</li>
</ul></li>
</ul>
</div>
<p>On va en déduire le programme suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>INCONNU <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>DECOUVERT <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>TRAITE <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">def</span> parcours(ladj, x, etat, composante):</span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="cf">if</span> etat[x] <span class="op">!=</span> TRAITE:</span>
<span id="cb8-7"><a href="#cb8-7"></a>        composante.append(x)</span>
<span id="cb8-8"><a href="#cb8-8"></a>        <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb8-9"><a href="#cb8-9"></a>            <span class="cf">if</span> etat[y] <span class="op">==</span> INCONNU:</span>
<span id="cb8-10"><a href="#cb8-10"></a>                etat[y] <span class="op">=</span> DECOUVERT</span>
<span id="cb8-11"><a href="#cb8-11"></a>                parcours(ladj, y, etat, composante)</span>
<span id="cb8-12"><a href="#cb8-12"></a>        etat[x] <span class="op">=</span> TRAITE</span>
<span id="cb8-13"><a href="#cb8-13"></a></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="kw">def</span> composantes_connexes(ladj):</span>
<span id="cb8-15"><a href="#cb8-15"></a>    composantes <span class="op">=</span> []</span>
<span id="cb8-16"><a href="#cb8-16"></a>    etat <span class="op">=</span> [ INCONNU ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ladj)):</span>
<span id="cb8-18"><a href="#cb8-18"></a>        <span class="cf">if</span> etat[i] <span class="op">==</span> INCONNU:</span>
<span id="cb8-19"><a href="#cb8-19"></a>            composante <span class="op">=</span> [ ]</span>
<span id="cb8-20"><a href="#cb8-20"></a>            parcours(ladj, x, etat, composante)</span>
<span id="cb8-21"><a href="#cb8-21"></a>            composantes.append( composante )</span>
<span id="cb8-22"><a href="#cb8-22"></a>    <span class="cf">return</span> composantes</span></code></pre></div>
<p></div></p>
<h3 data-number="4.2.4" id="sec:détection-de-cycles"><span
class="header-section-number">4.2.4</span> Détection de cycles</h3>
<p>Si on est en train de traiter le sommet <span
class="math inline">\(x\)</span> et qu’on rencontre une arête <span
class="math inline">\(x \rightarrow y\)</span> où <span
class="math inline">\(y\)</span> est découvert mais non traité, c’est
qu’on est dans l’appel récursif de <span
class="math inline">\(y\)</span> et donc que <span
class="math inline">\(x\)</span> est un de ses descendants : <span
class="math inline">\(y \leadsto x\)</span> en rajoutant la nouvelle
arête <span class="math inline">\(y \leadsto x \rightarrow x\)</span> on
en déduit un cycle dans le cas d’un graphe orienté.</p>
<p>Pour un graphe non orienté représenté par un graphe orienté
symétrique, il faut faire attention à ne pas prendre un aller-retour
<span class="math inline">\(x \rightarrow y \rightarrow x\)</span> pour
un cyle. On demande donc à avoir la condition :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a>etat[y] <span class="op">==</span> DECOUVERT <span class="kw">and</span> parent[x] <span class="op">!=</span> y</span></code></pre></div>
<p></div></p>
<p>On en déduit le programme suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>INCONNU <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>DECOUVERT <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>TRAITE <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="kw">def</span> parcours(ladj, x, etat, parent, est_oriente):</span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="cf">if</span> etat[x] <span class="op">!=</span> TRAITE:</span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a>        <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb10-9"><a href="#cb10-9"></a>            <span class="cf">if</span> etat[y] <span class="op">==</span> INCONNU:</span>
<span id="cb10-10"><a href="#cb10-10"></a>                parent[y] <span class="op">=</span> x</span>
<span id="cb10-11"><a href="#cb10-11"></a>                etat[y] <span class="op">=</span> DECOUVERT</span>
<span id="cb10-12"><a href="#cb10-12"></a>                cycle <span class="op">=</span> parcours(ladj, y, etat, parent, est_oriente)</span>
<span id="cb10-13"><a href="#cb10-13"></a>                <span class="cf">if</span> cycle <span class="op">!=</span> <span class="va">None</span>:</span>
<span id="cb10-14"><a href="#cb10-14"></a>                    <span class="cf">return</span> cycle</span>
<span id="cb10-15"><a href="#cb10-15"></a>            <span class="cf">elif</span> etat[y] <span class="op">==</span> TRAITE <span class="kw">and</span> (est_oriente <span class="kw">or</span> parent[x] <span class="op">!=</span> y):</span>
<span id="cb10-16"><a href="#cb10-16"></a>                <span class="cf">return</span> chemin(parent, y)</span>
<span id="cb10-17"><a href="#cb10-17"></a></span>
<span id="cb10-18"><a href="#cb10-18"></a>        etat[x] <span class="op">=</span> TRAITE</span>
<span id="cb10-19"><a href="#cb10-19"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb10-20"><a href="#cb10-20"></a></span>
<span id="cb10-21"><a href="#cb10-21"></a><span class="kw">def</span> detecte_cycle(ladj, x, est_oriente):</span>
<span id="cb10-22"><a href="#cb10-22"></a>    etat <span class="op">=</span> [ INCONNU ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb10-23"><a href="#cb10-23"></a>    parent <span class="op">=</span> [ <span class="va">None</span> ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb10-24"><a href="#cb10-24"></a>    etat[x] <span class="op">=</span> DECOUVERT</span>
<span id="cb10-25"><a href="#cb10-25"></a>    cycle <span class="op">=</span> parcours(ladj, x, etat, parent, est_oriente)</span>
<span id="cb10-26"><a href="#cb10-26"></a>    <span class="cf">if</span> cycle <span class="op">!=</span> <span class="va">None</span>:</span>
<span id="cb10-27"><a href="#cb10-27"></a>        <span class="bu">print</span>(<span class="st">&#39;Cyclique : &#39;</span>, cycle)</span>
<span id="cb10-28"><a href="#cb10-28"></a>    <span class="cf">else</span>:</span>
<span id="cb10-29"><a href="#cb10-29"></a>        <span class="bu">print</span>(<span class="st">&#39;Acyclique&#39;</span>)</span></code></pre></div>
<p></div></p>
<h3 data-number="4.2.5" id="sec:classification-des-arêtes"><span
class="header-section-number">4.2.5</span> Classification des
arêtes</h3>
<p><div class="ui label">     MP2I<div class="detail">S2</div> </div><div class="ui label">     OI<div class="detail">Spé</div> </div></p>
<h3 data-number="4.2.6" id="sec:temps-dentrée-et-de-sortie"><span
class="header-section-number">4.2.6</span> Temps d’entrée et de
sortie</h3>
<p><div class="ui label">     MP2I<div class="detail">S2</div> </div><div class="ui label">     OI<div class="detail">Spé</div> </div></p>
<h2 data-number="4.3" id="sec:parcours-quelconque"><span
class="header-section-number">4.3</span> Parcours
<strong>quelconque</strong></h2>
<p>On va considérer ici que l’on dispose d’une structure de donnée
<code>sac</code> dans laquelle on peut placer des éléments et en sortir.
On considère aussi qu’on a une moyen de marquer les sommets. Par défaut,
ils sont non marqués.</p>
<p>On considère alors l’algorithme suivant decrit en pseudo-code et
auquel on fera référence comme étant le parcours
<strong>quelconque</strong> dans la suite :</p>
<div class="ui message gray">
<div class="header">
Algorithme - parcours quelconque
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe <span class="math inline">\(G = (S,A)\)</span></li>
<li>Un somme <span class="math inline">\(s \in S\)</span> source du
parcours</li>
</ul>
</div>
<ul>
<li>On crée un sac ne contenant que <span
class="math inline">\(s\)</span></li>
<li>Tant que le sac est non vide
<ul>
<li>On tire un sommet <span class="math inline">\(x\)</span> du sac</li>
<li>Si <span class="math inline">\(x\)</span> n’est pas marqué
<ul>
<li>On marque <span class="math inline">\(x\)</span></li>
<li>pour chaque <span class="math inline">\(x \rightarrow y \in
A\)</span>
<ul>
<li>On ajoute y dans le sac</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<p>On remarque que les somets marqués sont exactement les sommets
accessibles depuis <span class="math inline">\(s\)</span>, on retrouve
ainsi le théorème vu pour le parcours récursif.</p>
<p>En fait, le parcours quelconque ne permet pas de déduire plus
d’information que cela, mais dans un graphe non orienté c’est déjà
suffisant pour en déduire les composantes connexes.</p>
<p>La question qui se pose alors est celle de la stratégie
d’ajout/tirage dans le sac. Selon ce que l’on considère, l’ordre de
visite des sommets va changer. On va considérer trois stratégies :</p>
<ul>
<li>LIFO : Last In First Out, le prochain sommet tiré est le dernier
ajouté</li>
<li>FIFO : First In First Out, le prochain sommet tiré est le sommet le
plus anciennement ajouté</li>
<li>aléatoire : on tire aléatoirement et uniformément un sommet du
sac</li>
</ul>
<p><div class="ui message"><div class="header">Définition</div> Un sac
avec une stratégie LIFO est appelé une <strong>pile</strong>.</p>
<p>Un sac avec une stratégie FIFO est appelé une <strong>file</strong>.
</div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on considère le graphe suivant :</p>
<p><img src="assets/pics/quelex.png" /></p>
<p>En effectuant un parcours quelconque issu de <span
class="math inline">\(a\)</span> :</p>
<ul>
<li>en stratégie LIFO, on va voir les sommets dans l’ordre <span
class="math inline">\(a, b, e, c, f, d, g\)</span>.</li>
<li>en stratégie FIFO, on va voir les sommets dans l’ordre <span
class="math inline">\(a, b, c, d, e, f, g\)</span></li>
<li>en stratégie aléatoire, on pourrait avoir <span
class="math inline">\(a, b, c, e, d, f, g\)</span></li>
</ul>
</div>
<p>Une manière de <em>voir</em> ces trois différentes stratégies est de
considérer une grille et de colorer les sommets marqués avec une couleur
changeant à chaque marquage. On peut voir dans l’ordre LIFO, FIFO,
aléatoire l’effet de ces trois stratégies en partant du même point sur
l’animation suivante :</p>
<p><img src="assets/pics/flood_fill_sac3.gif" /></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>La stratégie LIFO semble <em>bornée</em> : elle choisit un cap et
elle s’y tient tant que c’est possible. La stratégie FIFO va elle
s’étendre comme une onde partant du point de départ. De manière assez
étonnante, la stratégie aléatoire semble être une bonne approximation de
la stratégie FIFO, ce qui montre le caractère exceptionnel du LIFO.</p>
<p></div></p>
<p>Le parcours quelconque en stratégie FIFO s’appelle un <em>parcours en
largeur</em>. Comme on va le voir, le parcours avec stratégie LIFO est
exactement le <em>parcours en profondeur</em> précédent.</p>
<h3 data-number="4.3.1" id="sec:implémentation-en-python"><span
class="header-section-number">4.3.1</span> Implémentation en
<code>Python</code></h3>
<p><div class="ui label">     ITC<div class="detail">Sup</div> </div></p>
<p>On va supposer qu’on dispose de quatre fonctions manipulant des sacs
:</p>
<ul>
<li><code>sac_vide()</code> qui renvoie un nouveau sac vide</li>
<li><code>ajoute(sac, x)</code> qui ajoute <code>x</code> dans le sac
<code>sac</code></li>
<li><code>retire(sac)</code> qui retire un élément du sac
<code>sac</code> et le renvoie</li>
<li><code>est_vide(sac)</code> qui renvoie un booléen indiquant si le
<code>sac</code> est vide</li>
</ul>
<p>Le programme du parcours quelconque s’écrit alors</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">def</span> parcours_sac(ladj, source):</span>
<span id="cb11-2"><a href="#cb11-2"></a>    a_traiter <span class="op">=</span> sac_vide()</span>
<span id="cb11-3"><a href="#cb11-3"></a>    ajoute(a_traiter, source)</span>
<span id="cb11-4"><a href="#cb11-4"></a>    marque <span class="op">=</span> [ <span class="va">False</span> ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="cf">while</span> <span class="kw">not</span> est_vide(a_traiter):</span>
<span id="cb11-7"><a href="#cb11-7"></a>        x <span class="op">=</span> retire(a_traiter)</span>
<span id="cb11-8"><a href="#cb11-8"></a>        <span class="cf">if</span> <span class="kw">not</span> marque[x]:</span>
<span id="cb11-9"><a href="#cb11-9"></a>            marque[x] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>            <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb11-11"><a href="#cb11-11"></a>                ajoute(a_traiter, y)</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Pour utiliser ce parcours, on peut rajouter des instructions au
moment où on marque un sommet ou au moment où on traite une arête.</p>
<p></div></p>
<p>Pour implémenter un sac, on va d’abord utiliser le type
<code>list</code> de <code>Python</code> :</p>
<ul>
<li>Pour créer un sac vide, on utilise la valeur <code>[]</code> :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">def</span> sac_vide():</span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="cf">return</span> []</span></code></pre></div>
<p></div></p>
<ul>
<li>Pour tester si le sac est vide, on utilise donc le test à
<code>[]</code> :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">def</span> est_vide(sac):</span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="cf">return</span> sac <span class="op">==</span> []</span></code></pre></div>
<p></div></p>
<ul>
<li>Pour ajouter un élément <code>x</code> dans le sac <code>s</code>
dans tous les cas :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">def</span> ajoute(sac, x):</span>
<span id="cb14-2"><a href="#cb14-2"></a>    sac.append(x)</span></code></pre></div>
<p></div></p>
<ul>
<li>(FIFO) Pour retirer le dernier élément ajouté, on peut utiliser
directement <code>pop</code> :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">def</span> retire(sac):</span>
<span id="cb15-2"><a href="#cb15-2"></a>    <span class="cf">return</span> sac.pop()</span></code></pre></div>
<p></div> * (LIFO) Pour retirer l’élément le plus anciennement ajouté,
on peut utiliser la fonction de suppression <code>del l[0]</code> qui
retire le premier élément</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">def</span> retire(sac):</span>
<span id="cb16-2"><a href="#cb16-2"></a>    x <span class="op">=</span> sac[<span class="dv">0</span>]</span>
<span id="cb16-3"><a href="#cb16-3"></a>    <span class="kw">del</span> sac[<span class="dv">0</span>]</span>
<span id="cb16-4"><a href="#cb16-4"></a>    <span class="cf">return</span> x</span></code></pre></div>
<p></div></p>
<ul>
<li>C’est anecdotique, mais pour retirer un élément au hasard, il faut
choisir un indice <code>i</code>, renvoyer l’élément qui s’y trouve en
le supprimant du sac avec <code>del s[i]</code> :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="im">from</span> random <span class="im">import</span> randint</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">def</span> retire(sac):</span>
<span id="cb17-3"><a href="#cb17-3"></a>    i <span class="op">=</span> randint(<span class="bu">len</span>(sac))</span>
<span id="cb17-4"><a href="#cb17-4"></a>    x <span class="op">=</span> sac[i]</span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="kw">del</span> sac[i]</span>
<span id="cb17-6"><a href="#cb17-6"></a>    <span class="cf">return</span> x</span></code></pre></div>
<p></div></p>
<p>Si on peut supposer que les quatre premières opérations sont en temps
constant, les deux dernières sont linéaire en le nombre de sommets dans
le sac. Ce qui est assez coûteux.</p>
<p>En effet, le parcours quelconque va accéder en pire cas à chaque
sommet et à chaque liste d’adjacence et ajouter chaque sommet dans le
sac. Donc, une complexité en <span class="math inline">\(O(|S| + |A| +
|S| f(|S|))\)</span> où <span class="math inline">\(f(n)\)</span> est la
complexité du retrait dans un sac de taille <span
class="math inline">\(n\)</span>.</p>
<p>On obtient donc <span class="math inline">\(O(|S| + |A|)\)</span> en
LIFO mais <span class="math inline">\(O(|S|^2)\)</span> en FIFO car
<span class="math inline">\(|A| = O(|S|^2)\)</span> vu que <span
class="math inline">\(A \subset S^2\)</span>.</p>
<p>En <code>Python</code>, il est possible d’avoir une file
(<code>queue</code> en anglais) permettant de réaliser le retrait FIFO
en <span class="math inline">\(O(1)\)</span> :</p>
<ul>
<li>On importe le type <code>deque</code> :
<code>from collections import deque</code></li>
<li>On crée une file vide avec <code>s = deque()</code></li>
<li>On ajoute un élément <code>x</code> avec
<code>s.append(x)</code></li>
<li>Mais on dispose d’un fonction efficace <code>s.popleft()</code> pour
retirer le premier élément.</li>
</ul>
<p>En fait, on dispose également d’un <code>appendleft</code> et du
<code>pop</code>. Toutes ces opérations étant en <span
class="math inline">\(O(1)\)</span>.</p>
<p>Dans l’implémentation précédente, il suffit donc de remplacer les
deux fonctions suivantes :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">def</span> sac_vide():</span>
<span id="cb18-2"><a href="#cb18-2"></a>    <span class="cf">return</span> deque()</span>
<span id="cb18-3"><a href="#cb18-3"></a></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="kw">def</span> est_vide(sac):</span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="cf">return</span> <span class="bu">len</span>(sac) <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb18-6"><a href="#cb18-6"></a></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="kw">def</span> ajoute(sac, x):</span>
<span id="cb18-8"><a href="#cb18-8"></a>    sac.append(x)</span>
<span id="cb18-9"><a href="#cb18-9"></a></span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="kw">def</span> retire(sac):</span>
<span id="cb18-11"><a href="#cb18-11"></a>    <span class="cf">return</span> sac.popleft()</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p><div class="ui label">     OI<div class="detail">Sup</div> </div></p>
<p>La structure de donnée <code>deque</code> est une liste doublement
chaînée. Elle permet de remonter dans la chaîne d’un maillon vers le
maillon dont il est le suivant.</p>
<p></div></p>
<p>En pratique, on pourra définir des fonctions de parcours utilisant
directement les bonnes structures :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">def</span> parcours_profondeur(ladj, source):</span>
<span id="cb19-2"><a href="#cb19-2"></a>    a_traiter <span class="op">=</span> [ source ]</span>
<span id="cb19-3"><a href="#cb19-3"></a>    marque <span class="op">=</span> [ <span class="va">False</span> ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb19-4"><a href="#cb19-4"></a></span>
<span id="cb19-5"><a href="#cb19-5"></a>    <span class="cf">while</span> a_traiter <span class="op">!=</span> []</span>
<span id="cb19-6"><a href="#cb19-6"></a>        x <span class="op">=</span> a_traiter.pop()</span>
<span id="cb19-7"><a href="#cb19-7"></a>        <span class="cf">if</span> <span class="kw">not</span> marque[x]:</span>
<span id="cb19-8"><a href="#cb19-8"></a>            marque[x] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb19-9"><a href="#cb19-9"></a>            <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb19-10"><a href="#cb19-10"></a>                a_traiter.append(y)</span>
<span id="cb19-11"><a href="#cb19-11"></a></span>
<span id="cb19-12"><a href="#cb19-12"></a><span class="co"># à placer en début du programme :</span></span>
<span id="cb19-13"><a href="#cb19-13"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb19-14"><a href="#cb19-14"></a></span>
<span id="cb19-15"><a href="#cb19-15"></a><span class="kw">def</span> parcours_largeur(ladj, source):</span>
<span id="cb19-16"><a href="#cb19-16"></a>    a_traiter <span class="op">=</span> deque([ source ])</span>
<span id="cb19-17"><a href="#cb19-17"></a>    marque <span class="op">=</span> [ <span class="va">False</span> ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb19-18"><a href="#cb19-18"></a></span>
<span id="cb19-19"><a href="#cb19-19"></a>    <span class="cf">while</span> <span class="bu">len</span>(a_traiter) <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb19-20"><a href="#cb19-20"></a>        x <span class="op">=</span> a_traiter.popleft()</span>
<span id="cb19-21"><a href="#cb19-21"></a>        <span class="cf">if</span> <span class="kw">not</span> marque[x]:</span>
<span id="cb19-22"><a href="#cb19-22"></a>            marque[x] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb19-23"><a href="#cb19-23"></a>            <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb19-24"><a href="#cb19-24"></a>                a_traiter.append(y)</span></code></pre></div>
<p></div></p>
<h2 data-number="4.4" id="sec:parcours-en-largeur"><span
class="header-section-number">4.4</span> Parcours en largeur</h2>
<p>On va vu que le parcours quelconque en FIFO s’appelait le parcours en
largeur. Il permet de parcourir les sommets d’un graphe en rayonnant à
partir du sommet source. En effet on traite d’abord :</p>
<ul>
<li>le sommet source <span class="math inline">\(src\)</span></li>
<li>les voisins de <span class="math inline">\(src\)</span></li>
<li>les voisins des voisins de <span
class="math inline">\(src\)</span></li>
<li><span class="math inline">\(\dots\)</span></li>
</ul>
<p>Pour pouvoir parler de chemins, il est nécessaire d’introduire une
notion de parenté. Pour cela, on a deux possibilités.</p>
<ul>
<li>Soit on n’ajoute plus des sommets dans le sac mais des couples
(sommet, parent) qui correspondent a une arête de découverte :</li>
</ul>
<div class="ui message gray">
<div class="header">
Algorithme - parcours quelconque avec couples
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe <span class="math inline">\(G = (S,A)\)</span></li>
<li>Un somme <span class="math inline">\(s \in S\)</span> source du
parcours</li>
</ul>
</div>
<ul>
<li>On crée un sac ne contenant que <span class="math inline">\((s,
s)\)</span></li>
<li>Tant que le sac est non vide
<ul>
<li>On tire un couple <span class="math inline">\((x, p)\)</span> du sac
<ul>
<li>Si <span class="math inline">\(x\)</span> est non marqué
<ul>
<li>On indique que <span class="math inline">\(parent[x] =
p\)</span></li>
<li>pour chaque <span class="math inline">\(x \rightarrow y \in
A\)</span>
<ul>
<li>On ajoute <span class="math inline">\((y, x)\)</span> dans le
sac</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<ul>
<li>Soit on modifie le parcours <em>quelconque</em> pour en déduire un
parcours quelconque qui a l’air a priori d’être <em>optimisé</em>.</li>
</ul>
<div class="ui message gray">
<div class="header">
Algorithme - parcours quelconque <em>optimisé</em>
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe <span class="math inline">\(G = (S,A)\)</span></li>
<li>Un somme <span class="math inline">\(s \in S\)</span> source du
parcours</li>
</ul>
</div>
<ul>
<li>On crée un sac ne contenant que <span
class="math inline">\(s\)</span></li>
<li>Tant que le sac est non vide
<ul>
<li>On tire un sommet <span class="math inline">\(x\)</span> du sac
<ul>
<li>pour chaque <span class="math inline">\(x \rightarrow y \in
A\)</span>
<ul>
<li>Si <span class="math inline">\(y\)</span> est non marqué
<ul>
<li>On indique que <span class="math inline">\(parent[y] =
x\)</span></li>
<li>On ajoute y dans le sac</li>
<li>On marque <span class="math inline">\(y\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On va reprendre l’exemple précédent</p>
<p><img src="assets/pics/quelex.png" /></p>
<p>On obtient avec un parcours en largeur le schéma suivant :</p>
<p><img src="assets/pics/quelexlargeur.png" /></p>
<p>où on a noté les arêtes de parenté ainsi que d’une même couleur les
éléments à égale distance de <span class="math inline">\(a\)</span> dans
le parcours en largeur.</p>
<p>On remarque qu’on a obtenu le chemin <span class="math inline">\(a
\rightarrow c \rightarrow f\)</span> là où un parcours en profondeur
aurait pu donner le chemin plus long <span class="math inline">\(a
\rightarrow d \rightarrow g \rightarrow f\)</span>.</p>
</div>
<p>Comme semble le suggérer l’exemple précédent, on peut démontrer le
théorème suivant :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Les chemins donnés par un parcours en largeur depuis <span
class="math inline">\(x\)</span> sont de plus petite longueur :</p>
<p>Si <span class="math inline">\(\varphi : x\leadsto y\)</span> est
donné par le parcours, alors <span class="math inline">\(\forall \psi :
x \leadsto y\)</span>, <span class="math inline">\(|\psi| \ge
|\varphi|\)</span>.</p>
</div>
<h3 data-number="4.4.1" id="sec:preuve"><span
class="header-section-number">4.4.1</span> Preuve</h3>
<p><div class="ui label">     OI<div class="detail">Spé</div> </div><div class="ui label">     MP2I<div class="detail">S2</div> </div></p>
<h2 data-number="4.5" id="sec:pseudo-parcours-en-profondeur"><span
class="header-section-number">4.5</span> Pseudo-parcours en
profondeur</h2>
<p>On peut se poser la question de la nature du parcours quelconque
optimisé effectué avec une stratégie LIFO. Naïvement, on peut penser
qu’il s’agit d’un parcours en profondeur. Cependant, si on considère le
graphe :</p>
<p><img src="assets/pics/pseudoprof1.png" /></p>
<p>On va avoir les deux arbres différents suivants :</p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>Avec un parcours en profondeur :</p>
<p><img src="assets/pics/pseudoprof2.png" /></p>
<p></div><div class="eight wide column"></p>
<p>Avec un pseudo-parcours en profondeur :</p>
<p><img src="assets/pics/pseudoprof3.png" /></p>
<p></div></div></div></p>
<p>On perd une propriété fondamentale du parcours en profondeur qui est
de qu’un parent ne peut empecher un de ses enfants de découvrir un
sommet. Ici, dans le pseudo-parours, <span
class="math inline">\(a\)</span> bloque la découverte de <span
class="math inline">\(c\)</span> par <span
class="math inline">\(b\)</span>.</p>
<div class="ui message orange">
<div class="header">
Exercice
</div>
<p>Montrer qu’il n’existe aucune stratégie permettant au parcours
quelconque <em>optimisé</em> d’être un parcours en profondeur.</p>
</div>
<h1 data-number="5" id="sec:tri-topologique"><span
class="header-section-number">5</span> Tri topologique</h1>
<p>Un cas très important de graphes orientés est celui de graphes de
dépendances :</p>
<ul>
<li>les sommets sont des tâches à réaliser</li>
<li>Une arête <span class="math inline">\(x \rightarrow y\)</span>
indique la tâche <span class="math inline">\(x\)</span> doit être
réalisée avant la tâche <span class="math inline">\(y\)</span>.</li>
</ul>
<p>Citons, par exemple, les dépendances entre chapitres dans un cours,
entre unités de programme lors d’une compilation, entre produits dans un
procédé industriel…</p>
<p>Ces graphes ont tous la particularité d’être orienté et acycliques.
En effet, si on a un cycle, cela signifie qu’il y a une dépendance
inextricable.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On parle en anglais de <strong>DAG</strong> pour <em>directed acyclic
graph</em>.</p>
<p></div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(G = (S, A)\)</span> un graphe orienté
acyclique. Une énumération <span class="math inline">\((x_1, \dots,
x_n)\)</span> des sommets de <span class="math inline">\(S\)</span> est
appelée un <strong>tri topologique</strong> lorsque pour toute arête
<span class="math inline">\(x_i \rightarrow x_j\)</span> on a <span
class="math inline">\(i &lt; j\)</span>. </div></p>
<p>Autrement dit, un tri topologique est un ordre linéaire de traitement
des tâches respectant les dépendances.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(G\)</span> un graphe orienté
acyclique et <span class="math inline">\(x_1, \dots, x_p\)</span> les
sommets de degré entrant nuls de <span
class="math inline">\(G\)</span>.</p>
<p>Si on effectue plusieurs parcours en profondeur récursifs depuis
chacun des <span class="math inline">\(x_i\)</span> avec la même
horloge, alors les sommets triés dans l’ordre décroissant des temps de
sortie constituent un un tri topologique de <span
class="math inline">\(G\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Il suffit de vérifier que si <span
class="math inline">\(x \rightarrow y\)</span> n’est pas une arête
arrière, alors <span class="math inline">\(t_s(x) \ge t_s(y)\)</span> où
<span class="math inline">\(t_s(x)\)</span> est le temps de sortie de
<span class="math inline">\(x\)</span>. </div> </div></p>
<h1 data-number="6" id="sec:plus-courts-chemins"><span
class="header-section-number">6</span> Plus courts chemins</h1>
<h2 data-number="6.1"
id="sec:graphes-pondérés-et-définition-du-problème"><span
class="header-section-number">6.1</span> Graphes pondérés et définition
du problème</h2>
<p><div class="ui message"><div class="header">Définition</div> Un
graphe pondéré est la donnée d’un graphe, orienté ou non, <span
class="math inline">\(G = (S,A)\)</span> et d’une fonction de
pondération <span class="math inline">\(\pi : A \rightarrow \R\)</span>
qui associe à chaque arête un nombre réel, son poids. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>En informatique pratique, <span class="math inline">\(\R\)</span>
n’existe pas vraiment. Les poids seront donc le plus souvent des entiers
ou des flottants. Cependant, les problèmes possiblement rencontrés par
des poids réels sont pertinents et le cadre unifié rend les définitions
plus simples.</p>
<p></div></p>
<p><div class="ui message"><div class="header">Définition</div> On
définit le poids d’un chemin <span
class="math inline">\(\varphi\)</span> comme la somme des poids de ses
arêtes. </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Dans le graphe suivant : <center><div class="ui image center"><img
src="assets/pics/poids_ex1.png" /></div></center></p>
<p>le chemin <span class="math inline">\(\varphi = c \rightarrow b
\rightarrow d \rightarrow a\)</span> est de poids <span
class="math inline">\(\pi(\varphi) = 0 - 1 -1 = -2\)</span>.</p>
<p>On remarque que <span class="math inline">\(b \rightarrow d
\rightarrow a \rightarrow b\)</span> est un cycle de poids <span
class="math inline">\(-1\)</span>, on peut donc l’emprunter autant de
fois qu’on le souhaite sur un chemin passant par <span
class="math inline">\(a,b\)</span> ou <span
class="math inline">\(d\)</span> et faire diminuer son poids autant
qu’on le souhaite. On parle de cycle de poids négatif et leur présence
est problématique.</p>
</div>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Si <span class="math inline">\(G\)</span> est un graphe pondéré
<strong>sans cycles de poids négatif</strong>, <span
class="math inline">\(\varphi\)</span> est un chemin et <span
class="math inline">\(\psi\)</span> est un sous-chemin de <span
class="math inline">\(\varphi\)</span> obtenu en enlevant un cycle,
alors <span class="math inline">\(\pi(\varphi) \ge
\pi(\psi)\)</span>.</p>
</div>
<p>Du théorème précédent, on en déduit que pour obtenir un chemin de
poids minimum, on peut supposer que le chemin est élémentaire. Or, comme
il existe un nombre fini de chemins élémentaires entre deux sommets, on
peut en déduire la définition suivante :</p>
<p><div class="ui message"><div class="header">Définition</div> Soit
<span class="math inline">\(G = (S,A,\pi)\)</span> un graphe pondéré
<strong>sans cycles de poids négatifs</strong> et <span
class="math inline">\(x, y \in S\)</span> tels que <span
class="math inline">\(x \leadsto y\)</span>, on appelle plus court
chemin de <span class="math inline">\(x\)</span> à <span
class="math inline">\(y\)</span>, un chemin <span
class="math inline">\(\varphi : x \leadsto y\)</span> tel que <span
class="math display">\[
\pi(\varphi) = \min \enscomp{\pi(\psi)}{\psi : x \leadsto y}
\]</span> </div></p>
<p>Il est possible de travailer avec la complétion d’un graphe pondéré
en considérant toutes les arêtes possibles mais en spécifiant que si
<span class="math inline">\(x \rightarrow y\)</span> n’est pas une arête
du graphe initial, alors <span class="math inline">\(\pi(x \rightarrow
y) = \infty\)</span>. On peut alors poser pour tout couple <span
class="math inline">\((x,y) \in S\)</span>, <span
class="math inline">\(dist(x,y) = \min \enscomp{\pi(\psi)}{\psi : x
\leadsto y}\)</span> sachant que cette distance vaut <span
class="math inline">\(\infty\)</span> lorsque <span
class="math inline">\(y\)</span> n’est pas accessible depuis <span
class="math inline">\(x\)</span>.</p>
<p>On va s’intéresser à deux problèmes :</p>
<div class="ui message gray">
<div class="header">
Problème - PlusCourtCheminSource
</div>
<ul>
<li>
<p>Entrée(s) :</p>
<ul>
<li>Un graphe pondéré <span class="math inline">\(G =
(S,A,\pi)\)</span></li>
<li>Un sommet source <span class="math inline">\(s \in S\)</span></li>
</ul>
</li>
<li>
<p>Sortie :</p>
<ul>
<li>La donnée pour chaque <span class="math inline">\(x \in S\)</span>,
de la valeur <span class="math inline">\(dist(s,x)\)</span>.</li>
<li>Éventuellement, un chemin <span class="math inline">\(\varphi : s
\leadsto x\)</span> réalisant cette distance.</li>
</ul>
</li>
</ul>
</div>
<div class="ui message gray">
<div class="header">
Problème - PlusCourtCheminToutCouple
</div>
<ul>
<li>
<p>Entrée(s) :</p>
<ul>
<li>Un graphe pondéré <span class="math inline">\(G =
(S,A,\pi)\)</span></li>
</ul>
</li>
<li>
<p>Sortie :</p>
<ul>
<li>La donnée pour chaque couple <span class="math inline">\(x, y \in
S\)</span>, de la valeur <span
class="math inline">\(dist(x,y)\)</span>.</li>
<li>Éventuellement, un chemin <span class="math inline">\(\varphi : x
\leadsto y\)</span> réalisant cette distance.</li>
</ul>
</li>
</ul>
</div>
<p>Le premier problème est naturellement inclus dans le second.</p>
<h2 data-number="6.2" id="sec:cas-des-poids-rationnels"><span
class="header-section-number">6.2</span> Cas des poids rationnels</h2>
<p><div class="ui label">     MP2I<div class="detail">S2</div> </div></p>
<p>Il se trouve qu’on a déjà trouvé un algorithme permettant de résoudre
le problème quand <span class="math inline">\(\forall e \in A, \pi(e) =
1\)</span> : le <strong>parcours en largeur</strong>.</p>
<p>Si les poids sont dans <span class="math inline">\(\Q_+^*\)</span>,
on peut se ramener à des poids dans <span
class="math inline">\(\N^*\)</span> en multipliant chaque poids par le
ppcm des dénominateurs des poids. Cela ne change pas la relation d’ordre
entre les poids de chemins, et on peut donc les plus courts chemins sont
les mains.</p>
<p>Si <span class="math inline">\(\pi(x \rightarrow y) = k &gt;
1\)</span>, on peut rajouter <span class="math inline">\(k-1\)</span>
sommets artificiels <span class="math inline">\(z_1, \dots,
z_{k-1}\)</span> et des arêtes de poids unitaire <span
class="math inline">\(x \rightarrow z_1 \rightarrow z_2 \rightarrow
\dots \rightarrow z_k\)</span> à la place de l’arête <span
class="math inline">\(x \rightarrow y\)</span>. En procédant ainsi, on
se ramène donc à un graphe dont les poids sont unitaires et on peut
résoudre le problème avec un parcours en largeur.</p>
<p>Si on considère que la longueur des poids en mémoire fait partie de
l’entrée, alors cette réduction a l’air très coûteuse, mais si on
considère qu’ils sont constants en espace, alors toute cette réduction
ne fait que grossir la constante du <span
class="math inline">\(O(|S|+|A|)\)</span> !</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On pourrait être tenté de supprimer les poids négatifs en ajoutant
une constante à chaque poids, cependant, en faisant cela, on pénalise
les chemins en fonction de leur longueur et on ne préserve pas la notion
de plus court chemin.</p>
<p>Considérons par exemple le graphe :</p>
<p><img src="assets/pics/poidsneg_cex1.png" /></p>
<p>Le chemin le plus court entre <span class="math inline">\(a\)</span>
et <span class="math inline">\(c\)</span> est de poids <span
class="math inline">\(2\)</span> et est le chemin <span
class="math inline">\(a \rightarrow b \rightarrow c\)</span>.</p>
<p>Si on ajoute 5 à chaque poids pour qu’ils soient <span
class="math inline">\(&gt;0\)</span>, on obtient le graphe :</p>
<p><img src="assets/pics/poidsneg_cex2.png" /></p>
<p>Et ici, le chemin le plus court devient <span class="math inline">\(a
\rightarrow c\)</span> de poids <span class="math inline">\(9\)</span>
et non plus <span class="math inline">\(a \rightarrow b \rightarrow
c\)</span> qui devient de poids <span
class="math inline">\(10\)</span>.</p>
<p>Plus généralement, si on ajoute <span
class="math inline">\(\eta\)</span> à chaque poids, alors le poids de
<span class="math inline">\(\varphi\)</span> devient <span
class="math inline">\(\pi(\varphi) + \eta |\varphi|\)</span> qui n’est
pas croissante sur les chemins ordonnés par poids.</p>
<p></div></p>
<h2 data-number="6.3" id="sec:algorithme-de-dijkstra"><span
class="header-section-number">6.3</span> Algorithme de Dijkstra</h2>
<p><div class="ui label">     ITC<div class="detail">Sup</div> </div><div class="ui label">     MP2I<div class="detail">S2</div> </div></p>
<p>On se concentre ici sur le problème
<code>PlusCourtCheminSource</code> dans le cas de poids positifs.</p>
<p>Si <span class="math inline">\(G = (S,A,\pi)\)</span> est un graphe
pondéré et <span class="math inline">\(s \in S\)</span>, on considère un
étiquettage <span class="math inline">\(d : S \rightarrow \R \cup \{
\infty \}\)</span> qu’on va faire évoluer dans un algorithme et tel que
<span class="math inline">\(d(x)\)</span> représente le plus petit poids
trouvé jusqu’ici d’un chemin entre <span
class="math inline">\(s\)</span> et <span
class="math inline">\(x\)</span>. En l’absence de cycle négatif, on sait
qu’un tel chemin peut être supposé élémentaire.</p>
<p>Au départ, on pose <span class="math inline">\(d(s) = 0\)</span> et
<span class="math inline">\(\forall x \in S \backslash \{ s \}, d(x) =
\infty\)</span>.</p>
<p>L’idée est d’emprunter les raccourcis, c’est-à-dire les arêtes <span
class="math inline">\(y \rightarrow x\)</span> telles que <span
class="math inline">\(d(y) + \pi(y \rightarrow x) &lt; d(x)\)</span>
:</p>
<p><center><div class="ui image center"><img
src="assets/pics/dijkstra_expl.png" /></div></center></p>
<div class="ui message gray">
<div class="header">
Algorithme - Dijkstra
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe pondéré <span class="math inline">\(G = (S,A,\pi)\)</span>
où <span class="math inline">\(\pi : A \rightarrow \R_+\)</span></li>
<li>Un sommet <span class="math inline">\(s \in S\)</span></li>
</ul>
</div>
<ul>
<li>On crée un tableau <code>d</code> avec <span
class="math inline">\(d(s) = 0\)</span> et <span
class="math inline">\(d(x) = \infty\)</span> pour <span
class="math inline">\(x \neq s\)</span>.</li>
<li>On crée un tableau <code>a_traiter</code> et on ajoute
<code>s</code></li>
<li>Les sommets sont initialement non marqués</li>
<li>Tant que <code>a_traiter</code> est non vide
<ul>
<li>On retire le sommet <code>x</code> de <code>a_traiter</code> de
valeur <span class="math inline">\(d(x)\)</span>
<strong>minimale</strong></li>
<li>Si <code>x</code> est non marqué
<ul>
<li>On marque <code>x</code></li>
<li>Pour chaque arête <span class="math inline">\(x \rightarrow
y\)</span> où <span class="math inline">\(d(x) + \pi(x \rightarrow y)
&lt; d(y)\)</span>
<ul>
<li>On pose <span class="math inline">\(d(y) = d(x) + \pi(x \rightarrow
y)\)</span></li>
<li>On ajoute <span class="math inline">\(y\)</span> dans
<code>a_traiter</code></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On considère le graphe suivant pour <span class="math inline">\(s =
1\)</span> où les sommets dans <code>a_traiter</code> sont indiqués en
rouge, les sommets marqués sont indiqués en vert et où la valeur de
<span class="math inline">\(d\)</span> est donné dans le cadre à côté du
sommet :</p>
<p><img src="assets/pics/dijkstra_ex1_.png" /></p>
<p>On commence par retirer 1 qui est seul dans <code>a_traiter</code>
avec <span class="math inline">\(d(1) = 0\)</span>. On peut alors
ajouter les sommets <span class="math inline">\(6, 3\)</span> et <span
class="math inline">\(9\)</span> :</p>
<p><img src="assets/pics/dijkstra_ex2_.png" /></p>
<p>On retire alors le sommet 2 qui a la plus petite valeur de <span
class="math inline">\(d\)</span>. L’arête <span class="math inline">\(2
\rightarrow 15\)</span> vérifie la condition mais pas l’arête <span
class="math inline">\(2 \rightarrow 3\)</span>. On ajoute donc 4 dans
les sommets à traiter :</p>
<p><img src="assets/pics/dijkstra_ex3_.png" /></p>
<p>On retire alors 3 et on voit que les deux arêtes <span
class="math inline">\(3 \rightarrow 6\)</span> et <span
class="math inline">\(3 \rightarrow 4\)</span> permettent d’améliorer
<span class="math inline">\(d\)</span>. On rajoute donc <span
class="math inline">\(4\)</span> et <span
class="math inline">\(6\)</span> dans <code>a_traiter</code> :</p>
<p><img src="assets/pics/dijkstra_ex4_.png" /></p>
<p>On retire alors le sommet 6 qui permet d’emprunter <span
class="math inline">\(6 \rightarrow 5\)</span> et qui rajoute ainsi 5 à
<code>a_traiter</code> :</p>
<p><img src="assets/pics/dijkstra_ex5_.png" /></p>
<p>On traite les deux derniers sommets en les retirant.</p>
<p><img src="assets/pics/dijkstra_ex6_.png" /></p>
</div>
<p>Cet algorithme est un parcours quelconque où la stratégie de sortie
du sac est de retirer le sommet de plus petite valeur de <span
class="math inline">\(d\)</span>. On sait donc déjà qu’il termine et
qu’il explore <span class="math inline">\(acc(s) = \enscomp{ x \in S }{
s \leadsto x }\)</span>.</p>
<p>Comme on ne modifie <span class="math inline">\(d\)</span> que pour
mettre des nombres <span class="math inline">\(\neq \infty\)</span>, on
est assuré qu’à la fin de l’algorithme les sommets dans <span
class="math inline">\(acc(s)\)</span> ont une valeur dans <span
class="math inline">\(\R_+\)</span> dans le tableau <span
class="math inline">\(d\)</span> et que les autres ont <span
class="math inline">\(\infty\)</span>. La force de l’algorithme de
Dijkstra découle du contenu final de <span
class="math inline">\(d\)</span> qui répond à la question voulue :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>A la fin de l’algorithme, si <span class="math inline">\(s \leadsto
x\)</span>, <span class="math inline">\(d(x) = dist(s, x)\)</span>.</p>
</div>
<p>On peut implémenter directement cet algorithme :</p>
<p><div>   <div class="ui top attached tabular menu code">   <a class="active item" data-tab="ocaml-323">ocaml</a>   <a class="item" data-tab="c-323">c</a>   <a class="item" data-tab="python-323">python</a> </div> <div class="ui bottom attached active tab segment code" data-tab="ocaml-323"></p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> extrait_plus_petit l d =</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; <span class="dt">failwith</span> <span class="st">&quot;impossible&quot;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    | [x] -&gt; (x, [])</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    | x::q -&gt;</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (y, q&#39;) = extrait_plus_petit q d <span class="kw">in</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> d.(y) &lt; d.(x)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> (y, x :: q&#39;)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> (x, q)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> dijkstra g src =</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length g <span class="kw">in</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> inf = <span class="dt">max_int</span> <span class="kw">in</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> d = <span class="dt">Array</span>.make n inf <span class="kw">in</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    d.(src) &lt;- <span class="dv">0</span>;</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> marques = <span class="dt">Array</span>.make n <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a_traiter = <span class="dt">ref</span> [ src ] <span class="kw">in</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> !a_traiter &lt;&gt; [] <span class="kw">do</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x, q = extrait_plus_petit !a_traiter d <span class="kw">in</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>        a_traiter := q;</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="dt">not</span> marques.(x)</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>            marques.(x) &lt;- <span class="kw">true</span>;</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>            <span class="dt">List</span>.iter (<span class="kw">fun</span> (y, poids) -&gt;</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> n_d = d.(x) + poids <span class="kw">in</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>                <span class="kw">if</span> n_d &lt; d.(y)</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>                    d.(y) &lt;- n_d;</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>                    a_traiter := y :: !a_traiter</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>                <span class="kw">end</span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>            ) g.(x)</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>    d</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="c-323"></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>ERROR<span class="op">:</span> src<span class="op">/</span>structuresdonnees<span class="op">/../../</span>snippets<span class="op">/</span>structures<span class="op">/</span>dijkstra<span class="op">.</span>c does not exist</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="python-323"></p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extrait_plus_petit(t, d):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> t[<span class="dv">0</span>] <span class="co"># recherche du d[x] min dans t</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> t[<span class="dv">1</span>:]:</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> d[i] <span class="op">&lt;</span> d[x]:</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> i</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    t.remove(x) <span class="co"># on le retire</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="co"># on le renvoie</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dijkstra(g, src):</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(g)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    inf <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> [ inf ] <span class="op">*</span> n</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    d[src] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    a_traiter <span class="op">=</span> [ src ]</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    marques <span class="op">=</span> [ <span class="va">False</span> ] <span class="op">*</span> n</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> a_traiter <span class="op">!=</span> []:</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> extrait_plus_petit(a_traiter, d)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> marques[x]:</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>            marques[x] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> y, poids <span class="kw">in</span> g[x]:</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>                n_d <span class="op">=</span> d[x] <span class="op">+</span> poids</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> n_d <span class="op">&lt;</span> d[y]:</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>                    d[y] <span class="op">=</span> n_d</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>                    a_traiter.append(y)</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d <span class="co"># distandes finales</span></span></code></pre></div>
<p></div> </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>La complexité de la recherche sommet de valeur <span
class="math inline">\(d\)</span> minimale est en pire cas en <span
class="math inline">\(O(|S|)\)</span> comme on ajoute autant de sommets
que d’arêtes en pire cas, on a une complexité totale en <span
class="math inline">\(O(|S| \times |V|)\)</span>.</p>
<p></div></p>
<h3 data-number="6.3.1" id="sec:utilisation-dune-file-de-priorité"><span
class="header-section-number">6.3.1</span> Utilisation d’une file de
priorité</h3>
<p><div class="ui label">     MP2I<div class="detail">S2</div> </div><div class="ui label">     OI<div class="detail">Spé</div> </div></p>
<p>On peut améliorer l’algorithme précédent avec une <strong>file de
priorité</strong> où la priorité de <span
class="math inline">\(x\)</span> est <span
class="math inline">\(d(x)\)</span> et où on suppose qu’on extrait la
priorité minimale. Cela permet ainsi d’obtenir une complexité en <span
class="math inline">\(O(|A| \log |S|)\)</span>.</p>
<p>Cependant, il est alors nécessaire de modifier la priorité ce qui est
une opération assez pénible. A la place, on peut ajouter une autre fois
le sommet. Au pire, on fera grossir la file (qui reste de longueur <span
class="math inline">\(O(|A|)\)</span>) et quand on retirera un sommet
déjà traité, celui-ci sera ignoré.</p>
<p>On obtient ainsi l’algorithme suivant :</p>
<div class="ui message gray">
<div class="header">
Algorithme - Dijkstra
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe pondéré <span class="math inline">\(G = (S,A,\pi)\)</span>
où <span class="math inline">\(\pi : A \rightarrow \R_+\)</span></li>
<li>Un sommet <span class="math inline">\(s \in S\)</span></li>
</ul>
</div>
<ul>
<li>On crée un tableau <code>d</code> avec <span
class="math inline">\(d(s) = 0\)</span> et <span
class="math inline">\(d(x) = \infty\)</span> pour <span
class="math inline">\(x \neq s\)</span>.</li>
<li>On crée une file de min-priorité <code>a_traiter</code> et on ajoute
<code>s</code> avec priorité <code>0</code></li>
<li>Les sommets sont initialement non marqués</li>
<li>Tant que <code>a_traiter</code> est non vide
<ul>
<li>On retire le sommet <code>x</code> de <code>a_traiter</code></li>
<li>Si <code>x</code> est non marqué
<ul>
<li>On marque <code>x</code></li>
<li>Pour chaque arête <span class="math inline">\(x \rightarrow
y\)</span> où <span class="math inline">\(d(x) + \pi(x \rightarrow y)
&lt; d(y)\)</span>
<ul>
<li>On pose <span class="math inline">\(d(y) = d(x) + \pi(x \rightarrow
y)\)</span></li>
<li>On insère <span class="math inline">\(y\)</span> avec priorité <span
class="math inline">\(d(y)\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<h2 data-number="6.4" id="sec:relaxation"><span
class="header-section-number">6.4</span> Relaxation</h2>
<p><div class="ui label">     MP2I<div class="detail">S2</div> </div></p>
<p>Pour montrer la correction de Dijkstra et le lien avec la présence
d’arêtes positives, on va présenter ici un cadre plus général.</p>
<h3 data-number="6.4.1" id="sec:arêtes-tendues"><span
class="header-section-number">6.4.1</span> Arêtes tendues</h3>
<p><div class="ui message"><div class="header">Définition</div> On dit
qu’une arête <span class="math inline">\(x \rightarrow y\)</span> est
<strong>tendue</strong> si <span class="math display">\[d(y) &gt; d(x) +
\pi(x \rightarrow y)\]</span></p>
<p>Quand on pose ensuite <span class="math inline">\(d(y) = d(x) + \pi(x
\rightarrow y)\)</span> on dit qu’on <strong>relâche l’arête</strong>.
</div></p>
<p>Ainsi, une arête est tendue quand on peut l’emprunter pour améliorer
l’estimation du plus petit chemin de <span
class="math inline">\(s\)</span> à <span
class="math inline">\(y\)</span>.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Si aucune arête n’est tendue, alors <span class="math inline">\(d(x)
= dist(s, x)\)</span> (avec <span class="math inline">\(=\infty\)</span>
si inaccessible).</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i>
Preuve </div> <div class="content"> Par l’absurde, considérons <span
class="math inline">\(x\)</span> tel que <span
class="math inline">\(d(x) &gt; dist(s,x)\)</span> où <span
class="math inline">\(dist(s, x)\)</span> est minimale parmi les
contre-exemples, alors <span class="math inline">\(s \leadsto x\)</span>
et soit <span class="math inline">\(\varphi\)</span> un chemin de
longueur minimale.</p>
<p>Soit <span class="math inline">\(y\)</span> le prédécesseur de <span
class="math inline">\(x\)</span> dans ce chemin, on a donc un chemin
<span class="math inline">\(\varphi = \psi y \rightarrow x_0\)</span> où
<span class="math inline">\(\psi : s \leadsto y\)</span>.
Nécessairement, le chemin <span class="math inline">\(\psi\)</span> et
minimal car restriction d’un chemin minimal. Donc, son poids est <span
class="math inline">\(\pi(\psi) = dist(s, y) = d(y)\)</span> par
hypothèse de minimalité de <span class="math inline">\(x\)</span>.</p>
<p>On a alors <span class="math inline">\(dist(s, x) = d(y) + \pi(y
\rightarrow x) &lt; d(x)\)</span>. L’arête <span class="math inline">\(y
\rightarrow x\)</span> est donc tendue.</p>
<p>Contradiction. </div> </div></p>
<p>On en deduit un pseudo-algorithme appelé <em>méthode de
relaxation</em> :</p>
<div class="ui message gray">
<div class="header">
Algorithme - Relaxation
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe pondéré <span class="math inline">\(G = (S,A,\pi)\)</span>
sans cycle de poids négatif</li>
<li>Un sommet <span class="math inline">\(s \in S\)</span></li>
</ul>
</div>
<ul>
<li>On pose <span class="math inline">\(d\)</span> tel que <span
class="math inline">\(d(s) = 0\)</span> et <span
class="math inline">\(\forall x \in S \backslash \{ s \}, d(x) =
\infty\)</span>.</li>
<li>Tant qu’il existe une arête <span class="math inline">\(e\)</span>
tendue
<ul>
<li>On relâche l’arête <span class="math inline">\(e\)</span></li>
</ul></li>
</ul>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<ul>
<li><p>On montre par récurrence sur le nombre d’itérations que si <span
class="math inline">\(d(x) &lt; \infty\)</span> alors <span
class="math inline">\(d(x)\)</span> est le poids d’un chemin simple de
<span class="math inline">\(s\)</span> à <span
class="math inline">\(x\)</span>. Comme ces chemins simples sont en
nombre finis, leur poids aussi et donc <span
class="math inline">\(d\)</span> ne peut prendre qu’un nombre fini de
valeurs, comme <span class="math inline">\(d\)</span> change à chaque
itération, la boucle termine.</p></li>
<li><p>En présence d’un cycle négatif, on pourrait continuellement
relacher les arêtes du cycle et donc l’algorithme ne termine
pas.</p></li>
<li><p>En sortie de l’algorithme on a donc <span
class="math inline">\(dist(s,x) \le dist(s,y) + \pi(y\rightarrow
x)\)</span> pour toute arête <span class="math inline">\(y \rightarrow
x\)</span>. Or, on a l’égalité pour un plus court chemin. On en déduit
donc l’égalité <strong>très importante</strong> suivante :</p>
<p><span class="math display">\[
\forall x \in S \backslash \{ s \},
dist(s, x) = \min\enscomp{ dist(s,y) + \pi(y \rightarrow x) }{y \in S}
\]</span></p>
<p>En fait, si on considère l’opération <span
class="math inline">\(\Phi\)</span> définie par :</p>
<p><span class="math display">\[
\forall x \in S \backslash\{s\},
\Phi(d)(x) = \min
\enscomp{ d(y) + \pi(y \rightarrow x) }{y \in S}
\]</span></p>
<p>On remarque que <span class="math inline">\(x \mapsto dist(s,
x)\)</span> est un point fixe de <span
class="math inline">\(\Phi\)</span>.</p>
<p>On pourrait ainsi le calculer comme la limite de la suite
stationnaire <span class="math inline">\(d_{n+1} = \Phi(d_n)\)</span> où
<span class="math inline">\(d_0(s) = 0\)</span> et <span
class="math inline">\(\forall x \neq s, d_0(x) =
\infty\)</span>.</p></li>
</ul>
<p>Si on considère le graphe <center><div class="ui image center"><img
src="assets/pics/dijkstra_ex1__.png" /></div></center> et que l’on
représente la suite <span class="math inline">\(d\)</span> sous une
forme de tableau on obtient :</p>
<p><span class="math display">\[
\begin{array}{c|cccccc}
n  &amp;d_n(1) &amp; d_n(2) &amp; d_n(3)
&amp;d_n(4) &amp; d_n(5) &amp; d_n(6) \\
\hline
0 &amp; 0 &amp; \infty &amp; \infty &amp; \infty &amp; \infty &amp;
\infty  \\
1 &amp; 0 &amp; 7 &amp; 9 &amp; \infty &amp; \infty  &amp; 14\\
2 &amp; 0 &amp; 7 &amp; 9 &amp; 20 &amp; 23  &amp; 11 \\
3 &amp; 0 &amp; 7 &amp; 9 &amp; 20 &amp; 20  &amp; 11 \\
4 &amp; 0 &amp; 7 &amp; 9 &amp; 20 &amp; 20  &amp; 11 \\
...
\end{array}
\]</span> On peut montrer qu’en l’absence de cycles négatifs, on
converge en moins de <span class="math inline">\(|S|-1\)</span> étapes
car à chaque étape on rajoute un sommet dans un chemin simple réalisé
par l’estimation. L’algorithme obtenu s’appelle l’algorithme de
<strong>Bellman-Ford</strong>.</p>
<p></div></p>
<h3 data-number="6.4.2"
id="sec:algorithme-de-dijkstra-comme-relaxation"><span
class="header-section-number">6.4.2</span> Algorithme de Dijkstra comme
relaxation</h3>
<p>Quand on retire un sommet <span class="math inline">\(x\)</span> de
la file, si <span class="math inline">\(e = x \rightarrow y\)</span>
alors soit l’arête est non tendue et alors <span
class="math inline">\(d(y) \le d(x) + \pi(x \rightarrow y)\)</span> et
par hypothèse cela signifie qu’on a un chemin simple de poids <span
class="math inline">\(d(y)\)</span> qui est meilleur que de passer par
<span class="math inline">\(x\)</span>. Cela signifie notamment que
<span class="math inline">\(y\)</span> a déjà été traité à un moment par
l’algorithme. Soit l’arête est tendue et passer par <span
class="math inline">\(x\)</span> améliore le chemin vers <span
class="math inline">\(y\)</span>. On relâche l’arête. On a alors deux
possibilités : soit <span class="math inline">\(y\)</span> est dans la
file, et on change sa priorité soit on l’insère dans la file.</p>
<p>En procédant ainsi, on obtient un algorithme qui implémente le
pseudo-algorithme précédent :</p>
<div class="ui message gray">
<div class="header">
Algorithme - ProtoDijkstra
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe pondéré <span class="math inline">\(G = (S,A,\pi)\)</span>
sans cycle négatif</li>
<li>Un sommet <span class="math inline">\(s \in S\)</span></li>
</ul>
</div>
<ul>
<li>On crée un tableau <code>d</code> avec <span
class="math inline">\(d(s) = 0\)</span> et <span
class="math inline">\(d(x) = \infty\)</span> pour <span
class="math inline">\(x \neq s\)</span>.</li>
<li>On crée une file de min-priorité <code>a_traiter</code> et on ajoute
<code>s</code> avec priorité <code>0</code></li>
<li>Tant que <code>a_traiter</code> est non vide
<ul>
<li>On retire le sommet <code>x</code> de <code>a_traiter</code></li>
<li>Pour chaque arête <span class="math inline">\(x \rightarrow
y\)</span> tendue vis-à-vis de <span class="math inline">\(d\)</span>
<ul>
<li>On relâche l’arête dans <span class="math inline">\(d\)</span></li>
<li>Si <span class="math inline">\(y\)</span> est dans
<code>a_traiter</code>
<ul>
<li>Alors, on remplace sa priorité par la nouvelle valeur de <span
class="math inline">\(d(y)\)</span></li>
<li>Sinon, on insère <span class="math inline">\(y\)</span> avec
priorité <span class="math inline">\(d(y)\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>L’exemple suivant permet d’observer l’algorithme sur un graphe
comportant des poids négatifs. On a indiqué en rouge les sommets sur la
file et en rose le sommet actuellement traité. Les arêtes de parentés
sont présentées comme dans l’exemple précédent à mesure qu’elles sont
modifiées.</p>
<p>On va ainsi partir du graphe suivant et du sommet source <span
class="math inline">\(a\)</span> :
<center><div class="ui image center"><img
src="assets/pics/dijkstra_neg_depart.png" /></div></center></p>
<p><img src="assets/pics/dijkstra_neg0.png" /> <img
src="assets/pics/dijkstra_neg1.png" /> <img
src="assets/pics/dijkstra_neg2.png" /></p>
<p><img src="assets/pics/dijkstra_neg3.png" /> <img
src="assets/pics/dijkstra_neg4.png" /> <img
src="assets/pics/dijkstra_neg5.png" /></p>
<p><img src="assets/pics/dijkstra_neg6.png" /> <img
src="assets/pics/dijkstra_neg7.png" /> <img
src="assets/pics/dijkstra_neg8.png" /></p>
<p><img src="assets/pics/dijkstra_neg9.png" /> <img
src="assets/pics/dijkstra_neg10.png" /> <img
src="assets/pics/dijkstra_neg11.png" /></p>
<p><img src="assets/pics/dijkstra_neg12.png" /> <img
src="assets/pics/dijkstra_neg13.png" /></p>
</div>
<p>Contrairement à cet exemple, on constate, comme on l’a fait dans le
paragraphe précédent, qu’avec des poids positifs l’algorithme
particulièrement bien et d’une manière assez proche du parcours en
largeur. Notamment, un sommet n’est placé qu’une fois sur la file de
priorité. On constate donc une vague de traitement qui progresse
linéairement sur le graphe.</p>
<p>On peut donc se permettre de ne pas avoir à implémenter l’opération
assez pénible de mise à jour de la priorité.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Cette opération n’est pas vraiment compliquée en raison du tas car il
suffit de changer la valeur et de faire remonter l’élèment le long de sa
branche en direction de la racine en cas d’inversion de priorité. Le
problème est qu’on a besoin de préserver un lien entre les sommets et
leur emplacement dans le tas afin de savoir où est le nœud qui le
contient. Le plus simple est de rajouter un dictionnaire, par exemple
avec une table de hachage, mais cela alourdit conséquemment
l’implémentation du tas car il faut maintenir l’intégrité du
dictionnaire.</p>
<p></div></p>
<p>A la place, on va ajouter un sommet avec une autre priorité,
meilleure, et il sera ainsi retiré avant. Pour ne pas traiter deux fois
un sommet, on adopte alors une notion de marquage comme dans les
parcours précédents. On en déduit l’algorithme de Dijkstra :</p>
<h2 data-number="6.5" id="sec:floyd-warshall"><span
class="header-section-number">6.5</span> Floyd-Warshall</h2>
<p>Pour résoudre le problème PlusCourtCheminToutCouple dans le cas d’un
graphe orienté, l’algorithme de Floyd-Warshall va considérer une
énumération <span class="math inline">\(x_1, \dots, x_n\)</span> des
sommets du graphe et construire une famille de matrices <span
class="math inline">\(dist^{(k)}\)</span> où <span
class="math inline">\(dist^{(k)}(i, j)\)</span> indique le poids d’un
plus court chemin de <span class="math inline">\(i\)</span> à <span
class="math inline">\(j\)</span> <strong>dont les sommets
intermédiaires</strong> sont dans <span class="math inline">\(x_1,
\dots, x_k\)</span> lorsqu’un tel chemin existe, et <span
class="math inline">\(\infty\)</span> sinon.</p>
<p>On a donc <span class="math inline">\(dist^{(0)}(x, y) =
\begin{cases} 0 \text{ si } x = y \\ \pi(x \rightarrow y) \text{ si } x
\rightarrow y \in A \\ \infty \text{ sinon} \end{cases}\)</span>.</p>
<p>On remarque rapidement, <strong>en l’absence de cycle
négatif</strong>, que ces matrices vérifient l’égalité, pour <span
class="math inline">\(k &gt; 0\)</span> :</p>
<p><span class="math display">\[
dist^{(k)}(i,j) = \min\left(
dist^{(k-1)}(i,j), dist^{(k-1)}(i,k) + dist^{(k-1)}(k,j)
\right)
\]</span> En effet, un plus court chemin étant nécessairement
élémentaire, soit il ne passe pas par <span
class="math inline">\(k\)</span>, soit il passe exactement une fois par
<span class="math inline">\(k\)</span>.</p>
<p>On en déduit un algorithme consistant à calculer ces <span
class="math inline">\(n+1\)</span> matrices et les calculer avec trois
boucles for imbriquées.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on considère le graphe <center><div class="ui image center"><img
src="assets/pics/fw_neg.png" /></div></center> On va avoir la suite de
matrices suivantes, dans l’ordre d’énumération alphabétique des sommets
:</p>
<p><span class="math display">\[
dist^{(0)} = \begin{pmatrix}
0&amp;\infty&amp;-2&amp;\infty\\
4&amp;0&amp;\infty&amp;\infty\\
\infty&amp;\infty&amp;0&amp;2\\
\infty&amp;-1&amp;\infty&amp;0\\
\end{pmatrix}
\]</span> <span class="math display">\[
dist^{(1)} = \begin{pmatrix}
0&amp;\infty&amp;-2&amp;\infty\\
4&amp;0&amp;2&amp;\infty\\
\infty&amp;\infty&amp;0&amp;2\\
\infty&amp;-1&amp;\infty&amp;0\\
\end{pmatrix}
\]</span> <span class="math display">\[
dist^{(2)} = \begin{pmatrix}
0&amp;\infty&amp;-2&amp;\infty\\
4&amp;0&amp;2&amp;\infty\\
\infty&amp;\infty&amp;0&amp;2\\
3&amp;-1&amp;1&amp;0\\
\end{pmatrix}
\]</span> <span class="math display">\[
dist^{(3)} = \begin{pmatrix}
0&amp;\infty&amp;-2&amp;0\\
4&amp;0&amp;2&amp;4\\
\infty&amp;\infty&amp;0&amp;2\\
3&amp;-1&amp;1&amp;0\\
\end{pmatrix}
\]</span> <span class="math display">\[
dist^{(4)} = \begin{pmatrix}
0&amp;-1&amp;-2&amp;0\\
4&amp;0&amp;2&amp;4\\
5&amp;1&amp;0&amp;2\\
3&amp;-1&amp;1&amp;0\\
\end{pmatrix}
\]</span></p>
</div>
<p>Une première version consisterait à calculer les matrices ce qui
prend <span class="math inline">\(O(|S|^3)\)</span> espaces. On peut
optimiser cela avec une paire de matrices qui changent de rôle, mais on
peut faire mieux. En effet, on a <span
class="math inline">\(d^{(k)}(i,k) = d^{(k-1)}(i,k)\)</span> car le
chemin associé est élémentaire et il ne peut passer qu’une fois par
<span class="math inline">\(k\)</span>. De même, pour <span
class="math inline">\(d^{(k-1)}(k,j)\)</span>. On en déduit donc qu’on
peut effectuer le calcul <em>en place</em> dans une seule matrice. On
obtient alors l’algorithme suivant :</p>
<div class="ui message gray">
<div class="header">
Algorithme - Floyd-Warshall
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe pondéré <span class="math inline">\(G = (S,A,\pi)\)</span>
et une énumération <span class="math inline">\(x_1, \dots, x_n\)</span>
de <span class="math inline">\(S\)</span></li>
</ul>
</div>
<ul>
<li>On initialise une matrice <span class="math inline">\(d\)</span>
telle que <span class="math inline">\(d(i,j) = \pi(i\rightarrow
j)\)</span> si <span class="math inline">\(i \rightarrow j \in
A\)</span> et <span class="math inline">\(= \infty\)</span> sinon</li>
<li>Pour k allant de 1 à n
<ul>
<li>Pour i allant de 1 à n
<ul>
<li>Pour j allant de 1 à n
<ul>
<li><span class="math inline">\(d(i,j) = \min(d(i,j),
d(i,k)+d(k,j))\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<p>La matrice renvoyée vérifie ainsi <span class="math inline">\(d(i,j)
= dist(x_i,x_j)\)</span>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il est aussi possible d’imposer que les plus courts chemins soient de
longueur au moins 1, ce qui va mettre des <span
class="math inline">\(\infty\)</span> sur la diagonale dans <span
class="math inline">\(dist^{(0)}\)</span> et qui permettra, en fin
d’algorithme d’en déduire la présence de cycle ainsi que le poids d’un
poids plus court cycle issu de <span class="math inline">\(i\)</span>
dans <span class="math inline">\(d(i,i)\)</span>.</p>
<p></div></p>
<p>Il y a de nombreux contextes dans lesquels la détermination d’une
matrice des plus petits poids est suffisante. Cependant, si on a
également besoin des chemins eux-mêmes, il est possible de construire
une matrice de parenté <span class="math inline">\(P\)</span> où <span
class="math inline">\(P_{ij}\)</span> indique le prédécesseur de <span
class="math inline">\(j\)</span> dans un plus court chemin de <span
class="math inline">\(i\)</span> à <span
class="math inline">\(j\)</span>. On utilisera le symbole <span
class="math inline">\(\perp\)</span> quand un tel chemin n’existe
pas.</p>
<p>Pour calculer <span class="math inline">\(P\)</span> il suffit
d’adapter l’algorithme précédent en considérant les <span
class="math inline">\(P^{(k)}\)</span> et en posant :</p>
<p><span class="math display">\[
P^{(0)}_{ij} = \begin{cases}
i &amp; \text{ si } i \rightarrow j \in A \\
\perp &amp; \text{ sinon }
\end{cases}
\]</span></p>
<p>Puis, <span class="math display">\[
\text{Pour } k \ge 1,
P^{(k)}_{ij} = \begin{cases}
P^{(k-1)}_{ij} &amp; \text{ si } d^{(k)}_{ij} = d^{(k-1)}_{ij} \\
P^{(k-1)}_{kj} &amp; \text{ sinon }
\end{cases}
\]</span></p>
<p>Ce qui revient à changer le prédécesseur selon la résolution du <span
class="math inline">\(\min\)</span>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<ul>
<li>En appliquant Floyd-Warshall a un graphe quelconque, on peut
détecter la présence de cycles de poids négatifs. En effet, si un tel
cycle existe, on aura nécessairement <span class="math inline">\(d(i,i)
&lt; 0\)</span> à la fin.</li>
<li>Floyd-Warshall a une application importante dans le cas du calcul de
la fermeture transitive d’un graphe. En effet, il suffit de considérer
la matrice d’adjacence au départ et d’appliquer Floyd-Warshall pour en
déduire la matrice d’adjacence de la fermeture transitive où les arêtes
sont en plus pondérés par la longueur du chemin qui le réalise.</li>
</ul>
<p></div></p>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
