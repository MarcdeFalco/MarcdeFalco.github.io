<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Graphes</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

.ui.styled.accordion {
    width: 100% !important;
    font-size: 1rem !important;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\gO{\mathcal{O}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Graphes
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:graphes-orientés"><span>1</span> Graphes orientés</a><div class="menu"><a class="item" href="#sec:définition"><div class="ui label">1.1</div> Définition</a><a class="item" href="#sec:voisins-et-degrés"><div class="ui label">1.2</div> Voisins et degrés</a><a class="item" href="#sec:chemin"><div class="ui label">1.3</div> Chemin</a><a class="item" href="#sec:sous-graphe"><div class="ui label">1.4</div> Sous-graphe</a><a class="item" href="#sec:implémentation"><div class="ui label">1.5</div> Implémentation</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:énumération-de-sommets"><i class="circle icon"></i> Énumération de sommets</a><a style="font-size:0.6em" class="item" href="#sec:matrice-dadjacence"><i class="circle icon"></i> Matrice d’adjacence</a><a style="font-size:0.6em" class="item" href="#sec:listes-dadjacences"><i class="circle icon"></i> Listes d’adjacences</a><a style="font-size:0.6em" class="item" href="#sec:comparaison"><i class="circle icon"></i> Comparaison</a></div></div></div><div class="item header"> <a href="#sec:graphes-non-orientés"><span>2</span> Graphes non orientés</a><div class="menu"><a class="item" href="#sec:graphes_symetrises"><div class="ui label">2.1</div> Définition et adaptation du vocabulaire</a><a class="item" href="#sec:connexité"><div class="ui label">2.2</div> Connexité</a><a class="item" href="#sec:graphe-acyclique-connexe"><div class="ui label">2.3</div> Graphe acyclique connexe</a><a class="item" href="#sec:graphe-biparti"><div class="ui label">2.4</div> Graphe biparti</a></div></div><div class="item header"> <a href="#sec:graphes-classiques"><span>3</span> Graphes classiques</a><div class="menu"><a class="item" href="#sec:graphes-complets"><div class="ui label">3.1</div> Graphes complets</a><a class="item" href="#sec:cycles"><div class="ui label">3.2</div> Cycles</a><a class="item" href="#sec:grilles-et-hypercubes"><div class="ui label">3.3</div> Grilles et hypercubes</a></div></div><div class="item header"> <a href="#sec:parcours"><span>4</span> Parcours</a><div class="menu"><a class="item" href="#sec:principe"><div class="ui label">4.1</div> Principe</a><a class="item" href="#sec:parcours-en-profondeur-récursif"><div class="ui label">4.2</div> Parcours en profondeur récursif</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:première-version"><i class="circle icon"></i> Première version</a><a style="font-size:0.6em" class="item" href="#sec:arbre-de-parcours"><i class="circle icon"></i> Arbre de parcours</a><a style="font-size:0.6em" class="item" href="#sec:composantes-connexes"><i class="circle icon"></i> Composantes connexes</a><a style="font-size:0.6em" class="item" href="#sec:détection-de-cycles"><i class="circle icon"></i> Détection de cycles</a><a style="font-size:0.6em" class="item" href="#sec:classification-des-arêtes"><i class="circle icon"></i> Classification des arêtes</a><a style="font-size:0.6em" class="item" href="#sec:temps-dentrée-et-de-sortie"><i class="circle icon"></i> Temps d’entrée et de sortie</a></div><a class="item" href="#sec:parcours-quelconque"><div class="ui label">4.3</div> Parcours <strong>quelconque</strong></a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:implémentation-en-python"><i class="circle icon"></i> Implémentation en <code>Python</code></a></div><a class="item" href="#sec:parcours-en-largeur"><div class="ui label">4.4</div> Parcours en largeur</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:preuve"><i class="circle icon"></i> Preuve</a></div><a class="item" href="#sec:pseudo-parcours-en-profondeur"><div class="ui label">4.5</div> Pseudo-parcours en profondeur</a></div></div><div class="item header"> <a href="#sec:tri-topologique"><span>5</span> Tri topologique</a><div class="menu"></div></div><div class="item header"> <a href="#sec:plus-courts-chemins"><span>6</span> Plus courts chemins</a><div class="menu"><a class="item" href="#sec:graphes-pondérés-et-définition-du-problème"><div class="ui label">6.1</div> Graphes pondérés et définition du problème</a><a class="item" href="#sec:cas-des-poids-rationnels"><div class="ui label">6.2</div> Cas des poids rationnels</a><a class="item" href="#sec:relaxation"><div class="ui label">6.3</div> Relaxation</a><a class="item" href="#sec:algorithme-de-dijkstra"><div class="ui label">6.4</div> Algorithme de Dijkstra</a><a class="item" href="#sec:floyd-warshall"><div class="ui label">6.5</div> Floyd-Warshall</a></div></div><div class="item header"> <a href="#sec:travaux-pratiques"><span>7</span> Travaux Pratiques</a><div class="menu"><a class="item" href="#sec:parcours-de-graphes-en-c"><div class="ui label">7.1</div> Parcours de graphes en <code>C</code></a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:représentation"><i class="circle icon"></i> Représentation</a><a style="font-size:0.6em" class="item" href="#sec:parcours-en-profondeur-récursif-1"><i class="circle icon"></i> Parcours en profondeur récursif</a><a style="font-size:0.6em" class="item" href="#sec:temps-et-classification-des-arêtes"><i class="circle icon"></i> Temps et classification des arêtes</a><a style="font-size:0.6em" class="item" href="#sec:parcours-avec-une-structure"><i class="circle icon"></i> Parcours avec une structure</a></div><a class="item" href="#sec:étude-dun-graphe-issu-dun-réseau-social"><div class="ui label">7.2</div> Étude d’un graphe issu d’un réseau social</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:définition-et-lecture-du-graphe"><i class="circle icon"></i> Définition et lecture du graphe</a><a style="font-size:0.6em" class="item" href="#sec:statistiques-sur-les-degrés"><i class="circle icon"></i> Statistiques sur les degrés</a><a style="font-size:0.6em" class="item" href="#sec:parcours-en-largeur-1"><i class="circle icon"></i> Parcours en largeur</a><a style="font-size:0.6em" class="item" href="#sec:plus-long-chemin-et-diametre"><i class="circle icon"></i> Plus long chemin et diametre</a><a style="font-size:0.6em" class="item" href="#sec:table-de-résultats"><i class="circle icon"></i> Table de résultats</a><a style="font-size:0.6em" class="item" href="#sec:aller-plus-loin"><i class="circle icon"></i> Aller plus loin</a></div><a class="item" href="#sec:plus-courts-chemins-en-ocaml"><div class="ui label">7.3</div> Plus courts chemins en <code>OCaml</code></a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:écriture-naïve-de-dijkstra"><i class="circle icon"></i> Écriture naïve de Dijkstra</a><a style="font-size:0.6em" class="item" href="#sec:réalisation-dune-file-de-min-priorité"><i class="circle icon"></i> Réalisation d’une file de min-priorité</a><a style="font-size:0.6em" class="item" href="#sec:écriture-de-dijkstra-efficace"><i class="circle icon"></i> Écriture de Dijkstra efficace</a><a style="font-size:0.6em" class="item" href="#sec:floys-warshall"><i class="circle icon"></i> Floys-Warshall</a><a style="font-size:0.6em" class="item" href="#sec:problèmes"><i class="circle icon"></i> Problèmes</a></div></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Graphes
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Graphes     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_graphe.jpg"> </div></p>
<p><div class="ui message blue"><div class="header">Note</div></p>
<p>Une grande partie est issue verbatim de mon ancien poly. À affiner.</p>
<p></div></p>
<h1 data-number="1" id="sec:graphes-orientés"><span class="header-section-number">1</span> Graphes orientés</h1>
<h2 data-number="1.1" id="sec:définition"><span class="header-section-number">1.1</span> Définition</h2>
<p><div class="ui message"><div class="header">Définition</div> Un graphe orienté est un couple <span class="math inline">\(G = (S, A)\)</span> où <span class="math inline">\(S\)</span> est un ensemble fini et <span class="math inline">\(A\)</span> est une relation <strong>irréflexive</strong> sur <span class="math inline">\(S\)</span>, c’est-à-dire <span class="math inline">\(A \subset \{ (x,y) ~|~ x,y \in S, x \neq y\}\)</span>.</p>
<p>Les éléments de <span class="math inline">\(S\)</span> sont appelés les <strong>sommets</strong> du graphe <span class="math inline">\(G\)</span> et les éléments de <span class="math inline">\(A\)</span> les <strong>arêtes</strong>. Si <span class="math inline">\((x,y) \in A\)</span>, on dit que <span class="math inline">\(x\)</span> est la source de l’arête et <span class="math inline">\(y\)</span> est son but. Quand le contexte n’est pas ambigu, on notera <span class="math inline">\(x \rightarrow y\)</span>. </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li><span class="math inline">\(G = ( \{ a, b, c \}, \{ (a, b), (b, c), (c, b) \} )\)</span></li>
<li><span class="math inline">\(D_n = ( \range{1}{n}, \{ (a,b) ~|~ a \text{ divise } b, a \neq b \} )\)</span></li>
</ul>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Ici, on a exclu les graphes infinis ainsi que les graphes avec des boucles ou des arêtes parallèles. On est dans le contexte des <strong>graphes finis simples</strong>.</p>
<p></div></p>
<p>On représente graphiquement un graphe sous la forme d’un diagramme sagittaire où les sommets sont des points et où une arêtes <span class="math inline">\((a,b)\)</span> est une flèche allant du point <span class="math inline">\(a\)</span> au point <span class="math inline">\(b\)</span>.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li><p><span class="math inline">\(G\)</span> est représenté par <center><div class="ui image center"><img src="assets/pics/graphe_g_rep.png" /></div></center></p></li>
<li><p><span class="math inline">\(D_{10}\)</span> est représenté par <center><div class="ui image center"><img src="assets/pics/graphe_d10_rep.png" /></div></center></p></li>
</ul>
</div>
<h2 data-number="1.2" id="sec:voisins-et-degrés"><span class="header-section-number">1.2</span> Voisins et degrés</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G = (S, A)\)</span> un graphe orienté et <span class="math inline">\(x \in S\)</span>.</p>
<p>On appelle <strong>voisins sortants</strong>, ou <strong>successeurs</strong>, de <span class="math inline">\(x\)</span> les éléments de <span class="math display">\[
v_+(x) = \enscomp{y \in S}{(x,y) \in A}
\]</span> et on appelle <strong>degré sortant</strong> de <span class="math inline">\(x\)</span> le cardinal de cet ensemble <span class="math inline">\(d_+(x) = |v_+(x)|\)</span>.</p>
<p>De même, on parle de <strong>voisins entrants</strong>, ou <strong>prédéceseurs</strong> pour les éléments de <span class="math display">\[
v_-(x) = \enscomp{z \in S}{(z,x) \in A}
\]</span> et on parle de <strong>degré entrant</strong> pour <span class="math inline">\(d_-(x) = |v_-(x)|\)</span>. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(G = (S, A)\)</span> un graphe, on a <span class="math inline">\(\sum_{x \in S} d_+(x) = \sum_{x \in S} d_-(x) = |A|\)</span></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> On peut partitionner <span class="math inline">\(A\)</span> en regroupant les arêtes de même source, on a ainsi :</p>
<p><span class="math display">\[
A = \bigcup_{x \in S} \enscomp{(x,y)}{y \in S, (x,y) \in A}
= \bigcup_{x \in S} \enscomp{(x,y)}{y \in v_+(x)}
\]</span></p>
<p>Et en prenant la cardinal de cette égalité, on obtient directement <span class="math inline">\(|A| = \sum_{x \in S} d_+(x)\)</span>. L’autre égalité est symétrique en considérant les arêtes de même but. </div> </div></p>
<h2 data-number="1.3" id="sec:chemin"><span class="header-section-number">1.3</span> Chemin</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G = (S,A)\)</span> un graphe orienté et <span class="math inline">\(x, y \in S\)</span>.</p>
<p>Une suite finie <span class="math inline">\(\varphi = (s_0, s_1, \dots, s_p)\)</span> où <span class="math inline">\(p \in \N, s_0 = x, s_p = y\)</span> et <span class="math display">\[
\forall i \in \range{1}{p}, (s_{i-1},s_i) \in A
\]</span> est appelée un <strong>chemin</strong>, de longueur <span class="math inline">\(p\)</span>, de <span class="math inline">\(x\)</span> vers <span class="math inline">\(y\)</span>. On a donc <span class="math display">\[
s_0 \rightarrow s_1 \rightarrow \dots \rightarrow s_p
\]</span></p>
<p>On notera <span class="math inline">\(\varphi : x \leadsto y\)</span> pour signifier que <span class="math inline">\(\varphi\)</span> est un tel chemin et <span class="math inline">\(x \leadsto y\)</span> pour signifier qu’il existe un chemin de <span class="math inline">\(x\)</span> vers <span class="math inline">\(y\)</span>. On dit alors que <span class="math inline">\(y\)</span> est accessible depuis <span class="math inline">\(x\)</span>. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><span class="math inline">\(\leadsto\)</span> est la plus petite relation sur <span class="math inline">\(S\)</span> contenant <span class="math inline">\(\rightarrow\)</span> et qui soit réflexive et transitive.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> On considère <span class="math inline">\(\rightarrow \subset R \subset S^2\)</span> telle que <span class="math inline">\(R\)</span> soit réflexive et transitive.</p>
<p>Soient <span class="math inline">\(x, y \in S\)</span> et <span class="math inline">\(\varphi = (s_0, \dots, s_p) : x \leadsto y\)</span>.</p>
<p>Comme <span class="math inline">\(s_{i-1} \rightarrow s_i\)</span> on a <span class="math inline">\(s_{i-1} R s_i\)</span> et, par transitivité, <span class="math inline">\(x = s_0 R s_p = y\)</span>. Donc <span class="math inline">\(x \leadsto y \Rightarrow x R y\)</span>.</p>
<p>Ainsi <span class="math inline">\(\leadsto \subset R\)</span>. </div> </div></p>
<p>On dit que <span class="math inline">\(\leadsto\)</span> est la clôture réflexive et transitive de <span class="math inline">\(\rightarrow\)</span>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Vocabulaire additionnel :</p>
<ul>
<li>Si tous les sommets sont distincts, sauf éventuellement le premier et le dernier, on dit que le chemin est <strong>élémentaire</strong>.</li>
<li>Si toutes les arêtes sont distinctes, on dit que le chemin est <strong>simple</strong>.</li>
<li>Si <span class="math inline">\(x = y\)</span>, on dit que le chemin est <strong>fermé</strong>.</li>
<li>Un chemin simple dont tous les sommets sont distincts est appelé une <strong>chaîne</strong>.</li>
<li>Un chemin élémentaire fermé simple de longueur au moins 1 est appelé un <strong>cycle</strong>. <em>Comme le chemin vide issu de <span class="math inline">\(x\)</span> est fermé, il est nécessaire de considérer des chemins non vides.</em></li>
<li>Un graphe contenant au moins un cycle est dit <strong>cyclique</strong>. Dans le cas contraire, on dit qu’il est <strong>acyclique</strong>.</li>
</ul>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Si <span class="math inline">\(\varphi : x \leadsto y\)</span> et <span class="math inline">\(\psi : y \leadsto z\)</span> on note <span class="math inline">\(\varphi \psi :x \leadsto z\)</span> la concaténée des deux chemins.</p>
<p></div></p>
<p><div class="ui message"><div class="header">Définition</div> On note <span class="math inline">\(\leftrightarrow y\)</span> la plus grande relation d’équivalence incluse dans <span class="math inline">\(\leadsto\)</span>.</p>
<p>Plus précisément, on a <span class="math display">\[
x \leftrightarrow y \iff (x \leadsto y \wedge y \leadsto x)
\]</span></p>
<p>Les classes d’équivalences pour <span class="math inline">\(\leftrightarrow\)</span> sont appelées les composantes <strong>fortement connexes</strong> du graphe. S’il n’y a qu’une classe, on dit que le graphe est <strong>fortement connexe</strong>. </div></p>
<h2 data-number="1.4" id="sec:sous-graphe"><span class="header-section-number">1.4</span> Sous-graphe</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G = (S,A)\)</span> et <span class="math inline">\(X \subset S\)</span>. On appelle <strong>sous-graphe</strong> induit par <span class="math inline">\(X\)</span> le graphe <span class="math inline">\((X, A_X)\)</span> où <span class="math display">\[
A_X = \enscomp{ (a,b) \in A}{a \in X\wedge b \in X}
\]</span></p>
<p>Un graphe <span class="math inline">\(G&#39;\)</span> est un <strong>sous-graphe</strong> de <span class="math inline">\(G\)</span> quand c’est le sous-graphe de <span class="math inline">\(G\)</span> induit par les sommets de <span class="math inline">\(G&#39;\)</span> (ils sont alors nécessairement des sommets de <span class="math inline">\(G\)</span>). </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Les composantes fortement connexes sont les sous-graphes fortement connexes maximaux pour l’inclusion.</p>
<p></div></p>
<h2 data-number="1.5" id="sec:implémentation"><span class="header-section-number">1.5</span> Implémentation</h2>
<h3 data-number="1.5.1" id="sec:énumération-de-sommets"><span class="header-section-number">1.5.1</span> Énumération de sommets</h3>
<p>Si on considère un graphe <span class="math inline">\(G = (S,A)\)</span>, il est assez naturel de représenter ses sommets dans un tableau. Pour cela, on fixe naturellement un ordre sur ces sommets et on va associer à chaque sommet son indice dans le tableau.</p>
<p>Par exemple, si <span class="math inline">\(S = \{ a, b, c, d\}\)</span> on va pouvoir considérer <code>[ a, b, c, d ]</code> et ainsi associer à <code>a</code> son indice 0 dans le tableau. L’ordre est arbitraire, on aurait pu considérer <code>[ b, c, a, d ]</code> et l’indice de <code>a</code> aurait alors été 2.</p>
<p>Ce qui compte, c’est de pouvoir travailler directement sur les indices et pas sur les éléments. Une manière de s’en convaincre est d’imaginer le graphe d’un réseau social où un sommet correspond au profil d’une personne, et contient donc beaucoup (<em>trop</em>) d’informations. Il est bien plus raisonnable de lui associer un identifiant unique et d’utiliser cet identifiant ensuite.</p>
<p>Quand on va implémenter des graphes, on peut donc supposer que les sommets sont les entiers de <code>0</code> à <code>n-1</code> où <span class="math inline">\(|S| = n\)</span>. Il sera toujours possible de retrouver la correspondance avec les sommets eux-mêmes.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Si on est bloqué par le coût de l’opération permettant d’obtenir l’indice d’un sommet, qui est en <span class="math inline">\(O(|S|)\)</span> par une recherche linéaire, on peut très bien définir un dictionnaire associant à chaque sommet son indice en <span class="math inline">\(O(1)\)</span>.</p>
<p>Il se trouve qu’on ne va pas forcément s’intéresser à ces questions mais plus aux raisonnements sur la structure du graphe.</p>
<p></div></p>
<h3 data-number="1.5.2" id="sec:matrice-dadjacence"><span class="header-section-number">1.5.2</span> Matrice d’adjacence</h3>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G = (S,A)\)</span> un graphe et <span class="math inline">\(S = \{ s_1, \dots, s_n \}\)</span> une énumération sans répétition des sommets de <span class="math inline">\(G\)</span>. La matrice <span class="math inline">\(M_G = \left( m_{ij} \right)_{1 \le i, j \le n} \in \mathcal{M}_n(\R)\)</span> définie par <span class="math display">\[
\forall i, j \in \range{1}{n}, m_{ij} = \begin{cases}
1 &amp;\text{ si } s_i \rightarrow s_j \\ 0 &amp; \text{ sinon } \end{cases}
\]</span> est appelée une <strong>matrice d’adjacence</strong> de <span class="math inline">\(G\)</span>. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il s’agit bien d’<strong>une</strong> matrice d’adjacence et pas de <strong>la</strong> matrice car elle dépend de l’énumération des sommets.</p>
<p></div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on considère le graphe</p>
<p><img src="assets/pics/matex1.png" /></p>
<p>On aura pour l’énumération <span class="math inline">\(a,b,c,d\)</span> la matrice : <span class="math display">\[
\begin{pmatrix}
0 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 &amp; 0
\end{pmatrix}
\]</span> En fait, la ième ligne correspond au ième sommet de l’énumération. Ici, la dernière ligne <span class="math inline">\(1 1 0 0\)</span> correspond au sommet d et donne dans l’ordre <span class="math inline">\(a,b,c,d\)</span> la présence ou non d’une arête <span class="math inline">\(d \rightarrow *\)</span>.</p>
<p>Si on considère l’énumération <span class="math inline">\(b,a,d,c\)</span> on aura la matrice :</p>
<p><span class="math display">\[
\begin{pmatrix}
0 &amp; 1 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1 &amp; 1 \\
1 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}
\]</span></p>
</div>
<p>On en déduit ainsi une implémentation directe d’un graphe en représentant la matrice d’adjacence comme l’a fait pour des images.</p>
<p><div>   <div class="ui top attached tabular menu code">   <a class="active item" data-tab="python-91">python</a>   <a class="item" data-tab="c-91">c</a>   <a class="item" data-tab="ocaml-91">ocaml</a> </div> <div class="ui bottom attached active tab segment code" data-tab="python-91"></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> [ [ <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span> ],</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      [ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span> ],</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span> ],</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      [ <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span> ] ]</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="c-91"></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="ocaml-91"></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> m = [| [| <span class="dv">0</span>; <span class="dv">1</span>; <span class="dv">1</span>; <span class="dv">1</span> |];</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>           [| <span class="dv">1</span>; <span class="dv">0</span>; <span class="dv">0</span>; <span class="dv">1</span> |];</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>           [| <span class="dv">0</span>; <span class="dv">0</span>; <span class="dv">0</span>; <span class="dv">1</span> |];</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>           [| <span class="dv">1</span>; <span class="dv">1</span>; <span class="dv">0</span>; <span class="dv">0</span> |] |]</span></code></pre></div>
<p></div> </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il y a le même lien entre les différentes matrices d’adjacence d’un graphe donnée et la matrice d’un endomorphisme dans les différentes permutations d’une même base, à chaque fois on obtient la nouvelle matrice en permutant de même ses lignes et ses colonnes.</p>
<p></div></p>
<p>Cette représentation permet d’accéder, en lecture comme en écriture, à une arête en temps constant. Cependant, pour récupérer les voisins d’un sommet, il est nécessaire de parcourir toute la ligne correspondante, donc en <span class="math inline">\(O(|S|)\)</span>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Dans la majorité des cas, <span class="math inline">\(A\)</span> est petit par rapport à <span class="math inline">\(|S|^2\)</span>. Ainsi, la matrice contient très peu de 1 et beaucoup de 0, on dit qu’elle est <em>creuse</em>. Une telle matrice <em>creuse</em> peut-être efficacement représenté par l’ensemble fini des arêtes <span class="math inline">\((i,j)\)</span>. Par exemple, avec une table de hachage. Cependant, dans le cas des graphes, il est possible d’avoir une structure creuse plus efficace.</p>
<p>A titre d’exemple, un graphe issu d’un réseau social est présenté plus bas, il contient <span class="math inline">\(300 000\)</span> arêtes pour <span class="math inline">\(8 000\)</span> sommets. Donc le rapport <span class="math inline">\(|A|/|S|^2\)</span> est de 4 pour 1000 !</p>
<p></div></p>
<h3 data-number="1.5.3" id="sec:listes-dadjacences"><span class="header-section-number">1.5.3</span> Listes d’adjacences</h3>
<p>La donnée de <span class="math inline">\(v_+(x)\)</span> pour chaque sommet <span class="math inline">\(x \in S\)</span> suffit à reconstruire <span class="math inline">\(A\)</span>.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on reprend le graphe précédent, <img src="assets/pics/matex1_bis.png" /> on a <span class="math inline">\(S = \{ a,b,c,d\}\)</span> et <span class="math inline">\(A = \{ (a, b), (a, c), (a,d), (b,a), (b, d) , (c,d), (d, a), (d, b) \}\)</span>.</p>
<p>Or <span class="math inline">\(v_+(a) = \{ b, c, d \}, v_+(b) = \{ a, d \}, v_+(c) = \{ d \}\)</span> et <span class="math inline">\(v_+(d) = \{ a, b \}\)</span>.</p>
<p>Si on pose <span class="math inline">\(V_+(x) = \enscomp{ (x,y) }{ y \in v_+(x) }\)</span> on a directement <span class="math inline">\(A = \bigcup_{x \in S} V_+(x)\)</span>.</p>
</div>
<p>On en déduit ainsi une représentation d’un graphe où on place dans un tableau chaque <span class="math inline">\(v_+(x)\)</span> représenté par une liste chaînée ou un tableau dynamique.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Pour représenter <span class="math inline">\(v_+(x)\)</span> on a plusieurs choix : on peut utiliser directement les valeurs des sommets ou utiliser des indices dans une énumération. C’est le second choix qu’on fera en général car il est plus simple. Cependant, en cas de suppression d’un sommet, les indices changent, et il faut renuméroter dans les listes.</p>
<p>Pour le graphe précédent, on pourra donc considérer une énumeration <code>[ a, b, c, d ]</code> et la représentation sous forme de liste d’adjacence pourra être :</p>
<p><div class="ui top attached tabular menu code">   <a class="active item" data-tab="python">python</a>   <a class="item" data-tab="ocaml">ocaml</a> </div> <div class="ui bottom attached active tab segment code" data-tab="python"></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> [ [ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ], [ <span class="dv">0</span>, <span class="dv">3</span> ], [ <span class="dv">3</span> ], [ <span class="dv">0</span>, <span class="dv">1</span> ] ]</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="ocaml"></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> l = [| </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    [ <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span> ]; [ <span class="dv">0</span>; <span class="dv">3</span> ]; [ <span class="dv">3</span> ]; [ <span class="dv">0</span>; <span class="dv">1</span> ]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    |]</span></code></pre></div>
<p></div></p>
<p></div></p>
<p>L’accès en lecture ou en écriture à une arête est alors en <span class="math inline">\(O(|A|)\)</span> mais on peut parcourir les voisins sortant en <span class="math inline">\(O(|A|)\)</span> également. Pour un sommet donné, on peut même préciser <span class="math inline">\(O(d_+(x))\)</span>. Accéder à la liste peut même se faire en <span class="math inline">\(O(1)\)</span>.</p>
<p>Pour obtenir les voisins entrants, il est par contre nécessaire de tester la présence de <span class="math inline">\(x\)</span> dans chacune des autres listes, on obtient donc un algorithme en <span class="math inline">\(O(|S| + |A|)\)</span> : on parcourt chaque case du tableau des listes puis chaque maillon de listes d’adjacence.</p>
<p>Il est possible d’améliorer cela en utilisant un structure plus efficace pour stocker les ensembles. Cela peut-être un dictionnaire reposant sur une table de hachage. L’avantage de cela est que pour tester l’appartenance <span class="math inline">\(y \in v_+(x)\)</span> on sera en <span class="math inline">\(O(1)\)</span> avec un dictionnaire alors qu’on sera en <span class="math inline">\(O(d_+(x))\)</span> avec une liste.</p>
<h3 data-number="1.5.4" id="sec:comparaison"><span class="header-section-number">1.5.4</span> Comparaison</h3>
<table style="width:86%;">
<colgroup>
<col style="width: 29%" />
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th>opération</th>
<th>Matrice</th>
<th>Listes</th>
<th>Dictionnaire</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>complexité spatiale</td>
<td><span class="math inline">\(O(|S|^2)\)</span></td>
<td><span class="math inline">\(O(|S|+|A|)\)</span></td>
<td><span class="math inline">\(O(|S|+|A|)\)</span></td>
</tr>
<tr class="even">
<td>arête test</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(|A|)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>arête ajout</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>arête suppression</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(|A|)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>sommet ajout</td>
<td><span class="math inline">\(O(|S|^2)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
</tr>
<tr class="even">
<td>sommet suppression</td>
<td><span class="math inline">\(O(|S|^2)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
</tr>
<tr class="odd">
<td>voisins/degré +</td>
<td><span class="math inline">\(O(|S|)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>voisins/degré -</td>
<td><span class="math inline">\(O(|S|)\)</span></td>
<td><span class="math inline">\(O(|S|+|A|)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
</tr>
</tbody>
</table>
<p>Notons qu’il est possible d’améliorer certaines complexités en utilisant des tableaux dynamiques, notamment les ajouts et suppressions de sommets.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Il semble a priori clair qu’on devrait utiliser des dictionnaires pour manipuler des graphes en voyant ce tableau. Pourtant, on utilisera presque exclusivement des listes d’adjacence. Pourquoi ? En grande partie parce que les opérations rendues efficaces sont rares et ne justifient pas la difficulté accrue de manipulation. En effet, l’opération la plus importante est de pouvoir énumérer les voisins, et une liste chaînée le permet facilement et efficacement.</p>
<p></div></p>
<h1 data-number="2" id="sec:graphes-non-orientés"><span class="header-section-number">2</span> Graphes non orientés</h1>
<h2 data-number="2.1" id="sec:graphes_symetrises"><span class="header-section-number">2.1</span> Définition et adaptation du vocabulaire</h2>
<p><div class="ui message"><div class="header">Définition</div> Un graphe non orienté est un couple <span class="math inline">\(G = (S, A)\)</span> où <span class="math inline">\(S\)</span> est un ensemble fini et <span class="math inline">\(A\)</span> est un ensemble de paires d’éléments de <span class="math inline">\(S\)</span>, c’est-à-dire d’ensembles à deux éléments <span class="math inline">\(\{x,y\}\)</span> où <span class="math inline">\(x, y \in S\)</span>.</p>
<p>Les éléments de <span class="math inline">\(S\)</span> sont appelés les <strong>sommets</strong> du graphe <span class="math inline">\(G\)</span> et les éléments de <span class="math inline">\(A\)</span> les <strong>arêtes</strong>. Si <span class="math inline">\(\{ x,y \} \in A\)</span>, on note <span class="math inline">\(x \smile y\)</span>. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Si <span class="math inline">\(G = (S,A)\)</span> est un graphe orienté, on peut en déduire deux graphes non orientés :</p>
<ul>
<li>un graphe par défaut <span class="math inline">\(G^- = (S, A^-)\)</span> où <span class="math display">\[\forall x, y \in S, x \smile y
\iff (x \rightarrow y \wedge y \rightarrow x)\]</span></li>
<li>un graphe par excès <span class="math inline">\(G^+ = (S, A^+)\)</span> où <span class="math display">\[\forall x, y \in S, x \smile y
\iff (x \rightarrow y \vee y \rightarrow x)\]</span></li>
</ul>
<p>On a également <span class="math inline">\(A\)</span> symétrique <span class="math inline">\(\iff G^+ = G^-\)</span>. Cela correspond à un graphe où chaque arête est dans les deux sens <span class="math inline">\(x \leftrightarrow y\)</span> et, donc, on peut oublier l’orientation.</p>
<p>De la même manière, on peut associer à un graphe non orienté <span class="math inline">\(G\)</span> son graphe orienté symétrique obtenu en doublant chaque arête. C’est à dire en posant si <span class="math inline">\(x \rightarrow y\)</span> si <span class="math inline">\(x \smile y\)</span>. On a donc <span class="math inline">\(\forall x, y \in S, x \rightarrow y \iff y \rightarrow x\)</span> et le graphe est bien symétrique.</p>
<p></div></p>
<p>On reprend directement l’essentiel du vocabulaire des graphes orientés symétriques avec des simplifications :</p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G= (S,A)\)</span> un graphe et <span class="math inline">\(x \in S\)</span>.</p>
<ul>
<li>On appelle <em>voisins</em> de <span class="math inline">\(x\)</span> les éléments de <span class="math display">\[
v(x) = \enscomp{y \in S}{x \smile y}
\]</span></li>
<li>On appelle <em>degré</em> de <span class="math inline">\(x\)</span> l’entier <span class="math inline">\(d(x) = | v(x)|\)</span>. </div></li>
</ul>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><span class="math inline">\(\sum_{x \in S} d(x) = 2 |A|\)</span></p>
</div>
<p>On étend directement la notion de <strong>chemin</strong> mais il faut faire attention au fait que <strong>simple</strong> n’a pas le même sens entre un graphe non orienté symétrique et un graphe non orienté. En effet, on <span class="math inline">\(x \rightarrow y \rightarrow x\)</span> est simple pour un graphe orienté alors que <span class="math inline">\(x \smile y \smile x\)</span> ne l’est pas vu qu’il s’agit de la même arête.</p>
<h2 data-number="2.2" id="sec:connexité"><span class="header-section-number">2.2</span> Connexité</h2>
<p><div class="ui message"><div class="header">Définition</div> On définit <span class="math inline">\(\smile^*\)</span> comme étant la clôture réflexive et transitive de <span class="math inline">\(\smile\)</span>. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<ul>
<li><span class="math inline">\(\smile^*\)</span> est une relation d’équivalence dont les classes sont appelées les <strong>composantes connexes</strong> du graphe.</li>
<li><span class="math inline">\(x \smile^* y \iff\)</span> il existe un chemin de <span class="math inline">\(x\)</span> à <span class="math inline">\(y\)</span>.</li>
</ul>
</div>
<p><div class="ui message"><div class="header">Définition</div> Un graphe n’ayant qu’une classe d’équivalence pour <span class="math inline">\(\smile^*\)</span> est dit <strong>connexe</strong>. Cela signifie qu’il existe un chemin entre toute paire de sommets. </div></p>
<h2 data-number="2.3" id="sec:graphe-acyclique-connexe"><span class="header-section-number">2.3</span> Graphe acyclique connexe</h2>
<p><div class="ui message"><div class="header">Définition</div> On appelle <strong>arbre</strong> un graphe acyclique connexe. Quand on a distingué un sommet, on parle d’<strong>arbre enraciné</strong>. </div></p>
<h2 data-number="2.4" id="sec:graphe-biparti"><span class="header-section-number">2.4</span> Graphe biparti</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G = (S,A)\)</span> un graphe, on dit que le graphe est <strong>biparti</strong> lorsqu’il existe une partition <span class="math inline">\(S = S_1 \cup S_2\)</span> et que <span class="math display">\[
\forall \{ x, y \} \in A, x \in S_1 \iff y \in S_2
\]</span> </div></p>
<p>Ici, le graphe est biparti avec <span class="math inline">\(S_1 = \{a,e,f,g\}\)</span> et <span class="math inline">\(S_2 = \{b,c,d\}\)</span>.</p>
<p><center><div class="ui image center"><img src="assets/pics/graph_biparti.png" /></div></center></p>
<p>On peut s’en rendre compte en colorant les sommets.</p>
<p><center><div class="ui image center"><img src="assets/pics/graph_biparti2.png" /></div></center></p>
<p>En fait, être biparti est équivalent à pouvoir être coloré en deux couleurs en sorte que deux sommets reliés soient de couleur différente.</p>
<h1 data-number="3" id="sec:graphes-classiques"><span class="header-section-number">3</span> Graphes classiques</h1>
<p>On présente ici brièvement des graphes ou des familles de graphes classiques qui serviront, notamment pour les exemples.</p>
<h2 data-number="3.1" id="sec:graphes-complets"><span class="header-section-number">3.1</span> Graphes complets</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(n \in \N^*\)</span>, on appelle <strong>graphe complet</strong> à <span class="math inline">\(n\)</span> sommets le graphe non orienté <span class="math inline">\(K_n\)</span> de sommets <span class="math inline">\(\range{0}{n-1}\)</span> et tel que <span class="math display">\[
\forall x, y \in \range{0}{n-1}, x \neq y \iff x \smile y
\]</span> </div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p><span class="math inline">\(K_5\)</span> : <img src="assets/pics/complet5.png" /></p>
<p></div><div class="eight wide column"></p>
<p><span class="math inline">\(K_8\)</span> : <img src="assets/pics/complet8.png" /></p>
<p></div></div></div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(n, p \in \N^*\)</span>, on appelle <strong>graphe bipartite complet</strong> à <span class="math inline">\((n,p)\)</span> sommets le graphe non orienté <span class="math inline">\(K_{n,p}\)</span> de sommets <span class="math inline">\(\range{0}{n+p-1}\)</span> et tel que <span class="math display">\[
\forall x \in \range{0}{n-1}, \forall y \in \range{n}{n+p-1}, x \smile y
\]</span> </div></p>
<p><span class="math inline">\(K_{3,4}\)</span> : <img src="assets/pics/complet34.png" /></p>
<h2 data-number="3.2" id="sec:cycles"><span class="header-section-number">3.2</span> Cycles</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(n \in \N^*\)</span>, on appelle <strong>cycle</strong> de longueur <span class="math inline">\(n\)</span> le graphe non orienté <span class="math inline">\(C_n\)</span> de sommets <span class="math inline">\(\range{0}{n-1}\)</span> et tel que <span class="math display">\[
\forall x, y \in \range{0}{n-1}, |x - y| = 1  \iff x \smile y
\]</span> </div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p><span class="math inline">\(C_5\)</span> : <img src="assets/pics/cycle5.png" /></p>
<p></div><div class="eight wide column"></p>
<p><span class="math inline">\(C_8\)</span> : <img src="assets/pics/cycle8.png" /></p>
<p></div></div></div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(n \in \N^*\)</span>, on appelle <strong>cycle orienté</strong> de longueur <span class="math inline">\(n\)</span> le graphe orienté <span class="math inline">\(C^o_n\)</span> de sommets <span class="math inline">\(\range{0}{n-1}\)</span> et tel que <span class="math display">\[
\forall x, y \in \range{0}{n-1}, y \equiv  x + 1 ~ [n]  \iff x \rightarrow y
\]</span> </div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p><span class="math inline">\(C^o_5\)</span> : <img src="assets/pics/cycleo5.png" /></p>
<p></div><div class="eight wide column"></p>
<p><span class="math inline">\(C^o_8\)</span> : <img src="assets/pics/cycleo8.png" /></p>
<p></div></div></div></p>
<h2 data-number="3.3" id="sec:grilles-et-hypercubes"><span class="header-section-number">3.3</span> Grilles et hypercubes</h2>
<p>On va manipuler ici des vecteurs de dimension <span class="math inline">\(d\)</span> à coordonnées entières dans <span class="math inline">\(\range{0}{n-1}\)</span>.</p>
<p>On sait que <span class="math inline">\(\range{0}{n-1}^d\)</span> est en bijection avec <span class="math inline">\(\range{0}{n^d-1}\)</span> et on considère la bijection explicite suivante : <span class="math display">\[
\varphi(x) = \sum_{i=0}^{d-1} x_i \text{ où } x = (x_0, \dots, x_{d-1})
\]</span></p>
<p>Soit <span class="math inline">\(x = (x_0, \dots, x_{d-1})\)</span> et <span class="math inline">\(y = (y_0, \dots, y_{d-1}) \in \range{0}{n-1}^d\)</span>, on note <span class="math inline">\(d_1(x,y) = \sum_{i=0}^{d-1} |x_i-y_i|\)</span> qui compte la somme des différences de coordonnées. Ainsi <span class="math inline">\(d_1( (1,2,3), (3,2,2) ) = |1-3| + |2-2| + |3-2| = 3\)</span>. Comme les coordonnées sont entières, on a le théorème suivant qui indique que les vecteurs à distance 1 sont ceux qui différent exactement de 1 dans une unique coordonnée :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soient <span class="math inline">\(x, y \in \range{0}{n-1}^d\)</span>, on a <span class="math display">\[
d_1(x,y) = 1 \iff \exists i \in \range{0}{d-1},
\begin{cases}
\forall j \in \range{0}{d-1}, j \neq i \Rightarrow x_j = y_j \\
|x_j-y_j| = 1
\end{cases}
\]</span></p>
</div>
<p>On en déduit un graphe de grille des vecteurs à distance 1 :</p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(n, d \in \N^*\)</span>, on appelle <strong>grille de dimension <span class="math inline">\(d\)</span> et de taille <span class="math inline">\(n\)</span></strong> le graphe <span class="math inline">\(G_n^d\)</span> dont les sommets sont dans <span class="math inline">\(\range{0}{n-1}^d\)</span> et où <span class="math display">\[
\forall x, y \in \range{0}{n-1}^d, x \smile y \iff d_1(x,y) = 1
\]</span> </div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p><span class="math inline">\(G_3^2\)</span> : <img src="assets/pics/grille32.png" /></p>
<p></div><div class="eight wide column"></p>
<p><span class="math inline">\(G_2^3\)</span> : <img src="assets/pics/grille23.png" /></p>
<p></div></div></div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(n \in \N^*\)</span>, on appelle <strong>hypercube de dimension <span class="math inline">\(n\)</span></strong> le graphe <span class="math inline">\(H_n = G_2^n\)</span>. </div></p>
<p>On vient de voir l’hypercube de dimension 3 dans l’exemple précédent.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>L’hypercube de dimension <span class="math inline">\(n\)</span> est intéressant car il permet de représenter chaque nombre de <span class="math inline">\(\range{0}{2^n-1}\)</span> comme un sommet du graphe. Par exemple, toute chaîne hamiltonienne, c’est-à-dire qui contient chaque sommet du graphe, correspond à un ordre d’énumération des nombres qui vérifie qu’un nombre et son successeur ne diffèrent que sur un bit.</p>
<p></div></p>
<h1 data-number="4" id="sec:parcours"><span class="header-section-number">4</span> Parcours</h1>
<p><div class="ui label">     ITC<div class="detail">Sup</div> </div> <div class="ui label">     MP2I<div class="detail">S2</div> </div></p>
<h2 data-number="4.1" id="sec:principe"><span class="header-section-number">4.1</span> Principe</h2>
<p>La grande majorité des algorithmes sur les graphes consistent à parcourir les sommets de voisins en voisins pour effectuer des traitements. La manière dont on les parcourt pouvant changer selon les différentes applications.</p>
<p>Citons, par exemple, le fait de déterminer les composantes connexes d’un graphe ou de trouver le plus court chemin entre deux sommets.</p>
<p>On va se placer dans le cadre d’un graphe orienté représenté par listes d’adjacence et en supposant que les sommets sont identifiés par leur indice. Dans ce cadre, si on a, en fait, un graphe non orienté, il sera représenté par son graphe orienté symétrique comme on l’a vu plus haut.</p>
<p>On va également considérer qu’on veut effectuer un traitement, ou une visite, pour ces sommets ou les arêtes empruntées.</p>
<h2 data-number="4.2" id="sec:parcours-en-profondeur-récursif"><span class="header-section-number">4.2</span> Parcours en profondeur récursif</h2>
<p>On présente ici une première manière élémentaire de les parcourir en tirant partie de la récursivité :</p>
<ul>
<li>on considère une fonction <code>parcours</code> et l’appel à <code>parcours</code> pour le sommet <code>x</code> va effectuer des appels récursifs à <code>parcours</code> pour chaque sommet <span class="math inline">\(y\)</span> de <span class="math inline">\(v_+(x)\)</span>.</li>
</ul>
<p>Le problème est qu’on ne veut pas traiter deux fois un sommet et on veut que les appels terminent. Pour cela, on introduit une notion d’état associé à chaque sommet. Un sommet peut-être</p>
<ul>
<li><strong>Inconnu</strong>, cela correspond au fait qu’il n’est pas encore apparu en tant que voisin.</li>
<li><strong>Découvert</strong>, il est apparu mais n’a pas encore été traité complètement.</li>
<li><strong>Traité</strong> (ou <strong>Visité</strong>), il a non seulement été traité, mais également tous les sommets parcouru grâce à lui.</li>
</ul>
<p>Pour maintenir cet état dans le code, le plus simple est de considérer un tableau d’entiers <code>etat</code> où <code>etat[i]</code> donne l’état du sommet <code>i</code>.</p>
<p><div class="ui message"><div class="header">Définition</div> Ce parcours est appelé un <strong>parcours en profondeur</strong> récursif. En anglais, on parle de <strong>depth-first search</strong> et on utilise couramment l’acronyme <strong>DFS</strong>. </div></p>
<h3 data-number="4.2.1" id="sec:première-version"><span class="header-section-number">4.2.1</span> Première version</h3>
<p>On adapte directement le principe précédent en un programme.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>INCONNU <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>DECOUVERT <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>TRAITE <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">def</span> parcours(ladj, x, etat):</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="cf">if</span> etat[x] <span class="op">!=</span> TRAITE:</span>
<span id="cb6-7"><a href="#cb6-7"></a>        <span class="bu">print</span>(x)</span>
<span id="cb6-8"><a href="#cb6-8"></a>        <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb6-9"><a href="#cb6-9"></a>            <span class="cf">if</span> etat[y] <span class="op">==</span> INCONNU:</span>
<span id="cb6-10"><a href="#cb6-10"></a>                etat[y] <span class="op">=</span> DECOUVERT</span>
<span id="cb6-11"><a href="#cb6-11"></a>                parcours(ladj, y, etat)</span>
<span id="cb6-12"><a href="#cb6-12"></a>        etat[x] <span class="op">=</span> TRAITE</span>
<span id="cb6-13"><a href="#cb6-13"></a></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="kw">def</span> lance_parcours(ladj, x):</span>
<span id="cb6-15"><a href="#cb6-15"></a>    <span class="co"># État initial inconnu pour tous</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>    etat <span class="op">=</span> [ INCONNU ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb6-17"><a href="#cb6-17"></a>    etat[x] <span class="op">=</span> DECOUVERT</span>
<span id="cb6-18"><a href="#cb6-18"></a>    parcours(ladj, x, etat)</span></code></pre></div>
<p></div></p>
<p>Ici, on se contente d’afficher les sommets rencontrés.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On va réaliser un parcours en profondeur du graphe suivant en partant du sommet 0 :</p>
<p><img src="assets/pics/graphe_dfsrec_ex.png" /> On indique les sommets inconnus en blanc, les sommets découvert en rouge et les sommets traités en vert.</p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>On affiche 0 et on appelle relance le parcours du voisin 1.</p>
<p><img src="assets/pics/graphe_dfsrec_ex1.png" /></p>
<p></div><div class="eight wide column"></p>
<p>On affiche 1 et on relance le parcours du voisin 2.</p>
<p><img src="assets/pics/graphe_dfsrec_ex2.png" /></p>
<p></div></div></div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>On affiche 3 et on appelle relance le parcours du voisin 4.</p>
<p><img src="assets/pics/graphe_dfsrec_ex3.png" /></p>
<p></div><div class="eight wide column"></p>
<p>On affiche 4 et comme il n’a pas de voisins non traités, on traite 4 et on sort de l’appel.</p>
<p><img src="assets/pics/graphe_dfsrec_ex4.png" /></p>
<p></div></div></div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>On revient à 2 et on relance le parcours du voisin 3. On affiche 3, et on le traite car tous ses voisins sont connus.</p>
<p><img src="assets/pics/graphe_dfsrec_ex5.png" /></p>
<p></div><div class="eight wide column"></p>
<p>On revient à 2 et cette fois-ci il n’y a plus de voisins, on peut marquer 2 comme étant traité.</p>
<p><img src="assets/pics/graphe_dfsrec_ex6.png" /></p>
<p></div></div></div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>On revient à 1 et on peut marquer 1 comme étant traité.</p>
<p><img src="assets/pics/graphe_dfsrec_ex7.png" /></p>
<p></div><div class="eight wide column"></p>
<p>On revient à 0 et on peut marquer 0 comme étant traité.</p>
<p><img src="assets/pics/graphe_dfsrec_ex8.png" /></p>
<p></div></div></div></p>
<p>On a donc une vague de descente dans le graphe qui marque les sommets comme découverts et ensuite on remonte la pile d’appels récursifs en marquant les sommets comme étant traités.</p>
<p>Les sommets sont ici affichés dans l’ordre 0 1 2 4 3. On remarque que les sommets 5 et 6 sont inaccessibles, ils restent ainsi inconnus tout le long du parcours.</p>
</div>
<h3 data-number="4.2.2" id="sec:arbre-de-parcours"><span class="header-section-number">4.2.2</span> Arbre de parcours</h3>
<p>On peut noter les arêtes empruntées lors du parcours précédents pour découvrir un nouveau sommet, et donc relancer un appel récursif. On obtient alors une structure arborescente qui est appelé l’arbre du parcours en profondeur.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Dans le parcours précédent, on obtient l’arbre suivant : <div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p><img src="assets/pics/graphe_dfsrec_arbre.png" /></p>
<p></div><div class="eight wide column"></p>
<p><center><div class="ui image center"><img src="assets/pics/graphe_dfsrec_arbre2.png" /></div></center></p>
<p></div></div></div></p>
</div>
<p>Pour obtenir cet arbre, on va construire un tableau <code>parent</code> pendant le parcours. Lorsqu’on emprunte une arête <span class="math inline">\(x \rightarrow y\)</span> pour découvrir <span class="math inline">\(y\)</span>, on note <span class="math inline">\(parent[y] = x\)</span>. Par défaut, <span class="math inline">\(parent[y]\)</span> est indéfini (<code>None</code> ou une valeur d’indice invalide comme <span class="math inline">\(-1\)</span>).</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Si <span class="math inline">\(parent[y]\)</span> est défini à l’issue du parcours depuis <span class="math inline">\(x\)</span>, alors il existe un chemin <span class="math inline">\(\varphi : x \leadsto y\)</span> où les arêtes <span class="math inline">\(s \rightarrow s&#39;\)</span> empruntées lors du chemin vérifient toutes <span class="math inline">\(parent[s&#39;] = s\)</span>.</p>
</div>
<p>Comme <span class="math inline">\(parent[y]\)</span> est défini pour tous les sommets découverts et que les sommets découverts finissent tous par être traités, on peut en déduire directement le théorème suivant :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>A l’issue du parcours depuis <span class="math inline">\(x\)</span>, les sommets traités sont les sommets accessibles depuis <span class="math inline">\(x\)</span>, c’est-à-dire les éléments de <span class="math display">\[
\enscomp{y \in S}{x \leadsto y}
\]</span></p>
</div>
<p>On présente le calcul de ces chemins dans le programme suivant : <div class="ui segment code"></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>INCONNU <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>DECOUVERT <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>TRAITE <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="kw">def</span> parcours(ladj, x, etat, parent):</span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span class="cf">if</span> etat[x] <span class="op">!=</span> TRAITE:</span>
<span id="cb7-7"><a href="#cb7-7"></a>        <span class="bu">print</span>(x)</span>
<span id="cb7-8"><a href="#cb7-8"></a>        <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb7-9"><a href="#cb7-9"></a>            <span class="cf">if</span> etat[y] <span class="op">==</span> INCONNU:</span>
<span id="cb7-10"><a href="#cb7-10"></a>                parent[y] <span class="op">=</span> x</span>
<span id="cb7-11"><a href="#cb7-11"></a>                etat[y] <span class="op">=</span> DECOUVERT</span>
<span id="cb7-12"><a href="#cb7-12"></a>                parcours(ladj, y, etat, parent)</span>
<span id="cb7-13"><a href="#cb7-13"></a>        etat[x] <span class="op">=</span> TRAITE</span>
<span id="cb7-14"><a href="#cb7-14"></a></span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="kw">def</span> arbre_parcours(ladj, x):</span>
<span id="cb7-16"><a href="#cb7-16"></a>    etat <span class="op">=</span> [ INCONNU ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb7-17"><a href="#cb7-17"></a>    parent <span class="op">=</span> [ <span class="va">None</span> ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb7-18"><a href="#cb7-18"></a>    etat[x] <span class="op">=</span> DECOUVERT</span>
<span id="cb7-19"><a href="#cb7-19"></a>    parcours(ladj, x, etat, parent)</span>
<span id="cb7-20"><a href="#cb7-20"></a>    <span class="cf">return</span> parent</span>
<span id="cb7-21"><a href="#cb7-21"></a></span>
<span id="cb7-22"><a href="#cb7-22"></a><span class="kw">def</span> chemin(parent, y):</span>
<span id="cb7-23"><a href="#cb7-23"></a>    <span class="co"># Renvoie le chemin x -&gt; ... -&gt; y</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>    <span class="co"># en sens inverse</span></span>
<span id="cb7-25"><a href="#cb7-25"></a>    p <span class="op">=</span> [ y ]</span>
<span id="cb7-26"><a href="#cb7-26"></a>    <span class="cf">while</span> parent[y] <span class="op">!=</span> <span class="va">None</span>:</span>
<span id="cb7-27"><a href="#cb7-27"></a>        y <span class="op">=</span> parent[y]</span>
<span id="cb7-28"><a href="#cb7-28"></a>        p.append(y)</span>
<span id="cb7-29"><a href="#cb7-29"></a>    <span class="cf">return</span> p</span></code></pre></div>
<p></div></p>
<h3 data-number="4.2.3" id="sec:composantes-connexes"><span class="header-section-number">4.2.3</span> Composantes connexes</h3>
<p>On peut déduire directement du théorème précédent, le corollaire suivant dans le cas non orienté :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Dans un graphe non orienté, les sommets traités depuis un parcours en profondeur issu d’un sommet sont exactement les sommets de sa composante connexe.</p>
</div>
<p>On en déduit alors un algorithme pour obtenir les composantes connexes d’un graphe non orienté :</p>
<div class="ui message gray">
<div class="header">
Algorithme - Composantes connexes
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<p>Un graphe non orienté <span class="math inline">\(G = (S,A)\)</span></p>
</div>
<ul>
<li>Tant qu’il y a des sommets non traités
<ul>
<li>On choisit un sommet non traité <span class="math inline">\(x\)</span></li>
<li>On effectue un parcours récursif depuis <span class="math inline">\(x\)</span></li>
<li>Tous les sommets traités par ce parcours forment une composante connexe</li>
</ul></li>
</ul>
</div>
<p>On va en déduire le programme suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>INCONNU <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>DECOUVERT <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>TRAITE <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">def</span> parcours(ladj, x, etat, composante):</span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="cf">if</span> etat[x] <span class="op">!=</span> TRAITE:</span>
<span id="cb8-7"><a href="#cb8-7"></a>        composante.append(x)</span>
<span id="cb8-8"><a href="#cb8-8"></a>        <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb8-9"><a href="#cb8-9"></a>            <span class="cf">if</span> etat[y] <span class="op">==</span> INCONNU:</span>
<span id="cb8-10"><a href="#cb8-10"></a>                etat[y] <span class="op">=</span> DECOUVERT</span>
<span id="cb8-11"><a href="#cb8-11"></a>                parcours(ladj, y, etat, composante)</span>
<span id="cb8-12"><a href="#cb8-12"></a>        etat[x] <span class="op">=</span> TRAITE</span>
<span id="cb8-13"><a href="#cb8-13"></a></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="kw">def</span> composantes_connexes(ladj):</span>
<span id="cb8-15"><a href="#cb8-15"></a>    composantes <span class="op">=</span> []</span>
<span id="cb8-16"><a href="#cb8-16"></a>    etat <span class="op">=</span> [ INCONNU ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(ladj)):</span>
<span id="cb8-18"><a href="#cb8-18"></a>        <span class="cf">if</span> etat[i] <span class="op">==</span> INCONNU:</span>
<span id="cb8-19"><a href="#cb8-19"></a>            composante <span class="op">=</span> [ ]</span>
<span id="cb8-20"><a href="#cb8-20"></a>            parcours(ladj, x, etat, composante)</span>
<span id="cb8-21"><a href="#cb8-21"></a>            composantes.append( composante )</span>
<span id="cb8-22"><a href="#cb8-22"></a>    <span class="cf">return</span> composantes</span></code></pre></div>
<p></div></p>
<h3 data-number="4.2.4" id="sec:détection-de-cycles"><span class="header-section-number">4.2.4</span> Détection de cycles</h3>
<p>Si on est en train de traiter le sommet <span class="math inline">\(x\)</span> et qu’on rencontre une arête <span class="math inline">\(x \rightarrow y\)</span> où <span class="math inline">\(y\)</span> est découvert mais non traité, c’est qu’on est dans l’appel récursif de <span class="math inline">\(y\)</span> et donc que <span class="math inline">\(x\)</span> est un de ses descendants : <span class="math inline">\(y \leadsto x\)</span> en rajoutant la nouvelle arête <span class="math inline">\(y \leadsto x \rightarrow x\)</span> on en déduit un cycle dans le cas d’un graphe orienté.</p>
<p>Pour un graphe non orienté représenté par un graphe orienté symétrique, il faut faire attention à ne pas prendre un aller-retour <span class="math inline">\(x \rightarrow y \rightarrow x\)</span> pour un cyle. On demande donc à avoir la condition :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a>etat[y] <span class="op">==</span> DECOUVERT <span class="kw">and</span> parent[x] <span class="op">!=</span> y</span></code></pre></div>
<p></div></p>
<p>On en déduit le programme suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>INCONNU <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>DECOUVERT <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>TRAITE <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="kw">def</span> parcours(ladj, x, etat, parent, est_oriente):</span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="cf">if</span> etat[x] <span class="op">!=</span> TRAITE:</span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a>        <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb10-9"><a href="#cb10-9"></a>            <span class="cf">if</span> etat[y] <span class="op">==</span> INCONNU:</span>
<span id="cb10-10"><a href="#cb10-10"></a>                parent[y] <span class="op">=</span> x</span>
<span id="cb10-11"><a href="#cb10-11"></a>                etat[y] <span class="op">=</span> DECOUVERT</span>
<span id="cb10-12"><a href="#cb10-12"></a>                cycle <span class="op">=</span> parcours(ladj, y, etat, parent, est_oriente)</span>
<span id="cb10-13"><a href="#cb10-13"></a>                <span class="cf">if</span> cycle <span class="op">!=</span> <span class="va">None</span>:</span>
<span id="cb10-14"><a href="#cb10-14"></a>                    <span class="cf">return</span> cycle</span>
<span id="cb10-15"><a href="#cb10-15"></a>            <span class="cf">elif</span> etat[y] <span class="op">==</span> TRAITE <span class="kw">and</span> (est_oriente <span class="kw">or</span> parent[x] <span class="op">!=</span> y):</span>
<span id="cb10-16"><a href="#cb10-16"></a>                <span class="cf">return</span> chemin(parent, y)</span>
<span id="cb10-17"><a href="#cb10-17"></a></span>
<span id="cb10-18"><a href="#cb10-18"></a>        etat[x] <span class="op">=</span> TRAITE</span>
<span id="cb10-19"><a href="#cb10-19"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb10-20"><a href="#cb10-20"></a></span>
<span id="cb10-21"><a href="#cb10-21"></a><span class="kw">def</span> detecte_cycle(ladj, x, est_oriente):</span>
<span id="cb10-22"><a href="#cb10-22"></a>    etat <span class="op">=</span> [ INCONNU ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb10-23"><a href="#cb10-23"></a>    parent <span class="op">=</span> [ <span class="va">None</span> ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb10-24"><a href="#cb10-24"></a>    etat[x] <span class="op">=</span> DECOUVERT</span>
<span id="cb10-25"><a href="#cb10-25"></a>    cycle <span class="op">=</span> parcours(ladj, x, etat, parent, est_oriente)</span>
<span id="cb10-26"><a href="#cb10-26"></a>    <span class="cf">if</span> cycle <span class="op">!=</span> <span class="va">None</span>:</span>
<span id="cb10-27"><a href="#cb10-27"></a>        <span class="bu">print</span>(<span class="st">&#39;Cyclique : &#39;</span>, cycle)</span>
<span id="cb10-28"><a href="#cb10-28"></a>    <span class="cf">else</span>:</span>
<span id="cb10-29"><a href="#cb10-29"></a>        <span class="bu">print</span>(<span class="st">&#39;Acyclique&#39;</span>)</span></code></pre></div>
<p></div></p>
<h3 data-number="4.2.5" id="sec:classification-des-arêtes"><span class="header-section-number">4.2.5</span> Classification des arêtes</h3>
<p><div class="ui label">     MP2I<div class="detail">S2</div> </div><div class="ui label">     OI<div class="detail">Spé</div> </div></p>
<h3 data-number="4.2.6" id="sec:temps-dentrée-et-de-sortie"><span class="header-section-number">4.2.6</span> Temps d’entrée et de sortie</h3>
<p><div class="ui label">     MP2I<div class="detail">S2</div> </div><div class="ui label">     OI<div class="detail">Spé</div> </div></p>
<h2 data-number="4.3" id="sec:parcours-quelconque"><span class="header-section-number">4.3</span> Parcours <strong>quelconque</strong></h2>
<p>On va considérer ici que l’on dispose d’une structure de donnée <code>sac</code> dans laquelle on peut placer des éléments et en sortir. On considère aussi qu’on a une moyen de marquer les sommets. Par défaut, ils sont non marqués.</p>
<p>On considère alors l’algorithme suivant decrit en pseudo-code et auquel on fera référence comme étant le parcours <strong>quelconque</strong> dans la suite :</p>
<div class="ui message gray">
<div class="header">
Algorithme - parcours quelconque
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe <span class="math inline">\(G = (S,A)\)</span></li>
<li>Un somme <span class="math inline">\(s \in S\)</span> source du parcours</li>
</ul>
</div>
<ul>
<li>On crée un sac ne contenant que <span class="math inline">\(s\)</span></li>
<li>Tant que le sac est non vide
<ul>
<li>On tire un sommet <span class="math inline">\(x\)</span> du sac</li>
<li>Si <span class="math inline">\(x\)</span> n’est pas marqué
<ul>
<li>On marque <span class="math inline">\(x\)</span></li>
<li>pour chaque <span class="math inline">\(x \rightarrow y \in A\)</span>
<ul>
<li>On ajoute y dans le sac</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<p>On remarque que les somets marqués sont exactement les sommets accessibles depuis <span class="math inline">\(s\)</span>, on retrouve ainsi le théorème vu pour le parcours récursif.</p>
<p>En fait, le parcours quelconque ne permet pas de déduire plus d’information que cela, mais dans un graphe non orienté c’est déjà suffisant pour en déduire les composantes connexes.</p>
<p>La question qui se pose alors est celle de la stratégie d’ajout/tirage dans le sac. Selon ce que l’on considère, l’ordre de visite des sommets va changer. On va considérer trois stratégies :</p>
<ul>
<li>LIFO : Last In First Out, le prochain sommet tiré est le dernier ajouté</li>
<li>FIFO : First In First Out, le prochain sommet tiré est le sommet le plus anciennement ajouté</li>
<li>aléatoire : on tire aléatoirement et uniformément un sommet du sac</li>
</ul>
<p><div class="ui message"><div class="header">Définition</div> Un sac avec une stratégie LIFO est appelé une <strong>pile</strong>.</p>
<p>Un sac avec une stratégie FIFO est appelé une <strong>file</strong>. </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on considère le graphe suivant :</p>
<p><img src="assets/pics/quelex.png" /></p>
<p>En effectuant un parcours quelconque issu de <span class="math inline">\(a\)</span> :</p>
<ul>
<li>en stratégie LIFO, on va voir les sommets dans l’ordre <span class="math inline">\(a, b, e, c, f, d, g\)</span>.</li>
<li>en stratégie FIFO, on va voir les sommets dans l’ordre <span class="math inline">\(a, b, c, d, e, f, g\)</span></li>
<li>en stratégie aléatoire, on pourrait avoir <span class="math inline">\(a, b, c, e, d, f, g\)</span></li>
</ul>
</div>
<p>Une manière de <em>voir</em> ces trois différentes stratégies est de considérer une grille et de colorer les sommets marqués avec une couleur changeant à chaque marquage. On peut voir dans l’ordre LIFO, FIFO, aléatoire l’effet de ces trois stratégies en partant du même point sur l’animation suivante :</p>
<p><img src="assets/pics/flood_fill_sac3.gif" /></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>La stratégie LIFO semble <em>bornée</em> : elle choisit un cap et elle s’y tient tant que c’est possible. La stratégie FIFO va elle s’étendre comme une onde partant du point de départ. De manière assez étonnante, la stratégie aléatoire semble être une bonne approximation de la stratégie FIFO, ce qui montre le caractère exceptionnel du LIFO.</p>
<p></div></p>
<p>Le parcours quelconque en stratégie FIFO s’appelle un <em>parcours en largeur</em>. Comme on va le voir, le parcours avec stratégie LIFO est exactement le <em>parcours en profondeur</em> précédent.</p>
<h3 data-number="4.3.1" id="sec:implémentation-en-python"><span class="header-section-number">4.3.1</span> Implémentation en <code>Python</code></h3>
<p><div class="ui label">     ITC<div class="detail">Sup</div> </div></p>
<p>On va supposer qu’on dispose de quatre fonctions manipulant des sacs :</p>
<ul>
<li><code>sac_vide()</code> qui renvoie un nouveau sac vide</li>
<li><code>ajoute(sac, x)</code> qui ajoute <code>x</code> dans le sac <code>sac</code></li>
<li><code>retire(sac)</code> qui retire un élément du sac <code>sac</code> et le renvoie</li>
<li><code>est_vide(sac)</code> qui renvoie un booléen indiquant si le <code>sac</code> est vide</li>
</ul>
<p>Le programme du parcours quelconque s’écrit alors</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">def</span> parcours_sac(ladj, source):</span>
<span id="cb11-2"><a href="#cb11-2"></a>    a_traiter <span class="op">=</span> sac_vide()</span>
<span id="cb11-3"><a href="#cb11-3"></a>    ajoute(a_traiter, source)</span>
<span id="cb11-4"><a href="#cb11-4"></a>    marque <span class="op">=</span> [ <span class="va">False</span> ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="cf">while</span> <span class="kw">not</span> est_vide(a_traiter):</span>
<span id="cb11-7"><a href="#cb11-7"></a>        x <span class="op">=</span> retire(a_traiter)</span>
<span id="cb11-8"><a href="#cb11-8"></a>        <span class="cf">if</span> <span class="kw">not</span> marque[x]:</span>
<span id="cb11-9"><a href="#cb11-9"></a>            marque[x] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>            <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb11-11"><a href="#cb11-11"></a>                ajoute(a_traiter, y)</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Pour utiliser ce parcours, on peut rajouter des instructions au moment où on marque un sommet ou au moment où on traite une arête.</p>
<p></div></p>
<p>Pour implémenter un sac, on va d’abord utiliser le type <code>list</code> de <code>Python</code> :</p>
<ul>
<li>Pour créer un sac vide, on utilise la valeur <code>[]</code> :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">def</span> sac_vide():</span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="cf">return</span> []</span></code></pre></div>
<p></div></p>
<ul>
<li>Pour tester si le sac est vide, on utilise donc le test à <code>[]</code> :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">def</span> est_vide(sac):</span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="cf">return</span> sac <span class="op">==</span> []</span></code></pre></div>
<p></div></p>
<ul>
<li>Pour ajouter un élément <code>x</code> dans le sac <code>s</code> dans tous les cas :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">def</span> ajoute(sac, x):</span>
<span id="cb14-2"><a href="#cb14-2"></a>    sac.append(x)</span></code></pre></div>
<p></div></p>
<ul>
<li>(FIFO) Pour retirer le dernier élément ajouté, on peut utiliser directement <code>pop</code> :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">def</span> retire(sac):</span>
<span id="cb15-2"><a href="#cb15-2"></a>    <span class="cf">return</span> sac.pop()</span></code></pre></div>
<p></div> * (LIFO) Pour retirer l’élément le plus anciennement ajouté, on peut utiliser la fonction de suppression <code>del l[0]</code> qui retire le premier élément</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">def</span> retire(sac):</span>
<span id="cb16-2"><a href="#cb16-2"></a>    x <span class="op">=</span> sac[<span class="dv">0</span>]</span>
<span id="cb16-3"><a href="#cb16-3"></a>    <span class="kw">del</span> sac[<span class="dv">0</span>]</span>
<span id="cb16-4"><a href="#cb16-4"></a>    <span class="cf">return</span> x</span></code></pre></div>
<p></div></p>
<ul>
<li>C’est anecdotique, mais pour retirer un élément au hasard, il faut choisir un indice <code>i</code>, renvoyer l’élément qui s’y trouve en le supprimant du sac avec <code>del s[i]</code> :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="im">from</span> random <span class="im">import</span> randint</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">def</span> retire(sac):</span>
<span id="cb17-3"><a href="#cb17-3"></a>    i <span class="op">=</span> randint(<span class="bu">len</span>(sac))</span>
<span id="cb17-4"><a href="#cb17-4"></a>    x <span class="op">=</span> sac[i]</span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="kw">del</span> sac[i]</span>
<span id="cb17-6"><a href="#cb17-6"></a>    <span class="cf">return</span> x</span></code></pre></div>
<p></div></p>
<p>Si on peut supposer que les quatre premières opérations sont en temps constant, les deux dernières sont linéaire en le nombre de sommets dans le sac. Ce qui est assez coûteux.</p>
<p>En effet, le parcours quelconque va accéder en pire cas à chaque sommet et à chaque liste d’adjacence et ajouter chaque sommet dans le sac. Donc, une complexité en <span class="math inline">\(O(|S| + |A| + |S| f(|S|))\)</span> où <span class="math inline">\(f(n)\)</span> est la complexité du retrait dans un sac de taille <span class="math inline">\(n\)</span>.</p>
<p>On obtient donc <span class="math inline">\(O(|S| + |A|)\)</span> en LIFO mais <span class="math inline">\(O(|S|^2)\)</span> en FIFO car <span class="math inline">\(|A| = O(|S|^2)\)</span> vu que <span class="math inline">\(A \subset S^2\)</span>.</p>
<p>En <code>Python</code>, il est possible d’avoir une file (<code>queue</code> en anglais) permettant de réaliser le retrait FIFO en <span class="math inline">\(O(1)\)</span> :</p>
<ul>
<li>On importe le type <code>deque</code> : <code>from collections import deque</code></li>
<li>On crée une file vide avec <code>s = deque()</code></li>
<li>On ajoute un élément <code>x</code> avec <code>s.append(x)</code></li>
<li>Mais on dispose d’un fonction efficace <code>s.popleft()</code> pour retirer le premier élément.</li>
</ul>
<p>En fait, on dispose également d’un <code>appendleft</code> et du <code>pop</code>. Toutes ces opérations étant en <span class="math inline">\(O(1)\)</span>.</p>
<p>Dans l’implémentation précédente, il suffit donc de remplacer les deux fonctions suivantes :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">def</span> sac_vide():</span>
<span id="cb18-2"><a href="#cb18-2"></a>    <span class="cf">return</span> deque()</span>
<span id="cb18-3"><a href="#cb18-3"></a></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="kw">def</span> est_vide(sac):</span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="cf">return</span> <span class="bu">len</span>(sac) <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb18-6"><a href="#cb18-6"></a></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="kw">def</span> ajoute(sac, x):</span>
<span id="cb18-8"><a href="#cb18-8"></a>    sac.append(x)</span>
<span id="cb18-9"><a href="#cb18-9"></a></span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="kw">def</span> retire(sac):</span>
<span id="cb18-11"><a href="#cb18-11"></a>    <span class="cf">return</span> sac.popleft()</span></code></pre></div>
<p></div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p><div class="ui label">     OI<div class="detail">Sup</div> </div></p>
<p>La structure de donnée <code>deque</code> est une liste doublement chaînée. Elle permet de remonter dans la chaîne d’un maillon vers le maillon dont il est le suivant.</p>
<p></div></p>
<p>En pratique, on pourra définir des fonctions de parcours utilisant directement les bonnes structures :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">def</span> parcours_profondeur(ladj, source):</span>
<span id="cb19-2"><a href="#cb19-2"></a>    a_traiter <span class="op">=</span> [ source ]</span>
<span id="cb19-3"><a href="#cb19-3"></a>    marque <span class="op">=</span> [ <span class="va">False</span> ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb19-4"><a href="#cb19-4"></a></span>
<span id="cb19-5"><a href="#cb19-5"></a>    <span class="cf">while</span> a_traiter <span class="op">!=</span> []</span>
<span id="cb19-6"><a href="#cb19-6"></a>        x <span class="op">=</span> a_traiter.pop()</span>
<span id="cb19-7"><a href="#cb19-7"></a>        <span class="cf">if</span> <span class="kw">not</span> marque[x]:</span>
<span id="cb19-8"><a href="#cb19-8"></a>            marque[x] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb19-9"><a href="#cb19-9"></a>            <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb19-10"><a href="#cb19-10"></a>                a_traiter.append(y)</span>
<span id="cb19-11"><a href="#cb19-11"></a></span>
<span id="cb19-12"><a href="#cb19-12"></a><span class="co"># à placer en début du programme :</span></span>
<span id="cb19-13"><a href="#cb19-13"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb19-14"><a href="#cb19-14"></a></span>
<span id="cb19-15"><a href="#cb19-15"></a><span class="kw">def</span> parcours_largeur(ladj, source):</span>
<span id="cb19-16"><a href="#cb19-16"></a>    a_traiter <span class="op">=</span> deque([ source ])</span>
<span id="cb19-17"><a href="#cb19-17"></a>    marque <span class="op">=</span> [ <span class="va">False</span> ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb19-18"><a href="#cb19-18"></a></span>
<span id="cb19-19"><a href="#cb19-19"></a>    <span class="cf">while</span> <span class="bu">len</span>(a_traiter) <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb19-20"><a href="#cb19-20"></a>        x <span class="op">=</span> a_traiter.popleft()</span>
<span id="cb19-21"><a href="#cb19-21"></a>        <span class="cf">if</span> <span class="kw">not</span> marque[x]:</span>
<span id="cb19-22"><a href="#cb19-22"></a>            marque[x] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb19-23"><a href="#cb19-23"></a>            <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb19-24"><a href="#cb19-24"></a>                a_traiter.append(y)</span></code></pre></div>
<p></div></p>
<h2 data-number="4.4" id="sec:parcours-en-largeur"><span class="header-section-number">4.4</span> Parcours en largeur</h2>
<p>On va vu que le parcours quelconque en FIFO s’appelait le parcours en largeur. Il permet de parcourir les sommets d’un graphe en rayonnant à partir du sommet source. En effet on traite d’abord :</p>
<ul>
<li>le sommet source <span class="math inline">\(src\)</span></li>
<li>les voisins de <span class="math inline">\(src\)</span></li>
<li>les voisins des voisins de <span class="math inline">\(src\)</span></li>
<li><span class="math inline">\(\dots\)</span></li>
</ul>
<p>Pour pouvoir parler de chemins, il est nécessaire d’introduire une notion de parenté. Pour cela, on a deux possibilités.</p>
<ul>
<li>Soit on n’ajoute plus des sommets dans le sac mais des couples (sommet, parent) qui correspondent a une arête de découverte :</li>
</ul>
<div class="ui message gray">
<div class="header">
Algorithme - parcours quelconque avec couples
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe <span class="math inline">\(G = (S,A)\)</span></li>
<li>Un somme <span class="math inline">\(s \in S\)</span> source du parcours</li>
</ul>
</div>
<ul>
<li>On crée un sac ne contenant que <span class="math inline">\((s, s)\)</span></li>
<li>Tant que le sac est non vide
<ul>
<li>On tire un couple <span class="math inline">\((x, p)\)</span> du sac
<ul>
<li>Si <span class="math inline">\(x\)</span> est non marqué
<ul>
<li>On indique que <span class="math inline">\(parent[x] = p\)</span></li>
<li>pour chaque <span class="math inline">\(x \rightarrow y \in A\)</span>
<ul>
<li>On ajoute <span class="math inline">\((y, x)\)</span> dans le sac</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<ul>
<li>Soit on modifie le parcours <em>quelconque</em> pour en déduire un parcours quelconque qui a l’air a priori d’être <em>optimisé</em>.</li>
</ul>
<div class="ui message gray">
<div class="header">
Algorithme - parcours quelconque <em>optimisé</em>
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe <span class="math inline">\(G = (S,A)\)</span></li>
<li>Un somme <span class="math inline">\(s \in S\)</span> source du parcours</li>
</ul>
</div>
<ul>
<li>On crée un sac ne contenant que <span class="math inline">\(s\)</span></li>
<li>Tant que le sac est non vide
<ul>
<li>On tire un sommet <span class="math inline">\(x\)</span> du sac
<ul>
<li>pour chaque <span class="math inline">\(x \rightarrow y \in A\)</span>
<ul>
<li>Si <span class="math inline">\(y\)</span> est non marqué
<ul>
<li>On indique que <span class="math inline">\(parent[y] = x\)</span></li>
<li>On ajoute y dans le sac</li>
<li>On marque <span class="math inline">\(y\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On va reprendre l’exemple précédent</p>
<p><img src="assets/pics/quelex.png" /></p>
<p>On obtient avec un parcours en largeur le schéma suivant :</p>
<p><img src="assets/pics/quelexlargeur.png" /></p>
<p>où on a noté les arêtes de parenté ainsi que d’une même couleur les éléments à égale distance de <span class="math inline">\(a\)</span> dans le parcours en largeur.</p>
<p>On remarque qu’on a obtenu le chemin <span class="math inline">\(a \rightarrow c \rightarrow f\)</span> là où un parcours en profondeur aurait pu donner le chemin plus long <span class="math inline">\(a \rightarrow d \rightarrow g \rightarrow f\)</span>.</p>
</div>
<p>Comme semble le suggérer l’exemple précédent, on peut démontrer le théorème suivant :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Les chemins donnés par un parcours en largeur depuis <span class="math inline">\(x\)</span> sont de plus petite longueur :</p>
<p>Si <span class="math inline">\(\varphi : x\leadsto y\)</span> est donné par le parcours, alors <span class="math inline">\(\forall \psi : x \leadsto y\)</span>, <span class="math inline">\(|\psi| \ge |\varphi|\)</span>.</p>
</div>
<h3 data-number="4.4.1" id="sec:preuve"><span class="header-section-number">4.4.1</span> Preuve</h3>
<p><div class="ui label">     OI<div class="detail">Spé</div> </div><div class="ui label">     MP2I<div class="detail">S2</div> </div></p>
<h2 data-number="4.5" id="sec:pseudo-parcours-en-profondeur"><span class="header-section-number">4.5</span> Pseudo-parcours en profondeur</h2>
<p>On peut se poser la question de la nature du parcours quelconque optimisé effectué avec une stratégie LIFO. Naïvement, on peut penser qu’il s’agit d’un parcours en profondeur. Cependant, si on considère le graphe :</p>
<p><img src="assets/pics/pseudoprof1.png" /></p>
<p>On va avoir les deux arbres différents suivants :</p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>Avec un parcours en profondeur :</p>
<p><img src="assets/pics/pseudoprof2.png" /></p>
<p></div><div class="eight wide column"></p>
<p>Avec un pseudo-parcours en profondeur :</p>
<p><img src="assets/pics/pseudoprof3.png" /></p>
<p></div></div></div></p>
<p>On perd une propriété fondamentale du parcours en profondeur qui est de qu’un parent ne peut empecher un de ses enfants de découvrir un sommet. Ici, dans le pseudo-parours, <span class="math inline">\(a\)</span> bloque la découverte de <span class="math inline">\(c\)</span> par <span class="math inline">\(b\)</span>.</p>
<div class="ui message orange">
<div class="header">
Exercice
</div>
<p>Montrer qu’il n’existe aucune stratégie permettant au parcours quelconque <em>optimisé</em> d’être un parcours en profondeur.</p>
</div>
<h1 data-number="5" id="sec:tri-topologique"><span class="header-section-number">5</span> Tri topologique</h1>
<p>Un cas très important de graphes orientés est celui de graphes de dépendances :</p>
<ul>
<li>les sommets sont des tâches à réaliser</li>
<li>Une arête <span class="math inline">\(x \rightarrow y\)</span> indique la tâche <span class="math inline">\(x\)</span> doit être réalisée avant la tâche <span class="math inline">\(y\)</span>.</li>
</ul>
<p>Citons, par exemple, les dépendances entre chapitres dans un cours, entre unités de programme lors d’une compilation, entre produits dans un procédé industriel…</p>
<p>Ces graphes ont tous la particularité d’être orienté et acycliques. En effet, si on a un cycle, cela signifie qu’il y a une dépendance inextricable.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On parle en anglais de <strong>DAG</strong> pour <em>directed acyclic graph</em>.</p>
<p></div></p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G = (S, A)\)</span> un graphe orienté acyclique. Une énumération <span class="math inline">\((x_1, \dots, x_n)\)</span> des sommets de <span class="math inline">\(S\)</span> est appelée un <strong>tri topologique</strong> lorsque pour toute arête <span class="math inline">\(x_i \rightarrow x_j\)</span> on a <span class="math inline">\(i &lt; j\)</span>. </div></p>
<p>Autrement dit, un tri topologique est un ordre linéaire de traitement des tâches respectant les dépendances.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(G\)</span> un graphe orienté acyclique et <span class="math inline">\(x_1, \dots, x_p\)</span> les sommets de degré entrant nuls de <span class="math inline">\(G\)</span>.</p>
<p>Si on effectue plusieurs parcours en profondeur récursifs depuis chacun des <span class="math inline">\(x_i\)</span> avec la même horloge, alors les sommets triés dans l’ordre décroissant des temps de sortie constituent un un tri topologique de <span class="math inline">\(G\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> Il suffit de vérifier que si <span class="math inline">\(x \rightarrow y\)</span> n’est pas une arête arrière, alors <span class="math inline">\(t_s(x) \ge t_s(y)\)</span> où <span class="math inline">\(t_s(x)\)</span> est le temps de sortie de <span class="math inline">\(x\)</span>. </div> </div></p>
<h1 data-number="6" id="sec:plus-courts-chemins"><span class="header-section-number">6</span> Plus courts chemins</h1>
<h2 data-number="6.1" id="sec:graphes-pondérés-et-définition-du-problème"><span class="header-section-number">6.1</span> Graphes pondérés et définition du problème</h2>
<p><div class="ui message"><div class="header">Définition</div> Un graphe pondéré est la donnée d’un graphe, orienté ou non, <span class="math inline">\(G = (S,A)\)</span> et d’une fonction de pondération <span class="math inline">\(\pi : A \rightarrow \R\)</span> qui associe à chaque arête un nombre réel, son poids. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>En informatique pratique, <span class="math inline">\(\R\)</span> n’existe pas vraiment. Les poids seront donc le plus souvent des entiers ou des flottants. Cependant, les problèmes possiblement rencontrés par des poids réels sont pertinents et le cadre unifié rend les définitions plus simples.</p>
<p></div></p>
<p><div class="ui message"><div class="header">Définition</div> On définit le poids d’un chemin <span class="math inline">\(\varphi\)</span> comme la somme des poids de ses arêtes. </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Dans le graphe suivant : <img src="assets/pics/poids_ex1.png" /> le chemin <span class="math inline">\(\varphi = c \rightarrow b \rightarrow d \rightarrow a\)</span> est de poids $() = <span class="math inline">\(0 - 1 -1 = -2\)</span>.</p>
<p>On remarque que <span class="math inline">\(b \rightarrow d \rightarrow a \rightarrow b\)</span> est un cycle de poids <span class="math inline">\(-1\)</span>, on peut donc l’emprunter autant de fois qu’on le souhaite sur un chemin passant par <span class="math inline">\(a,b\)</span> ou <span class="math inline">\(d\)</span> et faire diminuer son poids autant qu’on le souhaite. On parle de cycle de poids négatif et leur présence est problématique.</p>
</div>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Si <span class="math inline">\(G\)</span> est un graphe pondéré <strong>sans cycles de poids négatif</strong>, <span class="math inline">\(\varphi\)</span> est un chemin et <span class="math inline">\(\psi\)</span> est un sous-chemin de <span class="math inline">\(\varphi\)</span> obtenu en enlevant un cycle, alors <span class="math inline">\(\pi(\varphi) \ge \pi(\psi)\)</span>.</p>
</div>
<p>Du théorème précédent, on en déduit que pour obtenir un chemin de poids minimum, on peut supposer que le chemin est simple. Or, comme il existe un nombre fini de chemins simples entre deux sommets, on peut en déduire la définition suivante :</p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G = (S,A,\pi)\)</span> un graphe pondéré <strong>sans cycles de poids négatifs</strong> et <span class="math inline">\(x, y \in S\)</span> tels que <span class="math inline">\(x \leadsto y\)</span>, on appelle plus court chemin de <span class="math inline">\(x\)</span> à <span class="math inline">\(y\)</span>, un chemin <span class="math inline">\(\varphi : x \leadsto y\)</span> tel que <span class="math display">\[
\pi(\varphi) = \min \enscomp{\pi(\psi)}{\psi : x \leadsto y}
\]</span> </div></p>
<p>Il est possible de travailer avec la complétion d’un graphe pondéré en considérant toutes les arêtes possibles mais en spécifiant que si <span class="math inline">\(x \rightarrow y\)</span> n’est pas une arête du graphe initial, alors <span class="math inline">\(\pi(x \rightarrow y) = \infty\)</span>. On peut alors poser pour tout couple <span class="math inline">\((x,y) \in S\)</span>, <span class="math inline">\(dist(x,y) = \min \enscomp{\pi(\psi)}{\psi : x \leadsto y}\)</span> sachant que cette distance vaut <span class="math inline">\(\infty\)</span> lorsque <span class="math inline">\(y\)</span> n’est pas accessible depuis <span class="math inline">\(x\)</span>.</p>
<p>On va s’intéresser à deux problèmes :</p>
<div class="ui message gray">
<div class="header">
Problème - PlusCourtCheminSource
</div>
<ul>
<li>
<p>Entrée(s) :</p>
<ul>
<li>Un graphe pondéré <span class="math inline">\(G = (S,A,\pi)\)</span></li>
<li>Un sommet source <span class="math inline">\(s \in S\)</span></li>
</ul>
</li>
<li>
<p>Sortie :</p>
<ul>
<li>La donnée pour chaque <span class="math inline">\(x \in S\)</span>, de la valeur <span class="math inline">\(dist(s,x)\)</span>.</li>
<li>Éventuellement, un chemin <span class="math inline">\(\varphi : s \leadsto x\)</span> réalisant cette distance.</li>
</ul>
</li>
</ul>
</div>
<div class="ui message gray">
<div class="header">
Problème - PlusCourtCheminToutCouple
</div>
<ul>
<li>
<p>Entrée(s) :</p>
<ul>
<li>Un graphe pondéré <span class="math inline">\(G = (S,A,\pi)\)</span></li>
</ul>
</li>
<li>
<p>Sortie :</p>
<ul>
<li>La donnée pour chaque couple <span class="math inline">\(x, y \in S\)</span>, de la valeur <span class="math inline">\(dist(x,y)\)</span>.</li>
<li>Éventuellement, un chemin <span class="math inline">\(\varphi : x \leadsto y\)</span> réalisant cette distance.</li>
</ul>
</li>
</ul>
</div>
<p>Le premier problème est naturellement inclus dans le second.</p>
<h2 data-number="6.2" id="sec:cas-des-poids-rationnels"><span class="header-section-number">6.2</span> Cas des poids rationnels</h2>
<p>Il se trouve qu’on a déjà trouvé un algorithme permettant de résoudre le problème quand <span class="math inline">\(\forall e \in A, \pi(e) = 1\)</span> : le <strong>parcours en largeur</strong>.</p>
<p>Si les poids sont dans <span class="math inline">\(\Q_+^*\)</span>, on peut se ramener à des poids dans <span class="math inline">\(\N^*\)</span> en multipliant chaque poids par le ppcm des dénominateurs des poids. Cela ne change pas la relation d’ordre entre les poids de chemins, et on peut donc les plus courts chemins sont les mains.</p>
<p>Si <span class="math inline">\(\pi(x \rightarrow y) = k &gt; 1\)</span>, on peut rajouter <span class="math inline">\(k-1\)</span> sommets artificiels <span class="math inline">\(z_1, \dots, z_{k-1}\)</span> et des arêtes de poids unitaire <span class="math inline">\(x \rightarrow z_1 \rightarrow z_2 \rightarrow \dots \rightarrow z_k\)</span> à la place de l’arête <span class="math inline">\(x \rightarrow y\)</span>. En procédant ainsi, on se ramène donc à un graphe dont les poids sont unitaires et on peut résoudre le problème avec un parcours en largeur.</p>
<p>Si on considère que la longueur des poids en mémoire fait partie de l’entrée, alors cette réduction a l’air très coûteuse, mais si on considère qu’ils sont constants en espace, alors toute cette réduction ne fait que grossir la constante du <span class="math inline">\(O(|S|+|A|)\)</span> !</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>On pourrait être tenté de supprimer les poids négatifs en ajoutant une constante à chaque poids, cependant, en faisant cela, on pénalise les chemins en fonction de leur longueur et on ne préserve pas la notion de plus court chemin.</p>
<p>Considérons par exemple le graphe :</p>
<p><img src="assets/pics/poidsneg_cex1.png" /> Le chemin le plus court entre <span class="math inline">\(a\)</span> et <span class="math inline">\(c\)</span> est de poids <span class="math inline">\(2\)</span> et est le chemin <span class="math inline">\(a \rightarrow b \rightarrow c\)</span>.</p>
<p>Si on ajoute 5 à chaque poids pour qu’ils soient <span class="math inline">\(&gt;0\)</span>, on obtient le graphe : <img src="assets/pics/poidsneg_cex2.png" /> Et ici, le chemin le plus court devient <span class="math inline">\(a \rightarrow c\)</span> de poids <span class="math inline">\(9\)</span> et non plus <span class="math inline">\(a \rightarrow b \rightarrow c\)</span> qui devient de poids <span class="math inline">\(10\)</span>.</p>
<p>Plus généralement, si on ajoute <span class="math inline">\(\eta\)</span> à chaque poids, alors le poids de <span class="math inline">\(\varphi\)</span> devient <span class="math inline">\(\pi(\varphi) + \eta |\varphi|\)</span> qui n’est pas croissante sur les chemins ordonnés par poids.</p>
<p></div></p>
<h2 data-number="6.3" id="sec:relaxation"><span class="header-section-number">6.3</span> Relaxation</h2>
<p>On se concentre ici sur le problème <code>PlusCourtCheminSource</code>.</p>
<p>Si <span class="math inline">\(G = (S,A,\pi)\)</span> est un graphe pondéré et <span class="math inline">\(s \in S\)</span>, on considère un étiquettage <span class="math inline">\(d : S \rightarrow \R \cup \{ \infty \}\)</span> qu’on va faire évoluer dans un algorithme et tel que <span class="math inline">\(d(x)\)</span> représente le plus petit poids trouvé jusqu’ici d’un chemin entre <span class="math inline">\(s\)</span> et <span class="math inline">\(x\)</span>.</p>
<p>Au départ, on pose <span class="math inline">\(d(s) = 0\)</span> et <span class="math inline">\(\forall x \in S \backslash \{ s \}, d(x) = \infty\)</span>.</p>
<p><div class="ui message"><div class="header">Définition</div> On dit qu’une arête <span class="math inline">\(x \rightarrow y\)</span> est <strong>tendue</strong> si <span class="math display">\[d(y) &gt; d(x) + \pi(x \rightarrow y)\]</span></p>
<p>Quand on pose ensuite <span class="math inline">\(d(y) = d(x) + \pi(x \rightarrow y)\)</span> on dit qu’on <strong>relâche l’arête</strong>. </div></p>
<p>Ainsi, une arête est tendue quand on peut l’emprunter pour améliorer l’estimation du plus petit chemin de <span class="math inline">\(s\)</span> à <span class="math inline">\(y\)</span>.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Si aucune arête n’est tendue, alors <span class="math inline">\(d(x) = dist(s, x)\)</span> (avec <span class="math inline">\(=\infty\)</span> si inaccessible).</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> Par l’absurde, considérons <span class="math inline">\(x\)</span> tel que <span class="math inline">\(d(x) &gt; dist(s,x)\)</span> où <span class="math inline">\(dist(s, x)\)</span> est minimale parmi les contre-exemples, alors <span class="math inline">\(s \leadsto x\)</span> et soit <span class="math inline">\(\varphi\)</span> un chemin de longueur minimale.</p>
<p>Soit <span class="math inline">\(y\)</span> le prédécesseur de <span class="math inline">\(x\)</span> dans ce chemin, on a donc un chemin <span class="math inline">\(\varphi = \psi y \rightarrow x_0\)</span> où <span class="math inline">\(\psi : s \leadsto y\)</span>. Nécessairement, le chemin <span class="math inline">\(\psi\)</span> et minimal car restriction d’un chemin minimal. Donc, son poids est <span class="math inline">\(\pi(\psi) = dist(s, y) = d(y)\)</span> par hypothèse de minimalité de <span class="math inline">\(x\)</span>.</p>
<p>On a alors <span class="math inline">\(dist(s, x) = d(y) + \pi(y \rightarrow x) &lt; d(x)\)</span>. L’arête <span class="math inline">\(y \rightarrow x\)</span> est donc tendue.</p>
<p>Contradiction. </div> </div></p>
<p>On en deduit un pseudo-algorithme appelé <em>méthode de relaxation</em> :</p>
<div class="ui message gray">
<div class="header">
Algorithme - Relaxation
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe pondéré <span class="math inline">\(G = (S,A,\pi)\)</span> sans cycle de poids négatif</li>
<li>Un sommet <span class="math inline">\(s \in S\)</span></li>
</ul>
</div>
<ul>
<li>On pose <span class="math inline">\(d\)</span> tel que <span class="math inline">\(d(s) = 0\)</span> et <span class="math inline">\(\forall x \in S \backslash \{ s \}, d(x) = \infty\)</span>.</li>
<li>Tant qu’il existe une arête <span class="math inline">\(e\)</span> tendue
<ul>
<li>On relâche l’arête <span class="math inline">\(e\)</span></li>
</ul></li>
</ul>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<ul>
<li><p>On montre par récurrence sur le nombre d’itérations que si <span class="math inline">\(d(x) &lt; \infty\)</span> alors <span class="math inline">\(d(x)\)</span> est le poids d’un chemin simple de <span class="math inline">\(s\)</span> à <span class="math inline">\(x\)</span>. Comme ces chemins simples sont en nombre finis, leur poids aussi et donc <span class="math inline">\(d\)</span> ne peut prendre qu’un nombre fini de valeurs, comme <span class="math inline">\(d\)</span> change à chaque itération, la boucle termine.</p></li>
<li><p>En présence d’un cycle négatif, on pourrait continuellement relacher les arêtes du cycle et donc l’algorithme ne termine pas.</p></li>
<li><p>En sortie de l’algorithme on a donc <span class="math inline">\(dist(s,x) \le dist(s,y) + \pi(y\rightarrow x)\)</span> pour toute arête <span class="math inline">\(y \rightarrow x\)</span>. Or, on a l’égalité pour un plus court chemin. On en déduit donc l’égalité <strong>très importante</strong> suivante :</p>
<p><span class="math display">\[
\forall x \in S \backslash \{ s \},
dist(s, x) = \min\enscomp{ dist(s,y) + \pi(y \rightarrow x) }{y \in S}
\]</span></p></li>
</ul>
<p></div></p>
<h2 data-number="6.4" id="sec:algorithme-de-dijkstra"><span class="header-section-number">6.4</span> Algorithme de Dijkstra</h2>
<p>Considérons le principe précédent de réalisation d’une estimation <span class="math inline">\(d\)</span> des distances. On peut effectuer un parcours quelconque avec une <strong>file de priorité</strong> où la priorité de <span class="math inline">\(x\)</span> est <span class="math inline">\(d(x)\)</span> et où on suppose qu’on extrait la priorité minimale.</p>
<p>Quand on retire un sommet <span class="math inline">\(x\)</span> de la file, si <span class="math inline">\(e = x \rightarrow y\)</span> alors soit l’arête est non tendue et alors <span class="math inline">\(d(y) \le d(x) + \pi(x \rightarrow y)\)</span> et par hypothèse cela signifie qu’on a un chemin simple de poids <span class="math inline">\(d(y)\)</span> qui est meilleur que de passer par <span class="math inline">\(x\)</span>. Cela signifie notamment que <span class="math inline">\(y\)</span> a déjà été traité à un moment par l’algorithme. Soit l’arête est tendue et passer par <span class="math inline">\(x\)</span> améliore le chemin vers <span class="math inline">\(y\)</span>. On relâche l’arête. On a alors deux possibilités : soit <span class="math inline">\(y\)</span> est dans la file, et on change sa priorité soit on l’insère dans la file.</p>
<p>En procédant ainsi, on obtient un algorithme qui implémente le pseudo-algorithme précédent :</p>
<div class="ui message gray">
<div class="header">
Algorithme - ProtoDijkstra
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe pondéré <span class="math inline">\(G = (S,A,\pi)\)</span> sans cycle négatif</li>
<li>Un sommet <span class="math inline">\(s \in S\)</span></li>
</ul>
</div>
<ul>
<li>On crée un tableau <code>d</code> avec <span class="math inline">\(d(s) = 0\)</span> et <span class="math inline">\(d(x) = \infty\)</span> pour <span class="math inline">\(x \neq s\)</span>.</li>
<li>On crée une file de min-priorité <code>a_traiter</code> et on ajoute <code>s</code> avec priorité <code>0</code></li>
<li>Tant que <code>a_traiter</code> est non vide
<ul>
<li>On retire le sommet <code>x</code> de <code>a_traiter</code></li>
<li>Pour chaque arête <span class="math inline">\(x \rightarrow y\)</span> tendue vis-à-vis de <span class="math inline">\(d\)</span>
<ul>
<li>On relâche l’arête dans <span class="math inline">\(d\)</span></li>
<li>Si <span class="math inline">\(y\)</span> est dans <code>a_traiter</code>
<ul>
<li>Alors, on remplace sa priorité par la nouvelle valeur de <span class="math inline">\(d(y)\)</span></li>
<li>Sinon, on insère <span class="math inline">\(y\)</span> avec priorité <span class="math inline">\(d(y)\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On présente ici un premier exemple uniquement avec des poids positifs.</p>
<p>On considère le graphe suivant pour <span class="math inline">\(s = 1\)</span> où les sommets sur la file sont indiqués en rouge et où la valeur de <span class="math inline">\(d\)</span> est donné dans le cadre à côté du sommet :</p>
<p><img src="assets/pics/dijkstra_ex1_.png" /></p>
<p>On commence par retirer 1 qui est seul dans la file avec <span class="math inline">\(d(1) = 0\)</span>. On peut alors relâcher chaque de ses arêtes et on place dans la file <span class="math inline">\(6, 3\)</span> et <span class="math inline">\(9\)</span> :</p>
<p><img src="assets/pics/dijkstra_ex2_.png" /></p>
<p>On retire alors le sommet 2 qui a la plus petite priorité. L’arête <span class="math inline">\(2 \rightarrow 15\)</span> est tendue mais pas l’arête <span class="math inline">\(2 \rightarrow 3\)</span>. On ajoute donc 4 dans la file :</p>
<p><img src="assets/pics/dijkstra_ex3_.png" /></p>
<p>On retire alors 3 de la file et on voit que les deux arêtes <span class="math inline">\(3 \rightarrow 6\)</span> et <span class="math inline">\(3 \rightarrow 4\)</span> sont tendues. On peut donc les relâcher et changer les liens de parenté dans l’arbre du parcours :</p>
<p><img src="assets/pics/dijkstra_ex4_.png" /></p>
<p>On retire alors le sommet 6 qui relâche <span class="math inline">\(6 \rightarrow 5\)</span> qui rajoute 5 à la file:</p>
<p><img src="assets/pics/dijkstra_ex5_.png" /></p>
<p>Aucune arête étant tendue, on peur traiter les deux derniers sommets :</p>
<p><img src="assets/pics/dijkstra_ex6_.png" /></p>
</div>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>L’exemple suivant permet d’observer l’algorithme sur un graphe comportant des poids négatifs. On a indiqué en rouge les sommets sur la file et en rose le sommet actuellement traité. Les arêtes de parentés sont présentées comme dans l’exemple précédent à mesure qu’elles sont modifiées.</p>
<p>On va ainsi partir du graphe suivant et du sommet source <span class="math inline">\(a\)</span> : <center><div class="ui image center"><img src="assets/pics/dijkstra_neg_depart.png" /></div></center></p>
<p><img src="assets/pics/dijkstra_neg0.png" /> <img src="assets/pics/dijkstra_neg1.png" /> <img src="assets/pics/dijkstra_neg2.png" /></p>
<p><img src="assets/pics/dijkstra_neg3.png" /> <img src="assets/pics/dijkstra_neg4.png" /> <img src="assets/pics/dijkstra_neg5.png" /></p>
<p><img src="assets/pics/dijkstra_neg6.png" /> <img src="assets/pics/dijkstra_neg7.png" /> <img src="assets/pics/dijkstra_neg8.png" /></p>
<p><img src="assets/pics/dijkstra_neg9.png" /> <img src="assets/pics/dijkstra_neg10.png" /> <img src="assets/pics/dijkstra_neg11.png" /></p>
<p><img src="assets/pics/dijkstra_neg12.png" /> <img src="assets/pics/dijkstra_neg13.png" /></p>
</div>
<p>Contrairement au second exemple, on constate que le premier se comporte particulièrement bien et d’une manière assez proche du parcours en largeur. Notamment, un sommet n’est placé qu’une fois sur la file de priorité. On constate donc une vague de traitement qui progresse linéairement sur le graphe.</p>
<p>On peut donc se permettre de ne pas avoir à implémenter l’opération assez pénible de mise à jour de la priorité.</p>
<p><div class="ui message orange"><div class="header">Remarque</div></p>
<p>Cette opération n’est pas vraiment compliquée en raison du tas car il suffit de changer la valeur et de faire remonter l’élèment le long de sa branche en direction de la racine en cas d’inversion de priorité. Le problème est qu’on a besoin de préserver un lien entre les sommets et leur emplacement dans le tas afin de savoir où est le nœud qui le contient. Le plus simple est de rajouter un dictionnaire, par exemple avec une table de hachage, mais cela alourdit conséquemment l’implémentation du tas car il faut maintenir l’intégrité du dictionnaire.</p>
<p></div></p>
<p>A la place, on va ajouter un sommet avec une autre priorité, meilleure, et il sera ainsi retiré avant. Pour ne pas traiter deux fois un sommet, on adopte alors une notion de marquage comme dans les parcours précédents. On en déduit l’algorithme de Dijkstra :</p>
<div class="ui message gray">
<div class="header">
Algorithme - Dijkstra
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe pondéré <span class="math inline">\(G = (S,A,\pi)\)</span> où <span class="math inline">\(\pi : A \rightarrow \R_+\)</span></li>
<li>Un sommet <span class="math inline">\(s \in S\)</span></li>
</ul>
</div>
<ul>
<li>On crée un tableau <code>d</code> avec <span class="math inline">\(d(s) = 0\)</span> et <span class="math inline">\(d(x) = \infty\)</span> pour <span class="math inline">\(x \neq s\)</span>.</li>
<li>On crée une file de min-priorité <code>a_traiter</code> et on ajoute <code>s</code> avec priorité <code>0</code></li>
<li>Les sommets sont initialement non marqués</li>
<li>Tant que <code>a_traiter</code> est non vide
<ul>
<li>On retire le sommet <code>x</code> de <code>a_traiter</code></li>
<li>Si <code>x</code> est non marqué
<ul>
<li>On marque <code>x</code></li>
<li>Pour chaque arête <span class="math inline">\(x \rightarrow y\)</span> tendue vis-à-vis de <span class="math inline">\(d\)</span>
<ul>
<li>On relâche l’arête dans <span class="math inline">\(d\)</span></li>
<li>On insère <span class="math inline">\(y\)</span> avec priorité <span class="math inline">\(d(y)\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<h2 data-number="6.5" id="sec:floyd-warshall"><span class="header-section-number">6.5</span> Floyd-Warshall</h2>
<p>Pour résoudre le problème PlusCourtCheminToutCouple, l’algorithme de Floyd-Warshall va considérer une énumération <span class="math inline">\(x_1, \dots, x_n\)</span> des sommets du graphe et construire une famille de matrices <span class="math inline">\(dist^{(k)}\)</span> où <span class="math inline">\(dist^{(k)}(i, j)\)</span> indique le poids d’un plus court chemin de <span class="math inline">\(i\)</span> à <span class="math inline">\(j\)</span> <strong>dont les sommets intermédiaires</strong> sont dans <span class="math inline">\(x_1, \dots, x_k\)</span> lorsqu’un tel chemin existe, et <span class="math inline">\(\infty\)</span> sinon.</p>
<p>On a donc <span class="math inline">\(dist^{(0)}(x, y) = \begin{cases} \pi(x \rightarrow y) \text{ si } x \rightarrow y \in A \\ \infty \text{ sinon} \end{cases}\)</span>.</p>
<p>On remarque rapidement, <strong>en l’absence de cycle négatif</strong>, que ces matrices vérifient l’égalité, pour <span class="math inline">\(k &gt; 0\)</span> :</p>
<p><span class="math display">\[
dist^{(k)}(i,j) = \min\left(
dist^{(k-1)}(i,j), dist^{(k-1)}(i,k) + dist^{(k-1)}(k,j)
\right)
\]</span> En effet, un plus court chemin étant nécessairement simple, soit il ne passe pas par <span class="math inline">\(k\)</span>, soit il passe exactement une fois par <span class="math inline">\(k\)</span>.</p>
<p>On en déduit un algorithme consistant à calculer ces <span class="math inline">\(n+1\)</span> matrices et les calculer avec trois boucles for imbriquées.</p>
<p>Il est possible de démontrer que le calcul peut s’effectuer en place au sein d’une unique matrice. On en déduit l’algorithme suivant :</p>
<div class="ui message gray">
<div class="header">
Algorithme - Floyd-Warshall
</div>
<div class="ui message gray">
<div class="header">
Entrée(s)
</div>
<ul>
<li>Un graphe pondéré <span class="math inline">\(G = (S,A,\pi)\)</span> et une énumération <span class="math inline">\(x_1, \dots, x_n\)</span> de <span class="math inline">\(S\)</span></li>
</ul>
</div>
<ul>
<li>On initialise une matrice <span class="math inline">\(d\)</span> telle que <span class="math inline">\(d(i,j) = \pi(i\rightarrow j)\)</span> si <span class="math inline">\(i \rightarrow j \in A\)</span> et <span class="math inline">\(= \infty\)</span> sinon</li>
<li>Pour k allant de 1 à n
<ul>
<li>Pour i allant de 1 à n
<ul>
<li>Pour j allant de 1 à n
<ul>
<li><span class="math inline">\(d(i,j) = \min(d(i,j), d(i,k)+d(k,j))\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<p>La matrice renvoyée vérifie ainsi <span class="math inline">\(d(i,j) = dist(x_i,x_j)\)</span>.</p>
<h1 data-number="7" id="sec:travaux-pratiques"><span class="header-section-number">7</span> Travaux Pratiques</h1>
<h2 data-number="7.1" id="sec:parcours-de-graphes-en-c"><span class="header-section-number">7.1</span> Parcours de graphes en <code>C</code></h2>
<h3 data-number="7.1.1" id="sec:représentation"><span class="header-section-number">7.1.1</span> Représentation</h3>
<p>On va considérer le type suivant pour les graphes qui suppose qu’on n’aura jamais plus que <code>MAXV</code> sommets. On utilise ici une constante avec l’alias <code>#define</code> : partout où on écrit <code>MAXV</code>, il sera remplacé par la valeur 100.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1"></a><span class="pp">#define MAXV 100 </span><span class="co">/* nombre maximum de sommets */</span></span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="kw">struct</span> edgenode <span class="op">{</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="dt">int</span> y<span class="op">;</span> <span class="co">// le voisin</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>    <span class="kw">struct</span> edgenode <span class="op">*</span>next<span class="op">;</span> <span class="co">// la suite de la liste</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="op">};</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="kw">typedef</span> <span class="kw">struct</span> edgenode edgenode<span class="op">;</span></span>
<span id="cb20-8"><a href="#cb20-8"></a></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="kw">struct</span> graph <span class="op">{</span></span>
<span id="cb20-10"><a href="#cb20-10"></a>    edgenode <span class="op">*</span>edges<span class="op">[</span>MAXV<span class="op">];</span> <span class="co">// tableau de listes d&#39;adjacence</span></span>
<span id="cb20-11"><a href="#cb20-11"></a>    <span class="dt">int</span> degree<span class="op">[</span>MAXV<span class="op">];</span> <span class="co">// le degré de chaque sommet</span></span>
<span id="cb20-12"><a href="#cb20-12"></a>    <span class="dt">int</span> nvertices<span class="op">;</span></span>
<span id="cb20-13"><a href="#cb20-13"></a>    <span class="dt">int</span> nedges<span class="op">;</span></span>
<span id="cb20-14"><a href="#cb20-14"></a>    <span class="dt">bool</span> directed<span class="op">;</span> <span class="co">// indique si le graphe est orienté</span></span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="op">};</span></span>
<span id="cb20-16"><a href="#cb20-16"></a><span class="kw">typedef</span> <span class="kw">struct</span> graph graph<span class="op">;</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1"></a><span class="dt">void</span> initialize_graph<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">bool</span> directed<span class="op">);</span></span></code></pre></div>
<p></div> qui initialise le graphe <code>g</code> passé par pointeur comme étant le graphe vide, dirigé ou non selon la valeur de <code>directed</code>.</p>
<p><strong>Attention</strong> vous êtes libres d’initialiser les listes d’adjancence à la liste vide ou de considérer que sera fait dans la fonction <code>read_graph</code> ci-dessous.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1"></a><span class="dt">void</span> initialize_graph<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">bool</span> directed<span class="op">)</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3"></a>    g<span class="op">-&gt;</span>directed <span class="op">=</span> directed<span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4"></a>    g<span class="op">-&gt;</span>nvertices <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>    g<span class="op">-&gt;</span>nedges <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> MAXV<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>    <span class="op">{</span></span>
<span id="cb22-8"><a href="#cb22-8"></a>        g<span class="op">-&gt;</span>edges<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb22-9"><a href="#cb22-9"></a>        g<span class="op">-&gt;</span>degree<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb22-10"><a href="#cb22-10"></a>    <span class="op">}</span></span>
<span id="cb22-11"><a href="#cb22-11"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1"></a><span class="dt">void</span> insert_edge<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">,</span> <span class="dt">bool</span> directed<span class="op">)</span></span></code></pre></div>
<p></div> qui insère une arête de x à y en considérant <code>g</code> comme orienté ou non selon <code>directed</code> <strong>et donc en ignorant</strong> <code>g-&gt;directed</code>.</p>
<p><strong>Attention</strong> il faudra prendre garde au fait que <code>g</code> soit orienté ou non. Dans le second cas, on représenté les arêtes comme dans un graphe orienté symétrique, donc il faut en ajouter deux. C’est la raison pour laquelle on utilise le paramètre <code>directed</code> plutôt que de consulter <code>g-&gt;directed</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1"></a><span class="dt">void</span> insert_edge<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">,</span> <span class="dt">bool</span> directed<span class="op">)</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>    edgenode <span class="op">*</span>edge <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>edgenode<span class="op">));</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>    edge<span class="op">-&gt;</span>y <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>    edge<span class="op">-&gt;</span>next <span class="op">=</span> g<span class="op">-&gt;</span>edges<span class="op">[</span>x<span class="op">];</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>    g<span class="op">-&gt;</span>edges<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> edge<span class="op">;</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>    <span class="cf">if</span> <span class="op">(!</span>directed<span class="op">)</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>        insert_edge<span class="op">(</span>g<span class="op">,</span> y<span class="op">,</span> x<span class="op">,</span> true<span class="op">);</span></span>
<span id="cb24-9"><a href="#cb24-9"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<p>Pour travailler sur des graphes, on va écrire une fonction permettant de lire un fichier contenant le graphe sous le format suivant :</p>
<ul>
<li>première ligne contenant trois entiers, le nombre de sommets n, le nombre d’arêtes p et 0 ou 1 selon que le graphe soit non orienté ou orienté</li>
<li>ensuite p lignes contenant deux entiers i et j et indiquant qu’il y a une arête de i vers j</li>
</ul>
<p>Par exemple :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1"></a><span class="dv">4</span> <span class="dv">5</span> <span class="dv">1</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="dv">0</span> <span class="dv">1</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="dv">0</span> <span class="dv">2</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="dv">1</span> <span class="dv">2</span></span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="dv">2</span> <span class="dv">3</span></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="dv">3</span> <span class="dv">1</span></span></code></pre></div>
<p></div> sera représenté par le graphe : <img src="assets/pics/tp_c_ex_fichier.png" /> <div class="ui message orange"><div class="header">Remarque</div></p>
<p>On va utiliser ici l’entrée standard, c’est-à-dire l’entrée de l’utilisateur depuis le terminal. Cependant, il est possible de rédiriger cette entrée depuis un fichier. En effet, si on appelle <div class="ui segment code"></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1"></a><span class="op">./</span>monprogramme <span class="op">&lt;</span> monfichier</span></code></pre></div>
<p></div> Alors l’entrée standard sera le contenu de <code>monfichier</code>. Cela permet de ne pas avoir à se préoccuper d’ouvrir de fichier et d’utiliser directement <code>scanf</code>.</p>
<p><strong>Rappel</strong> <code>scanf("%d %d", &amp;x, &amp;y);</code> va lire une ligne avec deux entiers et placer la valeur du premier dans <code>x</code> et la valeur du second dans <code>y</code>.</p>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1"></a><span class="dt">void</span> read_graph<span class="op">(</span>graph <span class="op">*</span>g<span class="op">)</span></span></code></pre></div>
<p></div> qui lit un graphe depuis l’entrée standard et le place dans <code>g</code> <strong>après l’avoir initialisé</strong>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1"></a><span class="dt">void</span> read_graph<span class="op">(</span>graph <span class="op">*</span>g<span class="op">)</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>    <span class="dt">int</span> directed<span class="op">;</span></span>
<span id="cb28-4"><a href="#cb28-4"></a>    initialize_graph<span class="op">(</span>g<span class="op">,</span> false<span class="op">);</span></span>
<span id="cb28-5"><a href="#cb28-5"></a>    scanf<span class="op">(</span><span class="st">&quot;%d %d %d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>g<span class="op">-&gt;</span>nvertices<span class="op">,</span> <span class="op">&amp;</span>g<span class="op">-&gt;</span>nedges<span class="op">,</span> <span class="op">&amp;</span>directed<span class="op">);</span></span>
<span id="cb28-6"><a href="#cb28-6"></a>    g<span class="op">-&gt;</span>directed <span class="op">=</span> directed <span class="op">==</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-7"><a href="#cb28-7"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> g<span class="op">-&gt;</span>nedges<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb28-8"><a href="#cb28-8"></a>    <span class="op">{</span></span>
<span id="cb28-9"><a href="#cb28-9"></a>        <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb28-10"><a href="#cb28-10"></a>        scanf<span class="op">(</span><span class="st">&quot;%d %d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span></span>
<span id="cb28-11"><a href="#cb28-11"></a>        insert_edge<span class="op">(</span>g<span class="op">,</span> x<span class="op">,</span> y<span class="op">,</span> g<span class="op">-&gt;</span>directed<span class="op">);</span></span>
<span id="cb28-12"><a href="#cb28-12"></a>    <span class="op">}</span></span>
<span id="cb28-13"><a href="#cb28-13"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1"></a><span class="dt">void</span> free_edges<span class="op">(</span>graph <span class="op">*</span>g<span class="op">)</span></span></code></pre></div>
<p></div> qui libère les listes d’adjacence.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1"></a><span class="dt">void</span> free_edges<span class="op">(</span>graph <span class="op">*</span>g<span class="op">)</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="op">{</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> g<span class="op">-&gt;</span>nvertices<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>    <span class="op">{</span></span>
<span id="cb30-5"><a href="#cb30-5"></a>        edgenode <span class="op">*</span>n <span class="op">=</span> g<span class="op">-&gt;</span>edges<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb30-6"><a href="#cb30-6"></a>        <span class="cf">while</span><span class="op">(</span>n <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb30-7"><a href="#cb30-7"></a>        <span class="op">{</span></span>
<span id="cb30-8"><a href="#cb30-8"></a>            edgenode <span class="op">*</span>temp <span class="op">=</span> n<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="cb30-9"><a href="#cb30-9"></a>            free<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb30-10"><a href="#cb30-10"></a>            n <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb30-11"><a href="#cb30-11"></a>        <span class="op">}</span></span>
<span id="cb30-12"><a href="#cb30-12"></a>    <span class="op">}</span></span>
<span id="cb30-13"><a href="#cb30-13"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<h3 data-number="7.1.2" id="sec:parcours-en-profondeur-récursif-1"><span class="header-section-number">7.1.2</span> Parcours en profondeur récursif</h3>
<p>On va modifier la structure de graphe et rajouter trois nouveaux champs :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1"></a><span class="dt">bool</span> discovered<span class="op">[</span>MAXV<span class="op">];</span> <span class="co">// Quels sommets sont connus</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="dt">bool</span> processed<span class="op">[</span>MAXV<span class="op">];</span> <span class="co">// Quels sommets sont traités</span></span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="dt">int</span> parent<span class="op">[</span>MAXV<span class="op">];</span> <span class="co">// parent[x] est le père de x dans le parcours</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>                  <span class="co">// s&#39;il n&#39;y en a pas, c&#39;est -1</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1"></a><span class="dt">void</span> initialize_search<span class="op">(</span>graph <span class="op">*</span>g<span class="op">);</span></span></code></pre></div>
<p></div> qui initialise ces tableaux pour commencer une nouvelle recherche.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1"></a><span class="dt">void</span> initialize_search<span class="op">(</span>graph <span class="op">*</span>g<span class="op">)</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> g<span class="op">-&gt;</span>nvertices<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb33-4"><a href="#cb33-4"></a>    <span class="op">{</span></span>
<span id="cb33-5"><a href="#cb33-5"></a>        g<span class="op">-&gt;</span>discovered<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> false<span class="op">;</span></span>
<span id="cb33-6"><a href="#cb33-6"></a>        g<span class="op">-&gt;</span>processed<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> false<span class="op">;</span></span>
<span id="cb33-7"><a href="#cb33-7"></a>        g<span class="op">-&gt;</span>parent<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb33-8"><a href="#cb33-8"></a>    <span class="op">}</span></span>
<span id="cb33-9"><a href="#cb33-9"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<p>On va définir trois fonctions qui seront appelées lors d’un parcours et qu’on pourra redéfinir.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1"></a><span class="dt">void</span> process_vertex_early<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> v<span class="op">)</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="op">{</span></span>
<span id="cb34-3"><a href="#cb34-3"></a>    printf<span class="op">(</span><span class="st">&quot;processing vertex %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> v<span class="op">);</span></span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="op">}</span></span>
<span id="cb34-5"><a href="#cb34-5"></a></span>
<span id="cb34-6"><a href="#cb34-6"></a><span class="dt">void</span> process_vertex_late<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> v<span class="op">)</span></span>
<span id="cb34-7"><a href="#cb34-7"></a><span class="op">{</span></span>
<span id="cb34-8"><a href="#cb34-8"></a><span class="op">}</span></span>
<span id="cb34-9"><a href="#cb34-9"></a></span>
<span id="cb34-10"><a href="#cb34-10"></a><span class="dt">void</span> process_edge<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span>
<span id="cb34-11"><a href="#cb34-11"></a><span class="op">{</span></span>
<span id="cb34-12"><a href="#cb34-12"></a>    printf<span class="op">(</span><span class="st">&quot;processed edge %d --&gt; %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb34-13"><a href="#cb34-13"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction récursive <div class="ui segment code"></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1"></a><span class="dt">void</span> dfs<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span></code></pre></div>
<p></div> qui effectue un parcours en profondeur en partant du sommet <code>x</code>.</p>
<p>Cette fonction va appeler <code>process_vertex_early</code> au début du traitement de <code>x</code>, <code>process_vertex_late</code> à la fin et <code>process_edge</code> pour chaque arête rencontrée.</p>
<p><strong>Attention</strong> si le graphe est non orienté et qu’on a rencontré <code>x -&gt; y</code> dans cet ordre, on ne fera pas de traitement dans le sens <code>y -&gt; x</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1"></a><span class="dt">void</span> dfs<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="op">{</span></span>
<span id="cb36-3"><a href="#cb36-3"></a>    <span class="co">// important uniquement pour le premier</span></span>
<span id="cb36-4"><a href="#cb36-4"></a>    g<span class="op">-&gt;</span>discovered<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb36-5"><a href="#cb36-5"></a>    process_vertex_early<span class="op">(</span>g<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb36-6"><a href="#cb36-6"></a></span>
<span id="cb36-7"><a href="#cb36-7"></a>    edgenode <span class="op">*</span>n <span class="op">=</span> g<span class="op">-&gt;</span>edges<span class="op">[</span>x<span class="op">];</span></span>
<span id="cb36-8"><a href="#cb36-8"></a>    <span class="cf">while</span><span class="op">(</span>n <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb36-9"><a href="#cb36-9"></a>    <span class="op">{</span></span>
<span id="cb36-10"><a href="#cb36-10"></a>        process_edge<span class="op">(</span>g<span class="op">,</span> x<span class="op">,</span> n<span class="op">-&gt;</span>y<span class="op">);</span></span>
<span id="cb36-11"><a href="#cb36-11"></a>        <span class="cf">if</span> <span class="op">(!</span>g<span class="op">-&gt;</span>discovered<span class="op">[</span>n<span class="op">-&gt;</span>y<span class="op">])</span></span>
<span id="cb36-12"><a href="#cb36-12"></a>        <span class="op">{</span></span>
<span id="cb36-13"><a href="#cb36-13"></a>            g<span class="op">-&gt;</span>discovered<span class="op">[</span>n<span class="op">-&gt;</span>y<span class="op">]</span> <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb36-14"><a href="#cb36-14"></a>            g<span class="op">-&gt;</span>parent<span class="op">[</span>n<span class="op">-&gt;</span>y<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb36-15"><a href="#cb36-15"></a>            g<span class="op">-&gt;</span>color<span class="op">[</span>n<span class="op">-&gt;</span>y<span class="op">]</span> <span class="op">=</span> <span class="op">!</span>g<span class="op">-&gt;</span>color<span class="op">[</span>x<span class="op">];</span></span>
<span id="cb36-16"><a href="#cb36-16"></a>            dfs<span class="op">(</span>g<span class="op">,</span> n<span class="op">-&gt;</span>y<span class="op">);</span></span>
<span id="cb36-17"><a href="#cb36-17"></a>        <span class="op">}</span></span>
<span id="cb36-18"><a href="#cb36-18"></a>        n <span class="op">=</span> n<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="cb36-19"><a href="#cb36-19"></a>    <span class="op">}</span></span>
<span id="cb36-20"><a href="#cb36-20"></a></span>
<span id="cb36-21"><a href="#cb36-21"></a>    process_vertex_late<span class="op">(</span>g<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb36-22"><a href="#cb36-22"></a>    g<span class="op">-&gt;</span>processed<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb36-23"><a href="#cb36-23"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Comme on l’a démontré, le parcours dans un graphe non orienté permet de traiter exactement la composante connexe du sommet de départ.</p>
<p>Écrire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1"></a><span class="dt">void</span> connected_components<span class="op">(</span>graph <span class="op">*</span>g<span class="op">)</span></span></code></pre></div>
<p></div> qui affiche les composantes connexes sous la forme : <div class="ui segment code"></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1"></a>Component <span class="dv">1</span><span class="op">:</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span></span>
<span id="cb38-2"><a href="#cb38-2"></a>Component <span class="dv">2</span><span class="op">:</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span></span></code></pre></div>
<p></div> pour le graphe <img src="assets/pics/tp_c_components.png" /></p>
<p>Il sera nécessaire de modifier les fonctions <code>process_*</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> On remplace les fonctions par : <div class="ui segment code"></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1"></a><span class="dt">void</span> process_vertex_early<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> v<span class="op">)</span></span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="op">{</span></span>
<span id="cb39-3"><a href="#cb39-3"></a>    printf<span class="op">(</span><span class="st">&quot; %d&quot;</span><span class="op">,</span> v<span class="op">);</span></span>
<span id="cb39-4"><a href="#cb39-4"></a><span class="op">}</span></span>
<span id="cb39-5"><a href="#cb39-5"></a></span>
<span id="cb39-6"><a href="#cb39-6"></a><span class="dt">void</span> process_vertex_late<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> v<span class="op">)</span></span>
<span id="cb39-7"><a href="#cb39-7"></a><span class="op">{</span></span>
<span id="cb39-8"><a href="#cb39-8"></a><span class="op">}</span></span>
<span id="cb39-9"><a href="#cb39-9"></a></span>
<span id="cb39-10"><a href="#cb39-10"></a><span class="dt">void</span> process_edge<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span>
<span id="cb39-11"><a href="#cb39-11"></a><span class="op">{</span></span>
<span id="cb39-12"><a href="#cb39-12"></a><span class="op">}</span></span></code></pre></div>
<p></div> et on définit : <div class="ui segment code"></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1"></a><span class="dt">void</span> connected_components<span class="op">(</span>graph <span class="op">*</span>g<span class="op">)</span></span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3"></a>    initialize_search<span class="op">(</span>g<span class="op">);</span></span>
<span id="cb40-4"><a href="#cb40-4"></a>    <span class="dt">int</span> comp <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb40-5"><a href="#cb40-5"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> g<span class="op">-&gt;</span>nvertices<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb40-6"><a href="#cb40-6"></a>    <span class="op">{</span></span>
<span id="cb40-7"><a href="#cb40-7"></a>        <span class="cf">if</span><span class="op">(!</span>g<span class="op">-&gt;</span>processed<span class="op">[</span>i<span class="op">])</span></span>
<span id="cb40-8"><a href="#cb40-8"></a>        <span class="op">{</span></span>
<span id="cb40-9"><a href="#cb40-9"></a>            comp <span class="op">=</span> comp<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb40-10"><a href="#cb40-10"></a>            printf<span class="op">(</span><span class="st">&quot;Component %d:&quot;</span><span class="op">,</span> comp<span class="op">);</span></span>
<span id="cb40-11"><a href="#cb40-11"></a>            dfs<span class="op">(</span>g<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb40-12"><a href="#cb40-12"></a>            printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb40-13"><a href="#cb40-13"></a>        <span class="op">}</span></span>
<span id="cb40-14"><a href="#cb40-14"></a>    <span class="op">}</span></span>
<span id="cb40-15"><a href="#cb40-15"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<p>On relance ainsi le parcours en repartant d’un sommet non traité. </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Adaptez le parcours pour détecter des cycles. Quand vous détectez un cycle, affichez les sommets qui le compose. Dans le graphe précédent il faut afficher : <div class="ui segment code"></p>
<div class="sourceCode" id="cb41"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1"></a>Cycle <span class="op">:</span> <span class="dv">0</span> <span class="dv">2</span> <span class="dv">3</span></span>
<span id="cb41-2"><a href="#cb41-2"></a>Cycle <span class="op">:</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">4</span></span>
<span id="cb41-3"><a href="#cb41-3"></a>Cycle <span class="op">:</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span></span></code></pre></div>
<p></div></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> Il suffit de changer <code>process_edge</code> dans le parcours de toutes les composantes pour détecter les arêtes arrières : <div class="ui segment code"></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1"></a><span class="dt">void</span> process_edge<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="op">{</span></span>
<span id="cb42-3"><a href="#cb42-3"></a>    <span class="co">// Teste si on a une arête arrière</span></span>
<span id="cb42-4"><a href="#cb42-4"></a>    <span class="cf">if</span> <span class="op">(</span>g<span class="op">-&gt;</span>discovered<span class="op">[</span>y<span class="op">]</span> </span>
<span id="cb42-5"><a href="#cb42-5"></a>            <span class="op">&amp;&amp;</span> <span class="op">!</span>g<span class="op">-&gt;</span>processed<span class="op">[</span>y<span class="op">]</span> </span>
<span id="cb42-6"><a href="#cb42-6"></a>            <span class="op">&amp;&amp;</span> <span class="op">(</span>g<span class="op">-&gt;</span>directed <span class="op">||</span> g<span class="op">-&gt;</span>parent<span class="op">[</span>x<span class="op">]</span> <span class="op">!=</span> y<span class="op">))</span></span>
<span id="cb42-7"><a href="#cb42-7"></a>    <span class="op">{</span></span>
<span id="cb42-8"><a href="#cb42-8"></a>        printf<span class="op">(</span><span class="st">&quot;Cycle : %d&quot;</span><span class="op">,</span> y<span class="op">);</span></span>
<span id="cb42-9"><a href="#cb42-9"></a>        <span class="dt">int</span> cur <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb42-10"><a href="#cb42-10"></a>        <span class="cf">while</span><span class="op">(</span>cur <span class="op">!=</span> y <span class="op">&amp;</span> cur <span class="op">&gt;</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb42-11"><a href="#cb42-11"></a>        <span class="op">{</span></span>
<span id="cb42-12"><a href="#cb42-12"></a>            printf<span class="op">(</span><span class="st">&quot; %d&quot;</span><span class="op">,</span> cur<span class="op">);</span></span>
<span id="cb42-13"><a href="#cb42-13"></a>            cur <span class="op">=</span> g<span class="op">-&gt;</span>parent<span class="op">[</span>cur<span class="op">];</span></span>
<span id="cb42-14"><a href="#cb42-14"></a>        <span class="op">}</span></span>
<span id="cb42-15"><a href="#cb42-15"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb42-16"><a href="#cb42-16"></a>    <span class="op">}</span></span>
<span id="cb42-17"><a href="#cb42-17"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>A l’aide d’un parcours, déterminez si un graphe non orienté est biparti.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> On rajoute des champs <div class="ui segment code"></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1"></a><span class="dt">bool</span> colors<span class="op">[</span>MAXV<span class="op">];</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="dt">bool</span> bipartite<span class="op">;</span></span></code></pre></div>
<p></div> dans <code>graph</code> et on commence en donnant la couleur <code>true</code> au sommet de départ du DFS. Ensuite, il suffit de colorer avec la couleur différente de <span class="math inline">\(x\)</span> quand on voit une arête <span class="math inline">\(x \rightarrow y\)</span> puis de vérifier à chaque arête qu’elle relie des sommets de couleur différente.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb44"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"></code></pre></div>
<p></div> </div> </div></p>
<h3 data-number="7.1.3" id="sec:temps-et-classification-des-arêtes"><span class="header-section-number">7.1.3</span> Temps et classification des arêtes</h3>
<p>On rajoute à la structure <code>graph</code> deux tableaux et un entier :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb45"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1"></a><span class="dt">int</span> time<span class="op">;</span> <span class="co">// l&#39;horloge</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="dt">int</span> entry_time<span class="op">[</span>MAXV<span class="op">];</span></span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="dt">int</span> exit_time<span class="op">[</span>MAXV<span class="op">];</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Rajouter à <code>dfs</code> le maintien de l’horloge et des temps d’entrée et de sortie.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> Il suffit de modifier les traitements de sommets : <div class="ui segment code"></p>
<div class="sourceCode" id="cb46"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1"></a><span class="dt">void</span> process_vertex_early<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> v<span class="op">)</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="op">{</span></span>
<span id="cb46-3"><a href="#cb46-3"></a>    g<span class="op">-&gt;</span>entry_time<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> g<span class="op">-&gt;</span>time<span class="op">;</span></span>
<span id="cb46-4"><a href="#cb46-4"></a>    g<span class="op">-&gt;</span>time <span class="op">=</span> g<span class="op">-&gt;</span>time <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb46-5"><a href="#cb46-5"></a>    printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> v<span class="op">);</span></span>
<span id="cb46-6"><a href="#cb46-6"></a><span class="op">}</span></span>
<span id="cb46-7"><a href="#cb46-7"></a></span>
<span id="cb46-8"><a href="#cb46-8"></a><span class="dt">void</span> process_vertex_late<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> v<span class="op">)</span></span>
<span id="cb46-9"><a href="#cb46-9"></a><span class="op">{</span></span>
<span id="cb46-10"><a href="#cb46-10"></a>    g<span class="op">-&gt;</span>exit_time<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> g<span class="op">-&gt;</span>time<span class="op">;</span></span>
<span id="cb46-11"><a href="#cb46-11"></a>    g<span class="op">-&gt;</span>time <span class="op">=</span> g<span class="op">-&gt;</span>time <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb46-12"><a href="#cb46-12"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<p>On définit des constantes :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb47"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1"></a><span class="pp">#define TREE 0</span></span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="pp">#define BACK 1</span></span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="pp">#define FORWARD 2</span></span>
<span id="cb47-4"><a href="#cb47-4"></a><span class="pp">#define CROSS 3</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction : <div class="ui segment code"></p>
<div class="sourceCode" id="cb48"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1"></a><span class="dt">int</span> edge_classification<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span></code></pre></div>
<p></div> qui pourra être appelée dans <code>process_edge</code> pour déterminer la classe d’une arête selon les constantes précédentes. On renverra -1 si l’arête ne peut être déterminée (est-ce possible ?).</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb49"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1"></a><span class="dt">int</span> edge_classification<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="op">{</span></span>
<span id="cb49-3"><a href="#cb49-3"></a>    <span class="cf">if</span> <span class="op">(!</span>g<span class="op">-&gt;</span>discovered<span class="op">[</span>y<span class="op">])</span></span>
<span id="cb49-4"><a href="#cb49-4"></a>        <span class="cf">return</span> TREE<span class="op">;</span></span>
<span id="cb49-5"><a href="#cb49-5"></a>    <span class="cf">if</span> <span class="op">(!</span>g<span class="op">-&gt;</span>processed<span class="op">[</span>y<span class="op">])</span></span>
<span id="cb49-6"><a href="#cb49-6"></a>        <span class="cf">return</span> BACK<span class="op">;</span></span>
<span id="cb49-7"><a href="#cb49-7"></a>    <span class="cf">if</span> <span class="op">(</span>g<span class="op">-&gt;</span>entry_time<span class="op">[</span>x<span class="op">]</span> <span class="op">&lt;</span> g<span class="op">-&gt;</span>entry_time<span class="op">[</span>y<span class="op">])</span></span>
<span id="cb49-8"><a href="#cb49-8"></a>        <span class="cf">return</span> FORWARD<span class="op">;</span></span>
<span id="cb49-9"><a href="#cb49-9"></a>    <span class="cf">return</span> CROSS<span class="op">;</span></span>
<span id="cb49-10"><a href="#cb49-10"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<h3 data-number="7.1.4" id="sec:parcours-avec-une-structure"><span class="header-section-number">7.1.4</span> Parcours avec une structure</h3>
<p>On va réutiliser ici des implémentations de files et de piles dans un tableau de taille fixe.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Compléter les implémentations en se basant sur ce qui a déjà été fait dans les TP précédents. <div class="ui segment code"></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1"></a><span class="kw">struct</span> queue <span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2"></a>    <span class="dt">int</span> elts<span class="op">[</span>MAXV<span class="op">];</span></span>
<span id="cb50-3"><a href="#cb50-3"></a>    <span class="dt">int</span> front<span class="op">;</span></span>
<span id="cb50-4"><a href="#cb50-4"></a>    <span class="dt">int</span> back<span class="op">;</span></span>
<span id="cb50-5"><a href="#cb50-5"></a><span class="op">};</span></span>
<span id="cb50-6"><a href="#cb50-6"></a><span class="kw">typedef</span> <span class="kw">struct</span> queue queue<span class="op">;</span></span>
<span id="cb50-7"><a href="#cb50-7"></a></span>
<span id="cb50-8"><a href="#cb50-8"></a><span class="kw">struct</span> stack <span class="op">{</span></span>
<span id="cb50-9"><a href="#cb50-9"></a>    <span class="dt">int</span> elts<span class="op">[</span>MAXV<span class="op">];</span></span>
<span id="cb50-10"><a href="#cb50-10"></a>    <span class="dt">int</span> back<span class="op">;</span></span>
<span id="cb50-11"><a href="#cb50-11"></a><span class="op">};</span></span>
<span id="cb50-12"><a href="#cb50-12"></a><span class="kw">typedef</span> <span class="kw">struct</span> stack stack<span class="op">;</span></span>
<span id="cb50-13"><a href="#cb50-13"></a></span>
<span id="cb50-14"><a href="#cb50-14"></a><span class="dt">void</span> init_stack<span class="op">(</span>stack <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb50-15"><a href="#cb50-15"></a><span class="op">{</span></span>
<span id="cb50-16"><a href="#cb50-16"></a>    <span class="co">// initialise la pile</span></span>
<span id="cb50-17"><a href="#cb50-17"></a><span class="op">}</span></span>
<span id="cb50-18"><a href="#cb50-18"></a></span>
<span id="cb50-19"><a href="#cb50-19"></a><span class="dt">int</span> pop<span class="op">(</span>stack <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb50-20"><a href="#cb50-20"></a><span class="op">{</span></span>
<span id="cb50-21"><a href="#cb50-21"></a>    <span class="co">// depile un élément</span></span>
<span id="cb50-22"><a href="#cb50-22"></a><span class="op">}</span></span>
<span id="cb50-23"><a href="#cb50-23"></a></span>
<span id="cb50-24"><a href="#cb50-24"></a><span class="dt">void</span> push<span class="op">(</span>stack <span class="op">*</span>s<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb50-25"><a href="#cb50-25"></a><span class="op">{</span></span>
<span id="cb50-26"><a href="#cb50-26"></a>    <span class="co">// empile x sur la pile s</span></span>
<span id="cb50-27"><a href="#cb50-27"></a><span class="op">}</span></span>
<span id="cb50-28"><a href="#cb50-28"></a></span>
<span id="cb50-29"><a href="#cb50-29"></a><span class="dt">void</span> init_queue<span class="op">(</span>queue <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb50-30"><a href="#cb50-30"></a><span class="op">{</span></span>
<span id="cb50-31"><a href="#cb50-31"></a>    <span class="co">// initialise la file</span></span>
<span id="cb50-32"><a href="#cb50-32"></a><span class="op">}</span></span>
<span id="cb50-33"><a href="#cb50-33"></a></span>
<span id="cb50-34"><a href="#cb50-34"></a><span class="dt">int</span> dequeue<span class="op">(</span>queue <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb50-35"><a href="#cb50-35"></a><span class="op">{</span></span>
<span id="cb50-36"><a href="#cb50-36"></a>    <span class="co">// defile un élément</span></span>
<span id="cb50-37"><a href="#cb50-37"></a><span class="op">}</span></span>
<span id="cb50-38"><a href="#cb50-38"></a></span>
<span id="cb50-39"><a href="#cb50-39"></a><span class="dt">void</span> enqueue<span class="op">(</span>queue <span class="op">*</span>s<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb50-40"><a href="#cb50-40"></a><span class="op">{</span></span>
<span id="cb50-41"><a href="#cb50-41"></a>    <span class="co">// enfile x sur la file s</span></span>
<span id="cb50-42"><a href="#cb50-42"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1"></a><span class="dt">void</span> init_stack<span class="op">(</span>stack <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="op">{</span></span>
<span id="cb51-3"><a href="#cb51-3"></a>    s<span class="op">-&gt;</span>back <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb51-4"><a href="#cb51-4"></a><span class="op">}</span></span>
<span id="cb51-5"><a href="#cb51-5"></a></span>
<span id="cb51-6"><a href="#cb51-6"></a><span class="dt">int</span> pop<span class="op">(</span>stack <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb51-7"><a href="#cb51-7"></a><span class="op">{</span></span>
<span id="cb51-8"><a href="#cb51-8"></a>    assert<span class="op">(</span>s<span class="op">-&gt;</span>back <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb51-9"><a href="#cb51-9"></a>    s<span class="op">-&gt;</span>back <span class="op">=</span> s<span class="op">-&gt;</span>back<span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb51-10"><a href="#cb51-10"></a>    <span class="cf">return</span> s<span class="op">-&gt;</span>elts<span class="op">[</span>s<span class="op">-&gt;</span>back<span class="op">];</span></span>
<span id="cb51-11"><a href="#cb51-11"></a><span class="op">}</span></span>
<span id="cb51-12"><a href="#cb51-12"></a></span>
<span id="cb51-13"><a href="#cb51-13"></a><span class="dt">void</span> push<span class="op">(</span>stack <span class="op">*</span>s<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb51-14"><a href="#cb51-14"></a><span class="op">{</span></span>
<span id="cb51-15"><a href="#cb51-15"></a>    assert<span class="op">(</span>s<span class="op">-&gt;</span>back <span class="op">&lt;</span> MAXV<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb51-16"><a href="#cb51-16"></a>    s<span class="op">-&gt;</span>elts<span class="op">[</span>s<span class="op">-&gt;</span>back<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb51-17"><a href="#cb51-17"></a>    s<span class="op">-&gt;</span>back <span class="op">=</span> s<span class="op">-&gt;</span>back<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb51-18"><a href="#cb51-18"></a><span class="op">}</span></span>
<span id="cb51-19"><a href="#cb51-19"></a></span>
<span id="cb51-20"><a href="#cb51-20"></a><span class="dt">bool</span> empty_stack<span class="op">(</span>stack <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb51-21"><a href="#cb51-21"></a><span class="op">{</span></span>
<span id="cb51-22"><a href="#cb51-22"></a>    <span class="cf">return</span> s<span class="op">-&gt;</span>back <span class="op">==</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb51-23"><a href="#cb51-23"></a><span class="op">}</span></span>
<span id="cb51-24"><a href="#cb51-24"></a></span>
<span id="cb51-25"><a href="#cb51-25"></a><span class="dt">void</span> init_queue<span class="op">(</span>queue <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb51-26"><a href="#cb51-26"></a><span class="op">{</span></span>
<span id="cb51-27"><a href="#cb51-27"></a>    s<span class="op">-&gt;</span>front <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb51-28"><a href="#cb51-28"></a>    s<span class="op">-&gt;</span>back <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb51-29"><a href="#cb51-29"></a><span class="op">}</span></span>
<span id="cb51-30"><a href="#cb51-30"></a></span>
<span id="cb51-31"><a href="#cb51-31"></a><span class="dt">int</span> dequeue<span class="op">(</span>queue <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb51-32"><a href="#cb51-32"></a><span class="op">{</span></span>
<span id="cb51-33"><a href="#cb51-33"></a>    <span class="dt">int</span> x <span class="op">=</span> s<span class="op">-&gt;</span>elts<span class="op">[</span>s<span class="op">-&gt;</span>front<span class="op">];</span></span>
<span id="cb51-34"><a href="#cb51-34"></a>    s<span class="op">-&gt;</span>front <span class="op">=</span> <span class="op">(</span>s<span class="op">-&gt;</span>front <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> MAXV<span class="op">;</span></span>
<span id="cb51-35"><a href="#cb51-35"></a>    <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb51-36"><a href="#cb51-36"></a><span class="op">}</span></span>
<span id="cb51-37"><a href="#cb51-37"></a></span>
<span id="cb51-38"><a href="#cb51-38"></a><span class="dt">void</span> enqueue<span class="op">(</span>queue <span class="op">*</span>s<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb51-39"><a href="#cb51-39"></a><span class="op">{</span></span>
<span id="cb51-40"><a href="#cb51-40"></a>    s<span class="op">-&gt;</span>elts<span class="op">[</span>s<span class="op">-&gt;</span>back<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb51-41"><a href="#cb51-41"></a>    s<span class="op">-&gt;</span>back <span class="op">=</span> <span class="op">(</span>s<span class="op">-&gt;</span>back <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> MAXV<span class="op">;</span></span>
<span id="cb51-42"><a href="#cb51-42"></a><span class="op">}</span></span>
<span id="cb51-43"><a href="#cb51-43"></a></span>
<span id="cb51-44"><a href="#cb51-44"></a><span class="dt">bool</span> empty_queue<span class="op">(</span>queue <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb51-45"><a href="#cb51-45"></a><span class="op">{</span></span>
<span id="cb51-46"><a href="#cb51-46"></a>    <span class="cf">return</span> s<span class="op">-&gt;</span>front <span class="op">==</span> s<span class="op">-&gt;</span>back<span class="op">;</span></span>
<span id="cb51-47"><a href="#cb51-47"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions <div class="ui segment code"></p>
<div class="sourceCode" id="cb52"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb52-1"><a href="#cb52-1"></a><span class="dt">void</span> dfs<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> src<span class="op">);</span></span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="dt">void</span> bfs<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> src<span class="op">);</span></span></code></pre></div>
<p></div> effectuant un parcours en utilisant pour les sommets à visiter une pile ou une file. On ne pourra pas maintenir les temps de sortie ici car cela n’a plus vraiment de sens.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb53"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1"></a><span class="dt">void</span> dfs<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> src<span class="op">)</span></span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="op">{</span></span>
<span id="cb53-3"><a href="#cb53-3"></a>    stack s<span class="op">;</span></span>
<span id="cb53-4"><a href="#cb53-4"></a>    init_stack<span class="op">(&amp;</span>s<span class="op">);</span></span>
<span id="cb53-5"><a href="#cb53-5"></a>    push<span class="op">(&amp;</span>s<span class="op">,</span> src<span class="op">);</span></span>
<span id="cb53-6"><a href="#cb53-6"></a>    <span class="cf">while</span><span class="op">(!</span>empty_stack<span class="op">(&amp;</span>s<span class="op">))</span></span>
<span id="cb53-7"><a href="#cb53-7"></a>    <span class="op">{</span></span>
<span id="cb53-8"><a href="#cb53-8"></a>        <span class="dt">int</span> x <span class="op">=</span> pop<span class="op">(&amp;</span>s<span class="op">);</span></span>
<span id="cb53-9"><a href="#cb53-9"></a>        <span class="cf">if</span> <span class="op">(!</span>g<span class="op">-&gt;</span>processed<span class="op">[</span>x<span class="op">])</span></span>
<span id="cb53-10"><a href="#cb53-10"></a>        <span class="op">{</span></span>
<span id="cb53-11"><a href="#cb53-11"></a>            g<span class="op">-&gt;</span>processed<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb53-12"><a href="#cb53-12"></a>            process_vertex_early<span class="op">(</span>g<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb53-13"><a href="#cb53-13"></a></span>
<span id="cb53-14"><a href="#cb53-14"></a>            edgenode <span class="op">*</span>n <span class="op">=</span> g<span class="op">-&gt;</span>edges<span class="op">[</span>x<span class="op">];</span></span>
<span id="cb53-15"><a href="#cb53-15"></a>            <span class="cf">while</span><span class="op">(</span>n <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb53-16"><a href="#cb53-16"></a>            <span class="op">{</span></span>
<span id="cb53-17"><a href="#cb53-17"></a>                push<span class="op">(&amp;</span>s<span class="op">,</span> n<span class="op">-&gt;</span>y<span class="op">);</span></span>
<span id="cb53-18"><a href="#cb53-18"></a>                n <span class="op">=</span> n<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="cb53-19"><a href="#cb53-19"></a>            <span class="op">}</span></span>
<span id="cb53-20"><a href="#cb53-20"></a>        <span class="op">}</span></span>
<span id="cb53-21"><a href="#cb53-21"></a>    <span class="op">}</span></span>
<span id="cb53-22"><a href="#cb53-22"></a><span class="op">}</span></span>
<span id="cb53-23"><a href="#cb53-23"></a></span>
<span id="cb53-24"><a href="#cb53-24"></a><span class="dt">void</span> bfs<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> src<span class="op">)</span></span>
<span id="cb53-25"><a href="#cb53-25"></a><span class="op">{</span></span>
<span id="cb53-26"><a href="#cb53-26"></a>    queue s<span class="op">;</span></span>
<span id="cb53-27"><a href="#cb53-27"></a>    init_queue<span class="op">(&amp;</span>s<span class="op">);</span></span>
<span id="cb53-28"><a href="#cb53-28"></a>    enqueue<span class="op">(&amp;</span>s<span class="op">,</span> src<span class="op">);</span></span>
<span id="cb53-29"><a href="#cb53-29"></a>    <span class="cf">while</span><span class="op">(!</span>empty_queue<span class="op">(&amp;</span>s<span class="op">))</span></span>
<span id="cb53-30"><a href="#cb53-30"></a>    <span class="op">{</span></span>
<span id="cb53-31"><a href="#cb53-31"></a>        <span class="dt">int</span> x <span class="op">=</span> dequeue<span class="op">(&amp;</span>s<span class="op">);</span></span>
<span id="cb53-32"><a href="#cb53-32"></a>        <span class="cf">if</span> <span class="op">(!</span>g<span class="op">-&gt;</span>processed<span class="op">[</span>x<span class="op">])</span></span>
<span id="cb53-33"><a href="#cb53-33"></a>        <span class="op">{</span></span>
<span id="cb53-34"><a href="#cb53-34"></a>            g<span class="op">-&gt;</span>processed<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb53-35"><a href="#cb53-35"></a>            process_vertex_early<span class="op">(</span>g<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb53-36"><a href="#cb53-36"></a></span>
<span id="cb53-37"><a href="#cb53-37"></a>            edgenode <span class="op">*</span>n <span class="op">=</span> g<span class="op">-&gt;</span>edges<span class="op">[</span>x<span class="op">];</span></span>
<span id="cb53-38"><a href="#cb53-38"></a>            <span class="cf">while</span><span class="op">(</span>n <span class="op">!=</span> NULL<span class="op">)</span></span>
<span id="cb53-39"><a href="#cb53-39"></a>            <span class="op">{</span></span>
<span id="cb53-40"><a href="#cb53-40"></a>                enqueue<span class="op">(&amp;</span>s<span class="op">,</span> n<span class="op">-&gt;</span>y<span class="op">);</span></span>
<span id="cb53-41"><a href="#cb53-41"></a>                n <span class="op">=</span> n<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="cb53-42"><a href="#cb53-42"></a>            <span class="op">}</span></span>
<span id="cb53-43"><a href="#cb53-43"></a>        <span class="op">}</span></span>
<span id="cb53-44"><a href="#cb53-44"></a>    <span class="op">}</span></span>
<span id="cb53-45"><a href="#cb53-45"></a><span class="op">}</span></span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>A l’aide d’un parcours en largeur, le <code>bfs</code>, déterminez étant donné un sommet <code>x</code> et un sommet <code>y</code> de sa composante connexe, le plus court chemin de <code>x</code> vers <code>y</code>. On l’affichera sous la forme <code>0 -- 3 -- 1 -- 5</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> On rajoute un champ comme vu dans le cours : <div class="ui segment code"></p>
<div class="sourceCode" id="cb54"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1"></a><span class="dt">int</span> d<span class="op">[</span>MAXV<span class="op">];</span></span></code></pre></div>
<p></div> on marque <code>d[x] = 0</code> et on utilise le any-search modifié pour tenir compte de la parenté : <div class="ui segment code"></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"></code></pre></div>
<p></div> </div> </div></p>
<h2 data-number="7.2" id="sec:étude-dun-graphe-issu-dun-réseau-social"><span class="header-section-number">7.2</span> Étude d’un graphe issu d’un réseau social</h2>
<p>Dans ce TP on va étudier le graphe <strong>orienté</strong> des followers du compte Twitter <code>@ENSdeLyon</code>.</p>
<p>Une représentation graphique de ce graphe est donné dans l’image suivante :</p>
<p><img src="assets/pics/ENSdeLyon.png" /></p>
<p>Les sommets sont les comptes donnés par leur identifiant (le <code>@identifiant</code> de Twitter) et une arête x <span class="math inline">\(\rightarrow\)</span> y indique que le compte x est abonné au compte y.</p>
<p>Ce graphe est assez conséquent : il comporte 8418 sommets et 305288 arêtes. Il nous permettra ainsi d’étudier en pratique la complexité des différents algorithmes étudiés. On va commencer par lire ce graphe depuis un fichier, ensuite, on en déduira différents graphes associés (sous-graphes, symétrisés par excès ou par défaut…) sur lesquels on pourra appliquer les algorithmes demandés. Une table de résultat est fourni en fin de TP pour vérifier vos résultats.</p>
<h3 data-number="7.2.1" id="sec:définition-et-lecture-du-graphe"><span class="header-section-number">7.2.1</span> Définition et lecture du graphe</h3>
<p>Le graphe est donné dans le fichier <a href="assets/data/ENSdeLyon.graph">ENSdeLyon.graph</a>. Il s’agit d’un fichier texte ayant la structure suivante :</p>
<ul>
<li>un entier <code>n_sommets</code> sur une ligne</li>
<li>un entiers <code>n_aretes</code> sur une ligne</li>
<li><code>n_sommets</code> lignes contenant une chaîne de caractère représentant l’identifiant d’un sommet</li>
<li><code>n_aretes</code> couple de lignes comportant sur la première un entier <code>src</code> et sur la seconde un entier <code>tgt</code> indiquant une arête <code>src -&gt; tgt</code>.</li>
</ul>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Expliquer pourquoi cela ne semble pas être une bonne idée de représenter ce graphe par une matrice d’adjacence.</p>
</div>
<p>On va utiliser le type suivant permettant de représenter le graphe par listes d’adjacence :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb56"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb56-1"><a href="#cb56-1"></a><span class="kw">type</span> graphe = {</span>
<span id="cb56-2"><a href="#cb56-2"></a>    sommets : <span class="dt">string</span> <span class="dt">array</span>;</span>
<span id="cb56-3"><a href="#cb56-3"></a>    aretes : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">array</span></span>
<span id="cb56-4"><a href="#cb56-4"></a>}</span></code></pre></div>
<p></div></p>
<p>Pour lire le graphe depuis le fichier, le plus simple est de le rediriger sur l’entrée standard (<em>Rappel</em> <code>./monprogramme &lt; monfichier</code>) et d’utiliser les deux fonctions suivantes :</p>
<ul>
<li><code>read_int : unit -&gt; int</code> lit une ligne composée d’un entier et renvoie sa valeur.</li>
<li><code>read_line : unit -&gt; string</code> lit une ligne et la renvoie sans le caractère de saut de ligne, c’est-à-dire, sans le <code>'\n'</code>.</li>
</ul>
<p>Alternativement, on peut lire le graphe depuis un fichier avec :</p>
<ul>
<li><code>open_in : string -&gt; in_channel</code> qui crée un descripteur de fichier en lecture pour le nom de fichier passé en paramètre</li>
<li><code>input_line : in_channel -&gt; string</code> qui lit une ligne dans le descripteur et la renvoie sans le saut de ligne</li>
<li><code>int_of_string : string -&gt; int</code> qui convertit une chaîne contenant un entier en entier.</li>
</ul>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>read_graphe : unit -&gt; graphe</code> qui lit un graphe dans le format précédent sur l’entrée standard et tester que vous arrivez à lire le fichier.</p>
<p>Un graphe minimaliste de 3 sommets et 4 arêtes est donné dans le fichier <a href="assets/data/test.graph">test.graph</a> afin de vous permettre de tester votre fonction.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb57"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb57-1"><a href="#cb57-1"></a><span class="kw">let</span> read_graphe () = </span>
<span id="cb57-2"><a href="#cb57-2"></a>    <span class="kw">let</span> nb_sommets = <span class="dt">read_int</span> () <span class="kw">in</span></span>
<span id="cb57-3"><a href="#cb57-3"></a>    <span class="kw">let</span> nb_aretes = <span class="dt">read_int</span> () <span class="kw">in</span></span>
<span id="cb57-4"><a href="#cb57-4"></a></span>
<span id="cb57-5"><a href="#cb57-5"></a>    <span class="kw">let</span> sommets = <span class="dt">Array</span>.init nb_sommets</span>
<span id="cb57-6"><a href="#cb57-6"></a>        (<span class="kw">fun</span> _ -&gt; <span class="dt">read_line</span> ()) <span class="kw">in</span></span>
<span id="cb57-7"><a href="#cb57-7"></a></span>
<span id="cb57-8"><a href="#cb57-8"></a>    <span class="kw">let</span> aretes = <span class="dt">Array</span>.make nb_sommets [] <span class="kw">in</span></span>
<span id="cb57-9"><a href="#cb57-9"></a></span>
<span id="cb57-10"><a href="#cb57-10"></a>    <span class="kw">for</span> _ = <span class="dv">0</span> <span class="kw">to</span> nb_aretes - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb57-11"><a href="#cb57-11"></a>        <span class="kw">let</span> src = <span class="dt">read_int</span> () <span class="kw">in</span></span>
<span id="cb57-12"><a href="#cb57-12"></a>        <span class="kw">let</span> tgt = <span class="dt">read_int</span> () <span class="kw">in</span></span>
<span id="cb57-13"><a href="#cb57-13"></a></span>
<span id="cb57-14"><a href="#cb57-14"></a>        aretes.(src) &lt;- tgt :: aretes.(src)</span>
<span id="cb57-15"><a href="#cb57-15"></a>    <span class="kw">done</span>;</span>
<span id="cb57-16"><a href="#cb57-16"></a>    { sommets=sommets; aretes=aretes }</span></code></pre></div>
<p></div> </div> </div></p>
<p>Si <span class="math inline">\(G = (S,A)\)</span> est un graphe dont les sommets sont énumérées <span class="math inline">\(S = \{ s_0, s_1, \dots, s_{n-1} \}\)</span>, on note, pour <span class="math inline">\(p \le n\)</span>, <span class="math inline">\(G_p\)</span> le sous-graphe induit par <span class="math inline">\(\{ s_0, \dots, s_{p-1} \}\)</span>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>restriction : graphe -&gt; int -&gt; graphe</code> tel que <code>restriction g p</code> où <code>g</code> est la représentation d’un graphe <span class="math inline">\(G\)</span> renvoie la représentation du graphe <span class="math inline">\(G_p\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> On adopte une approche proche de la fonction précédente : on itère sur les arêtes du graphe initial et on ne sélectionne que celles qui sont compatibles avec la restriction.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb58"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb58-1"><a href="#cb58-1"></a><span class="kw">let</span> restriction g p =</span>
<span id="cb58-2"><a href="#cb58-2"></a>    <span class="kw">let</span> sommets = <span class="dt">Array</span>.sub g.sommets <span class="dv">0</span> p <span class="kw">in</span></span>
<span id="cb58-3"><a href="#cb58-3"></a>    <span class="kw">let</span> aretes = <span class="dt">Array</span>.make p [] <span class="kw">in</span></span>
<span id="cb58-4"><a href="#cb58-4"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> p - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb58-5"><a href="#cb58-5"></a>        <span class="dt">List</span>.iter (<span class="kw">fun</span> j -&gt;</span>
<span id="cb58-6"><a href="#cb58-6"></a>            <span class="kw">if</span> j &lt; p <span class="kw">then</span> aretes.(i) &lt;- j :: aretes.(i))</span>
<span id="cb58-7"><a href="#cb58-7"></a>            g.aretes.(i)</span>
<span id="cb58-8"><a href="#cb58-8"></a>    <span class="kw">done</span>;</span>
<span id="cb58-9"><a href="#cb58-9"></a>    { sommets = sommets; aretes = aretes }</span></code></pre></div>
<p></div></p>
<p>Notons ici qu’on aurait pu avoir une approche plus fonctionnelle pour sélectionner les bonnes arêtes :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb59"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb59-1"><a href="#cb59-1"></a><span class="kw">let</span> restriction g p =</span>
<span id="cb59-2"><a href="#cb59-2"></a>    <span class="kw">let</span> sommets = <span class="dt">Array</span>.sub g.sommets <span class="dv">0</span> p <span class="kw">in</span></span>
<span id="cb59-3"><a href="#cb59-3"></a>    <span class="kw">let</span> aretes = <span class="dt">Array</span>.map (<span class="dt">List</span>.filter ((&gt;)p))</span>
<span id="cb59-4"><a href="#cb59-4"></a>        (<span class="dt">Array</span>.sub g.aretes <span class="dv">0</span> p) <span class="kw">in</span></span>
<span id="cb59-5"><a href="#cb59-5"></a>    { sommets = sommets; aretes = aretes }</span></code></pre></div>
<p></div></p>
<p></div> </div></p>
<p>Si <span class="math inline">\(G = (S,A)\)</span> est un graphe orienté, on a vu au paragraphe <a href="chap_structuresdonnees_graphes.html#sec:graphes_symetrises">Graphes non orientés</a> les graphes non orientés par défaut et par excès, <span class="math inline">\(G^-\)</span> et <span class="math inline">\(G^+\)</span> qui lui sont associés.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions <code>par_defaut : graphe -&gt; graphe</code> et <code>par_exces : graphe -&gt; graphe</code> qui, étant donné un graphe <span class="math inline">\(G\)</span>, renvoie les graphes <span class="math inline">\(G^-\)</span> et <span class="math inline">\(G^+\)</span> représentés en tant que graphes orientés symétriques.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> On adopte encore l’approche de création par remplissage. <div class="ui segment code"></p>
<div class="sourceCode" id="cb60"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb60-1"><a href="#cb60-1"></a><span class="kw">let</span> defaut g =</span>
<span id="cb60-2"><a href="#cb60-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length g.sommets <span class="kw">in</span></span>
<span id="cb60-3"><a href="#cb60-3"></a>    <span class="kw">let</span> sommets = <span class="dt">Array</span>.copy g.sommets <span class="kw">in</span></span>
<span id="cb60-4"><a href="#cb60-4"></a>    <span class="kw">let</span> aretes = <span class="dt">Array</span>.make n [] <span class="kw">in</span></span>
<span id="cb60-5"><a href="#cb60-5"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb60-6"><a href="#cb60-6"></a>        <span class="dt">List</span>.iter (<span class="kw">fun</span> j -&gt;</span>
<span id="cb60-7"><a href="#cb60-7"></a>            <span class="kw">if</span> <span class="dt">List</span>.mem i g.aretes.(j)</span>
<span id="cb60-8"><a href="#cb60-8"></a>            <span class="kw">then</span> aretes.(i) &lt;- j :: aretes.(i))</span>
<span id="cb60-9"><a href="#cb60-9"></a>            g.aretes.(i)</span>
<span id="cb60-10"><a href="#cb60-10"></a>    <span class="kw">done</span>;</span>
<span id="cb60-11"><a href="#cb60-11"></a>    { sommets = sommets; aretes = aretes }</span>
<span id="cb60-12"><a href="#cb60-12"></a></span>
<span id="cb60-13"><a href="#cb60-13"></a><span class="kw">let</span> exces g =</span>
<span id="cb60-14"><a href="#cb60-14"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length g.sommets <span class="kw">in</span></span>
<span id="cb60-15"><a href="#cb60-15"></a>    <span class="kw">let</span> sommets = <span class="dt">Array</span>.copy g.sommets <span class="kw">in</span></span>
<span id="cb60-16"><a href="#cb60-16"></a>    <span class="co">(* on recopie les arêtes existantes *)</span></span>
<span id="cb60-17"><a href="#cb60-17"></a>    <span class="kw">let</span> aretes = <span class="dt">Array</span>.copy g.aretes <span class="kw">in</span></span>
<span id="cb60-18"><a href="#cb60-18"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb60-19"><a href="#cb60-19"></a>        <span class="dt">List</span>.iter (<span class="kw">fun</span> j -&gt;</span>
<span id="cb60-20"><a href="#cb60-20"></a>            <span class="co">(* on rajoute les retours absents *)</span></span>
<span id="cb60-21"><a href="#cb60-21"></a>            <span class="kw">if</span> <span class="dt">not</span> (<span class="dt">List</span>.mem i g.aretes.(j))</span>
<span id="cb60-22"><a href="#cb60-22"></a>            <span class="kw">then</span> aretes.(j) &lt;- i :: aretes.(j))</span>
<span id="cb60-23"><a href="#cb60-23"></a>            g.aretes.(i)</span>
<span id="cb60-24"><a href="#cb60-24"></a>    <span class="kw">done</span>;</span>
<span id="cb60-25"><a href="#cb60-25"></a>    { sommets = sommets; aretes = aretes }</span></code></pre></div>
<p></div> </div> </div></p>
<p>Si <span class="math inline">\(G = (S,A)\)</span> est un graphe orienté, on note <span class="math inline">\(rev(G) = (S,A&#39;)\)</span> son miroir qui vérifie <span class="math inline">\((i,j) \in A \iff (j,i) \in A&#39;\)</span>, c’est-à-dire qui renverse toutes les arêtes.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>miroir : graphe -&gt; graphe</code> qui renvoie le miroir d’un graphe.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> Cette fonction c’est en fait le graphe par excès sans recopier les arêtes initiales sans retour : <div class="ui segment code"></p>
<div class="sourceCode" id="cb61"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb61-1"><a href="#cb61-1"></a><span class="kw">let</span> miroir g =</span>
<span id="cb61-2"><a href="#cb61-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length g.sommets <span class="kw">in</span></span>
<span id="cb61-3"><a href="#cb61-3"></a>    <span class="kw">let</span> sommets = <span class="dt">Array</span>.copy g.sommets <span class="kw">in</span></span>
<span id="cb61-4"><a href="#cb61-4"></a>    <span class="kw">let</span> aretes = <span class="dt">Array</span>.make n [] <span class="kw">in</span></span>
<span id="cb61-5"><a href="#cb61-5"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb61-6"><a href="#cb61-6"></a>        <span class="dt">List</span>.iter (<span class="kw">fun</span> j -&gt; aretes.(j) &lt;- i :: aretes.(j))</span>
<span id="cb61-7"><a href="#cb61-7"></a>            g.aretes.(i)</span>
<span id="cb61-8"><a href="#cb61-8"></a>    <span class="kw">done</span>;</span>
<span id="cb61-9"><a href="#cb61-9"></a>    { sommets = sommets; aretes = aretes }</span></code></pre></div>
<p></div> </div> </div></p>
<p>Dans la suite du sujet on note <span class="math inline">\(\mathcal{G}\)</span> le graphe des followers contenu dans le fichier. On va considérer dans la suite les graphes :</p>
<p><span class="math inline">\(\mathcal{G}, rev(\mathcal{G}), \mathcal{G}^-, \mathcal{G}^+, \mathcal{G}_{500}, rev(\mathcal{G}_{500}), \mathcal{G}_{500}^-\)</span> et <span class="math inline">\(\mathcal{G}_{500}^+\)</span>.</p>
<h3 data-number="7.2.2" id="sec:statistiques-sur-les-degrés"><span class="header-section-number">7.2.2</span> Statistiques sur les degrés</h3>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>stat_degre : graphe -&gt; int * float</code> qui renvoie un couple <span class="math inline">\((d_{max}, d_{moy})\)</span> où <span class="math inline">\(d_max\)</span> est le plus grand des degrés du graphe et <span class="math inline">\(d_{moy}\)</span> est le degré moyen donné par un nombre flottant.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> On itère directement sur les sommets : <div class="ui segment code"></p>
<div class="sourceCode" id="cb62"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb62-1"><a href="#cb62-1"></a><span class="kw">let</span> stat_degre g = </span>
<span id="cb62-2"><a href="#cb62-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length g.sommets <span class="kw">in</span></span>
<span id="cb62-3"><a href="#cb62-3"></a>    <span class="kw">let</span> sum_d, max_d = <span class="dt">ref</span> <span class="dv">0</span>, <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb62-4"><a href="#cb62-4"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb62-5"><a href="#cb62-5"></a>        <span class="kw">let</span> d = <span class="dt">List</span>.length g.aretes.(i) <span class="kw">in</span></span>
<span id="cb62-6"><a href="#cb62-6"></a>        max_d := <span class="dt">max</span> !max_d d;</span>
<span id="cb62-7"><a href="#cb62-7"></a>        sum_d := !sum_d + d</span>
<span id="cb62-8"><a href="#cb62-8"></a>    <span class="kw">done</span>;</span>
<span id="cb62-9"><a href="#cb62-9"></a>    !max_d, <span class="dt">float_of_int</span> !sum_d /. <span class="dt">float_of_int</span> n</span></code></pre></div>
<p></div></p>
<p>Notons qu’on peut, ici aussi, écrire une fonction utilisant la bibliothèque standard efficacement : <div class="ui segment code"></p>
<div class="sourceCode" id="cb63"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb63-1"><a href="#cb63-1"></a><span class="kw">let</span> stat_degre g = </span>
<span id="cb63-2"><a href="#cb63-2"></a>    <span class="kw">let</span> a = <span class="dt">Array</span>.map <span class="dt">List</span>.length g.aretes <span class="kw">in</span></span>
<span id="cb63-3"><a href="#cb63-3"></a>    <span class="kw">let</span> fold = <span class="dt">Array</span>.fold_left <span class="kw">in</span></span>
<span id="cb63-4"><a href="#cb63-4"></a>    <span class="kw">let</span> foi = <span class="dt">float_of_int</span> <span class="kw">in</span></span>
<span id="cb63-5"><a href="#cb63-5"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length g.aretes <span class="kw">in</span></span>
<span id="cb63-6"><a href="#cb63-6"></a>    fold <span class="dt">max</span> <span class="dv">0</span> a, foi (fold (+) <span class="dv">0</span> a) /. foi n</span></code></pre></div>
<p></div> </div> </div></p>
<h3 data-number="7.2.3" id="sec:parcours-en-largeur-1"><span class="header-section-number">7.2.3</span> Parcours en largeur</h3>
<p>On va réaliser ici un parcours en largeur qui sera amené à être modifié et enrichi dans les questions suivantes. On vous laisse libre d’enrichir ce parcours en utilisant des fonctionnelles pour les traitements ou de modifier le code du parcours directement.</p>
<p>Pour utiliser une file, on va utiliser le module <a href="https://v2.ocaml.org/api/Queue.html">Queue</a>. Dans le parcours on va calculer la fonction de distance <code>d</code> et pour gérer les cas où <span class="math inline">\(d(x) = \infty\)</span>, on va la représenter par un <code>int option array</code>. Si <code>d.(x) = None</code> c’est que <code>x</code> est inconnu, on peut donc se servir de ce tableau pour avoir l’état d’un sommet.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>bfs : graphe -&gt; int -&gt; int option array * int option array</code> telle que <code>bfs g x</code> renvoie un couple <code>(d,parent)</code> où <code>d.(y)</code> est la distance minimale de <span class="math inline">\(x\)</span> à <span class="math inline">\(y\)</span> et <code>parent.(y)</code> est l’indice du prédécesseur de <code>y</code> dans un tel chemin de <span class="math inline">\(x\)</span> à <span class="math inline">\(y\)</span>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> On implémente directement le parcours en largeur vu dans le cours.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb64"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb64-1"><a href="#cb64-1"></a><span class="kw">let</span> bfs g x =</span>
<span id="cb64-2"><a href="#cb64-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length g.sommets <span class="kw">in</span></span>
<span id="cb64-3"><a href="#cb64-3"></a>    <span class="kw">let</span> p = <span class="dt">Array</span>.make n <span class="dt">None</span> <span class="kw">in</span></span>
<span id="cb64-4"><a href="#cb64-4"></a>    <span class="kw">let</span> d = <span class="dt">Array</span>.make n <span class="dt">None</span> <span class="kw">in</span></span>
<span id="cb64-5"><a href="#cb64-5"></a>    <span class="kw">let</span> a_traiter = <span class="dt">Queue</span>.create () <span class="kw">in</span></span>
<span id="cb64-6"><a href="#cb64-6"></a>    <span class="dt">Queue</span>.add x a_traiter;</span>
<span id="cb64-7"><a href="#cb64-7"></a>    d.(x) &lt;- <span class="dt">Some</span> <span class="dv">0</span>;</span>
<span id="cb64-8"><a href="#cb64-8"></a>    <span class="kw">while</span> <span class="dt">not</span> (<span class="dt">Queue</span>.is_empty a_traiter) <span class="kw">do</span></span>
<span id="cb64-9"><a href="#cb64-9"></a>        <span class="kw">let</span> x = <span class="dt">Queue</span>.take a_traiter <span class="kw">in</span></span>
<span id="cb64-10"><a href="#cb64-10"></a>        <span class="dt">List</span>.iter (<span class="kw">fun</span> y -&gt;</span>
<span id="cb64-11"><a href="#cb64-11"></a>                 <span class="dt">Queue</span>.add y a_traiter;</span>
<span id="cb64-12"><a href="#cb64-12"></a>                 p.(y) &lt;- <span class="dt">Some</span> x;</span>
<span id="cb64-13"><a href="#cb64-13"></a>                 d.(y) &lt;- <span class="dt">Some</span> (Option.get d.(x) + <span class="dv">1</span>))</span>
<span id="cb64-14"><a href="#cb64-14"></a>            (<span class="dt">List</span>.filter (<span class="kw">fun</span> y -&gt; d.(y) = <span class="dt">None</span>) </span>
<span id="cb64-15"><a href="#cb64-15"></a>                g.aretes.(x))</span>
<span id="cb64-16"><a href="#cb64-16"></a>    <span class="kw">done</span>;</span>
<span id="cb64-17"><a href="#cb64-17"></a>    d, p</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>chemin : graphe -&gt; int option array -&gt; int -&gt; int list</code> tel que <code>chemin g parent y</code> renvoie les sommets présents dans un chemin de <code>x</code> à <code>y</code>.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> On utilise ici la récusivité terminale pour remettre le chemin dans l’ordre.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb65"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb65-1"><a href="#cb65-1"></a><span class="kw">let</span> chemin g p y =</span>
<span id="cb65-2"><a href="#cb65-2"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux y l =</span>
<span id="cb65-3"><a href="#cb65-3"></a>        <span class="kw">match</span> p.(y) <span class="kw">with</span></span>
<span id="cb65-4"><a href="#cb65-4"></a>        | <span class="dt">None</span> -&gt; y :: l</span>
<span id="cb65-5"><a href="#cb65-5"></a>        | <span class="dt">Some</span> x -&gt; aux x (y :: l)</span>
<span id="cb65-6"><a href="#cb65-6"></a>    <span class="kw">in</span> aux y []</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>affiche_chemin : graphe -&gt; int list -&gt; unit</code> qui prend un graphe et un chemin donné par la fonction précédente et l’affiche avec le format :</p>
<pre><code>compte1 -&gt; compte1 -&gt; ... -&gt; compten</code></pre>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb67"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb67-1"><a href="#cb67-1"></a><span class="kw">let</span> affiche_chemin g p = </span>
<span id="cb67-2"><a href="#cb67-2"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb67-3"><a href="#cb67-3"></a>        (<span class="dt">String</span>.concat <span class="st">&quot; -&gt; &quot;</span></span>
<span id="cb67-4"><a href="#cb67-4"></a>            (<span class="dt">List</span>.map (<span class="kw">fun</span> i -&gt; g.sommets.(i)) p))</span></code></pre></div>
<p></div> </div> </div></p>
<p>Si <span class="math inline">\(x \in S\)</span>, on note <span class="math inline">\(\underline{x} = \enscomp{y \in S}{x \leadsto y}\)</span>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>accessibles : graphe -&gt; int -&gt; int</code> qui calcule le cardinal de <span class="math inline">\(\underline{x}\)</span> étant donné un graphe <span class="math inline">\(G\)</span> et un sommet <span class="math inline">\(x\)</span> donné par son indice.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb68"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb68-1"><a href="#cb68-1"></a><span class="kw">let</span> accessibles g x =</span>
<span id="cb68-2"><a href="#cb68-2"></a>    <span class="kw">let</span> d, p = bfs g x <span class="kw">in</span></span>
<span id="cb68-3"><a href="#cb68-3"></a>    <span class="dt">Array</span>.fold_left (+) <span class="dv">0</span></span>
<span id="cb68-4"><a href="#cb68-4"></a>        (<span class="dt">Array</span>.map </span>
<span id="cb68-5"><a href="#cb68-5"></a>            (<span class="kw">fun</span> v -&gt; <span class="kw">if</span> v = <span class="dt">None</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> <span class="dv">1</span>) d)</span></code></pre></div>
<p></div> </div> </div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>max_accesibles : graphe -&gt; int * int</code> qui renvoie un couple <span class="math inline">\((x, |\underline{x}|)\)</span> où <span class="math inline">\(x\)</span> est un sommet pour lequel <span class="math inline">\(|\underline{x}|\)</span> est maximal.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb69"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb69-1"><a href="#cb69-1"></a><span class="kw">let</span> max_accessibles g =</span>
<span id="cb69-2"><a href="#cb69-2"></a>    <span class="kw">let</span> m, v = <span class="dt">ref</span> <span class="dv">0</span>, <span class="dt">ref</span> (accessibles g <span class="dv">0</span>) <span class="kw">in</span></span>
<span id="cb69-3"><a href="#cb69-3"></a>    <span class="kw">for</span> i = <span class="dv">1</span> <span class="kw">to</span> <span class="dt">Array</span>.length g.sommets - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb69-4"><a href="#cb69-4"></a>        <span class="kw">let</span> v&#39; = accessibles g i <span class="kw">in</span></span>
<span id="cb69-5"><a href="#cb69-5"></a>        <span class="kw">if</span> v&#39; &gt; !v</span>
<span id="cb69-6"><a href="#cb69-6"></a>        <span class="kw">then</span> ( v := v&#39;; m := i )</span>
<span id="cb69-7"><a href="#cb69-7"></a>    <span class="kw">done</span>;</span>
<span id="cb69-8"><a href="#cb69-8"></a>    !m, !v</span></code></pre></div>
<p></div> </div> </div></p>
<h3 data-number="7.2.4" id="sec:plus-long-chemin-et-diametre"><span class="header-section-number">7.2.4</span> Plus long chemin et diametre</h3>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>plus_loin : graphe -&gt; int -&gt; int list</code> telle que <code>plus_long_chemin g x</code> renvoie le chemin de <code>x</code> au sommet <code>y</code> qui lui est le plus éloigné.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb70"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb70-1"><a href="#cb70-1"></a><span class="kw">let</span> plus_loin g x =</span>
<span id="cb70-2"><a href="#cb70-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length g.sommets <span class="kw">in</span></span>
<span id="cb70-3"><a href="#cb70-3"></a>    <span class="kw">let</span> d, p = bfs g x <span class="kw">in</span></span>
<span id="cb70-4"><a href="#cb70-4"></a>    <span class="kw">let</span> i = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb70-5"><a href="#cb70-5"></a>    <span class="kw">while</span> d.(!i) = <span class="dt">None</span> <span class="kw">do</span></span>
<span id="cb70-6"><a href="#cb70-6"></a>        <span class="dt">incr</span> i</span>
<span id="cb70-7"><a href="#cb70-7"></a>    <span class="kw">done</span>;</span>
<span id="cb70-8"><a href="#cb70-8"></a>    <span class="kw">let</span> m = <span class="dt">ref</span> (!i) <span class="kw">in</span></span>
<span id="cb70-9"><a href="#cb70-9"></a>    <span class="kw">for</span> j = !i+<span class="dv">1</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb70-10"><a href="#cb70-10"></a>        <span class="kw">match</span> d.(j) <span class="kw">with</span></span>
<span id="cb70-11"><a href="#cb70-11"></a>        | <span class="dt">Some</span> v -&gt; <span class="kw">if</span> v &gt; Option.get d.(!m) <span class="kw">then</span> m := j</span>
<span id="cb70-12"><a href="#cb70-12"></a>        | <span class="dt">None</span> -&gt; ()</span>
<span id="cb70-13"><a href="#cb70-13"></a>    <span class="kw">done</span>;</span>
<span id="cb70-14"><a href="#cb70-14"></a>    <span class="kw">let</span> v = Option.get d.(!m) <span class="kw">in</span></span>
<span id="cb70-15"><a href="#cb70-15"></a>    !m, v, chemin g p !m</span></code></pre></div>
</div> </div> </div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>diametre : graphe -&gt; int list</code> qui renvoie un chemin réalisant le diamètre d’un graphe.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> <div class="ui segment code"></p>
<div class="sourceCode" id="cb71"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb71-1"><a href="#cb71-1"></a><span class="kw">let</span> diametre g = </span>
<span id="cb71-2"><a href="#cb71-2"></a>    <span class="kw">let</span> n = <span class="dt">Array</span>.length g.sommets <span class="kw">in</span></span>
<span id="cb71-3"><a href="#cb71-3"></a>    <span class="kw">let</span> v, p = <span class="dt">ref</span> <span class="dv">0</span>, <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb71-4"><a href="#cb71-4"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb71-5"><a href="#cb71-5"></a>        <span class="kw">let</span> j, v&#39;, chemin = plus_loin g i <span class="kw">in</span></span>
<span id="cb71-6"><a href="#cb71-6"></a>        <span class="kw">if</span> !v &lt; v&#39;</span>
<span id="cb71-7"><a href="#cb71-7"></a>        <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb71-8"><a href="#cb71-8"></a>            v := v&#39;;</span>
<span id="cb71-9"><a href="#cb71-9"></a>            p := chemin</span>
<span id="cb71-10"><a href="#cb71-10"></a>        <span class="kw">end</span></span>
<span id="cb71-11"><a href="#cb71-11"></a>    <span class="kw">done</span>;</span>
<span id="cb71-12"><a href="#cb71-12"></a>    !p</span></code></pre></div>
<p></div> </div> </div></p>
<h3 data-number="7.2.5" id="sec:table-de-résultats"><span class="header-section-number">7.2.5</span> Table de résultats</h3>
<p><strong>Attention</strong> : s’il faut peu de temps pour obtenir les résultats pour le sous-graphe de 500 sommets, c’est beaucoup plus long sur le graphe en entier.</p>
<ul>
<li><strong><span class="math inline">\(\mathcal{G}_{500}\)</span></strong> :</li>
</ul>
<pre><code>degré max 10
degré moyen 0.430000
max_accessibles Mishkalashnikov avec 16 sommets
Diamètre 7 réalisé par :
Isaac__K -&gt; naxonlabs -&gt; faezeh_db -&gt; MooreInst -&gt; 
    fath_gabrielle -&gt; hypothesesorg -&gt; ScienceFactor -&gt; savantures</code></pre>
<ul>
<li><strong><span class="math inline">\(rev(\mathcal{G}_{500})\)</span></strong> :</li>
</ul>
<pre><code>degré max 31
degré moyen 0.430000
max_accessibles savantures avec 76 sommets
Diamètre 7 réalisé par :
savantures -&gt; ScienceFactor -&gt; hypothesesorg -&gt; 
    fath_gabrielle -&gt; MooreInst -&gt; faezeh_db -&gt; naxonlabs -&gt; Isaac__K</code></pre>
<ul>
<li><strong><span class="math inline">\(\mathcal{G}_{500}^-\)</span></strong> :</li>
</ul>
<pre><code>degré max 4
degré moyen 0.176000
max_accessibles SeverineWozniak avec 8 sommets
Diamètre 4 réalisé par :
QLMB8mars -&gt; giu_sapio -&gt; louise_tbr -&gt; GroupeImpec -&gt; halfbloodqueenx</code></pre>
<ul>
<li><strong><span class="math inline">\(\mathcal{G}_{500}^+\)</span></strong> :</li>
</ul>
<pre><code>degré max 32
degré moyen 0.684000
max_accessibles helloselyn avec 98 sommets
Diamètre 12 réalisé par :
TsamiyahL -&gt; FES_AFNEUS -&gt; FlorestanAFNEUS -&gt; FedeAddiction -&gt; 
    LS46151053 -&gt; hypothesesorg -&gt; Osec2022 -&gt; ardakaniz -&gt; 
    ValRobert974 -&gt; DialloAIbrahim2 -&gt; Defense137 -&gt; KArthemis -&gt; 
    SGF_GEOSOC</code></pre>
<ul>
<li><strong><span class="math inline">\(\mathcal{G}\)</span></strong> :</li>
</ul>
<pre><code>degré max 950
degré moyen 36.266096
max_accessibles Boris_Brana avec 6049 sommets
Diamètre 9 réalisé par :
MonaEmara10 -&gt; SambitPhD -&gt; MIT_CSAIL -&gt; MehdiKaytoue -&gt; gromuald -&gt; 
    ECHARDE_ENSL -&gt; cerseilia_ -&gt; dadoyeldado -&gt; Deccefunjoogu -&gt; stoicsalik</code></pre>
<ul>
<li><strong><span class="math inline">\(rev(\mathcal{G})\)</span></strong> :</li>
</ul>
<pre><code>degré max 3655
degré moyen 36.266096
max_accessibles JustVonBraun avec 7532 sommets
Diamètre 9 réalisé par :
Bonusbasci -&gt; TCebere -&gt; Miruna_Rosca -&gt; h2020prometheus -&gt; 
    barENdSonLyon -&gt; INP_CNRS -&gt; ThierryCoulhon -&gt; Phil_Baty -&gt; 
    HigherEdFutures -&gt; HEMobilities</code></pre>
<ul>
<li><strong><span class="math inline">\(\mathcal{G}^-\)</span></strong> :</li>
</ul>
<pre><code>degré max 610
degré moyen 12.069850
max_accessibles augabcoh avec 5352 sommets
Diamètre 10 réalisé par :
LeaLescouzeres -&gt; Gauthier_tls -&gt; MorganeBoulch -&gt; CSNB14 -&gt; 
    leo_chapuis -&gt; CCILYONMETRO -&gt; IsabelleHuault -&gt; Phil_Baty -&gt; 
    UNIKEhighered -&gt; HigherEdFutures -&gt; HEMobilities</code></pre>
<ul>
<li><strong><span class="math inline">\(\mathcal{G}^+\)</span></strong> :</li>
</ul>
<pre><code>degré max 3655
degré moyen 60.462343
max_accessibles augabcoh avec 7854 sommets
Diamètre 7 réalisé par :
GabrielMarseres -&gt; caroched -&gt; MarieMoroso -&gt; L3vironaute -&gt; najatvb -&gt; 
    LeankonCarotte -&gt; JustVonBraun -&gt; Sardine49160063</code></pre>
<h3 data-number="7.2.6" id="sec:aller-plus-loin"><span class="header-section-number">7.2.6</span> Aller plus loin</h3>
<p>On propose ici plusieurs pistes de réflexions pour prolonger le TP :</p>
<ul>
<li>On a vu des algorithmes de dessin de graphes adaptés à des petits graphes. La présence de l’interaction sommet-sommet semble leur donner une complexité en <span class="math inline">\(O(n^2)\)</span> qui est rédhibitoire ici. Cependant, des sommets éloignés ont peu de chance d’interagir, comment pourrait-on modifier l’algorithme pour ignorer les interactions de répulsions entre sommets éloignés ? On remarque que la distance n’est pas un critère valide car les sommets peuvent être tous être superposés. Une manière de traiter cela efficacement est de découper le plan en région par des droites successives. Allez voir la page <a href="https://en.wikipedia.org/wiki/Binary_space_partitioning">Binary Space Partionning</a> et en déduire un algorithme effectif de dessin de graphe adapté.</li>
<li>Pour estimer l’importance d’un compte, on ne peut pas se fier à son degré. En effet, celui-ci peut être augmenté artificiellement. Une manière fiable de mesurer l’importance est d’imaginer quelqu’un naviguant aléatoirement sur des comptes en suivant des liens d’abonnement et de mesurer la probabilité qu’il se retrouve sur un compte donné. C’est le principe qui est à la base de l’algorithme <a href="https://en.wikipedia.org/wiki/PageRank">PageRank</a> utilisé par Google. Implémenter cet algorithme et en déduire les comptes les plus importants dans cet exemple.</li>
</ul>
<h2 data-number="7.3" id="sec:plus-courts-chemins-en-ocaml"><span class="header-section-number">7.3</span> Plus courts chemins en <code>OCaml</code></h2>
<p>Ce TP vous demande plus d’autonomie que les TP précédents. Il s’agit de mobiliser des connaissances plus anciennes et d’implémenter effectivement des algorithmes que l’on comprend bien en pseudo-code.</p>
<p>L’objectif est de pouvoir résoudre des problèmes comme :</p>
<ul>
<li><a href="https://www.spoj.com/problems/HIGHWAYS/">HIGHWAYS</a></li>
<li><a href="https://www.spoj.com/problems/MICEMAZE/">MICEMAZE</a></li>
<li><a href="https://www.spoj.com/problems/TRAFFICN/">TRAFFICN</a></li>
<li><a href="https://www.spoj.com/problems/SAMER08A/">SAMER08A</a></li>
</ul>
<p>Si vous êtes courageux, foncez sans lire la suite ;-)</p>
<h3 data-number="7.3.1" id="sec:écriture-naïve-de-dijkstra"><span class="header-section-number">7.3.1</span> Écriture naïve de Dijkstra</h3>
<p>Écrire une implémentation de Dijkstra reposant sur une file de priorité inefficace, comme une liste de couples, pour effectuer la recherche du sommet de plus petite priorité.</p>
<p>On considérera, comme pour les autres parcours que le graphe est donné sous la forme de listes d’adjacence.</p>
<h3 data-number="7.3.2" id="sec:réalisation-dune-file-de-min-priorité"><span class="header-section-number">7.3.2</span> Réalisation d’une file de min-priorité</h3>
<p>Reprendre l’implémentation des files de priorité donnée dans le corrigé du TP18 (cliquez sur les liens dans les titres de parties) en faisant en sorte de gérer des couples <span class="math inline">\((sommet, distance)\)</span> et en faisant attention au fait que <em>distance</em> peut être <span class="math inline">\(\infty\)</span>. On pourra définir un <code>type poids = I | N of int</code>.</p>
<p><strong>Attention</strong> il s’agit ici de file de priorité minimale !</p>
<h3 data-number="7.3.3" id="sec:écriture-de-dijkstra-efficace"><span class="header-section-number">7.3.3</span> Écriture de Dijkstra efficace</h3>
<p>Utiliser la file de priorité pour en déduire une implémentation efficace.</p>
<h3 data-number="7.3.4" id="sec:floys-warshall"><span class="header-section-number">7.3.4</span> Floys-Warshall</h3>
<p>Lire et implémenter l’algorithme de Floyd-Warshall au-dessus.</p>
<h3 data-number="7.3.5" id="sec:problèmes"><span class="header-section-number">7.3.5</span> Problèmes</h3>
<p>Résoudre les problèmes donnés au dessus. On pourra utiliser la fonction suivante en <code>OCaml</code> pour lire des entiers séparés par des espaces sur une ligne :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb80"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb80-1"><a href="#cb80-1"></a><span class="kw">let</span> read_int_list () =</span>
<span id="cb80-2"><a href="#cb80-2"></a>    <span class="dt">List</span>.map <span class="dt">int_of_string</span> (<span class="dt">String</span>.split_on_char <span class="ch">&#39; &#39;</span> (<span class="dt">read_line</span> ()))</span></code></pre></div>
<p></div></p>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
