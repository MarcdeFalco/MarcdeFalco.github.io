<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Marc de Falco">

    <title>Graphes</title>

    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css">
    <link href='//fonts.googleapis.com/css?family=Lato:300,400' rel='stylesheet' type='text/css'>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PHZQE2FC4W"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-PHZQE2FC4W');
	</script>

    <script
      src="https://code.jquery.com/jquery-3.1.1.min.js"
      integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
      crossorigin="anonymous"></script>
    <script src="assets/semantic.min.js"></script>

    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script>
$(document).ready(function() {
    
    $("#toc").sidebar("setting", "dimPage", false);
    $("#toc").sidebar("setting", "delaySetup", true);

   $('.ui.accordion').accordion();
    if (matchMedia) {
        var mq = window.matchMedia("(max-width: 900px)");
        mq.addListener(big_or_small);
        big_or_small(mq);
    }

    $("[href^='#']").click(
        () => {
            if (! $("#main").hasClass('shrink')) {
	            $("#toc").sidebar("hide");
            }
        })

    function big_or_small(mq) {
        // The sidebar *pushes* the pusher, the main content, so we
        // add a class that reduces the pusher's width so the edge
        // content isn't cut off.
        if (mq.matches) {
	        $("#toc").sidebar("hide");
            $("#main").removeClass("shrink")
        } else {
            $("#toc").sidebar("show");
            $("#main").addClass("shrink");
        }
    }

    $("#sidebar-menu-button").click(function() {
        $("#toc").sidebar("show");
    }).end();

    $('.tabular.menu .item').tab({
            context: 'parent'
        });

})

function setLang(l) {
    $('.tabular.menu .item').removeClass("active")
    $('.tabular.menu .item[data-tab^="'+l+'"]').addClass("active")
    $('.code').removeClass("active")
    $('.code[data-tab^="'+l+'"]').addClass("active")
}
</script>

  <style type="text/css">

  .ui.sidebar {
    font-size: 15px;
  }

  body {
    background-color: #FFFFFF;
    font-size: 20px;
  }
  .ui.segment {
    font-size: 20px;
  }
  .wireframe {
    //margin-top: 2em;
  }
  .ui.footer.segment {
    //margin: 5em 0em 0em;
    //padding: 5em 0em;
  }
  #top-menu {
    display: none;
    }

    .message {
        color: #000 !important;
    }

.shrink {
    width: 60%;
}

.code {
    font-size: 0.8em !important;
}

table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 24px;
    border-spacing: 0;
    border-bottom: 2px solid black;
    border-top: 2px solid black;
}

table tr {
    display: table-row !important;
}

table th {
    padding: 3px 10px;
    background-color: white;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid black;
}
table td {
    padding: 3px 10px;
    border-top: none;
    border-left: none;
    border-bottom: none;
    border-right: none;
}

.ui.styled.accordion {
    width: 100% !important;
    font-size: 1rem !important;
}

  .menu .item {
      padding: .5em 1em !important;
  }

@media only screen and (max-width: 900px) {
    .ui.image, .ui.image img {
        display: block;
        //width: 100%;
        width: auto;
        height: auto;
    }

    #top-menu {
        display: block !important;
    }
}
  </style>

  </head>
  <body class="pushable class="pushable"">
<div style="display: none;">
\(
\def\N{{\mathbb{N}}}
\def\R{{\mathbb{R}}}
\def\D{{\mathbb{D}}}
\def\C{{\mathbb{C}}}
\def\Z{{\mathbb{Z}}}
\def\Q{{\mathbb{Q}}}
\def\K{{\mathbb{K}}}
\def\KX{{\mathbb{K}}[X]}
\def\U{{\mathbb{U}}}
\def\B{{\mathcal{B}}}
\newcommand\ensfonctions[2]{\mathcal{F}(#1,#2)}
\newcommand\classeck[3]{\mathcal{C}^{#1}(#2,#3)}
\newcommand\range[2]{[| #1,#2 |]}
\newcommand\mod[0]{\mathop{mod}}
\newcommand\land[0]{\mathop{land}}
\newcommand\matrices[3]{\mathcal{M}_{#1,#2}(#3)}
\newcommand\matricescarres[2]{\mathcal{M}_{#1}(#2)}
\newcommand\gln[2]{\mbox{GL}_{#1}(#2)}
\newcommand\Support[1]{\mbox{Supp}(#1)}
\newcommand\dom[0]{\mbox{dom}}
\newcommand\uniondisjointe{\sqcup}
\def\lt{<}
\def\rR{\mathcal{R}}
\newcommand\parties[1]{\mathcal{P}(#1)}
\newcommand\entiere[1]{\left\lfloor #1 \right\rfloor}
\newcommand\congru[3]{#1 = #2\ [#3]}
\newcommand\enscomp[2]{\left\{\left.\ #1\ \right|\ #2\ \right\}}
\newcommand\classe[1]{\overline{#1}}
\newcommand\classemod[2]{\overline{#1}^{[#2]}}
\newcommand\quotient[2]{#1 / #2}
\newcommand\ZnZ[1]{\quotient{\Z}{#1 \Z}}
\newcommand\card[1]{\text{Card}\ #1}
\newcommand\indic{\mathbbm{1}}
\newcommand\id{\mbox{id}}
\newcommand\gO{\mathcal{O}}
\newcommand\Perm[1]{\mathfrak{S}_#1}
\newcommand\comb[2]{\binom{#1}{#2}}
\newcommand\tend[2]{\xrightarrow[#1 \rightarrow #2]{}}
\newcommand\limite[2]{\lim_{#1 \rightarrow #2}}
\newcommand\application[5]{\begin{array}{rcccc}
#1 & : & #2 & \mapsto & #3 \\ 
& & #4 & \mapsto & #5
\end{array}}
\)
</div>



<div class="ui vertical inverted visible fixed sidebar menu" id="toc">
    <div class="item">
    <a href="/">
        <i class="icon home"></i> Informatique en CPGE
    </a>
    </div>
    <div class="item">
        <div class="ui buttons compact">
            <button onClick="setLang('ocaml')" class="ui button compact">OCaml</button>
            <button onClick="setLang('c')" class="ui button compact">C</button>
            <button onClick="setLang('python')" class="ui button compact">Python</button>
        </div>
        <div>Langage des exemples</div>
    </div>
    <div class="item">
    <a href="#">
        Graphes
    </a>
    </div>
<!-- FIX TOC -->
<div class="item header"> <a href="#sec:graphes-orientés"><span>1</span> Graphes orientés</a><div class="menu"><a class="item" href="#sec:définition"><div class="ui label">1.1</div> Définition</a><a class="item" href="#sec:voisins-et-degrés"><div class="ui label">1.2</div> Voisins et degrés</a><a class="item" href="#sec:chemin"><div class="ui label">1.3</div> Chemin</a><a class="item" href="#sec:sous-graphe"><div class="ui label">1.4</div> Sous-graphe</a><a class="item" href="#sec:implémentation"><div class="ui label">1.5</div> Implémentation</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:énumération-de-sommets"><i class="circle icon"></i> Énumération de sommets</a><a style="font-size:0.6em" class="item" href="#sec:matrice-dadjacence"><i class="circle icon"></i> Matrice d’adjacence</a><a style="font-size:0.6em" class="item" href="#sec:listes-dadjacences"><i class="circle icon"></i> Listes d’adjacences</a><a style="font-size:0.6em" class="item" href="#sec:comparaison"><i class="circle icon"></i> Comparaison</a></div></div></div><div class="item header"> <a href="#sec:graphes-non-orientés"><span>2</span> Graphes non orientés</a><div class="menu"><a class="item" href="#sec:graphes_symetrises"><div class="ui label">2.1</div> Définition et adaptation du vocabulaire</a><a class="item" href="#sec:connexité"><div class="ui label">2.2</div> Connexité</a><a class="item" href="#sec:graphe-acyclique-connexe"><div class="ui label">2.3</div> Graphe acyclique connexe</a><a class="item" href="#sec:graphe-biparti"><div class="ui label">2.4</div> Graphe biparti</a></div></div><div class="item header"> <a href="#sec:parcours"><span>3</span> Parcours</a><div class="menu"><a class="item" href="#sec:principe"><div class="ui label">3.1</div> Principe</a><a class="item" href="#sec:parcours-en-profondeur-récursif"><div class="ui label">3.2</div> Parcours en profondeur récursif</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:première-version"><i class="circle icon"></i> Première version</a><a style="font-size:0.6em" class="item" href="#sec:arbre-de-parcours"><i class="circle icon"></i> Arbre de parcours</a></div></div></div><div class="item header"> <a href="#sec:parcours-1"><span>4</span> Parcours</a><div class="menu"><a class="item" href="#sec:principe-et-parcours-récursif"><div class="ui label">4.1</div> Principe et parcours récursif</a><a class="item" href="#sec:profondeur"><div class="ui label">4.2</div> Profondeur</a><a class="item" href="#sec:largeur"><div class="ui label">4.3</div> Largeur</a></div></div><div class="item header"> <a href="#sec:chemin-de-plus-petit-poids"><span>5</span> Chemin de plus petit poids</a><div class="menu"><a class="item" href="#sec:graphe-pondéré"><div class="ui label">5.1</div> Graphe pondéré</a><a class="item" href="#sec:dijkstra-source-unique"><div class="ui label">5.2</div> Dijkstra : source unique</a><a class="item" href="#sec:todo-floyd-warshall-toutes-paires"><div class="ui label">5.3</div> TODO Floyd-Warshall : toutes paires</a></div></div><div class="item header"> <a href="#sec:travaux-pratiques"><span>6</span> Travaux Pratiques</a><div class="menu"><a class="item" href="#sec:parcours-de-graphes-en-c"><div class="ui label">6.1</div> Parcours de graphes en <code>C</code></a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:représentation"><i class="circle icon"></i> Représentation</a><a style="font-size:0.6em" class="item" href="#sec:parcours-en-profondeur-récursif-1"><i class="circle icon"></i> Parcours en profondeur récursif</a><a style="font-size:0.6em" class="item" href="#sec:temps-et-classification-des-arêtes"><i class="circle icon"></i> Temps et classification des arêtes</a><a style="font-size:0.6em" class="item" href="#sec:parcours-avec-une-structure"><i class="circle icon"></i> Parcours avec une structure</a></div><a class="item" href="#sec:étude-dun-graphe-issu-dun-réseau-social"><div class="ui label">6.2</div> Étude d’un graphe issu d’un réseau social</a><div class="secondary menu"><a style="font-size:0.6em" class="item" href="#sec:définition-et-lecture-du-graphe"><i class="circle icon"></i> Définition et lecture du graphe</a><a style="font-size:0.6em" class="item" href="#sec:statistiques-sur-les-degrés"><i class="circle icon"></i> Statistiques sur les degrés</a><a style="font-size:0.6em" class="item" href="#sec:parcours-en-largeur"><i class="circle icon"></i> Parcours en largeur</a><a style="font-size:0.6em" class="item" href="#sec:plus-long-chemin-et-diametre"><i class="circle icon"></i> Plus long chemin et diametre</a><a style="font-size:0.6em" class="item" href="#sec:table-de-résultats"><i class="circle icon"></i> Table de résultats</a><a style="font-size:0.6em" class="item" href="#sec:aller-plus-loin"><i class="circle icon"></i> Aller plus loin</a></div></div></div><!-- FIX TOC -->
</div>

<div class="pusher" id="main-content">
    <div class="ui inverted top menu" id="top-menu">
        <div class="ui container">
	  <a class="launch icon item" id="sidebar-menu-button">
	    <i class="angle double left icon"></i>
	  </a>
	  <div class="item">
          Graphes
	  </div>
        </div>
      </div>
      <div class="ui padded basic segment shrink" id="main">
          <!-- <div class="masthead"> -->
<div class="segment">
<div class="ui container text">
<p><div class="ui image fluid">   <div class="ui inverted active dimmer">   <div class="content">     <h1 class="ui header" style="color:black; font-size: 4rem" >     Graphes     </h1>   </div>   </div>   <img class="" src="assets/pics/chap_graphe.jpg"> </div></p>
<p><div class="ui message blue"><div class="header">Note</div>Une grande partie est issue verbatim de mon ancien poly. À affiner.</div></p>
<h1 data-number="1" id="sec:graphes-orientés"><span class="header-section-number">1</span> Graphes orientés</h1>
<h2 data-number="1.1" id="sec:définition"><span class="header-section-number">1.1</span> Définition</h2>
<p><div class="ui message"><div class="header">Définition</div> Un graphe orienté est un couple <span class="math inline">\(G = (S, A)\)</span> où <span class="math inline">\(S\)</span> est un ensemble fini et <span class="math inline">\(A\)</span> est une relation <strong>irréflexive</strong> sur <span class="math inline">\(S\)</span>, c’est-à-dire <span class="math inline">\(S \subset \{ (x,y) ~|~ x,y \in S, x \neq y\}\)</span>.</p>
<p>Les éléments de <span class="math inline">\(S\)</span> sont appelés les <strong>sommets</strong> du graphe <span class="math inline">\(G\)</span> et les éléments de <span class="math inline">\(A\)</span> les <strong>arêtes</strong>. Si <span class="math inline">\((x,y) \in A\)</span>, on dit que <span class="math inline">\(x\)</span> est la source de l’arête et <span class="math inline">\(y\)</span> est son but. Quand le contexte n’est pas ambigu, on notera <span class="math inline">\(x \rightarrow y\)</span>. </div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li><span class="math inline">\(G = ( \{ a, b, c \}, \{ (a, b), (b, c), (c, b) \} )\)</span></li>
<li><span class="math inline">\(D_n = ( \range{1}{n}, \{ (a,b) ~|~ a \text{ divise } b \} )\)</span></li>
</ul>
</div>
<p><div class="ui message orange"><div class="header">Remarque</div>Ici, on a exclu les graphes infinis ainsi que les graphes avec des boucles ou des arêtes parallèles. On est dans le contexte des <strong>graphes finis simples</strong>.</div></p>
<p>On représente graphiquement un graphe sous la forme d’un diagramme sagittaire où les sommets sont des points et où une arêtes <span class="math inline">\((a,b)\)</span> est une flèche allant du point <span class="math inline">\(a\)</span> au point <span class="math inline">\(b\)</span>.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<ul>
<li><p><span class="math inline">\(G\)</span> est représenté par <center><div class="ui image center"><img src="assets/pics/graphe_g_rep.png" /></div></center></p></li>
<li><p><span class="math inline">\(D_{10}\)</span> est représenté par <center><div class="ui image center"><img src="assets/pics/graphe_d10_rep.png" /></div></center></p></li>
</ul>
</div>
<h2 data-number="1.2" id="sec:voisins-et-degrés"><span class="header-section-number">1.2</span> Voisins et degrés</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G = (S, A)\)</span> un graphe orienté et <span class="math inline">\(x \in S\)</span>.</p>
<p>On appelle <strong>voisins sortants</strong>, ou <strong>successeurs</strong>, de <span class="math inline">\(x\)</span> les éléments de <span class="math display">\[
v_+(x) = \enscomp{y \in S}{(x,y) \in A}
\]</span> et on appelle <strong>degré sortant</strong> de <span class="math inline">\(x\)</span> le cardinal de cet ensemble <span class="math inline">\(d_+(x) = |v_+(x)|\)</span>.</p>
<p>De même, on parle de <strong>voisins entrants</strong>, ou <strong>prédéceseurs</strong> pour les éléments de <span class="math display">\[
v_-(x) = \enscomp{z \in S}{(z,x) \in A}
\]</span> et on parle de <strong>degré entrant</strong> pour <span class="math inline">\(d_-(x) = |v_-(x)|\)</span>. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Soit <span class="math inline">\(G = (S, A)\)</span> un graphe, on a <span class="math inline">\(\sum_{x \in S} d_+(x) = \sum_{x \in S} d_-(x) = |A|\)</span></p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> On peut partitionner <span class="math inline">\(A\)</span> en regroupant les arêtes de même source, on a ainsi :</p>
<p><span class="math display">\[
A = \bigcup_{x \in S} \enscomp{(x,y)}{y \in S, (x,y) \in A}
= \bigcup_{x \in S} \enscomp{(x,y)}{y \in v_+(x)}
\]</span></p>
<p>Et en prenant la cardinal de cette égalité, on obtient directement <span class="math inline">\(|A| = \sum_{x \in S} d_+(x)\)</span>. L’autre égalité est symétrique en considérant les arêtes de même but. </div> </div></p>
<h2 data-number="1.3" id="sec:chemin"><span class="header-section-number">1.3</span> Chemin</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G = (S,A)\)</span> un graphe orienté et <span class="math inline">\(x, y \in S\)</span>.</p>
<p>Une suite finie <span class="math inline">\(\varphi = (s_0, s_1, \dots, s_p)\)</span> où <span class="math inline">\(p \in \N, s_0 = x, s_p = y\)</span> et <span class="math display">\[
\forall i \in \range{1}{p}, (s_{i-1},s_i) \in A
\]</span> est appelée un <strong>chemin</strong>, de longueur <span class="math inline">\(p\)</span>, de <span class="math inline">\(x\)</span> vers <span class="math inline">\(y\)</span>. On a donc <span class="math display">\[
s_0 \rightarrow s_1 \rightarrow \dots \rightarrow s_p
\]</span></p>
<p>On notera <span class="math inline">\(\varphi : x \leadsto y\)</span> pour signifier que <span class="math inline">\(\varphi\)</span> est un tel chemin et <span class="math inline">\(x \leadsto y\)</span> pour signifier qu’il existe un chemin de <span class="math inline">\(x\)</span> vers <span class="math inline">\(y\)</span>. On dit alors que <span class="math inline">\(y\)</span> est accessible depuis <span class="math inline">\(x\)</span>. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><span class="math inline">\(\leadsto\)</span> est la plus petite relation sur <span class="math inline">\(S\)</span> contenant <span class="math inline">\(\rightarrow\)</span> et qui soit réflexive et transitive.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> On considère <span class="math inline">\(\rightarrow \subset R \subset S^2\)</span> telle que <span class="math inline">\(R\)</span> soit réflexive et transitive.</p>
<p>Soient <span class="math inline">\(x, y \in S\)</span> et <span class="math inline">\(\varphi = (s_0, \dots, s_p) : x \leadsto y\)</span>.</p>
<p>Comme <span class="math inline">\(s_{i-1} \rightarrow s_i\)</span> on a <span class="math inline">\(s_{i-1} R s_i\)</span> et, par transitivité, <span class="math inline">\(x = s_0 R s_p = y\)</span>. Donc <span class="math inline">\(x \leadsto y \Rightarrow x R y\)</span>.</p>
<p>Ainsi <span class="math inline">\(\leadsto \subset R\)</span>. </div> </div></p>
<p>On dit que <span class="math inline">\(\leadsto\)</span> est la clôture réflexive et transitive de <span class="math inline">\(\rightarrow\)</span>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Vocabulaire additionnel :</p>
<ul>
<li>Si tous les sommets sont distincts, sauf éventuellement le premier et le dernier, on dit que le chemin est <strong>élémentaire</strong>.</li>
<li>Si toutes les arêtes sont distinctes, on dit que le chemin est <strong>simple</strong>.</li>
<li>Si <span class="math inline">\(x = y\)</span>, on dit que le chemin est <strong>fermé</strong>.</li>
<li>Un chemin simple dont tous les sommets sont distincts est appelé une <strong>chaîne</strong>.</li>
<li>Un chemin élémentaire fermé simple de longueur au moins 1 est appelé un <strong>cycle</strong>. <em>Comme le chemin vide issu de <span class="math inline">\(x\)</span> est fermé, il est nécessaire de considérer des chemins non vides.</em></li>
<li>Un graphe contenant au moins un cycle est dit <strong>cyclique</strong>. Dans le cas contraire, on dit qu’il est <strong>acyclique</strong>.</div></li>
</ul>
<p><div class="ui message orange"><div class="header">Remarque</div>Si <span class="math inline">\(\varphi : x \leadsto y\)</span> et <span class="math inline">\(\psi : y \leadsto z\)</span> on note <span class="math inline">\(\varphi \psi :x \leadsto z\)</span> la concaténée des deux chemins.</div></p>
<p><div class="ui message"><div class="header">Définition</div> On note <span class="math inline">\(\leftrightarrow y\)</span> la plus grande relation d’équivalence incluse dans <span class="math inline">\(\leadsto\)</span>.</p>
<p>Plus précisément, on a <span class="math display">\[
x \leftrightarrow y \iff (x \leadsto y \wedge y \leadsto x)
\]</span></p>
<p>Les classes d’équivalences pour <span class="math inline">\(\leftrightarrow\)</span> sont appelées les composantes <strong>fortement connexes</strong> du graphe. S’il n’y a qu’une classe, on dit que le graphe est <strong>fortement connexe</strong>. </div></p>
<h2 data-number="1.4" id="sec:sous-graphe"><span class="header-section-number">1.4</span> Sous-graphe</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G = (S,A)\)</span> et <span class="math inline">\(X \subset S\)</span>. On appelle <strong>sous-graphe</strong> induit par <span class="math inline">\(X\)</span> le graphe <span class="math inline">\((X, A_X)\)</span> où <span class="math display">\[
A_X = \enscomp{ (a,b) \in A}{a \in X\wedge b \in X}
\]</span></p>
<p>Un graphe <span class="math inline">\(G&#39;\)</span> est un <strong>sous-graphe</strong> de <span class="math inline">\(G\)</span> quand c’est le sous-graphe de <span class="math inline">\(G\)</span> induit par les sommets de <span class="math inline">\(G&#39;\)</span> (ils sont alors nécessairement des sommets de <span class="math inline">\(G\)</span>). </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Les composantes fortement connexes sont les sous-graphes fortement connexes maximaux pour l’inclusion.</div></p>
<h2 data-number="1.5" id="sec:implémentation"><span class="header-section-number">1.5</span> Implémentation</h2>
<h3 data-number="1.5.1" id="sec:énumération-de-sommets"><span class="header-section-number">1.5.1</span> Énumération de sommets</h3>
<p>Si on considère un graphe <span class="math inline">\(G = (S,A)\)</span>, il est assez naturel de représenter ses sommets dans un tableau. Pour cela, on fixe naturellement un ordre sur ces sommets et on va associer à chaque sommet son indice dans le tableau.</p>
<p>Par exemple, si <span class="math inline">\(S = \{ a, b, c, d\}\)</span> on va pouvoir considérer <code>[ a, b, c, d ]</code> et ainsi associer à <code>a</code> son indice 0 dans le tableau. L’ordre est arbitraire, on aurait pu considérer <code>[ b, c, a, d ]</code> et l’indice de <code>a</code> aurait alors été 2.</p>
<p>Ce qui compte, c’est de pouvoir travailler directement sur les indices et pas sur les éléments. Une manière de s’en convaincre est d’imaginer le graphe d’un réseau social où un sommet correspond au profil d’une personne, et contient donc beaucoup (<em>trop</em>) d’informations. Il est bien plus raisonnable de lui associer un identifiant unique et d’utiliser cet identifiant ensuite.</p>
<p>Quand on va implémenter des graphes, on peut donc supposer que les sommets sont les entiers de <code>0</code> à <code>n-1</code> où <span class="math inline">\(|S| = n\)</span>. Il sera toujours possible de retrouver la correspondance avec les sommets eux-mêmes.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Si on est bloqué par le coût de l’opération permettant d’obtenir l’indice d’un sommet, qui est en <span class="math inline">\(O(|S|)\)</span> par une recherche linéaire, on peut très bien définir un dictionnaire associant à chaque sommet son indice en <span class="math inline">\(O(1)\)</span>.</p>
<p>Il se trouve qu’on ne va pas forcément s’intéresser à ces questions mais plus aux raisonnements sur la structure du graphe.</div></p>
<h3 data-number="1.5.2" id="sec:matrice-dadjacence"><span class="header-section-number">1.5.2</span> Matrice d’adjacence</h3>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G = (S,A)\)</span> un graphe et <span class="math inline">\(S = \{ s_1, \dots, s_n \}\)</span> une énumération sans répétition des sommets de <span class="math inline">\(G\)</span>. La matrice <span class="math inline">\(M_G = \left( m_{ij} \right)_{1 \le i, j \le n} \in \mathcal{M}_n(\R)\)</span> définie par <span class="math display">\[
\forall i, j \in \range{1}{n}, m_{ij} = \begin{cases}
1 &amp;\text{ si } s_i \rightarrow s_j \\ 0 &amp; \text{ sinon } \end{cases}
\]</span> est appelée une <strong>matrice d’adjacence</strong> de <span class="math inline">\(G\)</span>. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Il s’agit bien d’<strong>une</strong> matrice d’adjacence et pas de <strong>la</strong> matrice car elle dépend de l’énumération des sommets.</div></p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on considère le graphe</p>
<p><center><div class="ui image center"><img src="assets/pics/matex1.png" /></div></center></p>
<p>On aura pour l’énumération <span class="math inline">\(a,b,c,d\)</span> la matrice : <span class="math display">\[
\begin{pmatrix}
0 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 &amp; 0
\end{pmatrix}
\]</span> En fait, la ième ligne correspond au ième sommet de l’énumération. Ici, la dernière ligne <span class="math inline">\(1 1 0 0\)</span> correspond au sommet d et donne dans l’ordre <span class="math inline">\(a,b,c,d\)</span> la présence ou non d’une arête <span class="math inline">\(d \rightarrow *\)</span>.</p>
<p>Si on considère l’énumération <span class="math inline">\(b,a,d,c\)</span> on aura la matrice :</p>
<p><span class="math display">\[
\begin{pmatrix}
0 &amp; 1 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1 &amp; 1 \\
1 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}
\]</span></p>
</div>
<p>On en déduit ainsi une implémentation directe d’un graphe en représentant la matrice d’adjacence comme l’a fait pour des images.</p>
<p><div>   <div class="ui top attached tabular menu code">   <a class="active item" data-tab="python-89">python</a>   <a class="item" data-tab="c-89">c</a>   <a class="item" data-tab="ocaml-89">ocaml</a> </div> <div class="ui bottom attached active tab segment code" data-tab="python-89"></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> [ [ <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span> ],</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      [ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span> ],</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span> ],</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      [ <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span> ] ]</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="c-89"></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="ocaml-89"></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> m = [| [| <span class="dv">0</span>; <span class="dv">1</span>; <span class="dv">1</span>; <span class="dv">1</span> |];</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>           [| <span class="dv">1</span>; <span class="dv">0</span>; <span class="dv">0</span>; <span class="dv">1</span> |];</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>           [| <span class="dv">0</span>; <span class="dv">0</span>; <span class="dv">0</span>; <span class="dv">1</span> |];</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>           [| <span class="dv">1</span>; <span class="dv">1</span>; <span class="dv">0</span>; <span class="dv">0</span> |] |]</span></code></pre></div>
<p></div> </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Il y a le même lien entre les différentes matrices d’adjacence d’un graphe donnée et la matrice d’un endomorphisme dans les différentes permutations d’une même base, à chaque fois on obtient la nouvelle matrice en permutant de même ses lignes et ses colonnes.</div></p>
<p>Cette représentation permet d’accéder, en lecture comme en écriture, à une arête en temps constant. Cependant, pour récupérer les voisins d’un sommet, il est nécessaire de parcourir toute la ligne correspondante, donc en <span class="math inline">\(O(|S|)\)</span>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Dans la majorité des cas, <span class="math inline">\(A\)</span> est petit par rapport à <span class="math inline">\(|S|^2\)</span>. Ainsi, la matrice contient très peu de 1 et beaucoup de 0, on dit qu’elle est <em>creuse</em>. Une telle matrice <em>creuse</em> peut-être efficacement représenté par l’ensemble fini des arêtes <span class="math inline">\((i,j)\)</span>. Par exemple, avec une table de hachage. Cependant, dans le cas des graphes, il est possible d’avoir une structure creuse plus efficace.</div></p>
<h3 data-number="1.5.3" id="sec:listes-dadjacences"><span class="header-section-number">1.5.3</span> Listes d’adjacences</h3>
<p>La donnée de <span class="math inline">\(v_+(x)\)</span> pour chaque sommet <span class="math inline">\(x \in S\)</span> suffit à reconstruire <span class="math inline">\(A\)</span>.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Si on reprend le graphe précédent, <center><div class="ui image center"><img src="assets/pics/matex1_bis.png" /></div></center></p>
<p>on a <span class="math inline">\(S = \{ a,b,c,d\}\)</span> et <span class="math inline">\(A = \{ (a, b), (a, c), (a,d), (b,a), (b, d) , (c,d), (d, a), (d, b) \}\)</span>.</p>
<p>Or <span class="math inline">\(v_+(a) = \{ b, c, d \}, v_+(b) = \{ a, d \}, v_+(c) = \{ d \}\)</span> et <span class="math inline">\(v_+(d) = \{ a, b \}\)</span>.</p>
<p>Si on pose <span class="math inline">\(V_+(x) = \enscomp{ (x,y) }{ y \in v_+(x) }\)</span> on a directement <span class="math inline">\(A = \bigcup_{x \in S} V_+(x)\)</span>.</p>
</div>
<p>On en déduit ainsi une représentation d’un graphe où on place dans un tableau chaque <span class="math inline">\(v_+(x)\)</span> représenté par une liste chaînée ou un tableau dynamique.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Pour représenter <span class="math inline">\(v_+(x)\)</span> on a plusieurs choix : on peut utiliser directement les valeurs des sommets ou utiliser des indices dans une énumération. C’est le second choix qu’on fera en général car il est plus simple. Cependant, en cas de suppression d’un sommet, les indices changent, et il faut renuméroter dans les listes.</p>
<p>Pour le graphe précédent, on pourra donc considérer une énumeration <code>[ a, b, c, d ]</code> et la représentation sous forme de liste d’adjacence pourra être :</p>
<p><div class="ui top attached tabular menu code">   <a class="active item" data-tab="python">python</a>   <a class="item" data-tab="ocaml">ocaml</a> </div> <div class="ui bottom attached active tab segment code" data-tab="python"></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> [ [ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ], [ <span class="dv">0</span>, <span class="dv">3</span> ], [ <span class="dv">3</span> ], [ <span class="dv">0</span>, <span class="dv">1</span> ] ]</span></code></pre></div>
<p></div> <div class="ui bottom attached tab segment code" data-tab="ocaml"></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> l = [| </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    [ <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span> ]; [ <span class="dv">0</span>; <span class="dv">3</span> ]; [ <span class="dv">3</span> ]; [ <span class="dv">0</span>; <span class="dv">1</span> ]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    |]</span></code></pre></div>
<p></div></p>
<p></div></p>
<p>L’accès en lecture ou en écriture à une arête est alors en <span class="math inline">\(O(|A|)\)</span> mais on peut parcourir les voisins sortant en <span class="math inline">\(O(|A|)\)</span> également. Pour un sommet donné, on peut même préciser <span class="math inline">\(O(d_+(x))\)</span>. Accéder à la liste peut même se faire en <span class="math inline">\(O(1)\)</span>.</p>
<p>Pour obtenir les voisins entrants, il est par contre nécessaire de tester la présence de <span class="math inline">\(x\)</span> dans chacune des autres listes, on obtient donc un algorithme en <span class="math inline">\(O(|S| + |A|)\)</span> : on parcourt chaque case du tableau des listes puis chaque maillon de listes d’adjacence.</p>
<p>Il est possible d’améliorer cela en utilisant un structure plus efficace pour stocker les ensembles. Cela peut-être un dictionnaire reposant sur une table de hachage. L’avantage de cela est que pour tester l’appartenance <span class="math inline">\(y \in v_+(x)\)</span> on sera en <span class="math inline">\(O(1)\)</span> avec un dictionnaire alors qu’on sera en <span class="math inline">\(O(d_+(x))\)</span> avec une liste.</p>
<h3 data-number="1.5.4" id="sec:comparaison"><span class="header-section-number">1.5.4</span> Comparaison</h3>
<table style="width:86%;">
<colgroup>
<col style="width: 29%" />
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th>opération</th>
<th>Matrice</th>
<th>Listes</th>
<th>Dictionnaire</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>complexité spatiale</td>
<td><span class="math inline">\(O(|S|^2)\)</span></td>
<td><span class="math inline">\(O(|S|+|A|)\)</span></td>
<td><span class="math inline">\(O(|S|+|A|)\)</span></td>
</tr>
<tr class="even">
<td>arête test</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(|A|)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>arête ajout</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>arête suppression</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(|A|)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>sommet ajout</td>
<td><span class="math inline">\(O(|S|^2)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
</tr>
<tr class="even">
<td>sommet suppression</td>
<td><span class="math inline">\(O(|S|^2)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
</tr>
<tr class="odd">
<td>voisins/degré +</td>
<td><span class="math inline">\(O(|S|)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>voisins/degré -</td>
<td><span class="math inline">\(O(|S|)\)</span></td>
<td><span class="math inline">\(O(|S|+|A|)\)</span></td>
<td><span class="math inline">\(O(|S|)\)</span></td>
</tr>
</tbody>
</table>
<p>Notons qu’il est possible d’améliorer certaines complexités en utilisant des tableaux dynamiques, notamment les ajouts et suppressions de sommets.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Il semble a priori clair qu’on devrait utiliser des dictionnaires pour manipuler des graphes en voyant ce tableau. Pourtant, on utilisera presque exclusivement des listes d’adjacence. Pourquoi ? En grande partie parce que les opérations rendues efficaces sont rares et ne justifient pas la difficulté accrue de manipulation. En effet, l’opération la plus importante est de pouvoir énumérer les voisins, et une liste chaînée le permet facilement et efficacement.</div></p>
<h1 data-number="2" id="sec:graphes-non-orientés"><span class="header-section-number">2</span> Graphes non orientés</h1>
<h2 data-number="2.1" id="sec:graphes_symetrises"><span class="header-section-number">2.1</span> Définition et adaptation du vocabulaire</h2>
<p><div class="ui message"><div class="header">Définition</div> Un graphe non orienté est un couple <span class="math inline">\(G = (S, A)\)</span> où <span class="math inline">\(S\)</span> est un ensemble fini et <span class="math inline">\(A\)</span> est un ensemble de paires d’éléments de <span class="math inline">\(S\)</span>, c’est-à-dire d’ensembles à deux éléments <span class="math inline">\(\{x,y\}\)</span> où <span class="math inline">\(x, y \in S\)</span>.</p>
<p>Les éléments de <span class="math inline">\(S\)</span> sont appelés les <strong>sommets</strong> du graphe <span class="math inline">\(G\)</span> et les éléments de <span class="math inline">\(A\)</span> les <strong>arêtes</strong>. Si <span class="math inline">\(\{ x,y \} \in A\)</span>, on note <span class="math inline">\(x \smile y\)</span>. </div></p>
<p><div class="ui message orange"><div class="header">Remarque</div>Si <span class="math inline">\(G = (S,A)\)</span> est un graphe orienté, on peut en déduire deux graphes non orientés :</p>
<ul>
<li>un graphe par défaut <span class="math inline">\(G^- = (S, A^-)\)</span> où <span class="math display">\[\forall x, y \in S, x \smile y
\iff (x \rightarrow y \wedge y \rightarrow x)\]</span></li>
<li>un graphe par excès <span class="math inline">\(G^+ = (S, A^+)\)</span> où <span class="math display">\[\forall x, y \in S, x \smile y
\iff (x \rightarrow y \vee y \rightarrow x)\]</span></li>
</ul>
<p>On a également <span class="math inline">\(A\)</span> symétrique <span class="math inline">\(\iff G^+ = G^-\)</span>. Cela correspond à un graphe où chaque arête est dans les deux sens <span class="math inline">\(x \leftrightarrow y\)</span> et, donc, on peut oublier l’orientation.</p>
<p>De la même manière, on peut associer à un graphe non orienté <span class="math inline">\(G\)</span> son graphe orienté symétrique obtenu en doublant chaque arête. C’est à dire en posant si <span class="math inline">\(x \rightarrow y\)</span> si <span class="math inline">\(x \smile y\)</span>. On a donc <span class="math inline">\(\forall x, y \in S, x \rightarrow y \iff y \rightarrow x\)</span> et le graphe est bien symétrique.</div></p>
<p>On reprend directement l’essentiel du vocabulaire des graphes orientés symétriques avec des simplifications :</p>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G= (S,A)\)</span> un graphe et <span class="math inline">\(x \in S\)</span>.</p>
<ul>
<li>On appelle <em>voisins</em> de <span class="math inline">\(x\)</span> les éléments de <span class="math display">\[
v(x) = \enscomp{y \in S}{x \smile y}
\]</span></li>
<li>On appelle <em>degré</em> de <span class="math inline">\(x\)</span> l’entier <span class="math inline">\(d(x) = | v(x)|\)</span>. </div></li>
</ul>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p><span class="math inline">\(\sum_{x \in S} d(x) = 2 |A|\)</span></p>
</div>
<p>On étend directement la notion de <strong>chemin</strong> mais il faut faire attention au fait que <strong>simple</strong> n’a pas le même sens entre un graphe non orienté symétrique et un graphe non orienté. En effet, on <span class="math inline">\(x \rightarrow y \rightarrow x\)</span> est simple pour un graphe orienté alors que <span class="math inline">\(x \smile y \smile x\)</span> ne l’est pas vu qu’il s’agit de la même arête.</p>
<h2 data-number="2.2" id="sec:connexité"><span class="header-section-number">2.2</span> Connexité</h2>
<p><div class="ui message"><div class="header">Définition</div> On définit <span class="math inline">\(\smile^*\)</span> comme étant la clôture réflexive et transitive de <span class="math inline">\(\smile\)</span>. </div></p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<ul>
<li><span class="math inline">\(\smile^*\)</span> est une relation d’équivalence dont les classes sont appelées les <strong>composantes connexes</strong> du graphe.</li>
<li><span class="math inline">\(x \smile^* y \iff\)</span> il existe un chemin de <span class="math inline">\(x\)</span> à <span class="math inline">\(y\)</span>.</li>
</ul>
</div>
<p><div class="ui message"><div class="header">Définition</div> Un graphe n’ayant qu’une classe d’équivalence pour <span class="math inline">\(\smile^*\)</span> est dit <strong>connexe</strong>. Cela signifie qu’il existe un chemin entre toute paire de sommets. </div></p>
<h2 data-number="2.3" id="sec:graphe-acyclique-connexe"><span class="header-section-number">2.3</span> Graphe acyclique connexe</h2>
<p><div class="ui message"><div class="header">Définition</div> On appelle <strong>arbre</strong> un graphe acyclique connexe. Quand on a distingué un sommet, on parle d’<strong>arbre enraciné</strong>. </div></p>
<h2 data-number="2.4" id="sec:graphe-biparti"><span class="header-section-number">2.4</span> Graphe biparti</h2>
<p><div class="ui message"><div class="header">Définition</div> Soit <span class="math inline">\(G = (S,A)\)</span> un graphe, on dit que le graphe est <strong>biparti</strong> lorsqu’il existe une partition <span class="math inline">\(S = S_1 \cup S_2\)</span> et que <span class="math display">\[
\forall \{ x, y \} \in A, x \in S_1 \iff y \in S_2
\]</span> </div></p>
<p>Ici, le graphe est biparti avec <span class="math inline">\(S_1 = \{a,e,f,g\}\)</span> et <span class="math inline">\(S_2 = \{b,c,d\}\)</span>. <center><div class="ui image center"><img src="assets/pics/graph_biparti.png" /></div></center></p>
<p>On peut s’en rendre compte en colorant les sommets. <center><div class="ui image center"><img src="assets/pics/graph_biparti2.png" /></div></center></p>
<p>En fait, être biparti est équivalent à pouvoir être coloré en deux couleurs en sorte que deux sommets reliés soient de couleur différente.</p>
<h1 data-number="3" id="sec:parcours"><span class="header-section-number">3</span> Parcours</h1>
<p><div class="ui label">     ITC<div class="detail">Sup</div> </div> <div class="ui label">     MP2I<div class="detail">S2</div> </div></p>
<h2 data-number="3.1" id="sec:principe"><span class="header-section-number">3.1</span> Principe</h2>
<p>La grande majorité des algorithmes sur les graphes consistent à parcourir les sommets de voisins en voisins pour effectuer des traitements. La manière dont on les parcourt pouvant changer selon les différentes applications.</p>
<p>Citons, par exemple, le fait de déterminer les composantes connexes d’un graphe ou de trouver le plus court chemin entre deux sommets.</p>
<p>On va se placer dans le cadre d’un graphe orienté représenté par listes d’adjacence et en supposant que les sommets sont identifiés par leur indice. Dans ce cadre, si on a, en fait, un graphe non orienté, il sera représenté par son graphe orienté symétrique comme on l’a vu plus haut.</p>
<p>On va également considérer qu’on veut effectuer un traitement, ou une visite, pour ces sommets ou les arêtes empruntées.</p>
<h2 data-number="3.2" id="sec:parcours-en-profondeur-récursif"><span class="header-section-number">3.2</span> Parcours en profondeur récursif</h2>
<p>On présente ici une première manière élémentaire de les parcourir en tirant partie de la récursivité :</p>
<ul>
<li>on considère une fonction <code>parcours</code> et l’appel à <code>parcours</code> pour le sommet <code>x</code> va effectuer des appels récursifs à <code>parcours</code> pour chaque sommet <span class="math inline">\(y\)</span> de <span class="math inline">\(v_+(x)\)</span>.</li>
</ul>
<p>Le problème est qu’on ne veut pas traiter deux fois un sommet et on veut que les appels terminent. Pour cela, on introduit une notion d’état associé à chaque sommet. Un sommet peut-être</p>
<ul>
<li><strong>Inconnu</strong>, cela correspond au fait qu’il n’est pas encore apparu en tant que voisin.</li>
<li><strong>Découvert</strong>, il est apparu mais n’a pas encore été traité complètement.</li>
<li><strong>Traité</strong> (ou <strong>Visité</strong>), il a non seulement été traité, mais également tous les sommets parcouru grâce à lui.</li>
</ul>
<p>Pour maintenir cet état dans le code, le plus simple est de considérer un tableau d’entiers <code>etat</code> où <code>etat[i]</code> donne l’état du sommet <code>i</code>.</p>
<p><div class="ui message"><div class="header">Définition</div> Ce parcours est appelé un <strong>parcours en profondeur</strong> récursif. En anglais, on parle de <strong>depth-first search</strong> et on utilise couramment l’acronyme <strong>DFS</strong>. </div></p>
<h3 data-number="3.2.1" id="sec:première-version"><span class="header-section-number">3.2.1</span> Première version</h3>
<p>On adapte directement le principe précédent en un programme.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>INCONNU <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>DECOUVERT <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>TRAITE <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">def</span> parcours(ladj, x, etat):</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="cf">if</span> etat[x] <span class="op">!=</span> TRAITE:</span>
<span id="cb6-7"><a href="#cb6-7"></a>        <span class="bu">print</span>(x)</span>
<span id="cb6-8"><a href="#cb6-8"></a>        <span class="cf">for</span> y <span class="kw">in</span> ladj[x]:</span>
<span id="cb6-9"><a href="#cb6-9"></a>            <span class="cf">if</span> etat[y] <span class="op">==</span> INCONNU:</span>
<span id="cb6-10"><a href="#cb6-10"></a>                etat[y] <span class="op">=</span> DECOUVERT</span>
<span id="cb6-11"><a href="#cb6-11"></a>                parcours(ladj, y, etat)</span>
<span id="cb6-12"><a href="#cb6-12"></a>        etat[x] <span class="op">=</span> TRAITE</span>
<span id="cb6-13"><a href="#cb6-13"></a></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="kw">def</span> lance_parcours(ladj, x):</span>
<span id="cb6-15"><a href="#cb6-15"></a>    <span class="co"># État initial inconnu pour tous</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>    etat <span class="op">=</span> [ INCONNU ] <span class="op">*</span> <span class="bu">len</span>(ladj)</span>
<span id="cb6-17"><a href="#cb6-17"></a>    etat[x] <span class="op">=</span> DECOUVERT</span>
<span id="cb6-18"><a href="#cb6-18"></a>    parcours(ladj, x, etat)</span></code></pre></div>
<p></div></p>
<p>Ici, on se contente d’afficher les sommets rencontrés.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>On va réaliser un parcours en profondeur du graphe suivant en partant du sommet 0 :</p>
<p><center><div class="ui image center"><img src="assets/pics/graphe_dfsrec_ex.png" /></div></center></p>
<p>On indique les sommets inconnus en blanc, les sommets découvert en rouge et les sommets traités en vert.</p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>On affiche 0 et on appelle relance le parcours du voisin 1.</p>
<p><center><div class="ui image center"><img src="assets/pics/graphe_dfsrec_ex1.png" /></div></center></p>
<p></div><div class="eight wide column"></p>
<p>On affiche 1 et on relance le parcours du voisin 2.</p>
<p><center><div class="ui image center"><img src="assets/pics/graphe_dfsrec_ex2.png" /></div></center></p>
<p></div></div></div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>On affiche 3 et on appelle relance le parcours du voisin 4.</p>
<p><center><div class="ui image center"><img src="assets/pics/graphe_dfsrec_ex3.png" /></div></center></p>
<p></div><div class="eight wide column"></p>
<p>On affiche 4 et comme il n’a pas de voisins non traités, on traite 4 et on sort de l’appel.</p>
<p><center><div class="ui image center"><img src="assets/pics/graphe_dfsrec_ex4.png" /></div></center></p>
<p></div></div></div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>On revient à 2 et on relance le parcours du voisin 3. On affiche 3, et on le traite car tous ses voisins sont connus.</p>
<p><center><div class="ui image center"><img src="assets/pics/graphe_dfsrec_ex5.png" /></div></center></p>
<p></div><div class="eight wide column"></p>
<p>On revient à 2 et cette fois-ci il n’y a plus de voisins, on peut marquer 2 comme étant traité.</p>
<p><center><div class="ui image center"><img src="assets/pics/graphe_dfsrec_ex6.png" /></div></center></p>
<p></div></div></div></p>
<p><div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p>On revient à 1 et on peut marquer 1 comme étant traité.</p>
<p><center><div class="ui image center"><img src="assets/pics/graphe_dfsrec_ex7.png" /></div></center></p>
<p></div><div class="eight wide column"></p>
<p>On revient à 0 et on peut marquer 0 comme étant traité.</p>
<p><center><div class="ui image center"><img src="assets/pics/graphe_dfsrec_ex8.png" /></div></center></p>
<p></div></div></div></p>
<p>On a donc une vague de descente dans le graphe qui marque les sommets comme découverts et ensuite on remonte la pile d’appels récursifs en marquant les sommets comme étant traités.</p>
<p>Les sommets sont ici affichés dans l’ordre 0 1 2 4 3. On remarque que les sommets 5 et 6 sont inaccessibles, ils restent ainsi inconnus tout le long du parcours.</p>
</div>
<h3 data-number="3.2.2" id="sec:arbre-de-parcours"><span class="header-section-number">3.2.2</span> Arbre de parcours</h3>
<p>On peut noter les arêtes empruntées lors du parcours précédents pour découvrir un nouveau sommet, et donc relancer un appel récursif. On obtient alors une structure arborescente qui est appelé l’arbre du parcours en profondeur.</p>
<div class="ui message blue">
<div class="header">
Exemple
</div>
<p>Dans le parcours précédent, on obtient l’arbre suivant : <div class="ui internally celled grid"><div class="row"><div class="eight wide column"></p>
<p><center><div class="ui image center"><img src="assets/pics/graphe_dfsrec_arbre.png" /></div></center></p>
<p></div><div class="eight wide column"></p>
<p><center><div class="ui image center"><img src="assets/pics/graphe_dfsrec_arbre2.png" /></div></center></p>
<p></div></div></div></p>
</div>
<p>Pour obtenir cet arbre, on va construire un tableau <code>parent</code> pendant le parcours. Lorsqu’on emprunte une arête <span class="math inline">\(x \rightarrow y\)</span> pour découvrir <span class="math inline">\(y\)</span>, on note <span class="math inline">\(parent[y] = x\)</span>. Par défaut, <span class="math inline">\(parent[y]\)</span> est indéfini (<code>None</code> ou une valeur d’indice invalide comme <span class="math inline">\(-1\)</span>).</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Si <span class="math inline">\(parent[y]\)</span> est défini à l’issue du parcours depuis <span class="math inline">\(x\)</span>, alors il existe un chemin <span class="math inline">\(\varphi : x \leadsto y\)</span> où les arêtes <span class="math inline">\(s \rightarrow s&#39;\)</span> empruntées lors du chemin vérifient toutes <span class="math inline">\(parent[s&#39;] = s\)</span>.</p>
</div>
<p>Comme <span class="math inline">\(parent[y]\)</span> est défini pour tous les sommets découverts et que les sommets découverts finissent tous par être traités, on peut en déduire directement le théorème suivant :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>A l’issue du parcours depuis <span class="math inline">\(x\)</span>, les sommets traités sont les sommets accessibles depuis <span class="math inline">\(x\)</span>, c’est-à-dire les éléments de <span class="math display">\[
\enscomp{y \in S}{x \leadsto y}
\]</span></p>
</div>
<p>Dont on peut déduire directement le corollaire suivant dans le cas non orienté :</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Dans un graphe non orienté, les sommets traités depuis un parcours en profondeur issu d’un sommet sont exactement les sommets de sa composante connexe.</p>
</div>
<h1 data-number="4" id="sec:parcours-1"><span class="header-section-number">4</span> Parcours</h1>
<h2 data-number="4.1" id="sec:principe-et-parcours-récursif"><span class="header-section-number">4.1</span> Principe et parcours récursif</h2>
<p>On reprend le principe des parcours d’arbres : un parcours de graphe est une méthode qui étant donné un sommet <span class="math inline">\(s\)</span> de départ parcourt tous les sommets accessibles depuis <span class="math inline">\(s\)</span> une fois et une seule. A chaque visite d’un nouveau sommet on effectue un traitement qui dépend du problème considéré.</p>
<p>On reprend ainsi naturellement le parcours en profondeur récursif vu pour les arbres :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"></code></pre></div>
<p></div></p>
<p>Tous les parcours de graphe ont la même structure :</p>
<ul>
<li>On marque tous les sommets comme étant non visités</li>
<li>On ajoute <span class="math inline">\(s\)</span> dans un ensemble de sommets à visiter <span class="math inline">\(V\)</span></li>
<li>Tant que <span class="math inline">\(V\)</span> est non vide
<ul>
<li>On extrait un sommet <span class="math inline">\(x\)</span> de <span class="math inline">\(V\)</span></li>
<li>Si <span class="math inline">\(x\)</span> a été marqué comme visité, on finit l’itération</li>
<li>On marque <span class="math inline">\(x\)</span> comme visité</li>
<li>On traite <span class="math inline">\(x\)</span></li>
<li>On ajoute à <span class="math inline">\(V\)</span> tous les successeurs de <span class="math inline">\(x\)</span></li>
</ul></li>
</ul>
<p>Notons qu’on peut aussi optimiser la taille de <span class="math inline">\(V\)</span> en ajoutant uniquement les successeurs non visités. <em>Mais il faudra tout de même garder le test pour savoir si un sommet extrait est visité, car on peut ajouter un successeur déjà présent dans <span class="math inline">\(V\)</span> et il ne faut pas le visiter de et il ne faut pas le visiter deux fois.</em></p>
<p>Pour marquer visité ou non des sommets, on considère un <code>bool array</code> donc le test est en c.t. <span class="math inline">\(\gO(1)\)</span> et la c.s. <span class="math inline">\(\gO(|S|)\)</span>.</p>
<p>Tout l’enjeu, et donc les différentes notions de parcours, provient de l’implémentation de l’ensemble <span class="math inline">\(V\)</span>. Au maximum <span class="math inline">\(V\)</span> contiendra tous les successeurs donc une c.s. en <span class="math inline">\(\gO(|A|)\)</span>. Si on considère qu’ajout/extraction sont en <span class="math inline">\(\gO(1)\)</span>, comme on effectue autant d’itérations que d’éléments ajoutés à <span class="math inline">\(V\)</span> on a une c.t. en <span class="math inline">\(\gO(|A|)\)</span>.</p>
<p>Voici le code <code>OCaml</code> générique de tout parcours en considérant un graphe donné par listes d’adjacence :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">let</span> parcours traitement g s =</span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="kw">let</span> visites = <span class="dt">Array</span>.make (<span class="dt">Array</span>.length g) <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="kw">let</span> a_visiter = cree_ensemble () <span class="kw">in</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span class="kw">let</span> <span class="kw">rec</span> ajoute_liste l = <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>        [] -&gt; () | t::q -&gt; ajoute t a_visiter; ajoute_liste q</span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="kw">in</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>    ajoute s a_visiter;</span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="kw">while</span> <span class="dt">not</span> (est_vide a_visiter) <span class="kw">do</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>        <span class="kw">let</span> x = extraction a_visiter <span class="kw">in</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>        <span class="kw">if</span> <span class="dt">not</span> (visites.(x)) <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>            visites.(x) &lt;- <span class="kw">true</span>;</span>
<span id="cb8-12"><a href="#cb8-12"></a>            traitement x;</span>
<span id="cb8-13"><a href="#cb8-13"></a>            ajoute_liste g.(x)</span>
<span id="cb8-14"><a href="#cb8-14"></a>        <span class="kw">end</span></span>
<span id="cb8-15"><a href="#cb8-15"></a>    <span class="kw">done</span></span></code></pre></div>
<p></div></p>
<h2 data-number="4.2" id="sec:profondeur"><span class="header-section-number">4.2</span> Profondeur</h2>
<p>Si on choisit d’implémenter l’ensemble <span class="math inline">\(V\)</span> par une pile, on obtient un parcours appelé parcours en profondeur (<em>depth-first search</em>).</p>
<p>Rappel : les piles sont des structures LIFO (Last In First Out), i.e. dernier entré premier sorti.</p>
<p>Exemple de parcours en profondeur (on marque les sommets visités en gris)</p>
<p><center><div class="ui image center"><img src="assets/pics/graph_prof_1.png" /></div></center></p>
<p>en partant de <span class="math inline">\(a\)</span> :</p>
<ul>
<li><p>Au départ <span class="math inline">\(V = [a]\)</span>.</p></li>
<li><p>Visite de <span class="math inline">\(a\)</span>, <span class="math inline">\(V = [b]\)</span> <center><div class="ui image center"><img src="assets/pics/graph_prof_2.png" /></div></center></p></li>
<li><p>Visite de <span class="math inline">\(b\)</span>, <span class="math inline">\(V = [c;d]\)</span> <center><div class="ui image center"><img src="assets/pics/graph_prof_3.png" /></div></center></p></li>
</ul>
<p>. Visite de <span class="math inline">\(c\)</span>, <span class="math inline">\(V = [d;e;d]\)</span> <center><div class="ui image center"><img src="assets/pics/graph_prof_4.png" /></div></center></p>
<p>. Visite de <span class="math inline">\(d\)</span>, <span class="math inline">\(V = [a;e;d]\)</span> <center><div class="ui image center"><img src="assets/pics/graph_prof_5.png" /></div></center></p>
<ul>
<li><p>Extraction sans visite de <span class="math inline">\(a\)</span> car déjà visité, <span class="math inline">\(V = [e;d]\)</span></p></li>
<li><p>Visite de <span class="math inline">\(e\)</span>, <span class="math inline">\(V = [d]\)</span> <center><div class="ui image center"><img src="assets/pics/graph_prof_6.png" /></div></center></p></li>
<li><p>Extraction sans visite de <span class="math inline">\(d\)</span> car déjà visité, <span class="math inline">\(V = []\)</span></p></li>
</ul>
<p>En marquant les arêtes qui ont été empruntés <center><div class="ui image center"><img src="assets/pics/parcours_prof_arbre.png" /></div></center></p>
<p>on remarque que ce parcours permet d’obtenir un arbre enraciné en <span class="math inline">\(a\)</span> comprenant tous les sommets accessibles depuis <span class="math inline">\(a\)</span>. L’ordre de visite des sommets (a,b,c,d,e) correspond alors à l’ordre de visite d’un parcours en profondeur de cet arbre.</p>
<p>Notons <span class="math inline">\(t_i(x)\)</span> le numéro de l’étape où le sommet <span class="math inline">\(x\)</span> a été visité et <span class="math inline">\(t_o(x)\)</span> le numéro de l’étape où on a extrait le dernier descendant de <span class="math inline">\(x\)</span>. C’est-à-dire que si la pile est <span class="math inline">\(\pi\)</span> avant d’avoir traité <span class="math inline">\(x\)</span>, on note <span class="math inline">\(t_o(x)\)</span> le numéro de l’étape où la pile redevient <span class="math inline">\(\pi\)</span>.</p>
<p>Ici, on a <span class="math inline">\(\begin{array}{l|c|c} x &amp; t_i(x) &amp; t_o(x) \\ \hline  a &amp; 2 &amp; 8 \\  b &amp; 3 &amp; 8 \\  c &amp; 4 &amp; 7 \\  d &amp; 5 &amp; 6 \\  e &amp; 7 &amp; 7 \end{array}\)</span>. On remarque que ces temps sont bien parenthésés : si <span class="math inline">\(t_i(x) &lt; t_i(y) \le t_o(x)\)</span> alors <span class="math inline">\(t_o(x) &gt; t_o(y)\)</span> (comme si on considère <span class="math inline">\(t_i\)</span> l’indice d’une parenthèse ouvrante et <span class="math inline">\(t_o\)</span> l’indice d’une parenthèse fermante dans une expression bien parenthésée, d’où le nom). Si on pose <span class="math inline">\(I(x) = [t_i(x);t_i(y)]\)</span>, on voit qu’étant donné deux sommets <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span>, on a soit <span class="math inline">\(I(x) \cap I(y) = \emptyset\)</span> soit <span class="math inline">\(I(x) \subset I(y)\)</span> soit <span class="math inline">\(I(x) \subset I(y)\)</span>. De plus, la relation de couverture associée à cet ordre est exactement l’arbre défini précédemment.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Pour programmer ce parcours en Caml, on a deux options :</p>
<ul>
<li>Utiliser directement le module <code>Stack</code> de <code>OCaml</code> avec le code précédent en posant :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">let</span> cree_ensemble () = <span class="dt">Stack</span>.create ()</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">let</span> est_vide pi = <span class="dt">Stack</span>.is_empty pi</span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">let</span> ajoute x pi = <span class="dt">Stack</span>.push x pi</span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="kw">let</span> extraction pi = <span class="dt">Stack</span>.pop pi</span></code></pre></div>
<p></div></p>
<ul>
<li>Tirer partie de la pile naturelle des appels récursifs :</li>
</ul>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">let</span> parcours traitement g s =</span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="kw">let</span> visites = make_vect (vect_length g) <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="kw">let</span> <span class="kw">rec</span> parcours_aux l =</span>
<span id="cb10-4"><a href="#cb10-4"></a>        <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>        | [] -&gt; () <span class="co">(* Plus de sommets *)</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>        | x::q -&gt; <span class="kw">if</span> <span class="dt">not</span> (visites.(x))</span>
<span id="cb10-7"><a href="#cb10-7"></a>                  <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>                    visites.(x) &lt;- <span class="kw">true</span>;</span>
<span id="cb10-9"><a href="#cb10-9"></a>                    traitement x;</span>
<span id="cb10-10"><a href="#cb10-10"></a>                    parcours_aux (g.(x) @ q)</span>
<span id="cb10-11"><a href="#cb10-11"></a>                  <span class="kw">end</span> <span class="kw">else</span> parcours_aux q</span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span class="kw">in</span> parcours_aux [s]</span></code></pre></div>
<p></div></p>
<p>Ici on remarque l’intérêt du test tardif pour savoir si on a déjà visité un sommet : on se contente de rajouter <strong>tous</strong> les voisins de <span class="math inline">\(x\)</span> avec une concaténation.</p>
<p>Avec un filtre on peut tout de même ajouter moins de sommets, mais attention il faut tout de même préserver le test pour éviter le double traitement.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">let</span> parcours traitement g s =</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="kw">let</span> visites = make_vect (vect_length g) <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="kw">let</span> <span class="kw">rec</span> filtre l = <span class="kw">match</span> l <span class="kw">with</span> [] -&gt; []</span>
<span id="cb11-4"><a href="#cb11-4"></a>        | x::q -&gt; <span class="kw">if</span> visites.(x) <span class="kw">then</span> filtre q <span class="kw">else</span> x::filtre q</span>
<span id="cb11-5"><a href="#cb11-5"></a>    <span class="kw">in</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="kw">let</span> <span class="kw">rec</span> parcours_aux l =</span>
<span id="cb11-7"><a href="#cb11-7"></a>        <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>        | [] -&gt; () <span class="co">(* Plus de sommets *)</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>        | x::q -&gt; <span class="kw">if</span> <span class="dt">not</span> (visites.(x))</span>
<span id="cb11-10"><a href="#cb11-10"></a>                  <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>                    visites.(x) &lt;- <span class="kw">true</span>;</span>
<span id="cb11-12"><a href="#cb11-12"></a>                    traitement x;</span>
<span id="cb11-13"><a href="#cb11-13"></a>                    parcours_aux (filtre g.(x) @ q)</span>
<span id="cb11-14"><a href="#cb11-14"></a>                  <span class="kw">end</span> <span class="kw">else</span> parcours_aux q</span>
<span id="cb11-15"><a href="#cb11-15"></a>    <span class="kw">in</span> parcours_aux [s];;</span></code></pre></div>
<p></div></p>
<p>Pour finir, une petite note sur la complexité temporelle de cette variante. On pourrait croire que l’ajout d’une concaténation augmente la complexité, mais ce n’est pas le cas la concaténation se substitue à l’ajout des successeurs un par un : on a donc remplacé n opérations en <span class="math inline">\(\gO(1)\)</span> par une opération en <span class="math inline">\(\gO(n)\)</span>.</div></p>
<p>Quels sont les problèmes qu’on peut résoudre avec un parcours en profondeur ?</p>
<ul>
<li><p>L’accessibilité : les sommets marqués en fin de parcours sont exactement les sommets <span class="math inline">\(x\)</span> tels que <span class="math inline">\(s \leadsto x\)</span>.</p></li>
<li><p>La forte connexité : posons <span class="math inline">\(G^{-1} = (S,A^{-1})\)</span> où <span class="math inline">\(A^{-1} = \enscomp{(v,u)}{(u,v) \in A}\)</span> le graphe miroir de <span class="math inline">\(G\)</span> obtenu en changeant l’orientation de toutes les arêtes. On a <span class="math inline">\(x \leadsto y\)</span> dans <span class="math inline">\(G\)</span> ssi <span class="math inline">\(y \leadsto x\)</span> dans <span class="math inline">\(G^{-1}\)</span>.</p>
<p>Si <span class="math inline">\(G\)</span> est fortement connexe et <span class="math inline">\(s \in G\)</span>, alors pour tout sommet <span class="math inline">\(x\)</span> on a <span class="math inline">\(s \leadsto x\)</span>  <span class="math inline">\(x \leadsto s\)</span>.</p>
<p>Réciproquement, s’il existe un sommet <span class="math inline">\(s\)</span> satisfaisant cela, alors pour tout <span class="math inline">\(x,y \in G\)</span>, on a un chemin <span class="math inline">\(x \leadsto s \leadsto y\)</span> et donc <span class="math inline">\(G\)</span> est fortement connexe.</p>
<p>On en déduit un test en deux parcours en profondeur de la forte connexité : un premier parcours sur <span class="math inline">\(G\)</span> et un second sur <span class="math inline">\(G^{-1}\)</span>.</p></li>
<li><p>La recherche d’un cycle : si on ajoute un sommet à visiter alors qu’on est déjà en train de visiter ses successeurs, c’est qu’il y a un cycle contenant ce sommet.</p></li>
<li><p>La recherche d’une solution dans un labyrinthe.</p></li>
<li><p>La 2-connexité : ici on exploite une propriété des revisites du parcours en profondeur. Si on voit deux fois un sommets c’est qu’il existe deux chemins pour l’atteindre depuis <span class="math inline">\(s\)</span>. On peut en déduire alors un algorithme de test de la 2-connexité : <span class="math inline">\(G\)</span> est 2-connexe si en enlevant une arête quelconque <span class="math inline">\(G\)</span> reste connexe.</p></li>
</ul>
<h2 data-number="4.3" id="sec:largeur"><span class="header-section-number">4.3</span> Largeur</h2>
<p>Si on choisit d’implémenter l’ensemble <span class="math inline">\(V\)</span> par une file, on obtient un parcours appelé parcours en largeur ().</p>
<p>Rappel : les files sont des structures FIFO (First In First Out), i.e. premier entré premier sorti.</p>
<p>Exemple de parcours en largeur (on marque les sommets visités en gris et on omet les sommets déjà visités) du graphe <center><div class="ui image center"><img src="assets/pics/parcours_largeur_0.png" /></div></center></p>
<p>en partant de <span class="math inline">\(a\)</span> :</p>
<ul>
<li><p>Visite de <span class="math inline">\(a\)</span>, <span class="math inline">\(V = [b;c;d]\)</span>, <center><div class="ui image center"><img src="assets/pics/parcours_largeur_1.png" /></div></center></p></li>
<li><p>Visite de <span class="math inline">\(b\)</span>, <span class="math inline">\(V = [c;d;a;e;f]\)</span>, <center><div class="ui image center"><img src="assets/pics/parcours_largeur_2.png" /></div></center></p></li>
<li><p>Visite de <span class="math inline">\(c\)</span>, <span class="math inline">\(V = [d;a;e;f;a;b]\)</span>, <center><div class="ui image center"><img src="assets/pics/parcours_largeur_3.png" /></div></center></p></li>
<li><p>Visite de <span class="math inline">\(d\)</span>, <span class="math inline">\(V = [e;f;a;b;a;f]\)</span>, <center><div class="ui image center"><img src="assets/pics/parcours_largeur_4.png" /></div></center></p></li>
<li><p>Visite de <span class="math inline">\(e\)</span>, <span class="math inline">\(V = [f;a;b;a;f;b]\)</span>, <center><div class="ui image center"><img src="assets/pics/parcours_largeur_5.png" /></div></center></p></li>
<li><p>Visite de <span class="math inline">\(f\)</span>, <span class="math inline">\(V = [a;b;a;f;b;b;d]\)</span>, <center><div class="ui image center"><img src="assets/pics/parcours_largeur_6.png" /></div></center></p></li>
<li><p>Plus que des sommets visités dans <span class="math inline">\(V\)</span>.</p></li>
</ul>
<p>L’intêret principal du parcours en largeur c’est qu’il garantit que chaque sommet soit découvert au plus tôt et donc il permet d’extraire des plus cours chemins depuis <span class="math inline">\(s\)</span>.</p>
<p>Dans notre exemple, on obtient un arbre issu du parcours en largeur qui est <center><div class="ui image center"><img src="assets/pics/parcours_largeur_arbre.png" /></div></center></p>
<p>et tous les chemins de <span class="math inline">\(a\)</span> vers les feuilles sont des plus courts chemins dans le graphe initial. Par opposition, l’arbre suivant issu d’un parcours en profondeur <center><div class="ui image center"><img src="assets/pics/parcours_largeur_arbre_prof.png" /></div></center></p>
<p>ne vérifie pas cela, le chemin <span class="math inline">\(a \rightarrow b \rightarrow f \rightarrow d\)</span> n’est pas minimal.</p>
<p>La plupart des questions auxquels on a pu répondre par parcours en profondeur pourront être résolues par parcours en largeur. Le problème du parcours en largeur c’est qu’on doit contenir dans la file  à un distance donné de <span class="math inline">\(s\)</span> (on parle de niveau). Si on considère un arbre <span class="math inline">\(n\)</span>-aire complet issu de <span class="math inline">\(s\)</span>, le <span class="math inline">\(k\)</span>-ième niveau contient exactement <span class="math inline">\(n^k\)</span> sommets et donc la file du parcours en largeur croit de manière exponentielle. Avec un parcours en profondeur, on se contente d’empiler les descendants le long d’une branche de la racine à une feuille, ce qui est de l’ordre de <span class="math inline">\(k n\)</span> quand on descend au niveau <span class="math inline">\(k\)</span>.</p>
<p><div class="ui message orange"><div class="header">Remarque</div>Pour implémenter ce parcours en Caml, on utilise le type <code>Queue</code> des files, en posant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">let</span> cree_ensemble () = <span class="dt">Queue</span>.create ()</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="kw">let</span> est_vide pi = <span class="dt">Queue</span>.is_empty pi;;</span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="kw">let</span> ajoute x pi = <span class="dt">Queue</span>.add x pi;;</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="kw">let</span> extraction pi = <span class="dt">Queue</span>.take pi;;</span></code></pre></div>
<p></div> </div></p>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<h1 data-number="5" id="sec:chemin-de-plus-petit-poids"><span class="header-section-number">5</span> Chemin de plus petit poids</h1>
<h2 data-number="5.1" id="sec:graphe-pondéré"><span class="header-section-number">5.1</span> Graphe pondéré</h2>
<p>On considère maintenant une pondération sur les arêtes d’un graphe. C’est-à-dire une fonction <span class="math inline">\(w : A \rightarrow \R\)</span>. On parle de graphe pondéré et <span class="math inline">\(w(a)\)</span> est appelé le poids de l’arête <span class="math inline">\(a\)</span>. Le poids d’un chemin est la somme des poids de ses arêtes.</p>
<p>On se pose alors la question suivante : étant donné <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> existe-t-il un chemin de plus petit poids de <span class="math inline">\(x\)</span> à <span class="math inline">\(y\)</span>, et si oui comment l’obtenir ?</p>
<p>Notons qu’il est possible de trouver un cycle dont la somme des poids soit <span class="math inline">\(&lt; 0\)</span>, en sorte qu’en prenant ce cycle plusieus fois on puisse rendre le poids d’un chemin aussi petit qu’on le souhaite. C’est en ce sens qu’il n’existe pas forcément de chemin de plus petit poids fini.</p>
<p>En donnant à chaque arête le même poids <span class="math inline">\(1\)</span>, on retrouve naturellement la notion de plus court chemin dans un graphe.</p>
<h2 data-number="5.2" id="sec:dijkstra-source-unique"><span class="header-section-number">5.2</span> Dijkstra : source unique</h2>
<p>On considère ici des poids dans <span class="math inline">\(\mathbb{R}_+^*\)</span>, ainsi prolonger un chemin a forcément un coût.</p>
<p>On va construire un sous-graphe <span class="math inline">\(G&#39; \subset G\)</span> et un tableau <span class="math inline">\(d\)</span> tel que <span class="math inline">\(d_x\)</span> contienne</p>
<ul>
<li>la distance minimale entre <span class="math inline">\(s\)</span> et <span class="math inline">\(x\)</span> pour tout <span class="math inline">\(x \in G&#39;\)</span>.</li>
<li>la distance minimale entre <span class="math inline">\(s\)</span> et <span class="math inline">\(x\)</span> passant par des sommets de <span class="math inline">\(G&#39;\)</span>.</li>
</ul>
<p>On commence avec <span class="math inline">\(G&#39; = \emptyset\)</span>. <span class="math inline">\(d.s = 0\)</span> et <span class="math inline">\(d.x = \infty\)</span> pour <span class="math inline">\(x \neq s\)</span>.</p>
<p>Si on a construit <span class="math inline">\(G&#39;\)</span>, on cherche un sommet qui n’est pas dans <span class="math inline">\(G&#39;\)</span> et qui a le <span class="math inline">\(d_x\)</span> minimal. On le rajoute dans <span class="math inline">\(G&#39;\)</span> et on met à jour ses voisins pour que <span class="math inline">\(d\)</span> contienne toujours les longueur passant par <span class="math inline">\(G&#39;\)</span> : <span class="math inline">\(d_y = d_x + w(x,y)\)</span>.</p>
<p>On itère jusqu’à avoir ajouté tous les sommets accessibles depuis <span class="math inline">\(s\)</span>.</p>
<p>On va le faire sur l’exemple suivant : <center><div class="ui image center"><img src="assets/pics/dijkstra_ex1.png" /></div></center></p>
<p>Les sommets de <span class="math inline">\(G&#39;\)</span> seront marqués en gris et les valeurs de <span class="math inline">\(d\)</span> indiquées à coté des noeuds dans des carrés.</p>
<p><center><div class="ui image center"><img src="assets/pics/dijkstra_ex2.png" /></div></center></p>
<p><center><div class="ui image center"><img src="assets/pics/dijkstra_ex3.png" /></div></center></p>
<p><center><div class="ui image center"><img src="assets/pics/dijkstra_ex4.png" /></div></center></p>
<p><center><div class="ui image center"><img src="assets/pics/dijkstra_ex5.png" /></div></center></p>
<p><center><div class="ui image center"><img src="assets/pics/dijkstra_ex6.png" /></div></center></p>
<p><center><div class="ui image center"><img src="assets/pics/dijkstra_ex7.png" /></div></center></p>
<p><center><div class="ui image center"><img src="assets/pics/dijkstra_ex8.png" /></div></center></p>
<p>On peut indiquer en gras les arêtes qui ont permis d’améliorer les valeurs du tableau <span class="math inline">\(d\)</span> : <center><div class="ui image center"><img src="assets/pics/dijkstra_amelioration.png" /></div></center></p>
<p>Les chemins de plus petits poids sont exactement ceux qui empruntent ces arêtes. Pour permettre de calculer efficacement ces chemins, il suffit de maintenir un second tableau <span class="math inline">\(p\)</span> tel que si on a ajouté une arête <span class="math inline">\((u,v)\)</span> alors on a <span class="math inline">\(p.v = u\)</span>.</p>
<div class="ui message olive">
<div class="header">
Théorème
</div>
<p>Cet algorithme permet d’obtenir un les poids des chemins minimaux issus de s.</p>
</div>
<p><div class="ui styled accordion"> <div class="title">     <i class="dropdown icon"></i> Preuve </div> <div class="content"> Pour cela il faut montrer que lorsqu’on considère un sommet à ajouter dans <span class="math inline">\(G&#39;\)</span>, on a bien la distance minimale. Si ce n’est pas le cas en ajoutant <span class="math inline">\(x\)</span>, alors cela signifie qu’il existe un chemin plus court de <span class="math inline">\(s\)</span> à <span class="math inline">\(x\)</span>. Soit <span class="math inline">\(y\)</span> le dernier sommet de <span class="math inline">\(G&#39;\)</span> dans ce chemin. On a forcément <span class="math inline">\(y\)</span> suivi d’un sommet <span class="math inline">\(z \neq x\)</span>. Sinon on aurait l’optimalité. Mais <span class="math inline">\(d_x \le d_z = d_y + w(y,z)\)</span> et donc le chemin ne peut être plus petit que <span class="math inline">\(d_x\)</span>. </div> </div></p>
<p>Pour implémenter cet algorithme, on considère une structure de file de priorité dont on rappelle l’interface :</p>
<ul>
<li><code>cree_file ()</code></li>
<li><code>ajoute x p f</code> qui ajoute x dans la file f avec la priorité p</li>
<li><code>min_priorite f</code> qui renvoie la priorité minimale d’un élément de f (utile pour la condition d’arrêt de Dijkstra quand le graphe n’est pas connexe)</li>
<li><code>extrait_minimum f</code> qui renvoie l’élément de priorité minimale et le supprime de la file</li>
<li><code>est_vide f</code></li>
<li>et une fonction spécifique à Dijkstra <code>diminue_priorite x p f</code> qui remplace la priorité de x dans f par p.</li>
</ul>
<p>Avec une structure de tas sur des couples <span class="math inline">\((priorité,valeur)\)</span>, on peut ajouter, exraire et diminuer en c.t. <span class="math inline">\(\gO(\log n)\)</span> (Attention, pour pouvoir diminuer la priorité, il suffit de changer la priorité dans le tas et faire remonter le sommet le long d’un chemin vers la racine, mais pour que la complexité soit bonne, il <strong>faut</strong> pouvoir accéder en <span class="math inline">\(\gO(1)\)</span> à la case correspondant à une valeur, donc maintenir une table de correspondance).</p>
<p>En <code>OCaml</code>, on va représenter un graphe pondéré par des listes d’adjancence pondérés, c’est-à-dire que pour chaque arête <span class="math inline">\((u,v)\)</span> on aura dans la liste de <span class="math inline">\(u\)</span> un couple <span class="math inline">\((v,w(u,v))\)</span>.</p>
<p>Avec cette structure de file de priorité, on obtient le code OCaml suivant :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1"></a>    <span class="kw">let</span> <span class="dt">pred</span> = make_vect n (<span class="dv">-1</span>) <span class="kw">in</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="kw">let</span> dists = make_vect n infini <span class="kw">in</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="kw">let</span> a_visiter = cree_file () <span class="kw">in</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>    dists.(s) &lt;- <span class="dv">0</span>;</span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n<span class="dv">-1</span> <span class="kw">do</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>        ajoute i dists.(i) a_visiter;</span>
<span id="cb13-7"><a href="#cb13-7"></a>    <span class="kw">done</span>;</span>
<span id="cb13-8"><a href="#cb13-8"></a>    <span class="kw">let</span> <span class="kw">rec</span> traite_liste x l =</span>
<span id="cb13-9"><a href="#cb13-9"></a>        <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>        | [] -&gt; ()</span>
<span id="cb13-11"><a href="#cb13-11"></a>        | (y,poids)::q -&gt; <span class="kw">let</span> nd = dists.(x) + poids <span class="kw">in</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>            <span class="kw">if</span> nd &lt; dists.(y)</span>
<span id="cb13-13"><a href="#cb13-13"></a>            <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb13-14"><a href="#cb13-14"></a>                dists.(y) &lt;- nd;</span>
<span id="cb13-15"><a href="#cb13-15"></a>                <span class="dt">pred</span>.(y) &lt;- x;</span>
<span id="cb13-16"><a href="#cb13-16"></a>                diminue_priorite y nd a_visiter</span>
<span id="cb13-17"><a href="#cb13-17"></a>            <span class="kw">end</span></span>
<span id="cb13-18"><a href="#cb13-18"></a>    <span class="kw">in</span></span>
<span id="cb13-19"><a href="#cb13-19"></a>    <span class="kw">while</span> <span class="dt">not</span> (est_vide a_visiter) &amp;&amp; min_priorite a_visiter &lt; infini <span class="kw">do</span></span>
<span id="cb13-20"><a href="#cb13-20"></a>        <span class="kw">let</span> x = extrait_minimum a_visiter <span class="kw">in</span></span>
<span id="cb13-21"><a href="#cb13-21"></a>        traite_liste x g.(x)   </span>
<span id="cb13-22"><a href="#cb13-22"></a>    <span class="kw">done</span>;</span>
<span id="cb13-23"><a href="#cb13-23"></a>    dists, <span class="dt">pred</span></span></code></pre></div>
<p></div></p>
<p>Au départ, tous les sommets sont dans la file et à chaque étape on extrait un sommet. Il n’est donc pas nécessaire de maintenir une marque sur les sommets visités. La condition d’arrêt n’est pas uniquement lié au fait que la file soit vide car si le graphe est non connexe, des sommets avec distance <span class="math inline">\(\infty\)</span> on été ajoutés dans la file au départ. Mais quand on extrait un sommet avec une priorité <span class="math inline">\(\infty\)</span> c’est nécessairement qu’il n’est pas accessible depuis le s.</p>
<p>La complexité spatiale de cet algorithme est celle de la file de priorité donc <span class="math inline">\(\gO(|S|)\)</span>. Pour la complexité temporelle, on a au départ la création de la file en <span class="math inline">\(\gO(|S| \log |S|)\)</span> puis <span class="math inline">\(|S|\)</span> itérations de la boucle principale avec une extraction du minimum en <span class="math inline">\(\gO(\log |S|)\)</span> et au maximum <span class="math inline">\(|A|\)</span> itérations de parcours d’arêtes ayant au maximum <span class="math inline">\(\gO(\log |S|)\)</span> en raison de diminue minimum. Au total, on a donc une complexité temporelle en <span class="math inline">\(\gO( (|S|+|A|) \log |S|)\)</span>.</p>
<h2 data-number="5.3" id="sec:todo-floyd-warshall-toutes-paires"><span class="header-section-number">5.3</span> TODO Floyd-Warshall : toutes paires</h2>
<p>On considère maintenant des poids quelconques.</p>
<p>Soit <span class="math inline">\(M^k\)</span> la matrice telle que <span class="math inline">\(M^k_{i,j}\)</span> contient le poids du plus court chemin de <span class="math inline">\(i\)</span> à <span class="math inline">\(j\)</span> n’utilisant que des sommets intermédiaires de <span class="math inline">\(1\)</span> à <span class="math inline">\(k\)</span> (on place <span class="math inline">\(\infty\)</span> s’il n’y en a pas).</p>
<p>On pose donc <span class="math inline">\(M^0_{i,j} = w(i,j)\)</span>.</p>
<p>On a <span class="math inline">\(M^k_{i,j} = min(M^{k-1}_{i,j}, M^{k-1}_{i,k} + M^{k-1}_{k,j})\)</span>.</p>
<p>On peut faire ce calcul en place (boucles sur k puis i, j).</p>
<p>Complexité en temps <span class="math inline">\(O(|S|^3)\)</span> et en espace <span class="math inline">\(O(|E|^2)\)</span>.</p>
<p>Détection de cycle négatif : <span class="math inline">\(M_{i,j} &lt; 0\)</span>.</p>
<h1 data-number="6" id="sec:travaux-pratiques"><span class="header-section-number">6</span> Travaux Pratiques</h1>
<h2 data-number="6.1" id="sec:parcours-de-graphes-en-c"><span class="header-section-number">6.1</span> Parcours de graphes en <code>C</code></h2>
<h3 data-number="6.1.1" id="sec:représentation"><span class="header-section-number">6.1.1</span> Représentation</h3>
<p>On va considérer le type suivant pour les graphes qui suppose qu’on n’aura jamais plus que <code>MAXV</code> sommets. On utilise ici une constante avec l’alias <code>#define</code> : partout où on écrit <code>MAXV</code>, il sera remplacé par la valeur 100.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#define MAXV 100 </span><span class="co">/* nombre maximum de sommets */</span></span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">struct</span> edgenode <span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="dt">int</span> y<span class="op">;</span> <span class="co">// le voisin</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="kw">struct</span> edgenode <span class="op">*</span>next<span class="op">;</span> <span class="co">// la suite de la liste</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="op">};</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="kw">typedef</span> <span class="kw">struct</span> edgenode edgenode<span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="kw">struct</span> graph <span class="op">{</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>    edgenode <span class="op">*</span>edges<span class="op">[</span>MAXV<span class="op">];</span> <span class="co">// tableau de listes d&#39;adjacence</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>    <span class="dt">int</span> degree<span class="op">[</span>MAXV<span class="op">];</span> <span class="co">// le degré de chaque sommet</span></span>
<span id="cb14-12"><a href="#cb14-12"></a>    <span class="dt">int</span> nvertices<span class="op">;</span></span>
<span id="cb14-13"><a href="#cb14-13"></a>    <span class="dt">int</span> nedges<span class="op">;</span></span>
<span id="cb14-14"><a href="#cb14-14"></a>    <span class="dt">bool</span> directed<span class="op">;</span> <span class="co">// indique si le graphe est orienté</span></span>
<span id="cb14-15"><a href="#cb14-15"></a><span class="op">};</span></span>
<span id="cb14-16"><a href="#cb14-16"></a><span class="kw">typedef</span> <span class="kw">struct</span> graph graph<span class="op">;</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1"></a><span class="dt">void</span> initialize_graph<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">bool</span> directed<span class="op">);</span></span></code></pre></div>
<p></div> qui initialise le graphe <code>g</code> passé par pointeur comme étant le graphe vide, dirigé ou non selon la valeur de <code>directed</code>.</p>
<p><strong>Attention</strong> vous êtes libres d’initialiser les listes d’adjancence à la liste vide ou de considérer que sera fait dans la fonction <code>read_graph</code> ci-dessous.</p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1"></a><span class="dt">void</span> insert_edge<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">,</span> <span class="dt">bool</span> directed<span class="op">)</span></span></code></pre></div>
<p></div> qui insère une arête de x à y en considérant <code>g</code> comme orienté ou non selon <code>directed</code> <strong>et donc en ignorant</strong> <code>g-&gt;directed</code>.</p>
<p><strong>Attention</strong> il faudra prendre garde au fait que <code>g</code> soit orienté ou non. Dans le second cas, on représenté les arêtes comme dans un graphe orienté symétrique, donc il faut en ajouter deux. C’est la raison pour laquelle on utilise le paramètre <code>directed</code> plutôt que de consulter <code>g-&gt;directed</code>.</p>
</div>
<p>Pour travailler sur des graphes, on va écrire une fonction permettant de lire un fichier contenant le graphe sous le format suivant :</p>
<ul>
<li>première ligne contenant trois entiers, le nombre de sommets n, le nombre d’arêtes p et 0 ou 1 selon que le graphe soit non orienté ou orienté</li>
<li>ensuite p lignes contenant deux entiers i et j et indiquant qu’il y a une arête de i vers j</li>
</ul>
<p>Par exemple :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1"></a><span class="dv">4</span> <span class="dv">5</span> <span class="dv">1</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="dv">0</span> <span class="dv">1</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="dv">0</span> <span class="dv">2</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="dv">1</span> <span class="dv">2</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="dv">2</span> <span class="dv">3</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="dv">3</span> <span class="dv">1</span></span></code></pre></div>
<p></div></p>
<p>sera représenté par le graphe : <center><div class="ui image center"><img src="assets/pics/tp_c_ex_fichier.png" /></div></center></p>
<p><div class="ui message orange"><div class="header">Remarque</div>On va utiliser ici l’entrée standard, c’est-à-dire l’entrée de l’utilisateur depuis le terminal. Cependant, il est possible de rédiriger cette entrée depuis un fichier. En effet, si on appelle <div class="ui segment code"></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1"></a><span class="op">./</span>monprogramme <span class="op">&lt;</span> monfichier</span></code></pre></div>
<p></div> Alors l’entrée standard sera le contenu de <code>monfichier</code>. Cela permet de ne pas avoir à se préoccuper d’ouvrir de fichier et d’utiliser directement <code>scanf</code>.</p>
<p><strong>Rappel</strong> <code>scanf("%d %d", &amp;x, &amp;y);</code> va lire une ligne avec deux entiers et placer la valeur du premier dans <code>x</code> et la valeur du second dans <code>y</code>.</div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1"></a><span class="dt">void</span> read_graph<span class="op">(</span>graph <span class="op">*</span>g<span class="op">)</span></span></code></pre></div>
<p></div> qui lit un graphe depuis l’entrée standard et le place dans <code>g</code> <strong>après l’avoir initialisé</strong>.</p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1"></a><span class="dt">void</span> free_edges<span class="op">(</span>graph <span class="op">*</span>g<span class="op">)</span></span></code></pre></div>
<p></div> qui libère les listes d’adjacence.</p>
</div>
<h3 data-number="6.1.2" id="sec:parcours-en-profondeur-récursif-1"><span class="header-section-number">6.1.2</span> Parcours en profondeur récursif</h3>
<p>On va modifier la structure de graphe et rajouter trois nouveaux champs :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1"></a><span class="dt">bool</span> discovered<span class="op">[</span>MAXV<span class="op">];</span> <span class="co">// Quels sommets sont connus</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="dt">bool</span> processed<span class="op">[</span>MAXV<span class="op">];</span> <span class="co">// Quels sommets sont traités</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="dt">int</span> parent<span class="op">[</span>MAXV<span class="op">];</span> <span class="co">// parent[x] est le père de x dans le parcours</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>                  <span class="co">// s&#39;il n&#39;y en a pas, c&#39;est -1</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1"></a><span class="dt">void</span> initialize_search<span class="op">(</span>graph <span class="op">*</span>g<span class="op">);</span></span></code></pre></div>
<p></div> qui initialise ces tableaux pour commencer une nouvelle recherche.</p>
</div>
<p>On va définir trois fonctions qui seront appelées lors d’un parcours et qu’on pourra redéfinir.</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1"></a><span class="dt">void</span> process_vertex_early<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> v<span class="op">)</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="op">{</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    printf<span class="op">(</span><span class="st">&quot;processing vertex %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> v<span class="op">);</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="op">}</span></span>
<span id="cb23-5"><a href="#cb23-5"></a></span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="dt">void</span> process_vertex_late<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> v<span class="op">)</span></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="op">{</span></span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="op">}</span></span>
<span id="cb23-9"><a href="#cb23-9"></a></span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="dt">void</span> process_edge<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span>
<span id="cb23-11"><a href="#cb23-11"></a><span class="op">{</span></span>
<span id="cb23-12"><a href="#cb23-12"></a>    printf<span class="op">(</span><span class="st">&quot;processed edge %d --&gt; %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb23-13"><a href="#cb23-13"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction récursive <div class="ui segment code"></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1"></a><span class="dt">void</span> dfs<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span></code></pre></div>
<p></div> qui effectue un parcours en profondeur en partant du sommet <code>x</code>.</p>
<p>Cette fonction va appeler <code>process_vertex_early</code> au début du traitement de <code>x</code>, <code>process_vertex_late</code> à la fin et <code>process_edge</code> pour chaque arête rencontrée.</p>
<p><strong>Attention</strong> si le graphe est non orienté et qu’on a rencontré <code>x -&gt; y</code> dans cet ordre, on ne fera pas de traitement dans le sens <code>y -&gt; x</code>.</p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Comme on l’a démontré, le parcours dans un graphe non orienté permet de traiter exactement la composante connexe du sommet de départ.</p>
<p>Écrire une fonction <div class="ui segment code"></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1"></a><span class="dt">void</span> connected_components<span class="op">(</span>graph <span class="op">*</span>g<span class="op">)</span></span></code></pre></div>
<p></div> qui affiche les composantes connexes sous la forme : <div class="ui segment code"></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1"></a>Component <span class="dv">1</span><span class="op">:</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>Component <span class="dv">2</span><span class="op">:</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span></span></code></pre></div>
<p></div></p>
<p>pour le graphe <center><div class="ui image center"><img src="assets/pics/tp_c_components.png" /></div></center></p>
<p>Il sera nécessaire de modifier les fonctions <code>process_*</code>.</p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Adaptez le parcours pour détecter des cycles. Quand vous détectez un cycle, affichez les sommets qui le compose. Dans le graphe précédent il faut afficher : <div class="ui segment code"></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1"></a>Cycle <span class="op">:</span> <span class="dv">0</span> <span class="dv">2</span> <span class="dv">3</span></span>
<span id="cb27-2"><a href="#cb27-2"></a>Cycle <span class="op">:</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">4</span></span>
<span id="cb27-3"><a href="#cb27-3"></a>Cycle <span class="op">:</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span></span></code></pre></div>
<p></div></p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>A l’aide d’un parcours, déterminez si un graphe non orienté est biparti.</p>
</div>
<h3 data-number="6.1.3" id="sec:temps-et-classification-des-arêtes"><span class="header-section-number">6.1.3</span> Temps et classification des arêtes</h3>
<p>On rajoute à la structure <code>graph</code> deux tableaux et un entier :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1"></a><span class="dt">int</span> time<span class="op">;</span> <span class="co">// l&#39;horloge</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="dt">int</span> entry_time<span class="op">[</span>MAXV<span class="op">];</span></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="dt">int</span> exit_time<span class="op">[</span>MAXV<span class="op">];</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Rajouter à <code>dfs</code> le maintien de l’horloge et des temps d’entrée et de sortie.</p>
</div>
<p>On définit des constantes :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1"></a><span class="pp">#define TREE 0</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="pp">#define BACK 1</span></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="pp">#define FORWARD 2</span></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="pp">#define CROSS 3</span></span></code></pre></div>
<p></div></p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction : <div class="ui segment code"></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1"></a><span class="dt">int</span> edge_classification<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span></span></code></pre></div>
<p></div> qui pourra être appelée dans <code>process_edge</code> pour déterminer la classe d’une arête selon les constantes précédentes. On renverra -1 si l’arête ne peut être déterminée (est-ce possible ?).</p>
</div>
<h3 data-number="6.1.4" id="sec:parcours-avec-une-structure"><span class="header-section-number">6.1.4</span> Parcours avec une structure</h3>
<p>On va réutiliser ici des implémentations de files et de piles dans un tableau de taille fixe.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Compléter les implémentations en se basant sur ce qui a déjà été fait dans les TP précédents. <div class="ui segment code"></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">struct</span> queue <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2"></a>    <span class="dt">int</span> elts<span class="op">[</span>MAXV<span class="op">];</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>    <span class="dt">int</span> front<span class="op">;</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>    <span class="dt">int</span> back<span class="op">;</span></span>
<span id="cb31-5"><a href="#cb31-5"></a><span class="op">};</span></span>
<span id="cb31-6"><a href="#cb31-6"></a><span class="kw">typedef</span> <span class="kw">struct</span> queue queue<span class="op">;</span></span>
<span id="cb31-7"><a href="#cb31-7"></a></span>
<span id="cb31-8"><a href="#cb31-8"></a><span class="kw">struct</span> stack <span class="op">{</span></span>
<span id="cb31-9"><a href="#cb31-9"></a>    <span class="dt">int</span> elts<span class="op">[</span>MAXV<span class="op">];</span></span>
<span id="cb31-10"><a href="#cb31-10"></a>    <span class="dt">int</span> back<span class="op">;</span></span>
<span id="cb31-11"><a href="#cb31-11"></a><span class="op">};</span></span>
<span id="cb31-12"><a href="#cb31-12"></a><span class="kw">typedef</span> <span class="kw">struct</span> stack stack<span class="op">;</span></span>
<span id="cb31-13"><a href="#cb31-13"></a></span>
<span id="cb31-14"><a href="#cb31-14"></a><span class="dt">void</span> init_stack<span class="op">(</span>stack <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb31-15"><a href="#cb31-15"></a><span class="op">{</span></span>
<span id="cb31-16"><a href="#cb31-16"></a>    <span class="co">// initialise la pile</span></span>
<span id="cb31-17"><a href="#cb31-17"></a><span class="op">}</span></span>
<span id="cb31-18"><a href="#cb31-18"></a></span>
<span id="cb31-19"><a href="#cb31-19"></a><span class="dt">int</span> pop<span class="op">(</span>stack <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb31-20"><a href="#cb31-20"></a><span class="op">{</span></span>
<span id="cb31-21"><a href="#cb31-21"></a>    <span class="co">// depile un élément</span></span>
<span id="cb31-22"><a href="#cb31-22"></a><span class="op">}</span></span>
<span id="cb31-23"><a href="#cb31-23"></a></span>
<span id="cb31-24"><a href="#cb31-24"></a><span class="dt">void</span> push<span class="op">(</span>stack <span class="op">*</span>s<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb31-25"><a href="#cb31-25"></a><span class="op">{</span></span>
<span id="cb31-26"><a href="#cb31-26"></a>    <span class="co">// empile x sur la pile s</span></span>
<span id="cb31-27"><a href="#cb31-27"></a><span class="op">}</span></span>
<span id="cb31-28"><a href="#cb31-28"></a></span>
<span id="cb31-29"><a href="#cb31-29"></a><span class="dt">void</span> init_queue<span class="op">(</span>queue <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb31-30"><a href="#cb31-30"></a><span class="op">{</span></span>
<span id="cb31-31"><a href="#cb31-31"></a>    <span class="co">// initialise la file</span></span>
<span id="cb31-32"><a href="#cb31-32"></a><span class="op">}</span></span>
<span id="cb31-33"><a href="#cb31-33"></a></span>
<span id="cb31-34"><a href="#cb31-34"></a><span class="dt">int</span> dequeue<span class="op">(</span>queue <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb31-35"><a href="#cb31-35"></a><span class="op">{</span></span>
<span id="cb31-36"><a href="#cb31-36"></a>    <span class="co">// defile un élément</span></span>
<span id="cb31-37"><a href="#cb31-37"></a><span class="op">}</span></span>
<span id="cb31-38"><a href="#cb31-38"></a></span>
<span id="cb31-39"><a href="#cb31-39"></a><span class="dt">void</span> enqueue<span class="op">(</span>queue <span class="op">*</span>s<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb31-40"><a href="#cb31-40"></a><span class="op">{</span></span>
<span id="cb31-41"><a href="#cb31-41"></a>    <span class="co">// enfile x sur la file s</span></span>
<span id="cb31-42"><a href="#cb31-42"></a><span class="op">}</span></span></code></pre></div>
<p></div></p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions <div class="ui segment code"></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1"></a><span class="dt">void</span> dfs<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> src<span class="op">);</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="dt">void</span> bfs<span class="op">(</span>graph <span class="op">*</span>g<span class="op">,</span> <span class="dt">int</span> src<span class="op">);</span></span></code></pre></div>
<p></div></p>
<p>effectuant un parcours en utilisant pour les sommets à visiter une pile ou une file. On ne pourra pas maintenir les temps de sortie ici car cela n’a plus vraiment de sens.</p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>A l’aide d’un parcours en largeur, le <code>bfs</code>, déterminez étant donné un sommet <code>x</code> et un sommet <code>y</code> de sa composante connexe, le plus court chemin de <code>x</code> vers <code>y</code>. On l’affichera sous la forme <code>0 -- 3 -- 1 -- 5</code>.</p>
</div>
<h2 data-number="6.2" id="sec:étude-dun-graphe-issu-dun-réseau-social"><span class="header-section-number">6.2</span> Étude d’un graphe issu d’un réseau social</h2>
<p>Dans ce TP on va étudier le graphe <strong>orienté</strong> des followers du compte Twitter <code>@ENSdeLyon</code>.</p>
<p>Une représentation graphique de ce graphe est donné dans l’image suivante :</p>
<p><img src="assets/pics/ENSdeLyon.png" /></p>
<p>Les sommets sont les comptes donnés par leur identifiant (le <code>@identifiant</code> de Twitter) et une arête x <span class="math inline">\(\rightarrow\)</span> y indique que le compte x est abonné au compte y.</p>
<p>Ce graphe est assez conséquent : il comporte 8418 sommets et 305288 arêtes. Il nous permettra ainsi d’étudier en pratique la complexité des différents algorithmes étudiés. On va commencer par lire ce graphe depuis un fichier, ensuite, on en déduira différents graphes associés (sous-graphes, symétrisés par excès ou par défaut…) sur lesquels on pourra appliquer les algorithmes demandés. Une table de résultat est fourni en fin de TP pour vérifier vos résultats.</p>
<h3 data-number="6.2.1" id="sec:définition-et-lecture-du-graphe"><span class="header-section-number">6.2.1</span> Définition et lecture du graphe</h3>
<p>Le graphe est donné dans le fichier <a href="assets/data/ENSdeLyon.graph">ENSdeLyon.graph</a>. Il s’agit d’un fichier texte ayant la structure suivante :</p>
<ul>
<li>un entier <code>n_sommets</code> sur une ligne</li>
<li>un entiers <code>n_aretes</code> sur une ligne</li>
<li><code>n_sommets</code> lignes contenant une chaîne de caractère représentant l’identifiant d’un sommet</li>
<li><code>n_aretes</code> couple de lignes comportant sur la première un entier <code>src</code> et sur la seconde un entier <code>tgt</code> indiquant une arête <code>src -&gt; tgt</code>.</li>
</ul>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Expliquer pourquoi cela ne semble pas être une bonne idée de représenter ce graphe par une matrice d’adjacence.</p>
</div>
<p>On va utiliser le type suivant permettant de représenter le graphe par listes d’adjacence :</p>
<p><div class="ui segment code"></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">type</span> graphe = {</span>
<span id="cb33-2"><a href="#cb33-2"></a>    sommets : <span class="dt">string</span> <span class="dt">array</span>;</span>
<span id="cb33-3"><a href="#cb33-3"></a>    aretes : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">array</span></span>
<span id="cb33-4"><a href="#cb33-4"></a>}</span></code></pre></div>
<p></div></p>
<p>Pour lire le graphe depuis le fichier, le plus simple est de le rediriger sur l’entrée standard (<em>Rappel</em> <code>./monprogramme &lt; monfichier</code>) et d’utiliser les deux fonctions suivantes :</p>
<ul>
<li><code>read_int : unit -&gt; int</code> lit une ligne composée d’un entier et renvoie sa valeur.</li>
<li><code>read_line : unit -&gt; string</code> lit une ligne et la renvoie sans le caractère de saut de ligne, c’est-à-dire, sans le <code>'\n'</code>.</li>
</ul>
<p>Alternativement, on peut lire le graphe depuis un fichier avec :</p>
<ul>
<li><code>open_in : string -&gt; in_channel</code> qui crée un descripteur de fichier en lecture pour le nom de fichier passé en paramètre</li>
<li><code>input_line : in_channel -&gt; string</code> qui lit une ligne dans le descripteur et la renvoie sans le saut de ligne</li>
<li><code>int_of_string : string -&gt; int</code> qui convertit une chaîne contenant un entier en entier.</li>
</ul>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>read_graphe : unit -&gt; graphe</code> qui lit un graphe dans le format précédent sur l’entrée standard et tester que vous arrivez à lire le fichier.</p>
<p>Un graphe minimaliste de 3 sommets et 4 arêtes est donné dans le fichier <a href="assets/data/test.graph">test.graph</a> afin de vous permettre de tester votre fonction.</p>
</div>
<p>Si <span class="math inline">\(G = (S,A)\)</span> est un graphe dont les sommets sont énumérées <span class="math inline">\(S = \{ s_0, s_1, \dots, s_{n-1} \}\)</span>, on note, pour <span class="math inline">\(p \le n\)</span>, <span class="math inline">\(G_p\)</span> le sous-graphe induit par <span class="math inline">\(\{ s_0, \dots, s_{p-1} \}\)</span>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>restriction : graphe -&gt; int -&gt; graphe</code> tel que <code>restriction g p</code> où <code>g</code> est la représentation d’un graphe <span class="math inline">\(G\)</span> renvoie la représentation du graphe <span class="math inline">\(G_p\)</span>.</p>
</div>
<p>Si <span class="math inline">\(G = (S,A)\)</span> est un graphe orienté, on a vu au paragraphe <a href="chap_structuresdonnees_graphes.html#sec:graphes_symetrises">Graphes non orientés</a> les graphes non orientés par défaut et par excès, <span class="math inline">\(G^-\)</span> et <span class="math inline">\(G^+\)</span> qui lui sont associés.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire des fonctions <code>par_defaut : graphe -&gt; graphe</code> et <code>par_exces : graphe -&gt; graphe</code> qui, étant donné un graphe <span class="math inline">\(G\)</span>, renvoie les graphes <span class="math inline">\(G^-\)</span> et <span class="math inline">\(G^+\)</span> représentés en tant que graphes orientés symétriques.</p>
</div>
<p>Si <span class="math inline">\(G = (S,A)\)</span> est un graphe orienté, on note <span class="math inline">\(rev(G) = (S,A&#39;)\)</span> son miroir qui vérifie <span class="math inline">\((i,j) \in A \iff (j,i) \in A&#39;\)</span>, c’est-à-dire qui renverse toutes les arêtes.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>miroir : graphe -&gt; graphe</code> qui renvoie le miroir d’un graphe.</p>
</div>
<p>Dans la suite du sujet on note <span class="math inline">\(\mathcal{G}\)</span> le graphe des followers contenu dans le fichier. On va considérer dans la suite les graphes :</p>
<p><span class="math inline">\(\mathcal{G}, rev(\mathcal{G}), \mathcal{G}^-, \mathcal{G}^+, \mathcal{G}_{500}, rev(\mathcal{G}_{500}), \mathcal{G}_{500}^-\)</span> et <span class="math inline">\(\mathcal{G}_{500}^+\)</span>.</p>
<h3 data-number="6.2.2" id="sec:statistiques-sur-les-degrés"><span class="header-section-number">6.2.2</span> Statistiques sur les degrés</h3>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>stat_degre : graphe -&gt; int * float</code> qui renvoie un couple <span class="math inline">\((d_{max}, d_{moy})\)</span> où <span class="math inline">\(d_max\)</span> est le plus grand des degrés du graphe et <span class="math inline">\(d_{moy}\)</span> est le degré moyen donné par un nombre flottant.</p>
</div>
<h3 data-number="6.2.3" id="sec:parcours-en-largeur"><span class="header-section-number">6.2.3</span> Parcours en largeur</h3>
<p>On va réaliser ici un parcours en largeur qui sera amené à être modifié et enrichi dans les questions suivantes. On vous laisse libre d’enrichir ce parcours en utilisant des fonctionnelles pour les traitements ou de modifier le code du parcours directement.</p>
<p>Pour utiliser une file, on va utiliser le module <a href="https://v2.ocaml.org/api/Queue.html">Queue</a>. Dans le parcours on va calculer la fonction de distance <code>d</code> et pour gérer les cas où <span class="math inline">\(d(x) = \infty\)</span>, on va la représenter par un <code>int option array</code>. Si <code>d.(x) = None</code> c’est que <code>x</code> est inconnu, on peut donc se servir de ce tableau pour avoir l’état d’un sommet.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>bfs : graphe -&gt; int -&gt; int option array * int option array</code> telle que <code>bfs g x</code> renvoie un couple <code>(d,parent)</code> où <code>d.(y)</code> est la distance minimale de <span class="math inline">\(x\)</span> à <span class="math inline">\(y\)</span> et <code>parent.(y)</code> est l’indice du prédécesseur de <code>y</code> dans un tel chemin de <span class="math inline">\(x\)</span> à <span class="math inline">\(y\)</span>.</p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>chemin : graphe -&gt; int option array -&gt; int -&gt; int list</code> tel que <code>chemin g parent y</code> renvoie les sommets présents dans un chemin de <code>x</code> à <code>y</code>.</p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>affiche_chemin : graphe -&gt; int list -&gt; unit</code> qui prend un graphe et un chemin donné par la fonction précédente et l’affiche avec le format :</p>
<pre><code>compte1 -&gt; compte1 -&gt; ... -&gt; compten</code></pre>
</div>
<p>Si <span class="math inline">\(x \in S\)</span>, on note <span class="math inline">\(\underline{x} = \enscomp{y \in S}{x \leadsto y}\)</span>.</p>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>accessibles : graphe -&gt; int -&gt; int</code> qui calcule le cardinal de <span class="math inline">\(\underline{x}\)</span> étant donné un graphe <span class="math inline">\(G\)</span> et un sommet <span class="math inline">\(x\)</span> donné par son indice.</p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>max_accesibles : graphe -&gt; int * int</code> qui renvoie un couple <span class="math inline">\((x, |\underline{x}|)\)</span> où <span class="math inline">\(x\)</span> est un sommet pour lequel <span class="math inline">\(|\underline{x}|\)</span> est maximal.</p>
</div>
<h3 data-number="6.2.4" id="sec:plus-long-chemin-et-diametre"><span class="header-section-number">6.2.4</span> Plus long chemin et diametre</h3>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>plus_loin : graphe -&gt; int -&gt; int list</code> telle que <code>plus_long_chemin g x</code> renvoie le chemin de <code>x</code> au sommet <code>y</code> qui lui est le plus éloigné.</p>
</div>
<div class="ui message blue">
<div class="header">
Question
</div>
<p>Écrire une fonction <code>diametre : graphe -&gt; int list</code> qui renvoie un chemin réalisant le diamètre d’un graphe.</p>
</div>
<h3 data-number="6.2.5" id="sec:table-de-résultats"><span class="header-section-number">6.2.5</span> Table de résultats</h3>
<p><strong>Attention</strong> : s’il faut peu de temps pour obtenir les résultats pour le sous-graphe de 500 sommets, c’est beaucoup plus long sur le graphe complet.</p>
<ul>
<li><strong><span class="math inline">\(\mathcal{G}_{500}\)</span></strong> :</li>
</ul>
<pre><code>degré max 10
degré moyen 0.430000
max_accessibles Mishkalashnikov avec 16 sommets
Diamètre 7 réalisé par :
Isaac__K -&gt; naxonlabs -&gt; faezeh_db -&gt; MooreInst -&gt; 
    fath_gabrielle -&gt; hypothesesorg -&gt; ScienceFactor -&gt; savantures</code></pre>
<ul>
<li><strong><span class="math inline">\(rev(\mathcal{G}_{500})\)</span></strong> :</li>
</ul>
<pre><code>degré max 31
degré moyen 0.430000
max_accessibles savantures avec 76 sommets
Diamètre 7 réalisé par :
savantures -&gt; ScienceFactor -&gt; hypothesesorg -&gt; 
    fath_gabrielle -&gt; MooreInst -&gt; faezeh_db -&gt; naxonlabs -&gt; Isaac__K</code></pre>
<ul>
<li><strong><span class="math inline">\(\mathcal{G}_{500}^-\)</span></strong> :</li>
</ul>
<pre><code>degré max 4
degré moyen 0.176000
max_accessibles SeverineWozniak avec 8 sommets
Diamètre 4 réalisé par :
QLMB8mars -&gt; giu_sapio -&gt; louise_tbr -&gt; GroupeImpec -&gt; halfbloodqueenx</code></pre>
<ul>
<li><strong><span class="math inline">\(\mathcal{G}_{500}^+\)</span></strong> :</li>
</ul>
<pre><code>degré max 32
degré moyen 0.684000
max_accessibles helloselyn avec 98 sommets
Diamètre 12 réalisé par :
TsamiyahL -&gt; FES_AFNEUS -&gt; FlorestanAFNEUS -&gt; FedeAddiction -&gt; 
    LS46151053 -&gt; hypothesesorg -&gt; Osec2022 -&gt; ardakaniz -&gt; 
    ValRobert974 -&gt; DialloAIbrahim2 -&gt; Defense137 -&gt; KArthemis -&gt; 
    SGF_GEOSOC</code></pre>
<ul>
<li><strong><span class="math inline">\(\mathcal{G}\)</span></strong> :</li>
</ul>
<pre><code>degré max 950
degré moyen 36.266096
max_accessibles Boris_Brana avec 6049 sommets
Diamètre 9 réalisé par :
MonaEmara10 -&gt; SambitPhD -&gt; MIT_CSAIL -&gt; MehdiKaytoue -&gt; gromuald -&gt; 
    ECHARDE_ENSL -&gt; cerseilia_ -&gt; dadoyeldado -&gt; Deccefunjoogu -&gt; stoicsalik</code></pre>
<ul>
<li><strong><span class="math inline">\(rev(\mathcal{G})\)</span></strong> :</li>
</ul>
<pre><code>degré max 3655
degré moyen 36.266096
max_accessibles JustVonBraun avec 7532 sommets
Diamètre 9 réalisé par :
Bonusbasci -&gt; TCebere -&gt; Miruna_Rosca -&gt; h2020prometheus -&gt; 
    barENdSonLyon -&gt; INP_CNRS -&gt; ThierryCoulhon -&gt; Phil_Baty -&gt; 
    HigherEdFutures -&gt; HEMobilities</code></pre>
<ul>
<li><strong><span class="math inline">\(\mathcal{G}^-\)</span></strong> :</li>
</ul>
<pre><code>degré max 610
degré moyen 12.069850
max_accessibles augabcoh avec 5352 sommets
Diamètre 10 réalisé par :
LeaLescouzeres -&gt; Gauthier_tls -&gt; MorganeBoulch -&gt; CSNB14 -&gt; 
    leo_chapuis -&gt; CCILYONMETRO -&gt; IsabelleHuault -&gt; Phil_Baty -&gt; 
    UNIKEhighered -&gt; HigherEdFutures -&gt; HEMobilities</code></pre>
<ul>
<li><strong><span class="math inline">\(\mathcal{G}^+\)</span></strong> :</li>
</ul>
<pre><code>degré max 3655
degré moyen 60.462343
max_accessibles augabcoh avec 7854 sommets
Diamètre 7 réalisé par :
GabrielMarseres -&gt; caroched -&gt; MarieMoroso -&gt; L3vironaute -&gt; najatvb -&gt; 
    LeankonCarotte -&gt; JustVonBraun -&gt; Sardine49160063</code></pre>
<h3 data-number="6.2.6" id="sec:aller-plus-loin"><span class="header-section-number">6.2.6</span> Aller plus loin</h3>
<p>On propose ici plusieurs pistes de réflexions pour prolonger le TP :</p>
<ul>
<li>On a vu des algorithmes de dessin de graphes adaptés à des petits graphes. La présence de l’interaction sommet-sommet semble leur donner une complexité en <span class="math inline">\(O(n^2)\)</span> qui est rédhibitoire ici. Cependant, des sommets éloignés ont peu de chance d’interagir, comment pourrait-on modifier l’algorithme pour ignorer les interactions de répulsions entre sommets éloignés ? On remarque que la distance n’est pas un critère valide car les sommets peuvent être tous être superposés. Une manière de traiter cela efficacement est de découper le plan en région par des droites successives. Allez voir la page <a href="https://en.wikipedia.org/wiki/Binary_space_partitioning">Binary Space Partionning</a> et en déduire un algorithme effectif de dessin de graphe adapté.</li>
<li>Pour estimer l’importance d’un compte, on ne peut pas se fier à son degré. En effet, celui-ci peut être augmenté artificiellement. Une manière fiable de mesurer l’importance est d’imaginer quelqu’un naviguant aléatoirement sur des comptes en suivant des liens d’abonnement et de mesurer la probabilité qu’il se retrouve sur un compte donné. C’est le principe qui est à la base de l’algorithme <a href="https://en.wikipedia.org/wiki/PageRank">PageRank</a> utilisé par Google. Implémenter cet algorithme et en déduire les comptes les plus importants dans cet exemple.</li>
</ul>
</div>
<!-- </div> -->
</div>

<div class="ui inverted vertical footer segment">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
Marc de Falco
</div>
  </body>
</html>
